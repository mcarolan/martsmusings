(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/maplibre-gl/dist/maplibre-gl.js
  var require_maplibre_gl = __commonJS({
    "node_modules/maplibre-gl/dist/maplibre-gl.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.maplibregl = factory());
      })(exports, function() {
        "use strict";
        var shared, worker, maplibregl;
        function define2(_, chunk) {
          if (!shared) {
            shared = chunk;
          } else if (!worker) {
            worker = chunk;
          } else {
            var workerBundleString = "var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk);";
            var sharedChunk = {};
            shared(sharedChunk);
            maplibregl = chunk(sharedChunk);
            if (typeof window !== "undefined") {
              maplibregl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
            }
          }
        }
        define2(["exports"], function(t) {
          "use strict";
          var e = r;
          function r(t2, e3, r2, n2) {
            this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e3, this.by = 3 * (n2 - e3) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = e3, this.p2x = r2, this.p2y = n2;
          }
          function n(t2, r2, n2, i2) {
            const a2 = new e(t2, r2, n2, i2);
            return function(t3) {
              return a2.solve(t3);
            };
          }
          r.prototype = { sampleCurveX: function(t2) {
            return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
          }, sampleCurveY: function(t2) {
            return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
          }, sampleCurveDerivativeX: function(t2) {
            return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
          }, solveCurveX: function(t2, e3) {
            if (void 0 === e3 && (e3 = 1e-6), t2 < 0)
              return 0;
            if (t2 > 1)
              return 1;
            for (var r2 = t2, n2 = 0; n2 < 8; n2++) {
              var i2 = this.sampleCurveX(r2) - t2;
              if (Math.abs(i2) < e3)
                return r2;
              var a2 = this.sampleCurveDerivativeX(r2);
              if (Math.abs(a2) < 1e-6)
                break;
              r2 -= i2 / a2;
            }
            var s2 = 0, o2 = 1;
            for (r2 = t2, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t2) < e3)); n2++)
              t2 > i2 ? s2 = r2 : o2 = r2, r2 = 0.5 * (o2 - s2) + s2;
            return r2;
          }, solve: function(t2, e3) {
            return this.sampleCurveY(this.solveCurveX(t2, e3));
          } };
          const i = n(0.25, 0.1, 0.25, 1);
          function a(t2, e3, r2) {
            return Math.min(r2, Math.max(e3, t2));
          }
          function s(t2, e3, r2) {
            const n2 = r2 - e3, i2 = ((t2 - e3) % n2 + n2) % n2 + e3;
            return i2 === e3 ? r2 : i2;
          }
          function o(t2, ...e3) {
            for (const r2 of e3)
              for (const e4 in r2)
                t2[e4] = r2[e4];
            return t2;
          }
          let l = 1;
          function u(t2, e3) {
            t2.forEach((t3) => {
              e3[t3] && (e3[t3] = e3[t3].bind(e3));
            });
          }
          function c(t2, e3, r2) {
            const n2 = {};
            for (const i2 in t2)
              n2[i2] = e3.call(r2 || this, t2[i2], i2, t2);
            return n2;
          }
          function h(t2, e3, r2) {
            const n2 = {};
            for (const i2 in t2)
              e3.call(r2 || this, t2[i2], i2, t2) && (n2[i2] = t2[i2]);
            return n2;
          }
          function p(t2) {
            return Array.isArray(t2) ? t2.map(p) : "object" == typeof t2 && t2 ? c(t2, p) : t2;
          }
          const f = {};
          function d(t2) {
            f[t2] || ("undefined" != typeof console && console.warn(t2), f[t2] = true);
          }
          function y2(t2, e3, r2) {
            return (r2.y - t2.y) * (e3.x - t2.x) > (e3.y - t2.y) * (r2.x - t2.x);
          }
          function m(t2) {
            let e3 = 0;
            for (let r2, n2, i2 = 0, a2 = t2.length, s2 = a2 - 1; i2 < a2; s2 = i2++)
              r2 = t2[i2], n2 = t2[s2], e3 += (n2.x - r2.x) * (r2.y + n2.y);
            return e3;
          }
          function g() {
            return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
          }
          function x2(t2) {
            const e3 = {};
            if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n2, i2) => {
              const a2 = n2 || i2;
              return e3[r2] = !a2 || a2.toLowerCase(), "";
            }), e3["max-age"]) {
              const t3 = parseInt(e3["max-age"], 10);
              isNaN(t3) ? delete e3["max-age"] : e3["max-age"] = t3;
            }
            return e3;
          }
          let v, b, w = null;
          function _(t2) {
            if (null == w) {
              const e3 = t2.navigator ? t2.navigator.userAgent : null;
              w = !!t2.safari || !(!e3 || !(/\b(iPad|iPhone|iPod)\b/.test(e3) || e3.match("Safari") && !e3.match("Chrome")));
            }
            return w;
          }
          function A(t2) {
            return "undefined" != typeof ImageBitmap && t2 instanceof ImageBitmap;
          }
          const k = { now: "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(t2) {
            const e3 = requestAnimationFrame(t2);
            return { cancel: () => cancelAnimationFrame(e3) };
          }, getImageData(t2, e3 = 0) {
            const r2 = window.document.createElement("canvas"), n2 = r2.getContext("2d");
            if (!n2)
              throw new Error("failed to create canvas 2d context");
            return r2.width = t2.width, r2.height = t2.height, n2.drawImage(t2, 0, 0, t2.width, t2.height), n2.getImageData(-e3, -e3, t2.width + 2 * e3, t2.height + 2 * e3);
          }, resolveURL: (t2) => (v || (v = document.createElement("a")), v.href = t2, v.href), hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
            return !!matchMedia && (null == b && (b = matchMedia("(prefers-reduced-motion: reduce)")), b.matches);
          } };
          var S = I;
          function I(t2, e3) {
            this.x = t2, this.y = e3;
          }
          I.prototype = { clone: function() {
            return new I(this.x, this.y);
          }, add: function(t2) {
            return this.clone()._add(t2);
          }, sub: function(t2) {
            return this.clone()._sub(t2);
          }, multByPoint: function(t2) {
            return this.clone()._multByPoint(t2);
          }, divByPoint: function(t2) {
            return this.clone()._divByPoint(t2);
          }, mult: function(t2) {
            return this.clone()._mult(t2);
          }, div: function(t2) {
            return this.clone()._div(t2);
          }, rotate: function(t2) {
            return this.clone()._rotate(t2);
          }, rotateAround: function(t2, e3) {
            return this.clone()._rotateAround(t2, e3);
          }, matMult: function(t2) {
            return this.clone()._matMult(t2);
          }, unit: function() {
            return this.clone()._unit();
          }, perp: function() {
            return this.clone()._perp();
          }, round: function() {
            return this.clone()._round();
          }, mag: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }, equals: function(t2) {
            return this.x === t2.x && this.y === t2.y;
          }, dist: function(t2) {
            return Math.sqrt(this.distSqr(t2));
          }, distSqr: function(t2) {
            var e3 = t2.x - this.x, r2 = t2.y - this.y;
            return e3 * e3 + r2 * r2;
          }, angle: function() {
            return Math.atan2(this.y, this.x);
          }, angleTo: function(t2) {
            return Math.atan2(this.y - t2.y, this.x - t2.x);
          }, angleWith: function(t2) {
            return this.angleWithSep(t2.x, t2.y);
          }, angleWithSep: function(t2, e3) {
            return Math.atan2(this.x * e3 - this.y * t2, this.x * t2 + this.y * e3);
          }, _matMult: function(t2) {
            var e3 = t2[2] * this.x + t2[3] * this.y;
            return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e3, this;
          }, _add: function(t2) {
            return this.x += t2.x, this.y += t2.y, this;
          }, _sub: function(t2) {
            return this.x -= t2.x, this.y -= t2.y, this;
          }, _mult: function(t2) {
            return this.x *= t2, this.y *= t2, this;
          }, _div: function(t2) {
            return this.x /= t2, this.y /= t2, this;
          }, _multByPoint: function(t2) {
            return this.x *= t2.x, this.y *= t2.y, this;
          }, _divByPoint: function(t2) {
            return this.x /= t2.x, this.y /= t2.y, this;
          }, _unit: function() {
            return this._div(this.mag()), this;
          }, _perp: function() {
            var t2 = this.y;
            return this.y = this.x, this.x = -t2, this;
          }, _rotate: function(t2) {
            var e3 = Math.cos(t2), r2 = Math.sin(t2), n2 = r2 * this.x + e3 * this.y;
            return this.x = e3 * this.x - r2 * this.y, this.y = n2, this;
          }, _rotateAround: function(t2, e3) {
            var r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = e3.y + n2 * (this.x - e3.x) + r2 * (this.y - e3.y);
            return this.x = e3.x + r2 * (this.x - e3.x) - n2 * (this.y - e3.y), this.y = i2, this;
          }, _round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
          } }, I.convert = function(t2) {
            return t2 instanceof I ? t2 : Array.isArray(t2) ? new I(t2[0], t2[1]) : t2;
          };
          const M = { MAX_PARALLEL_IMAGE_REQUESTS: 16, REGISTERED_PROTOCOLS: {} }, z = "mapbox-tiles";
          let B2, C, P = 500, V = 50;
          function E() {
            "undefined" == typeof caches || B2 || (B2 = caches.open(z));
          }
          let F = 1 / 0;
          const T = { supported: false, testSupport: function(t2) {
            !$ && D && (R ? O(t2) : L = t2);
          } };
          let L, D, $ = false, R = false;
          function O(t2) {
            const e3 = t2.createTexture();
            t2.bindTexture(t2.TEXTURE_2D, e3);
            try {
              if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, D), t2.isContextLost())
                return;
              T.supported = true;
            } catch (t3) {
            }
            t2.deleteTexture(e3), $ = true;
          }
          "undefined" != typeof document && (D = document.createElement("img"), D.onload = function() {
            L && O(L), L = null, R = true;
          }, D.onerror = function() {
            $ = true, L = null;
          }, D.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
          const U = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
          "function" == typeof Object.freeze && Object.freeze(U);
          class q extends Error {
            constructor(t2, e3, r2, n2) {
              super(`AJAXError: ${e3} (${t2}): ${r2}`), this.status = t2, this.statusText = e3, this.url = r2, this.body = n2;
            }
          }
          const j = g() ? () => self.worker && self.worker.referrer : () => ("blob:" === window.location.protocol ? window.parent : window).location.href;
          function N(t2, e3) {
            const r2 = new AbortController(), n2 = new Request(t2.url, { method: t2.method || "GET", body: t2.body, credentials: t2.credentials, headers: t2.headers, referrer: j(), signal: r2.signal });
            let i2 = false, a2 = false;
            "json" === t2.type && n2.headers.set("Accept", "application/json");
            return ((r3, s2, o2) => {
              if (a2)
                return;
              const l2 = Date.now();
              fetch(n2).then((r4) => r4.ok ? ((r5, s3, o3) => {
                ("arrayBuffer" === t2.type ? r5.arrayBuffer() : "json" === t2.type ? r5.json() : r5.text()).then((t3) => {
                  a2 || (s3 && o3 && function(t4, e4, r6) {
                    if (E(), !B2)
                      return;
                    const n3 = { status: e4.status, statusText: e4.statusText, headers: new Headers() };
                    e4.headers.forEach((t5, e6) => n3.headers.set(e6, t5));
                    const i3 = x2(e4.headers.get("Cache-Control") || "");
                    i3["no-store"] || (i3["max-age"] && n3.headers.set("Expires", new Date(r6 + 1e3 * i3["max-age"]).toUTCString()), new Date(n3.headers.get("Expires")).getTime() - r6 < 42e4 || function(t5, e6) {
                      if (void 0 === C)
                        try {
                          new Response(new ReadableStream()), C = true;
                        } catch (t6) {
                          C = false;
                        }
                      C ? e6(t5.body) : t5.blob().then(e6);
                    }(e4, (e6) => {
                      const r7 = new Response(e6, n3);
                      E(), B2 && B2.then((e7) => e7.put(function(t5) {
                        const e8 = t5.indexOf("?");
                        return e8 < 0 ? t5 : t5.slice(0, e8);
                      }(t4.url), r7)).catch((t5) => d(t5.message));
                    }));
                  }(n2, s3, o3), i2 = true, e3(null, t3, r5.headers.get("Cache-Control"), r5.headers.get("Expires")));
                }).catch((t3) => {
                  a2 || e3(new Error(t3.message));
                });
              })(r4, null, l2) : r4.blob().then((n3) => e3(new q(r4.status, r4.statusText, t2.url, n3)))).catch((t3) => {
                20 !== t3.code && e3(new Error(t3.message));
              });
            })(), { cancel: () => {
              a2 = true, i2 || r2.abort();
            } };
          }
          const Z = function(t2, e3) {
            if (/:\/\//.test(t2.url) && !/^https?:|^file:/.test(t2.url)) {
              if (g() && self.worker && self.worker.actor)
                return self.worker.actor.send("getResource", t2, e3);
              if (!g()) {
                const r3 = t2.url.substring(0, t2.url.indexOf("://"));
                return (M.REGISTERED_PROTOCOLS[r3] || N)(t2, e3);
              }
            }
            if (!(/^file:/.test(r2 = t2.url) || /^file:/.test(j()) && !/^\w+:/.test(r2))) {
              if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
                return N(t2, e3);
              if (g() && self.worker && self.worker.actor)
                return self.worker.actor.send("getResource", t2, e3, void 0, true);
            }
            var r2;
            return function(t3, e4) {
              const r3 = new XMLHttpRequest();
              r3.open(t3.method || "GET", t3.url, true), "arrayBuffer" === t3.type && (r3.responseType = "arraybuffer");
              for (const e6 in t3.headers)
                r3.setRequestHeader(e6, t3.headers[e6]);
              return "json" === t3.type && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = "include" === t3.credentials, r3.onerror = () => {
                e4(new Error(r3.statusText));
              }, r3.onload = () => {
                if ((r3.status >= 200 && r3.status < 300 || 0 === r3.status) && null !== r3.response) {
                  let n2 = r3.response;
                  if ("json" === t3.type)
                    try {
                      n2 = JSON.parse(r3.response);
                    } catch (t4) {
                      return e4(t4);
                    }
                  e4(null, n2, r3.getResponseHeader("Cache-Control"), r3.getResponseHeader("Expires"));
                } else {
                  const n2 = new Blob([r3.response], { type: r3.getResponseHeader("Content-Type") });
                  e4(new q(r3.status, r3.statusText, t3.url, n2));
                }
              }, r3.send(t3.body), { cancel: () => r3.abort() };
            }(t2, e3);
          }, K = function(t2, e3) {
            return Z(o(t2, { type: "arrayBuffer" }), e3);
          };
          function G(t2) {
            const e3 = window.document.createElement("a");
            return e3.href = t2, e3.protocol === window.document.location.protocol && e3.host === window.document.location.host;
          }
          const J = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
          let X, Y;
          X = [], Y = 0;
          const H = function(t2, e3) {
            if (T.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), Y >= M.MAX_PARALLEL_IMAGE_REQUESTS) {
              const r3 = { requestParameters: t2, callback: e3, cancelled: false, cancel() {
                this.cancelled = true;
              } };
              return X.push(r3), r3;
            }
            Y++;
            let r2 = false;
            const n2 = () => {
              if (!r2)
                for (r2 = true, Y--; X.length && Y < M.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                  const t3 = X.shift(), { requestParameters: e4, callback: r3, cancelled: n3 } = t3;
                  n3 || (t3.cancel = H(e4, r3).cancel);
                }
            }, i2 = K(t2, (t3, r3, i3, a2) => {
              n2(), t3 ? e3(t3) : r3 && function(t4, e4) {
                "function" == typeof createImageBitmap ? function(t5, e6) {
                  const r4 = new Blob([new Uint8Array(t5)], { type: "image/png" });
                  createImageBitmap(r4).then((t6) => {
                    e6(null, t6);
                  }).catch((t6) => {
                    e6(new Error(`Could not load image because of ${t6.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                  });
                }(t4, e4) : function(t5, e6) {
                  const r4 = new Image();
                  r4.onload = () => {
                    e6(null, r4), URL.revokeObjectURL(r4.src), r4.onload = null, window.requestAnimationFrame(() => {
                      r4.src = J;
                    });
                  }, r4.onerror = () => e6(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                  const n3 = new Blob([new Uint8Array(t5)], { type: "image/png" });
                  r4.src = t5.byteLength ? URL.createObjectURL(n3) : J;
                }(t4, e4);
              }(r3, (t4, r4) => {
                null != t4 ? e3(t4) : null != r4 && e3(null, r4, { cacheControl: i3, expires: a2 });
              });
            });
            return { cancel: () => {
              i2.cancel(), n2();
            } };
          };
          function W(t2, e3, r2) {
            r2[t2] && -1 !== r2[t2].indexOf(e3) || (r2[t2] = r2[t2] || [], r2[t2].push(e3));
          }
          function Q(t2, e3, r2) {
            if (r2 && r2[t2]) {
              const n2 = r2[t2].indexOf(e3);
              -1 !== n2 && r2[t2].splice(n2, 1);
            }
          }
          class tt {
            constructor(t2, e3 = {}) {
              o(this, e3), this.type = t2;
            }
          }
          class et extends tt {
            constructor(t2, e3 = {}) {
              super("error", o({ error: t2 }, e3));
            }
          }
          class rt {
            on(t2, e3) {
              return this._listeners = this._listeners || {}, W(t2, e3, this._listeners), this;
            }
            off(t2, e3) {
              return Q(t2, e3, this._listeners), Q(t2, e3, this._oneTimeListeners), this;
            }
            once(t2, e3) {
              return this._oneTimeListeners = this._oneTimeListeners || {}, W(t2, e3, this._oneTimeListeners), this;
            }
            fire(t2, e3) {
              "string" == typeof t2 && (t2 = new tt(t2, e3 || {}));
              const r2 = t2.type;
              if (this.listens(r2)) {
                t2.target = this;
                const e4 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
                for (const r3 of e4)
                  r3.call(this, t2);
                const n2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
                for (const e6 of n2)
                  Q(r2, e6, this._oneTimeListeners), e6.call(this, t2);
                const i2 = this._eventedParent;
                i2 && (o(t2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
              } else
                t2 instanceof et && console.error(t2.error);
              return this;
            }
            listens(t2) {
              return this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2);
            }
            setEventedParent(t2, e3) {
              return this._eventedParent = t2, this._eventedParentData = e3, this;
            }
          }
          var nt = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 }, elevationOffset: { type: "number", default: 450 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
          class it {
            constructor(t2, e3, r2, n2) {
              this.message = (t2 ? `${t2}: ` : "") + r2, n2 && (this.identifier = n2), null != e3 && e3.__line__ && (this.line = e3.__line__);
            }
          }
          function at(t2) {
            const e3 = t2.value;
            return e3 ? [new it(t2.key, e3, "constants have been deprecated as of v8")] : [];
          }
          function st(t2, ...e3) {
            for (const r2 of e3)
              for (const e4 in r2)
                t2[e4] = r2[e4];
            return t2;
          }
          function ot(t2) {
            return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
          }
          function lt(t2) {
            if (Array.isArray(t2))
              return t2.map(lt);
            if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
              const e3 = {};
              for (const r2 in t2)
                e3[r2] = lt(t2[r2]);
              return e3;
            }
            return ot(t2);
          }
          class ut extends Error {
            constructor(t2, e3) {
              super(e3), this.message = e3, this.key = t2;
            }
          }
          class ct {
            constructor(t2, e3 = []) {
              this.parent = t2, this.bindings = {};
              for (const [t3, r2] of e3)
                this.bindings[t3] = r2;
            }
            concat(t2) {
              return new ct(this, t2);
            }
            get(t2) {
              if (this.bindings[t2])
                return this.bindings[t2];
              if (this.parent)
                return this.parent.get(t2);
              throw new Error(`${t2} not found in scope.`);
            }
            has(t2) {
              return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
            }
          }
          const ht = { kind: "null" }, pt = { kind: "number" }, ft = { kind: "string" }, dt = { kind: "boolean" }, yt = { kind: "color" }, mt = { kind: "object" }, gt = { kind: "value" }, xt = { kind: "collator" }, vt = { kind: "formatted" }, bt = { kind: "padding" }, wt = { kind: "resolvedImage" };
          function _t(t2, e3) {
            return { kind: "array", itemType: t2, N: e3 };
          }
          function At(t2) {
            if ("array" === t2.kind) {
              const e3 = At(t2.itemType);
              return "number" == typeof t2.N ? `array<${e3}, ${t2.N}>` : "value" === t2.itemType.kind ? "array" : `array<${e3}>`;
            }
            return t2.kind;
          }
          const kt = [ht, pt, ft, dt, yt, vt, mt, _t(gt), bt, wt];
          function St(t2, e3) {
            if ("error" === e3.kind)
              return null;
            if ("array" === t2.kind) {
              if ("array" === e3.kind && (0 === e3.N && "value" === e3.itemType.kind || !St(t2.itemType, e3.itemType)) && ("number" != typeof t2.N || t2.N === e3.N))
                return null;
            } else {
              if (t2.kind === e3.kind)
                return null;
              if ("value" === t2.kind) {
                for (const t3 of kt)
                  if (!St(t3, e3))
                    return null;
              }
            }
            return `Expected ${At(t2)} but found ${At(e3)} instead.`;
          }
          function It(t2, e3) {
            return e3.some((e4) => e4.kind === t2.kind);
          }
          function Mt(t2, e3) {
            return e3.some((e4) => "null" === e4 ? null === t2 : "array" === e4 ? Array.isArray(t2) : "object" === e4 ? t2 && !Array.isArray(t2) && "object" == typeof t2 : e4 === typeof t2);
          }
          var zt, Bt = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
          function Ct(t2) {
            return (t2 = Math.round(t2)) < 0 ? 0 : t2 > 255 ? 255 : t2;
          }
          function Pt(t2) {
            return Ct("%" === t2[t2.length - 1] ? parseFloat(t2) / 100 * 255 : parseInt(t2));
          }
          function Vt(t2) {
            return (e3 = "%" === t2[t2.length - 1] ? parseFloat(t2) / 100 : parseFloat(t2)) < 0 ? 0 : e3 > 1 ? 1 : e3;
            var e3;
          }
          function Et(t2, e3, r2) {
            return r2 < 0 ? r2 += 1 : r2 > 1 && (r2 -= 1), 6 * r2 < 1 ? t2 + (e3 - t2) * r2 * 6 : 2 * r2 < 1 ? e3 : 3 * r2 < 2 ? t2 + (e3 - t2) * (2 / 3 - r2) * 6 : t2;
          }
          try {
            zt = {}.parseCSSColor = function(t2) {
              var e3, r2 = t2.replace(/ /g, "").toLowerCase();
              if (r2 in Bt)
                return Bt[r2].slice();
              if ("#" === r2[0])
                return 4 === r2.length ? (e3 = parseInt(r2.substr(1), 16)) >= 0 && e3 <= 4095 ? [(3840 & e3) >> 4 | (3840 & e3) >> 8, 240 & e3 | (240 & e3) >> 4, 15 & e3 | (15 & e3) << 4, 1] : null : 7 === r2.length && (e3 = parseInt(r2.substr(1), 16)) >= 0 && e3 <= 16777215 ? [(16711680 & e3) >> 16, (65280 & e3) >> 8, 255 & e3, 1] : null;
              var n2 = r2.indexOf("("), i2 = r2.indexOf(")");
              if (-1 !== n2 && i2 + 1 === r2.length) {
                var a2 = r2.substr(0, n2), s2 = r2.substr(n2 + 1, i2 - (n2 + 1)).split(","), o2 = 1;
                switch (a2) {
                  case "rgba":
                    if (4 !== s2.length)
                      return null;
                    o2 = Vt(s2.pop());
                  case "rgb":
                    return 3 !== s2.length ? null : [Pt(s2[0]), Pt(s2[1]), Pt(s2[2]), o2];
                  case "hsla":
                    if (4 !== s2.length)
                      return null;
                    o2 = Vt(s2.pop());
                  case "hsl":
                    if (3 !== s2.length)
                      return null;
                    var l2 = (parseFloat(s2[0]) % 360 + 360) % 360 / 360, u2 = Vt(s2[1]), c2 = Vt(s2[2]), h2 = c2 <= 0.5 ? c2 * (u2 + 1) : c2 + u2 - c2 * u2, p2 = 2 * c2 - h2;
                    return [Ct(255 * Et(p2, h2, l2 + 1 / 3)), Ct(255 * Et(p2, h2, l2)), Ct(255 * Et(p2, h2, l2 - 1 / 3)), o2];
                  default:
                    return null;
                }
              }
              return null;
            };
          } catch (t2) {
          }
          class Ft {
            constructor(t2, e3, r2, n2 = 1) {
              this.r = t2, this.g = e3, this.b = r2, this.a = n2;
            }
            static parse(t2) {
              if (!t2)
                return;
              if (t2 instanceof Ft)
                return t2;
              if ("string" != typeof t2)
                return;
              const e3 = zt(t2);
              return e3 ? new Ft(e3[0] / 255 * e3[3], e3[1] / 255 * e3[3], e3[2] / 255 * e3[3], e3[3]) : void 0;
            }
            toString() {
              const [t2, e3, r2, n2] = this.toArray();
              return `rgba(${Math.round(t2)},${Math.round(e3)},${Math.round(r2)},${n2})`;
            }
            toArray() {
              const { r: t2, g: e3, b: r2, a: n2 } = this;
              return 0 === n2 ? [0, 0, 0, 0] : [255 * t2 / n2, 255 * e3 / n2, 255 * r2 / n2, n2];
            }
          }
          Ft.black = new Ft(0, 0, 0, 1), Ft.white = new Ft(1, 1, 1, 1), Ft.transparent = new Ft(0, 0, 0, 0), Ft.red = new Ft(1, 0, 0, 1);
          class Tt {
            constructor(t2, e3, r2) {
              this.sensitivity = t2 ? e3 ? "variant" : "case" : e3 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
            }
            compare(t2, e3) {
              return this.collator.compare(t2, e3);
            }
            resolvedLocale() {
              return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
          }
          class Lt {
            constructor(t2, e3, r2, n2, i2) {
              this.text = t2, this.image = e3, this.scale = r2, this.fontStack = n2, this.textColor = i2;
            }
          }
          class Dt {
            constructor(t2) {
              this.sections = t2;
            }
            static fromString(t2) {
              return new Dt([new Lt(t2, null, null, null, null)]);
            }
            isEmpty() {
              return 0 === this.sections.length || !this.sections.some((t2) => 0 !== t2.text.length || t2.image && 0 !== t2.image.name.length);
            }
            static factory(t2) {
              return t2 instanceof Dt ? t2 : Dt.fromString(t2);
            }
            toString() {
              return 0 === this.sections.length ? "" : this.sections.map((t2) => t2.text).join("");
            }
          }
          class $t {
            constructor(t2) {
              this.values = t2.slice();
            }
            static parse(t2) {
              if (t2 instanceof $t)
                return t2;
              if ("number" == typeof t2)
                return new $t([t2, t2, t2, t2]);
              if (Array.isArray(t2) && !(t2.length < 1 || t2.length > 4)) {
                for (const e3 of t2)
                  if ("number" != typeof e3)
                    return;
                switch (t2.length) {
                  case 1:
                    t2 = [t2[0], t2[0], t2[0], t2[0]];
                    break;
                  case 2:
                    t2 = [t2[0], t2[1], t2[0], t2[1]];
                    break;
                  case 3:
                    t2 = [t2[0], t2[1], t2[2], t2[1]];
                }
                return new $t(t2);
              }
            }
            toString() {
              return JSON.stringify(this.values);
            }
          }
          class Rt {
            constructor(t2) {
              this.name = t2.name, this.available = t2.available;
            }
            toString() {
              return this.name;
            }
            static fromString(t2) {
              return t2 ? new Rt({ name: t2, available: false }) : null;
            }
          }
          function Ot(t2, e3, r2, n2) {
            return "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof e3 && e3 >= 0 && e3 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e3, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n2 ? [t2, e3, r2, n2] : [t2, e3, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
          }
          function Ut(t2) {
            if (null === t2)
              return true;
            if ("string" == typeof t2)
              return true;
            if ("boolean" == typeof t2)
              return true;
            if ("number" == typeof t2)
              return true;
            if (t2 instanceof Ft)
              return true;
            if (t2 instanceof Tt)
              return true;
            if (t2 instanceof Dt)
              return true;
            if (t2 instanceof $t)
              return true;
            if (t2 instanceof Rt)
              return true;
            if (Array.isArray(t2)) {
              for (const e3 of t2)
                if (!Ut(e3))
                  return false;
              return true;
            }
            if ("object" == typeof t2) {
              for (const e3 in t2)
                if (!Ut(t2[e3]))
                  return false;
              return true;
            }
            return false;
          }
          function qt(t2) {
            if (null === t2)
              return ht;
            if ("string" == typeof t2)
              return ft;
            if ("boolean" == typeof t2)
              return dt;
            if ("number" == typeof t2)
              return pt;
            if (t2 instanceof Ft)
              return yt;
            if (t2 instanceof Tt)
              return xt;
            if (t2 instanceof Dt)
              return vt;
            if (t2 instanceof $t)
              return bt;
            if (t2 instanceof Rt)
              return wt;
            if (Array.isArray(t2)) {
              const e3 = t2.length;
              let r2;
              for (const e4 of t2) {
                const t3 = qt(e4);
                if (r2) {
                  if (r2 === t3)
                    continue;
                  r2 = gt;
                  break;
                }
                r2 = t3;
              }
              return _t(r2 || gt, e3);
            }
            return mt;
          }
          function jt(t2) {
            const e3 = typeof t2;
            return null === t2 ? "" : "string" === e3 || "number" === e3 || "boolean" === e3 ? String(t2) : t2 instanceof Ft || t2 instanceof Dt || t2 instanceof $t || t2 instanceof Rt ? t2.toString() : JSON.stringify(t2);
          }
          class Nt {
            constructor(t2, e3) {
              this.type = t2, this.value = e3;
            }
            static parse(t2, e3) {
              if (2 !== t2.length)
                return e3.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
              if (!Ut(t2[1]))
                return e3.error("invalid value");
              const r2 = t2[1];
              let n2 = qt(r2);
              const i2 = e3.expectedType;
              return "array" !== n2.kind || 0 !== n2.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n2 = i2), new Nt(n2, r2);
            }
            evaluate() {
              return this.value;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
          }
          class Zt {
            constructor(t2) {
              this.name = "ExpressionEvaluationError", this.message = t2;
            }
            toJSON() {
              return this.message;
            }
          }
          const Kt = { string: ft, number: pt, boolean: dt, object: mt };
          class Gt {
            constructor(t2, e3) {
              this.type = t2, this.args = e3;
            }
            static parse(t2, e3) {
              if (t2.length < 2)
                return e3.error("Expected at least one argument.");
              let r2, n2 = 1;
              const i2 = t2[0];
              if ("array" === i2) {
                let i3, a3;
                if (t2.length > 2) {
                  const r3 = t2[1];
                  if ("string" != typeof r3 || !(r3 in Kt) || "object" === r3)
                    return e3.error('The item type argument of "array" must be one of string, number, boolean', 1);
                  i3 = Kt[r3], n2++;
                } else
                  i3 = gt;
                if (t2.length > 3) {
                  if (null !== t2[2] && ("number" != typeof t2[2] || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
                    return e3.error('The length argument to "array" must be a positive integer literal', 2);
                  a3 = t2[2], n2++;
                }
                r2 = _t(i3, a3);
              } else {
                if (!Kt[i2])
                  throw new Error(`Types doesn't contain name = ${i2}`);
                r2 = Kt[i2];
              }
              const a2 = [];
              for (; n2 < t2.length; n2++) {
                const r3 = e3.parse(t2[n2], n2, gt);
                if (!r3)
                  return null;
                a2.push(r3);
              }
              return new Gt(r2, a2);
            }
            evaluate(t2) {
              for (let e3 = 0; e3 < this.args.length; e3++) {
                const r2 = this.args[e3].evaluate(t2);
                if (!St(this.type, qt(r2)))
                  return r2;
                if (e3 === this.args.length - 1)
                  throw new Zt(`Expected value to be of type ${At(this.type)}, but found ${At(qt(r2))} instead.`);
              }
              throw new Error();
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
          }
          const Jt = { "to-boolean": dt, "to-color": yt, "to-number": pt, "to-string": ft };
          class Xt {
            constructor(t2, e3) {
              this.type = t2, this.args = e3;
            }
            static parse(t2, e3) {
              if (t2.length < 2)
                return e3.error("Expected at least one argument.");
              const r2 = t2[0];
              if (!Jt[r2])
                throw new Error(`Can't parse ${r2} as it is not part of the known types`);
              if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t2.length)
                return e3.error("Expected one argument.");
              const n2 = Jt[r2], i2 = [];
              for (let r3 = 1; r3 < t2.length; r3++) {
                const n3 = e3.parse(t2[r3], r3, gt);
                if (!n3)
                  return null;
                i2.push(n3);
              }
              return new Xt(n2, i2);
            }
            evaluate(t2) {
              if ("boolean" === this.type.kind)
                return Boolean(this.args[0].evaluate(t2));
              if ("color" === this.type.kind) {
                let e3, r2;
                for (const n2 of this.args) {
                  if (e3 = n2.evaluate(t2), r2 = null, e3 instanceof Ft)
                    return e3;
                  if ("string" == typeof e3) {
                    const r3 = t2.parseColor(e3);
                    if (r3)
                      return r3;
                  } else if (Array.isArray(e3) && (r2 = e3.length < 3 || e3.length > 4 ? `Invalid rbga value ${JSON.stringify(e3)}: expected an array containing either three or four numeric values.` : Ot(e3[0], e3[1], e3[2], e3[3]), !r2))
                    return new Ft(e3[0] / 255, e3[1] / 255, e3[2] / 255, e3[3]);
                }
                throw new Zt(r2 || `Could not parse color from value '${"string" == typeof e3 ? e3 : JSON.stringify(e3)}'`);
              }
              if ("padding" === this.type.kind) {
                let e3;
                for (const r2 of this.args) {
                  e3 = r2.evaluate(t2);
                  const n2 = $t.parse(e3);
                  if (n2)
                    return n2;
                }
                throw new Zt(`Could not parse padding from value '${"string" == typeof e3 ? e3 : JSON.stringify(e3)}'`);
              }
              if ("number" === this.type.kind) {
                let e3 = null;
                for (const r2 of this.args) {
                  if (e3 = r2.evaluate(t2), null === e3)
                    return 0;
                  const n2 = Number(e3);
                  if (!isNaN(n2))
                    return n2;
                }
                throw new Zt(`Could not convert ${JSON.stringify(e3)} to number.`);
              }
              return "formatted" === this.type.kind ? Dt.fromString(jt(this.args[0].evaluate(t2))) : "resolvedImage" === this.type.kind ? Rt.fromString(jt(this.args[0].evaluate(t2))) : jt(this.args[0].evaluate(t2));
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
          }
          const Yt = ["Unknown", "Point", "LineString", "Polygon"];
          class Ht {
            constructor() {
              this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
            }
            id() {
              return this.feature && "id" in this.feature ? this.feature.id : null;
            }
            geometryType() {
              return this.feature ? "number" == typeof this.feature.type ? Yt[this.feature.type] : this.feature.type : null;
            }
            geometry() {
              return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
              return this.canonical;
            }
            properties() {
              return this.feature && this.feature.properties || {};
            }
            parseColor(t2) {
              let e3 = this._parseColorCache[t2];
              return e3 || (e3 = this._parseColorCache[t2] = Ft.parse(t2)), e3;
            }
          }
          class Wt {
            constructor(t2, e3, r2, n2) {
              this.name = t2, this.type = e3, this._evaluate = r2, this.args = n2;
            }
            evaluate(t2) {
              return this._evaluate(t2, this.args);
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return false;
            }
            static parse(t2, e3) {
              const r2 = t2[0], n2 = Wt.definitions[r2];
              if (!n2)
                return e3.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
              const i2 = Array.isArray(n2) ? n2[0] : n2.type, a2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, s2 = a2.filter(([e4]) => !Array.isArray(e4) || e4.length === t2.length - 1);
              let o2 = null;
              for (const [n3, a3] of s2) {
                o2 = new we(e3.registry, e3.path, null, e3.scope);
                const s3 = [];
                let l2 = false;
                for (let e4 = 1; e4 < t2.length; e4++) {
                  const r3 = t2[e4], i3 = Array.isArray(n3) ? n3[e4 - 1] : n3.type, a4 = o2.parse(r3, 1 + s3.length, i3);
                  if (!a4) {
                    l2 = true;
                    break;
                  }
                  s3.push(a4);
                }
                if (!l2)
                  if (Array.isArray(n3) && n3.length !== s3.length)
                    o2.error(`Expected ${n3.length} arguments, but found ${s3.length} instead.`);
                  else {
                    for (let t3 = 0; t3 < s3.length; t3++) {
                      const e4 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = s3[t3];
                      o2.concat(t3 + 1).checkSubtype(e4, r3.type);
                    }
                    if (0 === o2.errors.length)
                      return new Wt(r2, i2, a3, s3);
                  }
              }
              if (1 === s2.length)
                e3.errors.push(...o2.errors);
              else {
                const r3 = (s2.length ? s2 : a2).map(([t3]) => {
                  return e4 = t3, Array.isArray(e4) ? `(${e4.map(At).join(", ")})` : `(${At(e4.type)}...)`;
                  var e4;
                }).join(" | "), n3 = [];
                for (let r4 = 1; r4 < t2.length; r4++) {
                  const i3 = e3.parse(t2[r4], 1 + n3.length);
                  if (!i3)
                    return null;
                  n3.push(At(i3.type));
                }
                e3.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
              }
              return null;
            }
            static register(t2, e3) {
              Wt.definitions = e3;
              for (const r2 in e3)
                t2[r2] = Wt;
            }
          }
          class Qt {
            constructor(t2, e3, r2) {
              this.type = xt, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e3;
            }
            static parse(t2, e3) {
              if (2 !== t2.length)
                return e3.error("Expected one argument.");
              const r2 = t2[1];
              if ("object" != typeof r2 || Array.isArray(r2))
                return e3.error("Collator options argument must be an object.");
              const n2 = e3.parse(void 0 !== r2["case-sensitive"] && r2["case-sensitive"], 1, dt);
              if (!n2)
                return null;
              const i2 = e3.parse(void 0 !== r2["diacritic-sensitive"] && r2["diacritic-sensitive"], 1, dt);
              if (!i2)
                return null;
              let a2 = null;
              return r2.locale && (a2 = e3.parse(r2.locale, 1, ft), !a2) ? null : new Qt(n2, i2, a2);
            }
            evaluate(t2) {
              return new Tt(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
            }
            eachChild(t2) {
              t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
            }
            outputDefined() {
              return false;
            }
          }
          const te = 8192;
          function ee(t2, e3) {
            t2[0] = Math.min(t2[0], e3[0]), t2[1] = Math.min(t2[1], e3[1]), t2[2] = Math.max(t2[2], e3[0]), t2[3] = Math.max(t2[3], e3[1]);
          }
          function re(t2, e3) {
            return !(t2[0] <= e3[0] || t2[2] >= e3[2] || t2[1] <= e3[1] || t2[3] >= e3[3]);
          }
          function ne(t2, e3) {
            const r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e3.z);
            return [Math.round(r2 * i2 * te), Math.round(n2 * i2 * te)];
          }
          function ie(t2, e3, r2) {
            const n2 = t2[0] - e3[0], i2 = t2[1] - e3[1], a2 = t2[0] - r2[0], s2 = t2[1] - r2[1];
            return n2 * s2 - a2 * i2 == 0 && n2 * a2 <= 0 && i2 * s2 <= 0;
          }
          function ae(t2, e3) {
            let r2 = false;
            for (let s2 = 0, o2 = e3.length; s2 < o2; s2++) {
              const o3 = e3[s2];
              for (let e4 = 0, s3 = o3.length; e4 < s3 - 1; e4++) {
                if (ie(t2, o3[e4], o3[e4 + 1]))
                  return false;
                (i2 = o3[e4])[1] > (n2 = t2)[1] != (a2 = o3[e4 + 1])[1] > n2[1] && n2[0] < (a2[0] - i2[0]) * (n2[1] - i2[1]) / (a2[1] - i2[1]) + i2[0] && (r2 = !r2);
              }
            }
            var n2, i2, a2;
            return r2;
          }
          function se(t2, e3) {
            for (let r2 = 0; r2 < e3.length; r2++)
              if (ae(t2, e3[r2]))
                return true;
            return false;
          }
          function oe(t2, e3, r2, n2) {
            const i2 = n2[0] - r2[0], a2 = n2[1] - r2[1], s2 = (t2[0] - r2[0]) * a2 - i2 * (t2[1] - r2[1]), o2 = (e3[0] - r2[0]) * a2 - i2 * (e3[1] - r2[1]);
            return s2 > 0 && o2 < 0 || s2 < 0 && o2 > 0;
          }
          function le(t2, e3, r2) {
            for (const u2 of r2)
              for (let r3 = 0; r3 < u2.length - 1; ++r3)
                if (0 != (o2 = [(s2 = u2[r3 + 1])[0] - (a2 = u2[r3])[0], s2[1] - a2[1]])[0] * (l2 = [(i2 = e3)[0] - (n2 = t2)[0], i2[1] - n2[1]])[1] - o2[1] * l2[0] && oe(n2, i2, a2, s2) && oe(a2, s2, n2, i2))
                  return true;
            var n2, i2, a2, s2, o2, l2;
            return false;
          }
          function ue(t2, e3) {
            for (let r2 = 0; r2 < t2.length; ++r2)
              if (!ae(t2[r2], e3))
                return false;
            for (let r2 = 0; r2 < t2.length - 1; ++r2)
              if (le(t2[r2], t2[r2 + 1], e3))
                return false;
            return true;
          }
          function ce(t2, e3) {
            for (let r2 = 0; r2 < e3.length; r2++)
              if (ue(t2, e3[r2]))
                return true;
            return false;
          }
          function he(t2, e3, r2) {
            const n2 = [];
            for (let i2 = 0; i2 < t2.length; i2++) {
              const a2 = [];
              for (let n3 = 0; n3 < t2[i2].length; n3++) {
                const s2 = ne(t2[i2][n3], r2);
                ee(e3, s2), a2.push(s2);
              }
              n2.push(a2);
            }
            return n2;
          }
          function pe(t2, e3, r2) {
            const n2 = [];
            for (let i2 = 0; i2 < t2.length; i2++) {
              const a2 = he(t2[i2], e3, r2);
              n2.push(a2);
            }
            return n2;
          }
          function fe(t2, e3, r2, n2) {
            if (t2[0] < r2[0] || t2[0] > r2[2]) {
              const e4 = 0.5 * n2;
              let i2 = t2[0] - r2[0] > e4 ? -n2 : r2[0] - t2[0] > e4 ? n2 : 0;
              0 === i2 && (i2 = t2[0] - r2[2] > e4 ? -n2 : r2[2] - t2[0] > e4 ? n2 : 0), t2[0] += i2;
            }
            ee(e3, t2);
          }
          function de(t2, e3, r2, n2) {
            const i2 = Math.pow(2, n2.z) * te, a2 = [n2.x * te, n2.y * te], s2 = [];
            for (const n3 of t2)
              for (const t3 of n3) {
                const n4 = [t3.x + a2[0], t3.y + a2[1]];
                fe(n4, e3, r2, i2), s2.push(n4);
              }
            return s2;
          }
          function ye(t2, e3, r2, n2) {
            const i2 = Math.pow(2, n2.z) * te, a2 = [n2.x * te, n2.y * te], s2 = [];
            for (const r3 of t2) {
              const t3 = [];
              for (const n3 of r3) {
                const r4 = [n3.x + a2[0], n3.y + a2[1]];
                ee(e3, r4), t3.push(r4);
              }
              s2.push(t3);
            }
            if (e3[2] - e3[0] <= i2 / 2) {
              (o2 = e3)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
              for (const t3 of s2)
                for (const n3 of t3)
                  fe(n3, e3, r2, i2);
            }
            var o2;
            return s2;
          }
          class me {
            constructor(t2, e3) {
              this.type = dt, this.geojson = t2, this.geometries = e3;
            }
            static parse(t2, e3) {
              if (2 !== t2.length)
                return e3.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
              if (Ut(t2[1])) {
                const e4 = t2[1];
                if ("FeatureCollection" === e4.type)
                  for (let t3 = 0; t3 < e4.features.length; ++t3) {
                    const r2 = e4.features[t3].geometry.type;
                    if ("Polygon" === r2 || "MultiPolygon" === r2)
                      return new me(e4, e4.features[t3].geometry);
                  }
                else if ("Feature" === e4.type) {
                  const t3 = e4.geometry.type;
                  if ("Polygon" === t3 || "MultiPolygon" === t3)
                    return new me(e4, e4.geometry);
                } else if ("Polygon" === e4.type || "MultiPolygon" === e4.type)
                  return new me(e4, e4);
              }
              return e3.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t2) {
              if (null != t2.geometry() && null != t2.canonicalID()) {
                if ("Point" === t2.geometryType())
                  return function(t3, e3) {
                    const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                    if ("Polygon" === e3.type) {
                      const a2 = he(e3.coordinates, n2, i2), s2 = de(t3.geometry(), r2, n2, i2);
                      if (!re(r2, n2))
                        return false;
                      for (const t4 of s2)
                        if (!ae(t4, a2))
                          return false;
                    }
                    if ("MultiPolygon" === e3.type) {
                      const a2 = pe(e3.coordinates, n2, i2), s2 = de(t3.geometry(), r2, n2, i2);
                      if (!re(r2, n2))
                        return false;
                      for (const t4 of s2)
                        if (!se(t4, a2))
                          return false;
                    }
                    return true;
                  }(t2, this.geometries);
                if ("LineString" === t2.geometryType())
                  return function(t3, e3) {
                    const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                    if ("Polygon" === e3.type) {
                      const a2 = he(e3.coordinates, n2, i2), s2 = ye(t3.geometry(), r2, n2, i2);
                      if (!re(r2, n2))
                        return false;
                      for (const t4 of s2)
                        if (!ue(t4, a2))
                          return false;
                    }
                    if ("MultiPolygon" === e3.type) {
                      const a2 = pe(e3.coordinates, n2, i2), s2 = ye(t3.geometry(), r2, n2, i2);
                      if (!re(r2, n2))
                        return false;
                      for (const t4 of s2)
                        if (!ce(t4, a2))
                          return false;
                    }
                    return true;
                  }(t2, this.geometries);
              }
              return false;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
          }
          function ge(t2) {
            if (t2 instanceof Wt) {
              if ("get" === t2.name && 1 === t2.args.length)
                return false;
              if ("feature-state" === t2.name)
                return false;
              if ("has" === t2.name && 1 === t2.args.length)
                return false;
              if ("properties" === t2.name || "geometry-type" === t2.name || "id" === t2.name)
                return false;
              if (/^filter-/.test(t2.name))
                return false;
            }
            if (t2 instanceof me)
              return false;
            let e3 = true;
            return t2.eachChild((t3) => {
              e3 && !ge(t3) && (e3 = false);
            }), e3;
          }
          function xe(t2) {
            if (t2 instanceof Wt && "feature-state" === t2.name)
              return false;
            let e3 = true;
            return t2.eachChild((t3) => {
              e3 && !xe(t3) && (e3 = false);
            }), e3;
          }
          function ve(t2, e3) {
            if (t2 instanceof Wt && e3.indexOf(t2.name) >= 0)
              return false;
            let r2 = true;
            return t2.eachChild((t3) => {
              r2 && !ve(t3, e3) && (r2 = false);
            }), r2;
          }
          class be {
            constructor(t2, e3) {
              this.type = e3.type, this.name = t2, this.boundExpression = e3;
            }
            static parse(t2, e3) {
              if (2 !== t2.length || "string" != typeof t2[1])
                return e3.error("'var' expression requires exactly one string literal argument.");
              const r2 = t2[1];
              return e3.scope.has(r2) ? new be(r2, e3.scope.get(r2)) : e3.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t2) {
              return this.boundExpression.evaluate(t2);
            }
            eachChild() {
            }
            outputDefined() {
              return false;
            }
          }
          class we {
            constructor(t2, e3 = [], r2, n2 = new ct(), i2 = []) {
              this.registry = t2, this.path = e3, this.key = e3.map((t3) => `[${t3}]`).join(""), this.scope = n2, this.errors = i2, this.expectedType = r2;
            }
            parse(t2, e3, r2, n2, i2 = {}) {
              return e3 ? this.concat(e3, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
            }
            _parse(t2, e3) {
              function r2(t3, e4, r3) {
                return "assert" === r3 ? new Gt(e4, [t3]) : "coerce" === r3 ? new Xt(e4, [t3]) : t3;
              }
              if (null !== t2 && "string" != typeof t2 && "boolean" != typeof t2 && "number" != typeof t2 || (t2 = ["literal", t2]), Array.isArray(t2)) {
                if (0 === t2.length)
                  return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                const n2 = t2[0];
                if ("string" != typeof n2)
                  return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
                const i2 = this.registry[n2];
                if (i2) {
                  let n3 = i2.parse(t2, this);
                  if (!n3)
                    return null;
                  if (this.expectedType) {
                    const t3 = this.expectedType, i3 = n3.type;
                    if ("string" !== t3.kind && "number" !== t3.kind && "boolean" !== t3.kind && "object" !== t3.kind && "array" !== t3.kind || "value" !== i3.kind)
                      if ("color" !== t3.kind && "formatted" !== t3.kind && "resolvedImage" !== t3.kind || "value" !== i3.kind && "string" !== i3.kind)
                        if ("padding" !== t3.kind || "value" !== i3.kind && "number" !== i3.kind && "array" !== i3.kind) {
                          if (this.checkSubtype(t3, i3))
                            return null;
                        } else
                          n3 = r2(n3, t3, e3.typeAnnotation || "coerce");
                      else
                        n3 = r2(n3, t3, e3.typeAnnotation || "coerce");
                    else
                      n3 = r2(n3, t3, e3.typeAnnotation || "assert");
                  }
                  if (!(n3 instanceof Nt) && "resolvedImage" !== n3.type.kind && _e(n3)) {
                    const t3 = new Ht();
                    try {
                      n3 = new Nt(n3.type, n3.evaluate(t3));
                    } catch (t4) {
                      return this.error(t4.message), null;
                    }
                  }
                  return n3;
                }
                return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
              }
              return this.error(void 0 === t2 ? "'undefined' value invalid. Use null instead." : "object" == typeof t2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
            }
            concat(t2, e3, r2) {
              const n2 = "number" == typeof t2 ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
              return new we(this.registry, n2, e3 || null, i2, this.errors);
            }
            error(t2, ...e3) {
              const r2 = `${this.key}${e3.map((t3) => `[${t3}]`).join("")}`;
              this.errors.push(new ut(r2, t2));
            }
            checkSubtype(t2, e3) {
              const r2 = St(t2, e3);
              return r2 && this.error(r2), r2;
            }
          }
          function _e(t2) {
            if (t2 instanceof be)
              return _e(t2.boundExpression);
            if (t2 instanceof Wt && "error" === t2.name)
              return false;
            if (t2 instanceof Qt)
              return false;
            if (t2 instanceof me)
              return false;
            const e3 = t2 instanceof Xt || t2 instanceof Gt;
            let r2 = true;
            return t2.eachChild((t3) => {
              r2 = e3 ? r2 && _e(t3) : r2 && t3 instanceof Nt;
            }), !!r2 && ge(t2) && ve(t2, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
          }
          function Ae(t2, e3) {
            const r2 = t2.length - 1;
            let n2, i2, a2 = 0, s2 = r2, o2 = 0;
            for (; a2 <= s2; )
              if (o2 = Math.floor((a2 + s2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e3) {
                if (o2 === r2 || e3 < i2)
                  return o2;
                a2 = o2 + 1;
              } else {
                if (!(n2 > e3))
                  throw new Zt("Input is not a number.");
                s2 = o2 - 1;
              }
            return 0;
          }
          class ke {
            constructor(t2, e3, r2) {
              this.type = t2, this.input = e3, this.labels = [], this.outputs = [];
              for (const [t3, e4] of r2)
                this.labels.push(t3), this.outputs.push(e4);
            }
            static parse(t2, e3) {
              if (t2.length - 1 < 4)
                return e3.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if ((t2.length - 1) % 2 != 0)
                return e3.error("Expected an even number of arguments.");
              const r2 = e3.parse(t2[1], 1, pt);
              if (!r2)
                return null;
              const n2 = [];
              let i2 = null;
              e3.expectedType && "value" !== e3.expectedType.kind && (i2 = e3.expectedType);
              for (let r3 = 1; r3 < t2.length; r3 += 2) {
                const a2 = 1 === r3 ? -1 / 0 : t2[r3], s2 = t2[r3 + 1], o2 = r3, l2 = r3 + 1;
                if ("number" != typeof a2)
                  return e3.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
                if (n2.length && n2[n2.length - 1][0] >= a2)
                  return e3.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
                const u2 = e3.parse(s2, l2, i2);
                if (!u2)
                  return null;
                i2 = i2 || u2.type, n2.push([a2, u2]);
              }
              return new ke(i2, r2, n2);
            }
            evaluate(t2) {
              const e3 = this.labels, r2 = this.outputs;
              if (1 === e3.length)
                return r2[0].evaluate(t2);
              const n2 = this.input.evaluate(t2);
              if (n2 <= e3[0])
                return r2[0].evaluate(t2);
              const i2 = e3.length;
              return n2 >= e3[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[Ae(e3, n2)].evaluate(t2);
            }
            eachChild(t2) {
              t2(this.input);
              for (const e3 of this.outputs)
                t2(e3);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined());
            }
          }
          function Se(t2, e3, r2) {
            return t2 * (1 - r2) + e3 * r2;
          }
          var Ie = Object.freeze({ __proto__: null, number: Se, color: function(t2, e3, r2) {
            return new Ft(Se(t2.r, e3.r, r2), Se(t2.g, e3.g, r2), Se(t2.b, e3.b, r2), Se(t2.a, e3.a, r2));
          }, array: function(t2, e3, r2) {
            return t2.map((t3, n2) => Se(t3, e3[n2], r2));
          }, padding: function(t2, e3, r2) {
            const n2 = t2.values, i2 = e3.values;
            return new $t([Se(n2[0], i2[0], r2), Se(n2[1], i2[1], r2), Se(n2[2], i2[2], r2), Se(n2[3], i2[3], r2)]);
          } });
          const Me = 0.95047, ze = 1.08883, Be = 4 / 29, Ce = 6 / 29, Pe = 3 * Ce * Ce, Ve = Math.PI / 180, Ee = 180 / Math.PI;
          function Fe(t2) {
            return t2 > 0.008856451679035631 ? Math.pow(t2, 1 / 3) : t2 / Pe + Be;
          }
          function Te(t2) {
            return t2 > Ce ? t2 * t2 * t2 : Pe * (t2 - Be);
          }
          function Le(t2) {
            return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
          }
          function De(t2) {
            return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
          }
          function $e(t2) {
            const e3 = De(t2.r), r2 = De(t2.g), n2 = De(t2.b), i2 = Fe((0.4124564 * e3 + 0.3575761 * r2 + 0.1804375 * n2) / Me), a2 = Fe((0.2126729 * e3 + 0.7151522 * r2 + 0.072175 * n2) / 1);
            return { l: 116 * a2 - 16, a: 500 * (i2 - a2), b: 200 * (a2 - Fe((0.0193339 * e3 + 0.119192 * r2 + 0.9503041 * n2) / ze)), alpha: t2.a };
          }
          function Re(t2) {
            let e3 = (t2.l + 16) / 116, r2 = isNaN(t2.a) ? e3 : e3 + t2.a / 500, n2 = isNaN(t2.b) ? e3 : e3 - t2.b / 200;
            return e3 = 1 * Te(e3), r2 = Me * Te(r2), n2 = ze * Te(n2), new Ft(Le(3.2404542 * r2 - 1.5371385 * e3 - 0.4985314 * n2), Le(-0.969266 * r2 + 1.8760108 * e3 + 0.041556 * n2), Le(0.0556434 * r2 - 0.2040259 * e3 + 1.0572252 * n2), t2.alpha);
          }
          function Oe(t2, e3, r2) {
            const n2 = e3 - t2;
            return t2 + r2 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
          }
          const Ue = { forward: $e, reverse: Re, interpolate: function(t2, e3, r2) {
            return { l: Se(t2.l, e3.l, r2), a: Se(t2.a, e3.a, r2), b: Se(t2.b, e3.b, r2), alpha: Se(t2.alpha, e3.alpha, r2) };
          } }, qe = { forward: function(t2) {
            const { l: e3, a: r2, b: n2 } = $e(t2), i2 = Math.atan2(n2, r2) * Ee;
            return { h: i2 < 0 ? i2 + 360 : i2, c: Math.sqrt(r2 * r2 + n2 * n2), l: e3, alpha: t2.a };
          }, reverse: function(t2) {
            const e3 = t2.h * Ve, r2 = t2.c;
            return Re({ l: t2.l, a: Math.cos(e3) * r2, b: Math.sin(e3) * r2, alpha: t2.alpha });
          }, interpolate: function(t2, e3, r2) {
            return { h: Oe(t2.h, e3.h, r2), c: Se(t2.c, e3.c, r2), l: Se(t2.l, e3.l, r2), alpha: Se(t2.alpha, e3.alpha, r2) };
          } };
          var je = Object.freeze({ __proto__: null, lab: Ue, hcl: qe });
          class Ne {
            constructor(t2, e3, r2, n2, i2) {
              this.type = t2, this.operator = e3, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
              for (const [t3, e4] of i2)
                this.labels.push(t3), this.outputs.push(e4);
            }
            static interpolationFactor(t2, r2, n2, i2) {
              let a2 = 0;
              if ("exponential" === t2.name)
                a2 = Ze(r2, t2.base, n2, i2);
              else if ("linear" === t2.name)
                a2 = Ze(r2, 1, n2, i2);
              else if ("cubic-bezier" === t2.name) {
                const s2 = t2.controlPoints;
                a2 = new e(s2[0], s2[1], s2[2], s2[3]).solve(Ze(r2, 1, n2, i2));
              }
              return a2;
            }
            static parse(t2, e3) {
              let [r2, n2, i2, ...a2] = t2;
              if (!Array.isArray(n2) || 0 === n2.length)
                return e3.error("Expected an interpolation type expression.", 1);
              if ("linear" === n2[0])
                n2 = { name: "linear" };
              else if ("exponential" === n2[0]) {
                const t3 = n2[1];
                if ("number" != typeof t3)
                  return e3.error("Exponential interpolation requires a numeric base.", 1, 1);
                n2 = { name: "exponential", base: t3 };
              } else {
                if ("cubic-bezier" !== n2[0])
                  return e3.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
                {
                  const t3 = n2.slice(1);
                  if (4 !== t3.length || t3.some((t4) => "number" != typeof t4 || t4 < 0 || t4 > 1))
                    return e3.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                  n2 = { name: "cubic-bezier", controlPoints: t3 };
                }
              }
              if (t2.length - 1 < 4)
                return e3.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if ((t2.length - 1) % 2 != 0)
                return e3.error("Expected an even number of arguments.");
              if (i2 = e3.parse(i2, 2, pt), !i2)
                return null;
              const s2 = [];
              let o2 = null;
              "interpolate-hcl" === r2 || "interpolate-lab" === r2 ? o2 = yt : e3.expectedType && "value" !== e3.expectedType.kind && (o2 = e3.expectedType);
              for (let t3 = 0; t3 < a2.length; t3 += 2) {
                const r3 = a2[t3], n3 = a2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
                if ("number" != typeof r3)
                  return e3.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
                if (s2.length && s2[s2.length - 1][0] >= r3)
                  return e3.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
                const u2 = e3.parse(n3, l2, o2);
                if (!u2)
                  return null;
                o2 = o2 || u2.type, s2.push([r3, u2]);
              }
              return "number" === o2.kind || "color" === o2.kind || "padding" === o2.kind || "array" === o2.kind && "number" === o2.itemType.kind && "number" == typeof o2.N ? new Ne(o2, r2, n2, i2, s2) : e3.error(`Type ${At(o2)} is not interpolatable.`);
            }
            evaluate(t2) {
              const e3 = this.labels, r2 = this.outputs;
              if (1 === e3.length)
                return r2[0].evaluate(t2);
              const n2 = this.input.evaluate(t2);
              if (n2 <= e3[0])
                return r2[0].evaluate(t2);
              const i2 = e3.length;
              if (n2 >= e3[i2 - 1])
                return r2[i2 - 1].evaluate(t2);
              const a2 = Ae(e3, n2), s2 = Ne.interpolationFactor(this.interpolation, n2, e3[a2], e3[a2 + 1]), o2 = r2[a2].evaluate(t2), l2 = r2[a2 + 1].evaluate(t2);
              return "interpolate" === this.operator ? Ie[this.type.kind.toLowerCase()](o2, l2, s2) : "interpolate-hcl" === this.operator ? qe.reverse(qe.interpolate(qe.forward(o2), qe.forward(l2), s2)) : Ue.reverse(Ue.interpolate(Ue.forward(o2), Ue.forward(l2), s2));
            }
            eachChild(t2) {
              t2(this.input);
              for (const e3 of this.outputs)
                t2(e3);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined());
            }
          }
          function Ze(t2, e3, r2, n2) {
            const i2 = n2 - r2, a2 = t2 - r2;
            return 0 === i2 ? 0 : 1 === e3 ? a2 / i2 : (Math.pow(e3, a2) - 1) / (Math.pow(e3, i2) - 1);
          }
          class Ke {
            constructor(t2, e3) {
              this.type = t2, this.args = e3;
            }
            static parse(t2, e3) {
              if (t2.length < 2)
                return e3.error("Expectected at least one argument.");
              let r2 = null;
              const n2 = e3.expectedType;
              n2 && "value" !== n2.kind && (r2 = n2);
              const i2 = [];
              for (const n3 of t2.slice(1)) {
                const t3 = e3.parse(n3, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
                if (!t3)
                  return null;
                r2 = r2 || t3.type, i2.push(t3);
              }
              if (!r2)
                throw new Error("No output type");
              const a2 = n2 && i2.some((t3) => St(n2, t3.type));
              return new Ke(a2 ? gt : r2, i2);
            }
            evaluate(t2) {
              let e3, r2 = null, n2 = 0;
              for (const i2 of this.args)
                if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof Rt && !r2.available && (e3 || (e3 = r2.name), r2 = null, n2 === this.args.length && (r2 = e3)), null !== r2)
                  break;
              return r2;
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
          }
          class Ge {
            constructor(t2, e3) {
              this.type = e3.type, this.bindings = [].concat(t2), this.result = e3;
            }
            evaluate(t2) {
              return this.result.evaluate(t2);
            }
            eachChild(t2) {
              for (const e3 of this.bindings)
                t2(e3[1]);
              t2(this.result);
            }
            static parse(t2, e3) {
              if (t2.length < 4)
                return e3.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
              const r2 = [];
              for (let n3 = 1; n3 < t2.length - 1; n3 += 2) {
                const i2 = t2[n3];
                if ("string" != typeof i2)
                  return e3.error(`Expected string, but found ${typeof i2} instead.`, n3);
                if (/[^a-zA-Z0-9_]/.test(i2))
                  return e3.error("Variable names must contain only alphanumeric characters or '_'.", n3);
                const a2 = e3.parse(t2[n3 + 1], n3 + 1);
                if (!a2)
                  return null;
                r2.push([i2, a2]);
              }
              const n2 = e3.parse(t2[t2.length - 1], t2.length - 1, e3.expectedType, r2);
              return n2 ? new Ge(r2, n2) : null;
            }
            outputDefined() {
              return this.result.outputDefined();
            }
          }
          class Je {
            constructor(t2, e3, r2) {
              this.type = t2, this.index = e3, this.input = r2;
            }
            static parse(t2, e3) {
              if (3 !== t2.length)
                return e3.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e3.parse(t2[1], 1, pt), n2 = e3.parse(t2[2], 2, _t(e3.expectedType || gt));
              return r2 && n2 ? new Je(n2.type.itemType, r2, n2) : null;
            }
            evaluate(t2) {
              const e3 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
              if (e3 < 0)
                throw new Zt(`Array index out of bounds: ${e3} < 0.`);
              if (e3 >= r2.length)
                throw new Zt(`Array index out of bounds: ${e3} > ${r2.length - 1}.`);
              if (e3 !== Math.floor(e3))
                throw new Zt(`Array index must be an integer, but found ${e3} instead.`);
              return r2[e3];
            }
            eachChild(t2) {
              t2(this.index), t2(this.input);
            }
            outputDefined() {
              return false;
            }
          }
          class Xe {
            constructor(t2, e3) {
              this.type = dt, this.needle = t2, this.haystack = e3;
            }
            static parse(t2, e3) {
              if (3 !== t2.length)
                return e3.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e3.parse(t2[1], 1, gt), n2 = e3.parse(t2[2], 2, gt);
              return r2 && n2 ? It(r2.type, [dt, ft, pt, ht, gt]) ? new Xe(r2, n2) : e3.error(`Expected first argument to be of type boolean, string, number or null, but found ${At(r2.type)} instead`) : null;
            }
            evaluate(t2) {
              const e3 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
              if (!r2)
                return false;
              if (!Mt(e3, ["boolean", "string", "number", "null"]))
                throw new Zt(`Expected first argument to be of type boolean, string, number or null, but found ${At(qt(e3))} instead.`);
              if (!Mt(r2, ["string", "array"]))
                throw new Zt(`Expected second argument to be of type array or string, but found ${At(qt(r2))} instead.`);
              return r2.indexOf(e3) >= 0;
            }
            eachChild(t2) {
              t2(this.needle), t2(this.haystack);
            }
            outputDefined() {
              return true;
            }
          }
          class Ye {
            constructor(t2, e3, r2) {
              this.type = pt, this.needle = t2, this.haystack = e3, this.fromIndex = r2;
            }
            static parse(t2, e3) {
              if (t2.length <= 2 || t2.length >= 5)
                return e3.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e3.parse(t2[1], 1, gt), n2 = e3.parse(t2[2], 2, gt);
              if (!r2 || !n2)
                return null;
              if (!It(r2.type, [dt, ft, pt, ht, gt]))
                return e3.error(`Expected first argument to be of type boolean, string, number or null, but found ${At(r2.type)} instead`);
              if (4 === t2.length) {
                const i2 = e3.parse(t2[3], 3, pt);
                return i2 ? new Ye(r2, n2, i2) : null;
              }
              return new Ye(r2, n2);
            }
            evaluate(t2) {
              const e3 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
              if (!Mt(e3, ["boolean", "string", "number", "null"]))
                throw new Zt(`Expected first argument to be of type boolean, string, number or null, but found ${At(qt(e3))} instead.`);
              if (!Mt(r2, ["string", "array"]))
                throw new Zt(`Expected second argument to be of type array or string, but found ${At(qt(r2))} instead.`);
              if (this.fromIndex) {
                const n2 = this.fromIndex.evaluate(t2);
                return r2.indexOf(e3, n2);
              }
              return r2.indexOf(e3);
            }
            eachChild(t2) {
              t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
            }
            outputDefined() {
              return false;
            }
          }
          class He {
            constructor(t2, e3, r2, n2, i2, a2) {
              this.inputType = t2, this.type = e3, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = a2;
            }
            static parse(t2, e3) {
              if (t2.length < 5)
                return e3.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if (t2.length % 2 != 1)
                return e3.error("Expected an even number of arguments.");
              let r2, n2;
              e3.expectedType && "value" !== e3.expectedType.kind && (n2 = e3.expectedType);
              const i2 = {}, a2 = [];
              for (let s3 = 2; s3 < t2.length - 1; s3 += 2) {
                let o3 = t2[s3];
                const l2 = t2[s3 + 1];
                Array.isArray(o3) || (o3 = [o3]);
                const u2 = e3.concat(s3);
                if (0 === o3.length)
                  return u2.error("Expected at least one branch label.");
                for (const t3 of o3) {
                  if ("number" != typeof t3 && "string" != typeof t3)
                    return u2.error("Branch labels must be numbers or strings.");
                  if ("number" == typeof t3 && Math.abs(t3) > Number.MAX_SAFE_INTEGER)
                    return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                  if ("number" == typeof t3 && Math.floor(t3) !== t3)
                    return u2.error("Numeric branch labels must be integer values.");
                  if (r2) {
                    if (u2.checkSubtype(r2, qt(t3)))
                      return null;
                  } else
                    r2 = qt(t3);
                  if (void 0 !== i2[String(t3)])
                    return u2.error("Branch labels must be unique.");
                  i2[String(t3)] = a2.length;
                }
                const c2 = e3.parse(l2, s3, n2);
                if (!c2)
                  return null;
                n2 = n2 || c2.type, a2.push(c2);
              }
              const s2 = e3.parse(t2[1], 1, gt);
              if (!s2)
                return null;
              const o2 = e3.parse(t2[t2.length - 1], t2.length - 1, n2);
              return o2 ? "value" !== s2.type.kind && e3.concat(1).checkSubtype(r2, s2.type) ? null : new He(r2, n2, s2, i2, a2, o2) : null;
            }
            evaluate(t2) {
              const e3 = this.input.evaluate(t2);
              return (qt(e3) === this.inputType && this.outputs[this.cases[e3]] || this.otherwise).evaluate(t2);
            }
            eachChild(t2) {
              t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
            }
          }
          class We {
            constructor(t2, e3, r2) {
              this.type = t2, this.branches = e3, this.otherwise = r2;
            }
            static parse(t2, e3) {
              if (t2.length < 4)
                return e3.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
              if (t2.length % 2 != 0)
                return e3.error("Expected an odd number of arguments.");
              let r2;
              e3.expectedType && "value" !== e3.expectedType.kind && (r2 = e3.expectedType);
              const n2 = [];
              for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
                const a2 = e3.parse(t2[i3], i3, dt);
                if (!a2)
                  return null;
                const s2 = e3.parse(t2[i3 + 1], i3 + 1, r2);
                if (!s2)
                  return null;
                n2.push([a2, s2]), r2 = r2 || s2.type;
              }
              const i2 = e3.parse(t2[t2.length - 1], t2.length - 1, r2);
              if (!i2)
                return null;
              if (!r2)
                throw new Error("Can't infer output type");
              return new We(r2, n2, i2);
            }
            evaluate(t2) {
              for (const [e3, r2] of this.branches)
                if (e3.evaluate(t2))
                  return r2.evaluate(t2);
              return this.otherwise.evaluate(t2);
            }
            eachChild(t2) {
              for (const [e3, r2] of this.branches)
                t2(e3), t2(r2);
              t2(this.otherwise);
            }
            outputDefined() {
              return this.branches.every(([t2, e3]) => e3.outputDefined()) && this.otherwise.outputDefined();
            }
          }
          class Qe {
            constructor(t2, e3, r2, n2) {
              this.type = t2, this.input = e3, this.beginIndex = r2, this.endIndex = n2;
            }
            static parse(t2, e3) {
              if (t2.length <= 2 || t2.length >= 5)
                return e3.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e3.parse(t2[1], 1, gt), n2 = e3.parse(t2[2], 2, pt);
              if (!r2 || !n2)
                return null;
              if (!It(r2.type, [_t(gt), ft, gt]))
                return e3.error(`Expected first argument to be of type array or string, but found ${At(r2.type)} instead`);
              if (4 === t2.length) {
                const i2 = e3.parse(t2[3], 3, pt);
                return i2 ? new Qe(r2.type, r2, n2, i2) : null;
              }
              return new Qe(r2.type, r2, n2);
            }
            evaluate(t2) {
              const e3 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
              if (!Mt(e3, ["string", "array"]))
                throw new Zt(`Expected first argument to be of type array or string, but found ${At(qt(e3))} instead.`);
              if (this.endIndex) {
                const n2 = this.endIndex.evaluate(t2);
                return e3.slice(r2, n2);
              }
              return e3.slice(r2);
            }
            eachChild(t2) {
              t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
            }
            outputDefined() {
              return false;
            }
          }
          function tr(t2, e3) {
            return "==" === t2 || "!=" === t2 ? "boolean" === e3.kind || "string" === e3.kind || "number" === e3.kind || "null" === e3.kind || "value" === e3.kind : "string" === e3.kind || "number" === e3.kind || "value" === e3.kind;
          }
          function er(t2, e3, r2, n2) {
            return 0 === n2.compare(e3, r2);
          }
          function rr(t2, e3, r2) {
            const n2 = "==" !== t2 && "!=" !== t2;
            return class i2 {
              constructor(t3, e4, r3) {
                this.type = dt, this.lhs = t3, this.rhs = e4, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e4.type.kind;
              }
              static parse(t3, e4) {
                if (3 !== t3.length && 4 !== t3.length)
                  return e4.error("Expected two or three arguments.");
                const r3 = t3[0];
                let a2 = e4.parse(t3[1], 1, gt);
                if (!a2)
                  return null;
                if (!tr(r3, a2.type))
                  return e4.concat(1).error(`"${r3}" comparisons are not supported for type '${At(a2.type)}'.`);
                let s2 = e4.parse(t3[2], 2, gt);
                if (!s2)
                  return null;
                if (!tr(r3, s2.type))
                  return e4.concat(2).error(`"${r3}" comparisons are not supported for type '${At(s2.type)}'.`);
                if (a2.type.kind !== s2.type.kind && "value" !== a2.type.kind && "value" !== s2.type.kind)
                  return e4.error(`Cannot compare types '${At(a2.type)}' and '${At(s2.type)}'.`);
                n2 && ("value" === a2.type.kind && "value" !== s2.type.kind ? a2 = new Gt(s2.type, [a2]) : "value" !== a2.type.kind && "value" === s2.type.kind && (s2 = new Gt(a2.type, [s2])));
                let o2 = null;
                if (4 === t3.length) {
                  if ("string" !== a2.type.kind && "string" !== s2.type.kind && "value" !== a2.type.kind && "value" !== s2.type.kind)
                    return e4.error("Cannot use collator to compare non-string types.");
                  if (o2 = e4.parse(t3[3], 3, xt), !o2)
                    return null;
                }
                return new i2(a2, s2, o2);
              }
              evaluate(i3) {
                const a2 = this.lhs.evaluate(i3), s2 = this.rhs.evaluate(i3);
                if (n2 && this.hasUntypedArgument) {
                  const e4 = qt(a2), r3 = qt(s2);
                  if (e4.kind !== r3.kind || "string" !== e4.kind && "number" !== e4.kind)
                    throw new Zt(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e4.kind}, ${r3.kind}) instead.`);
                }
                if (this.collator && !n2 && this.hasUntypedArgument) {
                  const t3 = qt(a2), r3 = qt(s2);
                  if ("string" !== t3.kind || "string" !== r3.kind)
                    return e3(i3, a2, s2);
                }
                return this.collator ? r2(i3, a2, s2, this.collator.evaluate(i3)) : e3(i3, a2, s2);
              }
              eachChild(t3) {
                t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
              }
              outputDefined() {
                return true;
              }
            };
          }
          const nr = rr("==", function(t2, e3, r2) {
            return e3 === r2;
          }, er), ir = rr("!=", function(t2, e3, r2) {
            return e3 !== r2;
          }, function(t2, e3, r2, n2) {
            return !er(0, e3, r2, n2);
          }), ar = rr("<", function(t2, e3, r2) {
            return e3 < r2;
          }, function(t2, e3, r2, n2) {
            return n2.compare(e3, r2) < 0;
          }), sr = rr(">", function(t2, e3, r2) {
            return e3 > r2;
          }, function(t2, e3, r2, n2) {
            return n2.compare(e3, r2) > 0;
          }), or = rr("<=", function(t2, e3, r2) {
            return e3 <= r2;
          }, function(t2, e3, r2, n2) {
            return n2.compare(e3, r2) <= 0;
          }), lr = rr(">=", function(t2, e3, r2) {
            return e3 >= r2;
          }, function(t2, e3, r2, n2) {
            return n2.compare(e3, r2) >= 0;
          });
          class ur {
            constructor(t2, e3, r2, n2, i2) {
              this.type = ft, this.number = t2, this.locale = e3, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i2;
            }
            static parse(t2, e3) {
              if (3 !== t2.length)
                return e3.error("Expected two arguments.");
              const r2 = e3.parse(t2[1], 1, pt);
              if (!r2)
                return null;
              const n2 = t2[2];
              if ("object" != typeof n2 || Array.isArray(n2))
                return e3.error("NumberFormat options argument must be an object.");
              let i2 = null;
              if (n2.locale && (i2 = e3.parse(n2.locale, 1, ft), !i2))
                return null;
              let a2 = null;
              if (n2.currency && (a2 = e3.parse(n2.currency, 1, ft), !a2))
                return null;
              let s2 = null;
              if (n2["min-fraction-digits"] && (s2 = e3.parse(n2["min-fraction-digits"], 1, pt), !s2))
                return null;
              let o2 = null;
              return n2["max-fraction-digits"] && (o2 = e3.parse(n2["max-fraction-digits"], 1, pt), !o2) ? null : new ur(r2, i2, a2, s2, o2);
            }
            evaluate(t2) {
              return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
            }
            eachChild(t2) {
              t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
            }
            outputDefined() {
              return false;
            }
          }
          class cr {
            constructor(t2) {
              this.type = vt, this.sections = t2;
            }
            static parse(t2, e3) {
              if (t2.length < 2)
                return e3.error("Expected at least one argument.");
              const r2 = t2[1];
              if (!Array.isArray(r2) && "object" == typeof r2)
                return e3.error("First argument must be an image or text section.");
              const n2 = [];
              let i2 = false;
              for (let r3 = 1; r3 <= t2.length - 1; ++r3) {
                const a2 = t2[r3];
                if (i2 && "object" == typeof a2 && !Array.isArray(a2)) {
                  i2 = false;
                  let t3 = null;
                  if (a2["font-scale"] && (t3 = e3.parse(a2["font-scale"], 1, pt), !t3))
                    return null;
                  let r4 = null;
                  if (a2["text-font"] && (r4 = e3.parse(a2["text-font"], 1, _t(ft)), !r4))
                    return null;
                  let s2 = null;
                  if (a2["text-color"] && (s2 = e3.parse(a2["text-color"], 1, yt), !s2))
                    return null;
                  const o2 = n2[n2.length - 1];
                  o2.scale = t3, o2.font = r4, o2.textColor = s2;
                } else {
                  const a3 = e3.parse(t2[r3], 1, gt);
                  if (!a3)
                    return null;
                  const s2 = a3.type.kind;
                  if ("string" !== s2 && "value" !== s2 && "null" !== s2 && "resolvedImage" !== s2)
                    return e3.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                  i2 = true, n2.push({ content: a3, scale: null, font: null, textColor: null });
                }
              }
              return new cr(n2);
            }
            evaluate(t2) {
              return new Dt(this.sections.map((e3) => {
                const r2 = e3.content.evaluate(t2);
                return qt(r2) === wt ? new Lt("", r2, null, null, null) : new Lt(jt(r2), null, e3.scale ? e3.scale.evaluate(t2) : null, e3.font ? e3.font.evaluate(t2).join(",") : null, e3.textColor ? e3.textColor.evaluate(t2) : null);
              }));
            }
            eachChild(t2) {
              for (const e3 of this.sections)
                t2(e3.content), e3.scale && t2(e3.scale), e3.font && t2(e3.font), e3.textColor && t2(e3.textColor);
            }
            outputDefined() {
              return false;
            }
          }
          class hr {
            constructor(t2) {
              this.type = wt, this.input = t2;
            }
            static parse(t2, e3) {
              if (2 !== t2.length)
                return e3.error("Expected two arguments.");
              const r2 = e3.parse(t2[1], 1, ft);
              return r2 ? new hr(r2) : e3.error("No image name provided.");
            }
            evaluate(t2) {
              const e3 = this.input.evaluate(t2), r2 = Rt.fromString(e3);
              return r2 && t2.availableImages && (r2.available = t2.availableImages.indexOf(e3) > -1), r2;
            }
            eachChild(t2) {
              t2(this.input);
            }
            outputDefined() {
              return false;
            }
          }
          class pr {
            constructor(t2) {
              this.type = pt, this.input = t2;
            }
            static parse(t2, e3) {
              if (2 !== t2.length)
                return e3.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
              const r2 = e3.parse(t2[1], 1);
              return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e3.error(`Expected argument of type string or array, but found ${At(r2.type)} instead.`) : new pr(r2) : null;
            }
            evaluate(t2) {
              const e3 = this.input.evaluate(t2);
              if ("string" == typeof e3)
                return e3.length;
              if (Array.isArray(e3))
                return e3.length;
              throw new Zt(`Expected value to be of type string or array, but found ${At(qt(e3))} instead.`);
            }
            eachChild(t2) {
              t2(this.input);
            }
            outputDefined() {
              return false;
            }
          }
          const fr = { "==": nr, "!=": ir, ">": sr, "<": ar, ">=": lr, "<=": or, array: Gt, at: Je, boolean: Gt, case: We, coalesce: Ke, collator: Qt, format: cr, image: hr, in: Xe, "index-of": Ye, interpolate: Ne, "interpolate-hcl": Ne, "interpolate-lab": Ne, length: pr, let: Ge, literal: Nt, match: He, number: Gt, "number-format": ur, object: Gt, slice: Qe, step: ke, string: Gt, "to-boolean": Xt, "to-color": Xt, "to-number": Xt, "to-string": Xt, var: be, within: me };
          function dr(t2, [e3, r2, n2, i2]) {
            e3 = e3.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
            const a2 = i2 ? i2.evaluate(t2) : 1, s2 = Ot(e3, r2, n2, a2);
            if (s2)
              throw new Zt(s2);
            return new Ft(e3 / 255 * a2, r2 / 255 * a2, n2 / 255 * a2, a2);
          }
          function yr(t2, e3) {
            return t2 in e3;
          }
          function mr(t2, e3) {
            const r2 = e3[t2];
            return void 0 === r2 ? null : r2;
          }
          function gr(t2) {
            return { type: t2 };
          }
          function xr(t2) {
            return { result: "success", value: t2 };
          }
          function vr(t2) {
            return { result: "error", value: t2 };
          }
          function br(t2) {
            return "data-driven" === t2["property-type"] || "cross-faded-data-driven" === t2["property-type"];
          }
          function wr(t2) {
            return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
          }
          function _r(t2) {
            return !!t2.expression && t2.expression.interpolated;
          }
          function Ar(t2) {
            return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
          }
          function kr(t2) {
            return "object" == typeof t2 && null !== t2 && !Array.isArray(t2);
          }
          function Sr(t2) {
            return t2;
          }
          function Ir(t2, e3) {
            const r2 = "color" === e3.type, n2 = t2.stops && "object" == typeof t2.stops[0][0], i2 = n2 || !(n2 || void 0 !== t2.property), a2 = t2.type || (_r(e3) ? "exponential" : "interval");
            if (r2 || "padding" === e3.type) {
              const n3 = r2 ? Ft.parse : $t.parse;
              (t2 = st({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], n3(t3[1])])), t2.default = n3(t2.default ? t2.default : e3.default);
            }
            if (t2.colorSpace && "rgb" !== t2.colorSpace && !je[t2.colorSpace])
              throw new Error(`Unknown color space: ${t2.colorSpace}`);
            let s2, o2, l2;
            if ("exponential" === a2)
              s2 = Cr;
            else if ("interval" === a2)
              s2 = Br;
            else if ("categorical" === a2) {
              s2 = zr, o2 = /* @__PURE__ */ Object.create(null);
              for (const e4 of t2.stops)
                o2[e4[0]] = e4[1];
              l2 = typeof t2.stops[0][0];
            } else {
              if ("identity" !== a2)
                throw new Error(`Unknown function type "${a2}"`);
              s2 = Pr;
            }
            if (n2) {
              const r3 = {}, n3 = [];
              for (let e4 = 0; e4 < t2.stops.length; e4++) {
                const i4 = t2.stops[e4], a4 = i4[0].zoom;
                void 0 === r3[a4] && (r3[a4] = { zoom: a4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(a4)), r3[a4].stops.push([i4[0].value, i4[1]]);
              }
              const i3 = [];
              for (const t3 of n3)
                i3.push([r3[t3].zoom, Ir(r3[t3], e3)]);
              const a3 = { name: "linear" };
              return { kind: "composite", interpolationType: a3, interpolationFactor: Ne.interpolationFactor.bind(void 0, a3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => Cr({ stops: i3, base: t2.base }, e3, r4).evaluate(r4, n4) };
            }
            if (i2) {
              const r3 = "exponential" === a2 ? { name: "exponential", base: void 0 !== t2.base ? t2.base : 1 } : null;
              return { kind: "camera", interpolationType: r3, interpolationFactor: Ne.interpolationFactor.bind(void 0, r3), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => s2(t2, e3, r4, o2, l2) };
            }
            return { kind: "source", evaluate(r3, n3) {
              const i3 = n3 && n3.properties ? n3.properties[t2.property] : void 0;
              return void 0 === i3 ? Mr(t2.default, e3.default) : s2(t2, e3, i3, o2, l2);
            } };
          }
          function Mr(t2, e3, r2) {
            return void 0 !== t2 ? t2 : void 0 !== e3 ? e3 : void 0 !== r2 ? r2 : void 0;
          }
          function zr(t2, e3, r2, n2, i2) {
            return Mr(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e3.default);
          }
          function Br(t2, e3, r2) {
            if ("number" !== Ar(r2))
              return Mr(t2.default, e3.default);
            const n2 = t2.stops.length;
            if (1 === n2)
              return t2.stops[0][1];
            if (r2 <= t2.stops[0][0])
              return t2.stops[0][1];
            if (r2 >= t2.stops[n2 - 1][0])
              return t2.stops[n2 - 1][1];
            const i2 = Ae(t2.stops.map((t3) => t3[0]), r2);
            return t2.stops[i2][1];
          }
          function Cr(t2, e3, r2) {
            const n2 = void 0 !== t2.base ? t2.base : 1;
            if ("number" !== Ar(r2))
              return Mr(t2.default, e3.default);
            const i2 = t2.stops.length;
            if (1 === i2)
              return t2.stops[0][1];
            if (r2 <= t2.stops[0][0])
              return t2.stops[0][1];
            if (r2 >= t2.stops[i2 - 1][0])
              return t2.stops[i2 - 1][1];
            const a2 = Ae(t2.stops.map((t3) => t3[0]), r2), s2 = function(t3, e4, r3, n3) {
              const i3 = n3 - r3, a3 = t3 - r3;
              return 0 === i3 ? 0 : 1 === e4 ? a3 / i3 : (Math.pow(e4, a3) - 1) / (Math.pow(e4, i3) - 1);
            }(r2, n2, t2.stops[a2][0], t2.stops[a2 + 1][0]), o2 = t2.stops[a2][1], l2 = t2.stops[a2 + 1][1];
            let u2 = Ie[e3.type] || Sr;
            if (t2.colorSpace && "rgb" !== t2.colorSpace) {
              const e4 = je[t2.colorSpace];
              u2 = (t3, r3) => e4.reverse(e4.interpolate(e4.forward(t3), e4.forward(r3), s2));
            }
            return "function" == typeof o2.evaluate ? { evaluate(...t3) {
              const e4 = o2.evaluate.apply(void 0, t3), r3 = l2.evaluate.apply(void 0, t3);
              if (void 0 !== e4 && void 0 !== r3)
                return u2(e4, r3, s2);
            } } : u2(o2, l2, s2);
          }
          function Pr(t2, e3, r2) {
            switch (e3.type) {
              case "color":
                r2 = Ft.parse(r2);
                break;
              case "formatted":
                r2 = Dt.fromString(r2.toString());
                break;
              case "resolvedImage":
                r2 = Rt.fromString(r2.toString());
                break;
              case "padding":
                r2 = $t.parse(r2);
                break;
              default:
                Ar(r2) === e3.type || "enum" === e3.type && e3.values[r2] || (r2 = void 0);
            }
            return Mr(r2, t2.default, e3.default);
          }
          Wt.register(fr, { error: [{ kind: "error" }, [ft], (t2, [e3]) => {
            throw new Zt(e3.evaluate(t2));
          }], typeof: [ft, [gt], (t2, [e3]) => At(qt(e3.evaluate(t2)))], "to-rgba": [_t(pt, 4), [yt], (t2, [e3]) => e3.evaluate(t2).toArray()], rgb: [yt, [pt, pt, pt], dr], rgba: [yt, [pt, pt, pt, pt], dr], has: { type: dt, overloads: [[[ft], (t2, [e3]) => yr(e3.evaluate(t2), t2.properties())], [[ft, mt], (t2, [e3, r2]) => yr(e3.evaluate(t2), r2.evaluate(t2))]] }, get: { type: gt, overloads: [[[ft], (t2, [e3]) => mr(e3.evaluate(t2), t2.properties())], [[ft, mt], (t2, [e3, r2]) => mr(e3.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [gt, [ft], (t2, [e3]) => mr(e3.evaluate(t2), t2.featureState || {})], properties: [mt, [], (t2) => t2.properties()], "geometry-type": [ft, [], (t2) => t2.geometryType()], id: [gt, [], (t2) => t2.id()], zoom: [pt, [], (t2) => t2.globals.zoom], "heatmap-density": [pt, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [pt, [], (t2) => t2.globals.lineProgress || 0], accumulated: [gt, [], (t2) => void 0 === t2.globals.accumulated ? null : t2.globals.accumulated], "+": [pt, gr(pt), (t2, e3) => {
            let r2 = 0;
            for (const n2 of e3)
              r2 += n2.evaluate(t2);
            return r2;
          }], "*": [pt, gr(pt), (t2, e3) => {
            let r2 = 1;
            for (const n2 of e3)
              r2 *= n2.evaluate(t2);
            return r2;
          }], "-": { type: pt, overloads: [[[pt, pt], (t2, [e3, r2]) => e3.evaluate(t2) - r2.evaluate(t2)], [[pt], (t2, [e3]) => -e3.evaluate(t2)]] }, "/": [pt, [pt, pt], (t2, [e3, r2]) => e3.evaluate(t2) / r2.evaluate(t2)], "%": [pt, [pt, pt], (t2, [e3, r2]) => e3.evaluate(t2) % r2.evaluate(t2)], ln2: [pt, [], () => Math.LN2], pi: [pt, [], () => Math.PI], e: [pt, [], () => Math.E], "^": [pt, [pt, pt], (t2, [e3, r2]) => Math.pow(e3.evaluate(t2), r2.evaluate(t2))], sqrt: [pt, [pt], (t2, [e3]) => Math.sqrt(e3.evaluate(t2))], log10: [pt, [pt], (t2, [e3]) => Math.log(e3.evaluate(t2)) / Math.LN10], ln: [pt, [pt], (t2, [e3]) => Math.log(e3.evaluate(t2))], log2: [pt, [pt], (t2, [e3]) => Math.log(e3.evaluate(t2)) / Math.LN2], sin: [pt, [pt], (t2, [e3]) => Math.sin(e3.evaluate(t2))], cos: [pt, [pt], (t2, [e3]) => Math.cos(e3.evaluate(t2))], tan: [pt, [pt], (t2, [e3]) => Math.tan(e3.evaluate(t2))], asin: [pt, [pt], (t2, [e3]) => Math.asin(e3.evaluate(t2))], acos: [pt, [pt], (t2, [e3]) => Math.acos(e3.evaluate(t2))], atan: [pt, [pt], (t2, [e3]) => Math.atan(e3.evaluate(t2))], min: [pt, gr(pt), (t2, e3) => Math.min(...e3.map((e4) => e4.evaluate(t2)))], max: [pt, gr(pt), (t2, e3) => Math.max(...e3.map((e4) => e4.evaluate(t2)))], abs: [pt, [pt], (t2, [e3]) => Math.abs(e3.evaluate(t2))], round: [pt, [pt], (t2, [e3]) => {
            const r2 = e3.evaluate(t2);
            return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
          }], floor: [pt, [pt], (t2, [e3]) => Math.floor(e3.evaluate(t2))], ceil: [pt, [pt], (t2, [e3]) => Math.ceil(e3.evaluate(t2))], "filter-==": [dt, [ft, gt], (t2, [e3, r2]) => t2.properties()[e3.value] === r2.value], "filter-id-==": [dt, [gt], (t2, [e3]) => t2.id() === e3.value], "filter-type-==": [dt, [ft], (t2, [e3]) => t2.geometryType() === e3.value], "filter-<": [dt, [ft, gt], (t2, [e3, r2]) => {
            const n2 = t2.properties()[e3.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 < i2;
          }], "filter-id-<": [dt, [gt], (t2, [e3]) => {
            const r2 = t2.id(), n2 = e3.value;
            return typeof r2 == typeof n2 && r2 < n2;
          }], "filter->": [dt, [ft, gt], (t2, [e3, r2]) => {
            const n2 = t2.properties()[e3.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 > i2;
          }], "filter-id->": [dt, [gt], (t2, [e3]) => {
            const r2 = t2.id(), n2 = e3.value;
            return typeof r2 == typeof n2 && r2 > n2;
          }], "filter-<=": [dt, [ft, gt], (t2, [e3, r2]) => {
            const n2 = t2.properties()[e3.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 <= i2;
          }], "filter-id-<=": [dt, [gt], (t2, [e3]) => {
            const r2 = t2.id(), n2 = e3.value;
            return typeof r2 == typeof n2 && r2 <= n2;
          }], "filter->=": [dt, [ft, gt], (t2, [e3, r2]) => {
            const n2 = t2.properties()[e3.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 >= i2;
          }], "filter-id->=": [dt, [gt], (t2, [e3]) => {
            const r2 = t2.id(), n2 = e3.value;
            return typeof r2 == typeof n2 && r2 >= n2;
          }], "filter-has": [dt, [gt], (t2, [e3]) => e3.value in t2.properties()], "filter-has-id": [dt, [], (t2) => null !== t2.id() && void 0 !== t2.id()], "filter-type-in": [dt, [_t(ft)], (t2, [e3]) => e3.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [dt, [_t(gt)], (t2, [e3]) => e3.value.indexOf(t2.id()) >= 0], "filter-in-small": [dt, [ft, _t(gt)], (t2, [e3, r2]) => r2.value.indexOf(t2.properties()[e3.value]) >= 0], "filter-in-large": [dt, [ft, _t(gt)], (t2, [e3, r2]) => function(t3, e4, r3, n2) {
            for (; r3 <= n2; ) {
              const i2 = r3 + n2 >> 1;
              if (e4[i2] === t3)
                return true;
              e4[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
            }
            return false;
          }(t2.properties()[e3.value], r2.value, 0, r2.value.length - 1)], all: { type: dt, overloads: [[[dt, dt], (t2, [e3, r2]) => e3.evaluate(t2) && r2.evaluate(t2)], [gr(dt), (t2, e3) => {
            for (const r2 of e3)
              if (!r2.evaluate(t2))
                return false;
            return true;
          }]] }, any: { type: dt, overloads: [[[dt, dt], (t2, [e3, r2]) => e3.evaluate(t2) || r2.evaluate(t2)], [gr(dt), (t2, e3) => {
            for (const r2 of e3)
              if (r2.evaluate(t2))
                return true;
            return false;
          }]] }, "!": [dt, [dt], (t2, [e3]) => !e3.evaluate(t2)], "is-supported-script": [dt, [ft], (t2, [e3]) => {
            const r2 = t2.globals && t2.globals.isSupportedScript;
            return !r2 || r2(e3.evaluate(t2));
          }], upcase: [ft, [ft], (t2, [e3]) => e3.evaluate(t2).toUpperCase()], downcase: [ft, [ft], (t2, [e3]) => e3.evaluate(t2).toLowerCase()], concat: [ft, gr(gt), (t2, e3) => e3.map((e4) => jt(e4.evaluate(t2))).join("")], "resolved-locale": [ft, [xt], (t2, [e3]) => e3.evaluate(t2).resolvedLocale()] });
          class Vr {
            constructor(t2, e3) {
              this.expression = t2, this._warningHistory = {}, this._evaluator = new Ht(), this._defaultValue = e3 ? function(t3) {
                return "color" === t3.type && kr(t3.default) ? new Ft(0, 0, 0, 0) : "color" === t3.type ? Ft.parse(t3.default) || null : "padding" === t3.type ? $t.parse(t3.default) || null : void 0 === t3.default ? null : t3.default;
              }(e3) : null, this._enumValues = e3 && "enum" === e3.type ? e3.values : null;
            }
            evaluateWithoutErrorHandling(t2, e3, r2, n2, i2, a2) {
              return this._evaluator.globals = t2, this._evaluator.feature = e3, this._evaluator.featureState = r2, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = a2, this.expression.evaluate(this._evaluator);
            }
            evaluate(t2, e3, r2, n2, i2, a2) {
              this._evaluator.globals = t2, this._evaluator.feature = e3 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = a2 || null;
              try {
                const t3 = this.expression.evaluate(this._evaluator);
                if (null == t3 || "number" == typeof t3 && t3 != t3)
                  return this._defaultValue;
                if (this._enumValues && !(t3 in this._enumValues))
                  throw new Zt(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
                return t3;
              } catch (t3) {
                return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn(t3.message)), this._defaultValue;
              }
            }
          }
          function Er(t2) {
            return Array.isArray(t2) && t2.length > 0 && "string" == typeof t2[0] && t2[0] in fr;
          }
          function Fr(t2, e3) {
            const r2 = new we(fr, [], e3 ? function(t3) {
              const e4 = { color: yt, string: ft, number: pt, enum: ft, boolean: dt, formatted: vt, padding: bt, resolvedImage: wt };
              return "array" === t3.type ? _t(e4[t3.value] || gt, t3.length) : e4[t3.type];
            }(e3) : void 0), n2 = r2.parse(t2, void 0, void 0, void 0, e3 && "string" === e3.type ? { typeAnnotation: "coerce" } : void 0);
            return n2 ? xr(new Vr(n2, e3)) : vr(r2.errors);
          }
          class Tr {
            constructor(t2, e3) {
              this.kind = t2, this._styleExpression = e3, this.isStateDependent = "constant" !== t2 && !xe(e3.expression);
            }
            evaluateWithoutErrorHandling(t2, e3, r2, n2, i2, a2) {
              return this._styleExpression.evaluateWithoutErrorHandling(t2, e3, r2, n2, i2, a2);
            }
            evaluate(t2, e3, r2, n2, i2, a2) {
              return this._styleExpression.evaluate(t2, e3, r2, n2, i2, a2);
            }
          }
          class Lr {
            constructor(t2, e3, r2, n2) {
              this.kind = t2, this.zoomStops = r2, this._styleExpression = e3, this.isStateDependent = "camera" !== t2 && !xe(e3.expression), this.interpolationType = n2;
            }
            evaluateWithoutErrorHandling(t2, e3, r2, n2, i2, a2) {
              return this._styleExpression.evaluateWithoutErrorHandling(t2, e3, r2, n2, i2, a2);
            }
            evaluate(t2, e3, r2, n2, i2, a2) {
              return this._styleExpression.evaluate(t2, e3, r2, n2, i2, a2);
            }
            interpolationFactor(t2, e3, r2) {
              return this.interpolationType ? Ne.interpolationFactor(this.interpolationType, t2, e3, r2) : 0;
            }
          }
          function Dr(t2, e3) {
            const r2 = Fr(t2, e3);
            if ("error" === r2.result)
              return r2;
            const n2 = r2.value.expression, i2 = ge(n2);
            if (!i2 && !br(e3))
              return vr([new ut("", "data expressions not supported")]);
            const a2 = ve(n2, ["zoom"]);
            if (!a2 && !wr(e3))
              return vr([new ut("", "zoom expressions not supported")]);
            const s2 = Rr(n2);
            return s2 || a2 ? s2 instanceof ut ? vr([s2]) : s2 instanceof Ne && !_r(e3) ? vr([new ut("", '"interpolate" expressions cannot be used with this property')]) : xr(s2 ? new Lr(i2 ? "camera" : "composite", r2.value, s2.labels, s2 instanceof Ne ? s2.interpolation : void 0) : new Tr(i2 ? "constant" : "source", r2.value)) : vr([new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
          }
          class $r {
            constructor(t2, e3) {
              this._parameters = t2, this._specification = e3, st(this, Ir(this._parameters, this._specification));
            }
            static deserialize(t2) {
              return new $r(t2._parameters, t2._specification);
            }
            static serialize(t2) {
              return { _parameters: t2._parameters, _specification: t2._specification };
            }
          }
          function Rr(t2) {
            let e3 = null;
            if (t2 instanceof Ge)
              e3 = Rr(t2.result);
            else if (t2 instanceof Ke) {
              for (const r2 of t2.args)
                if (e3 = Rr(r2), e3)
                  break;
            } else
              (t2 instanceof ke || t2 instanceof Ne) && t2.input instanceof Wt && "zoom" === t2.input.name && (e3 = t2);
            return e3 instanceof ut || t2.eachChild((t3) => {
              const r2 = Rr(t3);
              r2 instanceof ut ? e3 = r2 : !e3 && r2 ? e3 = new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e3 && r2 && e3 !== r2 && (e3 = new ut("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e3;
          }
          function Or(t2) {
            const e3 = t2.key, r2 = t2.value, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, a2 = t2.style, s2 = t2.styleSpec;
            let o2 = [];
            const l2 = Ar(r2);
            if ("object" !== l2)
              return [new it(e3, r2, `object expected, ${l2} found`)];
            for (const t3 in r2) {
              const l3 = t3.split(".")[0], u2 = n2[l3] || n2["*"];
              let c2;
              if (i2[l3])
                c2 = i2[l3];
              else if (n2[l3])
                c2 = yn;
              else if (i2["*"])
                c2 = i2["*"];
              else {
                if (!n2["*"]) {
                  o2.push(new it(e3, r2[t3], `unknown property "${t3}"`));
                  continue;
                }
                c2 = yn;
              }
              o2 = o2.concat(c2({ key: (e3 ? `${e3}.` : e3) + t3, value: r2[t3], valueSpec: u2, style: a2, styleSpec: s2, object: r2, objectKey: t3 }, r2));
            }
            for (const t3 in n2)
              i2[t3] || n2[t3].required && void 0 === n2[t3].default && void 0 === r2[t3] && o2.push(new it(e3, r2, `missing required property "${t3}"`));
            return o2;
          }
          function Ur(t2) {
            const e3 = t2.value, r2 = t2.valueSpec, n2 = t2.style, i2 = t2.styleSpec, a2 = t2.key, s2 = t2.arrayElementValidator || yn;
            if ("array" !== Ar(e3))
              return [new it(a2, e3, `array expected, ${Ar(e3)} found`)];
            if (r2.length && e3.length !== r2.length)
              return [new it(a2, e3, `array length ${r2.length} expected, length ${e3.length} found`)];
            if (r2["min-length"] && e3.length < r2["min-length"])
              return [new it(a2, e3, `array length at least ${r2["min-length"]} expected, length ${e3.length} found`)];
            let o2 = { type: r2.value, values: r2.values };
            i2.$version < 7 && (o2.function = r2.function), "object" === Ar(r2.value) && (o2 = r2.value);
            let l2 = [];
            for (let t3 = 0; t3 < e3.length; t3++)
              l2 = l2.concat(s2({ array: e3, arrayIndex: t3, value: e3[t3], valueSpec: o2, style: n2, styleSpec: i2, key: `${a2}[${t3}]` }));
            return l2;
          }
          function qr(t2) {
            const e3 = t2.key, r2 = t2.value, n2 = t2.valueSpec;
            let i2 = Ar(r2);
            return "number" === i2 && r2 != r2 && (i2 = "NaN"), "number" !== i2 ? [new it(e3, r2, `number expected, ${i2} found`)] : "minimum" in n2 && r2 < n2.minimum ? [new it(e3, r2, `${r2} is less than the minimum value ${n2.minimum}`)] : "maximum" in n2 && r2 > n2.maximum ? [new it(e3, r2, `${r2} is greater than the maximum value ${n2.maximum}`)] : [];
          }
          function jr(t2) {
            const e3 = t2.valueSpec, r2 = ot(t2.value.type);
            let n2, i2, a2, s2 = {};
            const o2 = "categorical" !== r2 && void 0 === t2.value.property, l2 = !o2, u2 = "array" === Ar(t2.value.stops) && "array" === Ar(t2.value.stops[0]) && "object" === Ar(t2.value.stops[0][0]), c2 = Or({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
              if ("identity" === r2)
                return [new it(t3.key, t3.value, 'identity function may not have a "stops" property')];
              let e4 = [];
              const n3 = t3.value;
              return e4 = e4.concat(Ur({ key: t3.key, value: n3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: h2 })), "array" === Ar(n3) && 0 === n3.length && e4.push(new it(t3.key, n3, "array must have at least one stop")), e4;
            }, default: function(t3) {
              return yn({ key: t3.key, value: t3.value, valueSpec: e3, style: t3.style, styleSpec: t3.styleSpec });
            } } });
            return "identity" === r2 && o2 && c2.push(new it(t2.key, t2.value, 'missing required property "property"')), "identity" === r2 || t2.value.stops || c2.push(new it(t2.key, t2.value, 'missing required property "stops"')), "exponential" === r2 && t2.valueSpec.expression && !_r(t2.valueSpec) && c2.push(new it(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l2 && !br(t2.valueSpec) ? c2.push(new it(t2.key, t2.value, "property functions not supported")) : o2 && !wr(t2.valueSpec) && c2.push(new it(t2.key, t2.value, "zoom functions not supported"))), "categorical" !== r2 && !u2 || void 0 !== t2.value.property || c2.push(new it(t2.key, t2.value, '"property" property is required')), c2;
            function h2(t3) {
              let r3 = [];
              const n3 = t3.value, o3 = t3.key;
              if ("array" !== Ar(n3))
                return [new it(o3, n3, `array expected, ${Ar(n3)} found`)];
              if (2 !== n3.length)
                return [new it(o3, n3, `array length 2 expected, length ${n3.length} found`)];
              if (u2) {
                if ("object" !== Ar(n3[0]))
                  return [new it(o3, n3, `object expected, ${Ar(n3[0])} found`)];
                if (void 0 === n3[0].zoom)
                  return [new it(o3, n3, "object stop key must have zoom")];
                if (void 0 === n3[0].value)
                  return [new it(o3, n3, "object stop key must have value")];
                if (a2 && a2 > ot(n3[0].zoom))
                  return [new it(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
                ot(n3[0].zoom) !== a2 && (a2 = ot(n3[0].zoom), i2 = void 0, s2 = {}), r3 = r3.concat(Or({ key: `${o3}[0]`, value: n3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: qr, value: p2 } }));
              } else
                r3 = r3.concat(p2({ key: `${o3}[0]`, value: n3[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, n3));
              return Er(lt(n3[1])) ? r3.concat([new it(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r3.concat(yn({ key: `${o3}[1]`, value: n3[1], valueSpec: e3, style: t3.style, styleSpec: t3.styleSpec }));
            }
            function p2(t3, a3) {
              const o3 = Ar(t3.value), l3 = ot(t3.value), u3 = null !== t3.value ? t3.value : a3;
              if (n2) {
                if (o3 !== n2)
                  return [new it(t3.key, u3, `${o3} stop domain type must match previous stop domain type ${n2}`)];
              } else
                n2 = o3;
              if ("number" !== o3 && "string" !== o3 && "boolean" !== o3)
                return [new it(t3.key, u3, "stop domain value must be a number, string, or boolean")];
              if ("number" !== o3 && "categorical" !== r2) {
                let n3 = `number expected, ${o3} found`;
                return br(e3) && void 0 === r2 && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new it(t3.key, u3, n3)];
              }
              return "categorical" !== r2 || "number" !== o3 || isFinite(l3) && Math.floor(l3) === l3 ? "categorical" !== r2 && "number" === o3 && void 0 !== i2 && l3 < i2 ? [new it(t3.key, u3, "stop domain values must appear in ascending order")] : (i2 = l3, "categorical" === r2 && l3 in s2 ? [new it(t3.key, u3, "stop domain values must be unique")] : (s2[l3] = true, [])) : [new it(t3.key, u3, `integer expected, found ${l3}`)];
            }
          }
          function Nr(t2) {
            const e3 = ("property" === t2.expressionContext ? Dr : Fr)(lt(t2.value), t2.valueSpec);
            if ("error" === e3.result)
              return e3.value.map((e4) => new it(`${t2.key}${e4.key}`, t2.value, e4.message));
            const r2 = e3.value.expression || e3.value._styleExpression.expression;
            if ("property" === t2.expressionContext && "text-font" === t2.propertyKey && !r2.outputDefined())
              return [new it(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
            if ("property" === t2.expressionContext && "layout" === t2.propertyType && !xe(r2))
              return [new it(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
            if ("filter" === t2.expressionContext && !xe(r2))
              return [new it(t2.key, t2.value, '"feature-state" data expressions are not supported with filters.')];
            if (t2.expressionContext && 0 === t2.expressionContext.indexOf("cluster")) {
              if (!ve(r2, ["zoom", "feature-state"]))
                return [new it(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
              if ("cluster-initial" === t2.expressionContext && !ge(r2))
                return [new it(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
            }
            return [];
          }
          function Zr(t2) {
            const e3 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = [];
            return Array.isArray(n2.values) ? -1 === n2.values.indexOf(ot(r2)) && i2.push(new it(e3, r2, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r2)} found`)) : -1 === Object.keys(n2.values).indexOf(ot(r2)) && i2.push(new it(e3, r2, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r2)} found`)), i2;
          }
          function Kr(t2) {
            if (true === t2 || false === t2)
              return true;
            if (!Array.isArray(t2) || 0 === t2.length)
              return false;
            switch (t2[0]) {
              case "has":
                return t2.length >= 2 && "$id" !== t2[1] && "$type" !== t2[1];
              case "in":
                return t2.length >= 3 && ("string" != typeof t2[1] || Array.isArray(t2[2]));
              case "!in":
              case "!has":
              case "none":
                return false;
              case "==":
              case "!=":
              case ">":
              case ">=":
              case "<":
              case "<=":
                return 3 !== t2.length || Array.isArray(t2[1]) || Array.isArray(t2[2]);
              case "any":
              case "all":
                for (const e3 of t2.slice(1))
                  if (!Kr(e3) && "boolean" != typeof e3)
                    return false;
                return true;
              default:
                return true;
            }
          }
          const Gr = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
          function Jr(t2) {
            if (null == t2)
              return { filter: () => true, needGeometry: false };
            Kr(t2) || (t2 = Hr(t2));
            const e3 = Fr(t2, Gr);
            if ("error" === e3.result)
              throw new Error(e3.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
            return { filter: (t3, r2, n2) => e3.value.evaluate(t3, r2, {}, n2), needGeometry: Yr(t2) };
          }
          function Xr(t2, e3) {
            return t2 < e3 ? -1 : t2 > e3 ? 1 : 0;
          }
          function Yr(t2) {
            if (!Array.isArray(t2))
              return false;
            if ("within" === t2[0])
              return true;
            for (let e3 = 1; e3 < t2.length; e3++)
              if (Yr(t2[e3]))
                return true;
            return false;
          }
          function Hr(t2) {
            if (!t2)
              return true;
            const e3 = t2[0];
            return t2.length <= 1 ? "any" !== e3 : "==" === e3 ? Wr(t2[1], t2[2], "==") : "!=" === e3 ? en(Wr(t2[1], t2[2], "==")) : "<" === e3 || ">" === e3 || "<=" === e3 || ">=" === e3 ? Wr(t2[1], t2[2], e3) : "any" === e3 ? (r2 = t2.slice(1), ["any"].concat(r2.map(Hr))) : "all" === e3 ? ["all"].concat(t2.slice(1).map(Hr)) : "none" === e3 ? ["all"].concat(t2.slice(1).map(Hr).map(en)) : "in" === e3 ? Qr(t2[1], t2.slice(2)) : "!in" === e3 ? en(Qr(t2[1], t2.slice(2))) : "has" === e3 ? tn(t2[1]) : "!has" === e3 ? en(tn(t2[1])) : "within" !== e3 || t2;
            var r2;
          }
          function Wr(t2, e3, r2) {
            switch (t2) {
              case "$type":
                return [`filter-type-${r2}`, e3];
              case "$id":
                return [`filter-id-${r2}`, e3];
              default:
                return [`filter-${r2}`, t2, e3];
            }
          }
          function Qr(t2, e3) {
            if (0 === e3.length)
              return false;
            switch (t2) {
              case "$type":
                return ["filter-type-in", ["literal", e3]];
              case "$id":
                return ["filter-id-in", ["literal", e3]];
              default:
                return e3.length > 200 && !e3.some((t3) => typeof t3 != typeof e3[0]) ? ["filter-in-large", t2, ["literal", e3.sort(Xr)]] : ["filter-in-small", t2, ["literal", e3]];
            }
          }
          function tn(t2) {
            switch (t2) {
              case "$type":
                return true;
              case "$id":
                return ["filter-has-id"];
              default:
                return ["filter-has", t2];
            }
          }
          function en(t2) {
            return ["!", t2];
          }
          function rn(t2) {
            return Kr(lt(t2.value)) ? Nr(st({}, t2, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : nn(t2);
          }
          function nn(t2) {
            const e3 = t2.value, r2 = t2.key;
            if ("array" !== Ar(e3))
              return [new it(r2, e3, `array expected, ${Ar(e3)} found`)];
            const n2 = t2.styleSpec;
            let i2, a2 = [];
            if (e3.length < 1)
              return [new it(r2, e3, "filter array must have at least 1 element")];
            switch (a2 = a2.concat(Zr({ key: `${r2}[0]`, value: e3[0], valueSpec: n2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), ot(e3[0])) {
              case "<":
              case "<=":
              case ">":
              case ">=":
                e3.length >= 2 && "$type" === ot(e3[1]) && a2.push(new it(r2, e3, `"$type" cannot be use with operator "${e3[0]}"`));
              case "==":
              case "!=":
                3 !== e3.length && a2.push(new it(r2, e3, `filter array for operator "${e3[0]}" must have 3 elements`));
              case "in":
              case "!in":
                e3.length >= 2 && (i2 = Ar(e3[1]), "string" !== i2 && a2.push(new it(`${r2}[1]`, e3[1], `string expected, ${i2} found`)));
                for (let s2 = 2; s2 < e3.length; s2++)
                  i2 = Ar(e3[s2]), "$type" === ot(e3[1]) ? a2 = a2.concat(Zr({ key: `${r2}[${s2}]`, value: e3[s2], valueSpec: n2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : "string" !== i2 && "number" !== i2 && "boolean" !== i2 && a2.push(new it(`${r2}[${s2}]`, e3[s2], `string, number, or boolean expected, ${i2} found`));
                break;
              case "any":
              case "all":
              case "none":
                for (let n3 = 1; n3 < e3.length; n3++)
                  a2 = a2.concat(nn({ key: `${r2}[${n3}]`, value: e3[n3], style: t2.style, styleSpec: t2.styleSpec }));
                break;
              case "has":
              case "!has":
                i2 = Ar(e3[1]), 2 !== e3.length ? a2.push(new it(r2, e3, `filter array for "${e3[0]}" operator must have 2 elements`)) : "string" !== i2 && a2.push(new it(`${r2}[1]`, e3[1], `string expected, ${i2} found`));
                break;
              case "within":
                i2 = Ar(e3[1]), 2 !== e3.length ? a2.push(new it(r2, e3, `filter array for "${e3[0]}" operator must have 2 elements`)) : "object" !== i2 && a2.push(new it(`${r2}[1]`, e3[1], `object expected, ${i2} found`));
            }
            return a2;
          }
          function an(t2, e3) {
            const r2 = t2.key, n2 = t2.style, i2 = t2.styleSpec, a2 = t2.value, s2 = t2.objectKey, o2 = i2[`${e3}_${t2.layerType}`];
            if (!o2)
              return [];
            const l2 = s2.match(/^(.*)-transition$/);
            if ("paint" === e3 && l2 && o2[l2[1]] && o2[l2[1]].transition)
              return yn({ key: r2, value: a2, valueSpec: i2.transition, style: n2, styleSpec: i2 });
            const u2 = t2.valueSpec || o2[s2];
            if (!u2)
              return [new it(r2, a2, `unknown property "${s2}"`)];
            let c2;
            if ("string" === Ar(a2) && br(u2) && !u2.tokens && (c2 = /^{([^}]+)}$/.exec(a2)))
              return [new it(r2, a2, `"${s2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(c2[1])} }\`.`)];
            const h2 = [];
            return "symbol" === t2.layerType && ("text-field" === s2 && n2 && !n2.glyphs && h2.push(new it(r2, a2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === s2 && kr(lt(a2)) && "identity" === ot(a2.type) && h2.push(new it(r2, a2, '"text-font" does not support identity functions'))), h2.concat(yn({ key: t2.key, value: a2, valueSpec: u2, style: n2, styleSpec: i2, expressionContext: "property", propertyType: e3, propertyKey: s2 }));
          }
          function sn(t2) {
            return an(t2, "paint");
          }
          function on(t2) {
            return an(t2, "layout");
          }
          function ln(t2) {
            let e3 = [];
            const r2 = t2.value, n2 = t2.key, i2 = t2.style, a2 = t2.styleSpec;
            r2.type || r2.ref || e3.push(new it(n2, r2, 'either "type" or "ref" is required'));
            let s2 = ot(r2.type);
            const o2 = ot(r2.ref);
            if (r2.id) {
              const a3 = ot(r2.id);
              for (let s3 = 0; s3 < t2.arrayIndex; s3++) {
                const t3 = i2.layers[s3];
                ot(t3.id) === a3 && e3.push(new it(n2, r2.id, `duplicate layer id "${r2.id}", previously used at line ${t3.id.__line__}`));
              }
            }
            if ("ref" in r2) {
              let t3;
              ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
                t4 in r2 && e3.push(new it(n2, r2[t4], `"${t4}" is prohibited for ref layers`));
              }), i2.layers.forEach((e4) => {
                ot(e4.id) === o2 && (t3 = e4);
              }), t3 ? t3.ref ? e3.push(new it(n2, r2.ref, "ref cannot reference another ref layer")) : s2 = ot(t3.type) : e3.push(new it(n2, r2.ref, `ref layer "${o2}" not found`));
            } else if ("background" !== s2)
              if (r2.source) {
                const t3 = i2.sources && i2.sources[r2.source], a3 = t3 && ot(t3.type);
                t3 ? "vector" === a3 && "raster" === s2 ? e3.push(new it(n2, r2.source, `layer "${r2.id}" requires a raster source`)) : "raster" === a3 && "raster" !== s2 ? e3.push(new it(n2, r2.source, `layer "${r2.id}" requires a vector source`)) : "vector" !== a3 || r2["source-layer"] ? "raster-dem" === a3 && "hillshade" !== s2 ? e3.push(new it(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s2 || !r2.paint || !r2.paint["line-gradient"] || "geojson" === a3 && t3.lineMetrics || e3.push(new it(n2, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e3.push(new it(n2, r2, `layer "${r2.id}" must specify a "source-layer"`)) : e3.push(new it(n2, r2.source, `source "${r2.source}" not found`));
              } else
                e3.push(new it(n2, r2, 'missing required property "source"'));
            return e3 = e3.concat(Or({ key: n2, value: r2, valueSpec: a2.layer, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { "*": () => [], type: () => yn({ key: `${n2}.type`, value: r2.type, valueSpec: a2.layer.type, style: t2.style, styleSpec: t2.styleSpec, object: r2, objectKey: "type" }), filter: rn, layout: (t3) => Or({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => on(st({ layerType: s2 }, t4)) } }), paint: (t3) => Or({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => sn(st({ layerType: s2 }, t4)) } }) } })), e3;
          }
          function un(t2) {
            const e3 = t2.value, r2 = t2.key, n2 = Ar(e3);
            return "string" !== n2 ? [new it(r2, e3, `string expected, ${n2} found`)] : [];
          }
          const cn = { promoteId: function({ key: t2, value: e3 }) {
            if ("string" === Ar(e3))
              return un({ key: t2, value: e3 });
            {
              const r2 = [];
              for (const n2 in e3)
                r2.push(...un({ key: `${t2}.${n2}`, value: e3[n2] }));
              return r2;
            }
          } };
          function hn(t2) {
            const e3 = t2.value, r2 = t2.key, n2 = t2.styleSpec, i2 = t2.style;
            if (!e3.type)
              return [new it(r2, e3, '"type" is required')];
            const a2 = ot(e3.type);
            let s2;
            switch (a2) {
              case "vector":
              case "raster":
              case "raster-dem":
                return s2 = Or({ key: r2, value: e3, valueSpec: n2[`source_${a2.replace("-", "_")}`], style: t2.style, styleSpec: n2, objectElementValidators: cn }), s2;
              case "geojson":
                if (s2 = Or({ key: r2, value: e3, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, objectElementValidators: cn }), e3.cluster)
                  for (const t3 in e3.clusterProperties) {
                    const [n3, i3] = e3.clusterProperties[t3], a3 = "string" == typeof n3 ? [n3, ["accumulated"], ["get", t3]] : n3;
                    s2.push(...Nr({ key: `${r2}.${t3}.map`, value: i3, expressionContext: "cluster-map" })), s2.push(...Nr({ key: `${r2}.${t3}.reduce`, value: a3, expressionContext: "cluster-reduce" }));
                  }
                return s2;
              case "video":
                return Or({ key: r2, value: e3, valueSpec: n2.source_video, style: i2, styleSpec: n2 });
              case "image":
                return Or({ key: r2, value: e3, valueSpec: n2.source_image, style: i2, styleSpec: n2 });
              case "canvas":
                return [new it(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
              default:
                return Zr({ key: `${r2}.type`, value: e3.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i2, styleSpec: n2 });
            }
          }
          function pn(t2) {
            const e3 = t2.value, r2 = t2.styleSpec, n2 = r2.light, i2 = t2.style;
            let a2 = [];
            const s2 = Ar(e3);
            if (void 0 === e3)
              return a2;
            if ("object" !== s2)
              return a2 = a2.concat([new it("light", e3, `object expected, ${s2} found`)]), a2;
            for (const t3 in e3) {
              const s3 = t3.match(/^(.*)-transition$/);
              a2 = a2.concat(s3 && n2[s3[1]] && n2[s3[1]].transition ? yn({ key: t3, value: e3[t3], valueSpec: r2.transition, style: i2, styleSpec: r2 }) : n2[t3] ? yn({ key: t3, value: e3[t3], valueSpec: n2[t3], style: i2, styleSpec: r2 }) : [new it(t3, e3[t3], `unknown property "${t3}"`)]);
            }
            return a2;
          }
          function fn(t2) {
            const e3 = t2.value, r2 = t2.styleSpec, n2 = r2.terrain, i2 = t2.style;
            let a2 = [];
            const s2 = Ar(e3);
            if (void 0 === e3)
              return a2;
            if ("object" !== s2)
              return a2 = a2.concat([new it("terrain", e3, `object expected, ${s2} found`)]), a2;
            for (const t3 in e3)
              a2 = a2.concat(n2[t3] ? yn({ key: t3, value: e3[t3], valueSpec: n2[t3], style: i2, styleSpec: r2 }) : [new it(t3, e3[t3], `unknown property "${t3}"`)]);
            return a2;
          }
          const dn = { "*": () => [], array: Ur, boolean: function(t2) {
            const e3 = t2.value, r2 = t2.key, n2 = Ar(e3);
            return "boolean" !== n2 ? [new it(r2, e3, `boolean expected, ${n2} found`)] : [];
          }, number: qr, color: function(t2) {
            const e3 = t2.key, r2 = t2.value, n2 = Ar(r2);
            return "string" !== n2 ? [new it(e3, r2, `color expected, ${n2} found`)] : null === zt(r2) ? [new it(e3, r2, `color expected, "${r2}" found`)] : [];
          }, constants: at, enum: Zr, filter: rn, function: jr, layer: ln, object: Or, source: hn, light: pn, terrain: fn, string: un, formatted: function(t2) {
            return 0 === un(t2).length ? [] : Nr(t2);
          }, resolvedImage: function(t2) {
            return 0 === un(t2).length ? [] : Nr(t2);
          }, padding: function(t2) {
            const e3 = t2.key, r2 = t2.value;
            if ("array" === Ar(r2)) {
              if (r2.length < 1 || r2.length > 4)
                return [new it(e3, r2, `padding requires 1 to 4 values; ${r2.length} values found`)];
              const t3 = { type: "number" };
              let n2 = [];
              for (let i2 = 0; i2 < r2.length; i2++)
                n2 = n2.concat(yn({ key: `${e3}[${i2}]`, value: r2[i2], valueSpec: t3 }));
              return n2;
            }
            return qr({ key: e3, value: r2, valueSpec: {} });
          } };
          function yn(t2) {
            const e3 = t2.value, r2 = t2.valueSpec, n2 = t2.styleSpec;
            return r2.expression && kr(ot(e3)) ? jr(t2) : r2.expression && Er(lt(e3)) ? Nr(t2) : r2.type && dn[r2.type] ? dn[r2.type](t2) : Or(st({}, t2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
          }
          function mn(t2) {
            const e3 = t2.value, r2 = t2.key, n2 = un(t2);
            return n2.length || (-1 === e3.indexOf("{fontstack}") && n2.push(new it(r2, e3, '"glyphs" url must include a "{fontstack}" token')), -1 === e3.indexOf("{range}") && n2.push(new it(r2, e3, '"glyphs" url must include a "{range}" token'))), n2;
          }
          function gn(t2, e3 = nt) {
            let r2 = [];
            return r2 = r2.concat(yn({ key: "", value: t2, valueSpec: e3.$root, styleSpec: e3, style: t2, objectElementValidators: { glyphs: mn, "*": () => [] } })), t2.constants && (r2 = r2.concat(at({ key: "constants", value: t2.constants, style: t2, styleSpec: e3 }))), xn(r2);
          }
          function xn(t2) {
            return [].concat(t2).sort((t3, e3) => t3.line - e3.line);
          }
          function vn(t2) {
            return function(...e3) {
              return xn(t2.apply(this, e3));
            };
          }
          gn.source = vn(hn), gn.light = vn(pn), gn.terrain = vn(fn), gn.layer = vn(ln), gn.filter = vn(rn), gn.paintProperty = vn(sn), gn.layoutProperty = vn(on);
          const bn = gn, wn = bn.light, _n = bn.paintProperty, An = bn.layoutProperty;
          function kn(t2, e3) {
            let r2 = false;
            if (e3 && e3.length)
              for (const n2 of e3)
                t2.fire(new et(new Error(n2.message))), r2 = true;
            return r2;
          }
          class Sn {
            constructor(t2, e3, r2) {
              const n2 = this.cells = [];
              if (t2 instanceof ArrayBuffer) {
                this.arrayBuffer = t2;
                const i3 = new Int32Array(this.arrayBuffer);
                t2 = i3[0], this.d = (e3 = i3[1]) + 2 * (r2 = i3[2]);
                for (let t3 = 0; t3 < this.d * this.d; t3++) {
                  const e4 = i3[3 + t3], r3 = i3[3 + t3 + 1];
                  n2.push(e4 === r3 ? null : i3.subarray(e4, r3));
                }
                const a2 = i3[3 + n2.length + 1];
                this.keys = i3.subarray(i3[3 + n2.length], a2), this.bboxes = i3.subarray(a2), this.insert = this._insertReadonly;
              } else {
                this.d = e3 + 2 * r2;
                for (let t3 = 0; t3 < this.d * this.d; t3++)
                  n2.push([]);
                this.keys = [], this.bboxes = [];
              }
              this.n = e3, this.extent = t2, this.padding = r2, this.scale = e3 / t2, this.uid = 0;
              const i2 = r2 / e3 * t2;
              this.min = -i2, this.max = t2 + i2;
            }
            insert(t2, e3, r2, n2, i2) {
              this._forEachCell(e3, r2, n2, i2, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t2), this.bboxes.push(e3), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
            }
            _insertReadonly() {
              throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
            }
            _insertCell(t2, e3, r2, n2, i2, a2) {
              this.cells[i2].push(a2);
            }
            query(t2, e3, r2, n2, i2) {
              const a2 = this.min, s2 = this.max;
              if (t2 <= a2 && e3 <= a2 && s2 <= r2 && s2 <= n2 && !i2)
                return Array.prototype.slice.call(this.keys);
              {
                const a3 = [];
                return this._forEachCell(t2, e3, r2, n2, this._queryCell, a3, {}, i2), a3;
              }
            }
            _queryCell(t2, e3, r2, n2, i2, a2, s2, o2) {
              const l2 = this.cells[i2];
              if (null !== l2) {
                const i3 = this.keys, u2 = this.bboxes;
                for (let c2 = 0; c2 < l2.length; c2++) {
                  const h2 = l2[c2];
                  if (void 0 === s2[h2]) {
                    const l3 = 4 * h2;
                    (o2 ? o2(u2[l3 + 0], u2[l3 + 1], u2[l3 + 2], u2[l3 + 3]) : t2 <= u2[l3 + 2] && e3 <= u2[l3 + 3] && r2 >= u2[l3 + 0] && n2 >= u2[l3 + 1]) ? (s2[h2] = true, a2.push(i3[h2])) : s2[h2] = false;
                  }
                }
              }
            }
            _forEachCell(t2, e3, r2, n2, i2, a2, s2, o2) {
              const l2 = this._convertToCellCoord(t2), u2 = this._convertToCellCoord(e3), c2 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n2);
              for (let p2 = l2; p2 <= c2; p2++)
                for (let l3 = u2; l3 <= h2; l3++) {
                  const u3 = this.d * l3 + p2;
                  if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(l3), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(l3 + 1))) && i2.call(this, t2, e3, r2, n2, u3, a2, s2, o2))
                    return;
                }
            }
            _convertFromCellCoord(t2) {
              return (t2 - this.padding) / this.scale;
            }
            _convertToCellCoord(t2) {
              return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
            }
            toArrayBuffer() {
              if (this.arrayBuffer)
                return this.arrayBuffer;
              const t2 = this.cells, e3 = 3 + this.cells.length + 1 + 1;
              let r2 = 0;
              for (let t3 = 0; t3 < this.cells.length; t3++)
                r2 += this.cells[t3].length;
              const n2 = new Int32Array(e3 + r2 + this.keys.length + this.bboxes.length);
              n2[0] = this.extent, n2[1] = this.n, n2[2] = this.padding;
              let i2 = e3;
              for (let e4 = 0; e4 < t2.length; e4++) {
                const r3 = t2[e4];
                n2[3 + e4] = i2, n2.set(r3, i2), i2 += r3.length;
              }
              return n2[3 + t2.length] = i2, n2.set(this.keys, i2), i2 += this.keys.length, n2[3 + t2.length + 1] = i2, n2.set(this.bboxes, i2), i2 += this.bboxes.length, n2.buffer;
            }
            static serialize(t2, e3) {
              const r2 = t2.toArrayBuffer();
              return e3 && e3.push(r2), { buffer: r2 };
            }
            static deserialize(t2) {
              return new Sn(t2.buffer);
            }
          }
          const In = {};
          function Mn(t2, e3, r2 = {}) {
            if (In[t2])
              throw new Error(`${t2} is already registered.`);
            Object.defineProperty(e3, "_classRegistryKey", { value: t2, writeable: false }), In[t2] = { klass: e3, omit: r2.omit || [], shallow: r2.shallow || [] };
          }
          Mn("Object", Object), Mn("TransferableGridIndex", Sn), Mn("Color", Ft), Mn("Error", Error), Mn("AJAXError", q), Mn("ResolvedImage", Rt), Mn("StylePropertyFunction", $r), Mn("StyleExpression", Vr, { omit: ["_evaluator"] }), Mn("ZoomDependentExpression", Lr), Mn("ZoomConstantExpression", Tr), Mn("CompoundExpression", Wt, { omit: ["_evaluate"] });
          for (const t2 in fr)
            fr[t2]._classRegistryKey || Mn(`Expression_${t2}`, fr[t2]);
          function zn(t2) {
            return t2 && "undefined" != typeof ArrayBuffer && (t2 instanceof ArrayBuffer || t2.constructor && "ArrayBuffer" === t2.constructor.name);
          }
          function Bn(t2, e3) {
            if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || t2 instanceof Blob)
              return t2;
            if (zn(t2))
              return e3 && e3.push(t2), t2;
            if (A(t2))
              return e3 && e3.push(t2), t2;
            if (ArrayBuffer.isView(t2)) {
              const r2 = t2;
              return e3 && e3.push(r2.buffer), r2;
            }
            if (t2 instanceof ImageData)
              return e3 && e3.push(t2.data.buffer), t2;
            if (Array.isArray(t2)) {
              const r2 = [];
              for (const n2 of t2)
                r2.push(Bn(n2, e3));
              return r2;
            }
            if ("object" == typeof t2) {
              const r2 = t2.constructor, n2 = r2._classRegistryKey;
              if (!n2)
                throw new Error("can't serialize object of unregistered class");
              if (!In[n2])
                throw new Error(`${n2} is not registered.`);
              const i2 = r2.serialize ? r2.serialize(t2, e3) : {};
              if (r2.serialize) {
                if (e3 && i2 === e3[e3.length - 1])
                  throw new Error("statically serialized object won't survive transfer of $name property");
              } else {
                for (const r3 in t2) {
                  if (!t2.hasOwnProperty(r3))
                    continue;
                  if (In[n2].omit.indexOf(r3) >= 0)
                    continue;
                  const a2 = t2[r3];
                  i2[r3] = In[n2].shallow.indexOf(r3) >= 0 ? a2 : Bn(a2, e3);
                }
                t2 instanceof Error && (i2.message = t2.message);
              }
              if (i2.$name)
                throw new Error("$name property is reserved for worker serialization logic.");
              return "Object" !== n2 && (i2.$name = n2), i2;
            }
            throw new Error("can't serialize object of type " + typeof t2);
          }
          function Cn(t2) {
            if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || t2 instanceof Blob || zn(t2) || A(t2) || ArrayBuffer.isView(t2) || t2 instanceof ImageData)
              return t2;
            if (Array.isArray(t2))
              return t2.map(Cn);
            if ("object" == typeof t2) {
              const e3 = t2.$name || "Object";
              if (!In[e3])
                throw new Error(`can't deserialize unregistered class ${e3}`);
              const { klass: r2 } = In[e3];
              if (!r2)
                throw new Error(`can't deserialize unregistered class ${e3}`);
              if (r2.deserialize)
                return r2.deserialize(t2);
              const n2 = Object.create(r2.prototype);
              for (const r3 of Object.keys(t2)) {
                if ("$name" === r3)
                  continue;
                const i2 = t2[r3];
                n2[r3] = In[e3].shallow.indexOf(r3) >= 0 ? i2 : Cn(i2);
              }
              return n2;
            }
            throw new Error("can't deserialize object of type " + typeof t2);
          }
          class Pn {
            constructor() {
              this.first = true;
            }
            update(t2, e3) {
              const r2 = Math.floor(t2);
              return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t2, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e3) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e3), t2 !== this.lastZoom && (this.lastZoom = t2, this.lastFloorZoom = r2, true));
            }
          }
          const Vn = { "Latin-1 Supplement": (t2) => t2 >= 128 && t2 <= 255, Arabic: (t2) => t2 >= 1536 && t2 <= 1791, "Arabic Supplement": (t2) => t2 >= 1872 && t2 <= 1919, "Arabic Extended-A": (t2) => t2 >= 2208 && t2 <= 2303, "Hangul Jamo": (t2) => t2 >= 4352 && t2 <= 4607, "Unified Canadian Aboriginal Syllabics": (t2) => t2 >= 5120 && t2 <= 5759, Khmer: (t2) => t2 >= 6016 && t2 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t2) => t2 >= 6320 && t2 <= 6399, "General Punctuation": (t2) => t2 >= 8192 && t2 <= 8303, "Letterlike Symbols": (t2) => t2 >= 8448 && t2 <= 8527, "Number Forms": (t2) => t2 >= 8528 && t2 <= 8591, "Miscellaneous Technical": (t2) => t2 >= 8960 && t2 <= 9215, "Control Pictures": (t2) => t2 >= 9216 && t2 <= 9279, "Optical Character Recognition": (t2) => t2 >= 9280 && t2 <= 9311, "Enclosed Alphanumerics": (t2) => t2 >= 9312 && t2 <= 9471, "Geometric Shapes": (t2) => t2 >= 9632 && t2 <= 9727, "Miscellaneous Symbols": (t2) => t2 >= 9728 && t2 <= 9983, "Miscellaneous Symbols and Arrows": (t2) => t2 >= 11008 && t2 <= 11263, "CJK Radicals Supplement": (t2) => t2 >= 11904 && t2 <= 12031, "Kangxi Radicals": (t2) => t2 >= 12032 && t2 <= 12255, "Ideographic Description Characters": (t2) => t2 >= 12272 && t2 <= 12287, "CJK Symbols and Punctuation": (t2) => t2 >= 12288 && t2 <= 12351, Hiragana: (t2) => t2 >= 12352 && t2 <= 12447, Katakana: (t2) => t2 >= 12448 && t2 <= 12543, Bopomofo: (t2) => t2 >= 12544 && t2 <= 12591, "Hangul Compatibility Jamo": (t2) => t2 >= 12592 && t2 <= 12687, Kanbun: (t2) => t2 >= 12688 && t2 <= 12703, "Bopomofo Extended": (t2) => t2 >= 12704 && t2 <= 12735, "CJK Strokes": (t2) => t2 >= 12736 && t2 <= 12783, "Katakana Phonetic Extensions": (t2) => t2 >= 12784 && t2 <= 12799, "Enclosed CJK Letters and Months": (t2) => t2 >= 12800 && t2 <= 13055, "CJK Compatibility": (t2) => t2 >= 13056 && t2 <= 13311, "CJK Unified Ideographs Extension A": (t2) => t2 >= 13312 && t2 <= 19903, "Yijing Hexagram Symbols": (t2) => t2 >= 19904 && t2 <= 19967, "CJK Unified Ideographs": (t2) => t2 >= 19968 && t2 <= 40959, "Yi Syllables": (t2) => t2 >= 40960 && t2 <= 42127, "Yi Radicals": (t2) => t2 >= 42128 && t2 <= 42191, "Hangul Jamo Extended-A": (t2) => t2 >= 43360 && t2 <= 43391, "Hangul Syllables": (t2) => t2 >= 44032 && t2 <= 55215, "Hangul Jamo Extended-B": (t2) => t2 >= 55216 && t2 <= 55295, "Private Use Area": (t2) => t2 >= 57344 && t2 <= 63743, "CJK Compatibility Ideographs": (t2) => t2 >= 63744 && t2 <= 64255, "Arabic Presentation Forms-A": (t2) => t2 >= 64336 && t2 <= 65023, "Vertical Forms": (t2) => t2 >= 65040 && t2 <= 65055, "CJK Compatibility Forms": (t2) => t2 >= 65072 && t2 <= 65103, "Small Form Variants": (t2) => t2 >= 65104 && t2 <= 65135, "Arabic Presentation Forms-B": (t2) => t2 >= 65136 && t2 <= 65279, "Halfwidth and Fullwidth Forms": (t2) => t2 >= 65280 && t2 <= 65519 };
          function En(t2) {
            for (const e3 of t2)
              if (Ln(e3.charCodeAt(0)))
                return true;
            return false;
          }
          function Fn(t2) {
            for (const e3 of t2)
              if (!Tn(e3.charCodeAt(0)))
                return false;
            return true;
          }
          function Tn(t2) {
            return !(Vn.Arabic(t2) || Vn["Arabic Supplement"](t2) || Vn["Arabic Extended-A"](t2) || Vn["Arabic Presentation Forms-A"](t2) || Vn["Arabic Presentation Forms-B"](t2));
          }
          function Ln(t2) {
            return !(746 !== t2 && 747 !== t2 && (t2 < 4352 || !(Vn["Bopomofo Extended"](t2) || Vn.Bopomofo(t2) || Vn["CJK Compatibility Forms"](t2) && !(t2 >= 65097 && t2 <= 65103) || Vn["CJK Compatibility Ideographs"](t2) || Vn["CJK Compatibility"](t2) || Vn["CJK Radicals Supplement"](t2) || Vn["CJK Strokes"](t2) || !(!Vn["CJK Symbols and Punctuation"](t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || 12336 === t2) || Vn["CJK Unified Ideographs Extension A"](t2) || Vn["CJK Unified Ideographs"](t2) || Vn["Enclosed CJK Letters and Months"](t2) || Vn["Hangul Compatibility Jamo"](t2) || Vn["Hangul Jamo Extended-A"](t2) || Vn["Hangul Jamo Extended-B"](t2) || Vn["Hangul Jamo"](t2) || Vn["Hangul Syllables"](t2) || Vn.Hiragana(t2) || Vn["Ideographic Description Characters"](t2) || Vn.Kanbun(t2) || Vn["Kangxi Radicals"](t2) || Vn["Katakana Phonetic Extensions"](t2) || Vn.Katakana(t2) && 12540 !== t2 || !(!Vn["Halfwidth and Fullwidth Forms"](t2) || 65288 === t2 || 65289 === t2 || 65293 === t2 || t2 >= 65306 && t2 <= 65310 || 65339 === t2 || 65341 === t2 || 65343 === t2 || t2 >= 65371 && t2 <= 65503 || 65507 === t2 || t2 >= 65512 && t2 <= 65519) || !(!Vn["Small Form Variants"](t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || Vn["Unified Canadian Aboriginal Syllabics"](t2) || Vn["Unified Canadian Aboriginal Syllabics Extended"](t2) || Vn["Vertical Forms"](t2) || Vn["Yijing Hexagram Symbols"](t2) || Vn["Yi Syllables"](t2) || Vn["Yi Radicals"](t2))));
          }
          function Dn(t2) {
            return !(Ln(t2) || function(t3) {
              return !!(Vn["Latin-1 Supplement"](t3) && (167 === t3 || 169 === t3 || 174 === t3 || 177 === t3 || 188 === t3 || 189 === t3 || 190 === t3 || 215 === t3 || 247 === t3) || Vn["General Punctuation"](t3) && (8214 === t3 || 8224 === t3 || 8225 === t3 || 8240 === t3 || 8241 === t3 || 8251 === t3 || 8252 === t3 || 8258 === t3 || 8263 === t3 || 8264 === t3 || 8265 === t3 || 8273 === t3) || Vn["Letterlike Symbols"](t3) || Vn["Number Forms"](t3) || Vn["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || Vn["Control Pictures"](t3) && 9251 !== t3 || Vn["Optical Character Recognition"](t3) || Vn["Enclosed Alphanumerics"](t3) || Vn["Geometric Shapes"](t3) || Vn["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || Vn["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || Vn["CJK Symbols and Punctuation"](t3) || Vn.Katakana(t3) || Vn["Private Use Area"](t3) || Vn["CJK Compatibility Forms"](t3) || Vn["Small Form Variants"](t3) || Vn["Halfwidth and Fullwidth Forms"](t3) || 8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3);
            }(t2));
          }
          function $n(t2) {
            return t2 >= 1424 && t2 <= 2303 || Vn["Arabic Presentation Forms-A"](t2) || Vn["Arabic Presentation Forms-B"](t2);
          }
          function Rn(t2, e3) {
            return !(!e3 && $n(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || Vn.Khmer(t2));
          }
          function On(t2) {
            for (const e3 of t2)
              if ($n(e3.charCodeAt(0)))
                return true;
            return false;
          }
          const Un = "deferred", qn = "loading", jn = "loaded";
          let Nn = null, Zn = "unavailable", Kn = null;
          const Gn = function(t2) {
            t2 && "string" == typeof t2 && t2.indexOf("NetworkError") > -1 && (Zn = "error"), Nn && Nn(t2);
          };
          function Jn() {
            Xn.fire(new tt("pluginStateChange", { pluginStatus: Zn, pluginURL: Kn }));
          }
          const Xn = new rt(), Yn = function() {
            return Zn;
          }, Hn = function() {
            if (Zn !== Un || !Kn)
              throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            Zn = qn, Jn(), Kn && K({ url: Kn }, (t2) => {
              t2 ? Gn(t2) : (Zn = jn, Jn());
            });
          }, Wn = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => Zn === jn || null != Wn.applyArabicShaping, isLoading: () => Zn === qn, setState(t2) {
            if (!g())
              throw new Error("Cannot set the state of the rtl-text-plugin when not in the web-worker context");
            Zn = t2.pluginStatus, Kn = t2.pluginURL;
          }, isParsed() {
            if (!g())
              throw new Error("rtl-text-plugin is only parsed on the worker-threads");
            return null != Wn.applyArabicShaping && null != Wn.processBidirectionalText && null != Wn.processStyledBidirectionalText;
          }, getPluginURL() {
            if (!g())
              throw new Error("rtl-text-plugin url can only be queried from the worker threads");
            return Kn;
          } };
          class Qn {
            constructor(t2, e3) {
              this.zoom = t2, e3 ? (this.now = e3.now, this.fadeDuration = e3.fadeDuration, this.zoomHistory = e3.zoomHistory, this.transition = e3.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Pn(), this.transition = {});
            }
            isSupportedScript(t2) {
              return function(t3, e3) {
                for (const r2 of t3)
                  if (!Rn(r2.charCodeAt(0), e3))
                    return false;
                return true;
              }(t2, Wn.isLoaded());
            }
            crossFadingFactor() {
              return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
            }
            getCrossfadeParameters() {
              const t2 = this.zoom, e3 = t2 - Math.floor(t2), r2 = this.crossFadingFactor();
              return t2 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e3 + (1 - e3) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e3 };
            }
          }
          class ti {
            constructor(t2, e3) {
              this.property = t2, this.value = e3, this.expression = function(t3, e4) {
                if (kr(t3))
                  return new $r(t3, e4);
                if (Er(t3)) {
                  const r2 = Dr(t3, e4);
                  if ("error" === r2.result)
                    throw new Error(r2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
                  return r2.value;
                }
                {
                  let r2 = t3;
                  return "color" === e4.type && "string" == typeof t3 ? r2 = Ft.parse(t3) : "padding" !== e4.type || "number" != typeof t3 && !Array.isArray(t3) || (r2 = $t.parse(t3)), { kind: "constant", evaluate: () => r2 };
                }
              }(void 0 === e3 ? t2.specification.default : e3, t2.specification);
            }
            isDataDriven() {
              return "source" === this.expression.kind || "composite" === this.expression.kind;
            }
            possiblyEvaluate(t2, e3, r2) {
              return this.property.possiblyEvaluate(this, t2, e3, r2);
            }
          }
          class ei {
            constructor(t2) {
              this.property = t2, this.value = new ti(t2, void 0);
            }
            transitioned(t2, e3) {
              return new ni(this.property, this.value, e3, o({}, t2.transition, this.transition), t2.now);
            }
            untransitioned() {
              return new ni(this.property, this.value, null, {}, 0);
            }
          }
          class ri {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
            }
            getValue(t2) {
              return p(this._values[t2].value.value);
            }
            setValue(t2, e3) {
              Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new ei(this._values[t2].property)), this._values[t2].value = new ti(this._values[t2].property, null === e3 ? void 0 : p(e3));
            }
            getTransition(t2) {
              return p(this._values[t2].transition);
            }
            setTransition(t2, e3) {
              Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new ei(this._values[t2].property)), this._values[t2].transition = p(e3) || void 0;
            }
            serialize() {
              const t2 = {};
              for (const e3 of Object.keys(this._values)) {
                const r2 = this.getValue(e3);
                void 0 !== r2 && (t2[e3] = r2);
                const n2 = this.getTransition(e3);
                void 0 !== n2 && (t2[`${e3}-transition`] = n2);
              }
              return t2;
            }
            transitioned(t2, e3) {
              const r2 = new ii(this._properties);
              for (const n2 of Object.keys(this._values))
                r2._values[n2] = this._values[n2].transitioned(t2, e3._values[n2]);
              return r2;
            }
            untransitioned() {
              const t2 = new ii(this._properties);
              for (const e3 of Object.keys(this._values))
                t2._values[e3] = this._values[e3].untransitioned();
              return t2;
            }
          }
          class ni {
            constructor(t2, e3, r2, n2, i2) {
              this.property = t2, this.value = e3, this.begin = i2 + n2.delay || 0, this.end = this.begin + n2.duration || 0, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
            }
            possiblyEvaluate(t2, e3, r2) {
              const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e3, r2), a2 = this.prior;
              if (a2) {
                if (n2 > this.end)
                  return this.prior = null, i2;
                if (this.value.isDataDriven())
                  return this.prior = null, i2;
                if (n2 < this.begin)
                  return a2.possiblyEvaluate(t2, e3, r2);
                {
                  const s2 = (n2 - this.begin) / (this.end - this.begin);
                  return this.property.interpolate(a2.possiblyEvaluate(t2, e3, r2), i2, function(t3) {
                    if (t3 <= 0)
                      return 0;
                    if (t3 >= 1)
                      return 1;
                    const e4 = t3 * t3, r3 = e4 * t3;
                    return 4 * (t3 < 0.5 ? r3 : 3 * (t3 - e4) + r3 - 0.75);
                  }(s2));
                }
              }
              return i2;
            }
          }
          class ii {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t2, e3, r2) {
              const n2 = new oi(this._properties);
              for (const i2 of Object.keys(this._values))
                n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e3, r2);
              return n2;
            }
            hasTransition() {
              for (const t2 of Object.keys(this._values))
                if (this._values[t2].prior)
                  return true;
              return false;
            }
          }
          class ai {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
            }
            getValue(t2) {
              return p(this._values[t2].value);
            }
            setValue(t2, e3) {
              this._values[t2] = new ti(this._values[t2].property, null === e3 ? void 0 : p(e3));
            }
            serialize() {
              const t2 = {};
              for (const e3 of Object.keys(this._values)) {
                const r2 = this.getValue(e3);
                void 0 !== r2 && (t2[e3] = r2);
              }
              return t2;
            }
            possiblyEvaluate(t2, e3, r2) {
              const n2 = new oi(this._properties);
              for (const i2 of Object.keys(this._values))
                n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e3, r2);
              return n2;
            }
          }
          class si {
            constructor(t2, e3, r2) {
              this.property = t2, this.value = e3, this.parameters = r2;
            }
            isConstant() {
              return "constant" === this.value.kind;
            }
            constantOr(t2) {
              return "constant" === this.value.kind ? this.value.value : t2;
            }
            evaluate(t2, e3, r2, n2) {
              return this.property.evaluate(this.value, this.parameters, t2, e3, r2, n2);
            }
          }
          class oi {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
            }
            get(t2) {
              return this._values[t2];
            }
          }
          class li {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e3) {
              if (t2.isDataDriven())
                throw new Error("Value should not be data driven");
              return t2.expression.evaluate(e3);
            }
            interpolate(t2, e3, r2) {
              const n2 = Ie[this.specification.type];
              return n2 ? n2(t2, e3, r2) : t2;
            }
          }
          class ui {
            constructor(t2, e3) {
              this.specification = t2, this.overrides = e3;
            }
            possiblyEvaluate(t2, e3, r2, n2) {
              return new si(this, "constant" === t2.expression.kind || "camera" === t2.expression.kind ? { kind: "constant", value: t2.expression.evaluate(e3, null, {}, r2, n2) } : t2.expression, e3);
            }
            interpolate(t2, e3, r2) {
              if ("constant" !== t2.value.kind || "constant" !== e3.value.kind)
                return t2;
              if (void 0 === t2.value.value || void 0 === e3.value.value)
                return new si(this, { kind: "constant", value: void 0 }, t2.parameters);
              const n2 = Ie[this.specification.type];
              return n2 ? new si(this, { kind: "constant", value: n2(t2.value.value, e3.value.value, r2) }, t2.parameters) : t2;
            }
            evaluate(t2, e3, r2, n2, i2, a2) {
              return "constant" === t2.kind ? t2.value : t2.evaluate(e3, r2, n2, i2, a2);
            }
          }
          class ci extends ui {
            possiblyEvaluate(t2, e3, r2, n2) {
              if (void 0 === t2.value)
                return new si(this, { kind: "constant", value: void 0 }, e3);
              if ("constant" === t2.expression.kind) {
                const i2 = t2.expression.evaluate(e3, null, {}, r2, n2), a2 = "resolvedImage" === t2.property.specification.type && "string" != typeof i2 ? i2.name : i2, s2 = this._calculate(a2, a2, a2, e3);
                return new si(this, { kind: "constant", value: s2 }, e3);
              }
              if ("camera" === t2.expression.kind) {
                const r3 = this._calculate(t2.expression.evaluate({ zoom: e3.zoom - 1 }), t2.expression.evaluate({ zoom: e3.zoom }), t2.expression.evaluate({ zoom: e3.zoom + 1 }), e3);
                return new si(this, { kind: "constant", value: r3 }, e3);
              }
              return new si(this, t2.expression, e3);
            }
            evaluate(t2, e3, r2, n2, i2, a2) {
              if ("source" === t2.kind) {
                const s2 = t2.evaluate(e3, r2, n2, i2, a2);
                return this._calculate(s2, s2, s2, e3);
              }
              return "composite" === t2.kind ? this._calculate(t2.evaluate({ zoom: Math.floor(e3.zoom) - 1 }, r2, n2), t2.evaluate({ zoom: Math.floor(e3.zoom) }, r2, n2), t2.evaluate({ zoom: Math.floor(e3.zoom) + 1 }, r2, n2), e3) : t2.value;
            }
            _calculate(t2, e3, r2, n2) {
              return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e3 } : { from: r2, to: e3 };
            }
            interpolate(t2) {
              return t2;
            }
          }
          class hi {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e3, r2, n2) {
              if (void 0 !== t2.value) {
                if ("constant" === t2.expression.kind) {
                  const i2 = t2.expression.evaluate(e3, null, {}, r2, n2);
                  return this._calculate(i2, i2, i2, e3);
                }
                return this._calculate(t2.expression.evaluate(new Qn(Math.floor(e3.zoom - 1), e3)), t2.expression.evaluate(new Qn(Math.floor(e3.zoom), e3)), t2.expression.evaluate(new Qn(Math.floor(e3.zoom + 1), e3)), e3);
              }
            }
            _calculate(t2, e3, r2, n2) {
              return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e3 } : { from: r2, to: e3 };
            }
            interpolate(t2) {
              return t2;
            }
          }
          class pi2 {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e3, r2, n2) {
              return !!t2.expression.evaluate(e3, null, {}, r2, n2);
            }
            interpolate() {
              return false;
            }
          }
          class fi {
            constructor(t2) {
              this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
              for (const e3 in t2) {
                const r2 = t2[e3];
                r2.specification.overridable && this.overridableProperties.push(e3);
                const n2 = this.defaultPropertyValues[e3] = new ti(r2, void 0), i2 = this.defaultTransitionablePropertyValues[e3] = new ei(r2);
                this.defaultTransitioningPropertyValues[e3] = i2.untransitioned(), this.defaultPossiblyEvaluatedValues[e3] = n2.possiblyEvaluate({});
              }
            }
          }
          Mn("DataDrivenProperty", ui), Mn("DataConstantProperty", li), Mn("CrossFadedDataDrivenProperty", ci), Mn("CrossFadedProperty", hi), Mn("ColorRampProperty", pi2);
          const di = "-transition";
          class yi extends rt {
            constructor(t2, e3) {
              if (super(), this.id = t2.id, this.type = t2.type, this._featureFilter = { filter: () => true, needGeometry: false }, "custom" !== t2.type && (this.metadata = t2.metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, "background" !== t2.type && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), e3.layout && (this._unevaluatedLayout = new ai(e3.layout)), e3.paint)) {
                this._transitionablePaint = new ri(e3.paint);
                for (const e4 in t2.paint)
                  this.setPaintProperty(e4, t2.paint[e4], { validate: false });
                for (const e4 in t2.layout)
                  this.setLayoutProperty(e4, t2.layout[e4], { validate: false });
                this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new oi(e3.paint);
              }
            }
            getCrossfadeParameters() {
              return this._crossfadeParameters;
            }
            getLayoutProperty(t2) {
              return "visibility" === t2 ? this.visibility : this._unevaluatedLayout.getValue(t2);
            }
            setLayoutProperty(t2, e3, r2 = {}) {
              null != e3 && this._validate(An, `layers.${this.id}.layout.${t2}`, t2, e3, r2) || ("visibility" !== t2 ? this._unevaluatedLayout.setValue(t2, e3) : this.visibility = e3);
            }
            getPaintProperty(t2) {
              return t2.endsWith(di) ? this._transitionablePaint.getTransition(t2.slice(0, -di.length)) : this._transitionablePaint.getValue(t2);
            }
            setPaintProperty(t2, e3, r2 = {}) {
              if (null != e3 && this._validate(_n, `layers.${this.id}.paint.${t2}`, t2, e3, r2))
                return false;
              if (t2.endsWith(di))
                return this._transitionablePaint.setTransition(t2.slice(0, -di.length), e3 || void 0), false;
              {
                const r3 = this._transitionablePaint._values[t2], n2 = "cross-faded-data-driven" === r3.property.specification["property-type"], i2 = r3.value.isDataDriven(), a2 = r3.value;
                this._transitionablePaint.setValue(t2, e3), this._handleSpecialPaintPropertyUpdate(t2);
                const s2 = this._transitionablePaint._values[t2].value;
                return s2.isDataDriven() || i2 || n2 || this._handleOverridablePaintPropertyUpdate(t2, a2, s2);
              }
            }
            _handleSpecialPaintPropertyUpdate(t2) {
            }
            _handleOverridablePaintPropertyUpdate(t2, e3, r2) {
              return false;
            }
            isHidden(t2) {
              return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || "none" === this.visibility;
            }
            updateTransitions(t2) {
              this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
            }
            hasTransition() {
              return this._transitioningPaint.hasTransition();
            }
            recalculate(t2, e3) {
              t2.getCrossfadeParameters && (this._crossfadeParameters = t2.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e3)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e3);
            }
            serialize() {
              const t2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
              return this.visibility && (t2.layout = t2.layout || {}, t2.layout.visibility = this.visibility), h(t2, (t3, e3) => !(void 0 === t3 || "layout" === e3 && !Object.keys(t3).length || "paint" === e3 && !Object.keys(t3).length));
            }
            _validate(t2, e3, r2, n2, i2 = {}) {
              return (!i2 || false !== i2.validate) && kn(this, t2.call(bn, { key: e3, layerType: this.type, objectKey: r2, value: n2, styleSpec: nt, style: { glyphs: true, sprite: true } }));
            }
            is3D() {
              return false;
            }
            isTileClipped() {
              return false;
            }
            hasOffscreenPass() {
              return false;
            }
            resize() {
            }
            isStateDependent() {
              for (const t2 in this.paint._values) {
                const e3 = this.paint.get(t2);
                if (e3 instanceof si && br(e3.property.specification) && ("source" === e3.value.kind || "composite" === e3.value.kind) && e3.value.isStateDependent)
                  return true;
              }
              return false;
            }
          }
          const mi = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
          class gi {
            constructor(t2, e3) {
              this._structArray = t2, this._pos1 = e3 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
          }
          class xi {
            constructor() {
              this.isTransferred = false, this.capacity = -1, this.resize(0);
            }
            static serialize(t2, e3) {
              return t2._trim(), e3 && (t2.isTransferred = true, e3.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
            }
            static deserialize(t2) {
              const e3 = Object.create(this.prototype);
              return e3.arrayBuffer = t2.arrayBuffer, e3.length = t2.length, e3.capacity = t2.arrayBuffer.byteLength / e3.bytesPerElement, e3._refreshViews(), e3;
            }
            _trim() {
              this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
              this.length = 0;
            }
            resize(t2) {
              this.reserve(t2), this.length = t2;
            }
            reserve(t2) {
              if (t2 > this.capacity) {
                this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                const e3 = this.uint8;
                this._refreshViews(), e3 && this.uint8.set(e3);
              }
            }
            _refreshViews() {
              throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
            }
          }
          function vi(t2, e3 = 1) {
            let r2 = 0, n2 = 0;
            return { members: t2.map((t3) => {
              const i2 = mi[t3.type].BYTES_PER_ELEMENT, a2 = r2 = bi(r2, Math.max(e3, i2)), s2 = t3.components || 1;
              return n2 = Math.max(n2, i2), r2 += i2 * s2, { name: t3.name, type: t3.type, components: s2, offset: a2 };
            }), size: bi(r2, Math.max(n2, e3)), alignment: e3 };
          }
          function bi(t2, e3) {
            return Math.ceil(t2 / e3) * e3;
          }
          class wi extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e3);
            }
            emplace(t2, e3, r2) {
              const n2 = 2 * t2;
              return this.int16[n2 + 0] = e3, this.int16[n2 + 1] = r2, t2;
            }
          }
          wi.prototype.bytesPerElement = 4, Mn("StructArrayLayout2i4", wi);
          class _i extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e3, r2, n2);
            }
            emplace(t2, e3, r2, n2, i2) {
              const a2 = 4 * t2;
              return this.int16[a2 + 0] = e3, this.int16[a2 + 1] = r2, this.int16[a2 + 2] = n2, this.int16[a2 + 3] = i2, t2;
            }
          }
          _i.prototype.bytesPerElement = 8, Mn("StructArrayLayout4i8", _i);
          class Ai extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3, r2, n2, i2, a2) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t2, e3, r2, n2, i2, a2);
            }
            emplace(t2, e3, r2, n2, i2, a2, s2) {
              const o2 = 6 * t2;
              return this.int16[o2 + 0] = e3, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = a2, this.int16[o2 + 5] = s2, t2;
            }
          }
          Ai.prototype.bytesPerElement = 12, Mn("StructArrayLayout2i4i12", Ai);
          class ki extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3, r2, n2, i2, a2) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t2, e3, r2, n2, i2, a2);
            }
            emplace(t2, e3, r2, n2, i2, a2, s2) {
              const o2 = 4 * t2, l2 = 8 * t2;
              return this.int16[o2 + 0] = e3, this.int16[o2 + 1] = r2, this.uint8[l2 + 4] = n2, this.uint8[l2 + 5] = i2, this.uint8[l2 + 6] = a2, this.uint8[l2 + 7] = s2, t2;
            }
          }
          ki.prototype.bytesPerElement = 8, Mn("StructArrayLayout2i4ub8", ki);
          class Si extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e3);
            }
            emplace(t2, e3, r2) {
              const n2 = 2 * t2;
              return this.float32[n2 + 0] = e3, this.float32[n2 + 1] = r2, t2;
            }
          }
          Si.prototype.bytesPerElement = 8, Mn("StructArrayLayout2f8", Si);
          class Ii extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3, r2, n2, i2, a2, s2, o2, l2, u2) {
              const c2 = this.length;
              return this.resize(c2 + 1), this.emplace(c2, t2, e3, r2, n2, i2, a2, s2, o2, l2, u2);
            }
            emplace(t2, e3, r2, n2, i2, a2, s2, o2, l2, u2, c2) {
              const h2 = 10 * t2;
              return this.uint16[h2 + 0] = e3, this.uint16[h2 + 1] = r2, this.uint16[h2 + 2] = n2, this.uint16[h2 + 3] = i2, this.uint16[h2 + 4] = a2, this.uint16[h2 + 5] = s2, this.uint16[h2 + 6] = o2, this.uint16[h2 + 7] = l2, this.uint16[h2 + 8] = u2, this.uint16[h2 + 9] = c2, t2;
            }
          }
          Ii.prototype.bytesPerElement = 20, Mn("StructArrayLayout10ui20", Ii);
          class Mi extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2) {
              const p2 = this.length;
              return this.resize(p2 + 1), this.emplace(p2, t2, e3, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2);
            }
            emplace(t2, e3, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2) {
              const f2 = 12 * t2;
              return this.int16[f2 + 0] = e3, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = a2, this.uint16[f2 + 5] = s2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l2, this.int16[f2 + 8] = u2, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p2, t2;
            }
          }
          Mi.prototype.bytesPerElement = 24, Mn("StructArrayLayout4i4ui4i24", Mi);
          class zi extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e3, r2);
            }
            emplace(t2, e3, r2, n2) {
              const i2 = 3 * t2;
              return this.float32[i2 + 0] = e3, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
            }
          }
          zi.prototype.bytesPerElement = 12, Mn("StructArrayLayout3f12", zi);
          class Bi extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e3 = this.length;
              return this.resize(e3 + 1), this.emplace(e3, t2);
            }
            emplace(t2, e3) {
              return this.uint32[1 * t2 + 0] = e3, t2;
            }
          }
          Bi.prototype.bytesPerElement = 4, Mn("StructArrayLayout1ul4", Bi);
          class Ci extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3, r2, n2, i2, a2, s2, o2, l2) {
              const u2 = this.length;
              return this.resize(u2 + 1), this.emplace(u2, t2, e3, r2, n2, i2, a2, s2, o2, l2);
            }
            emplace(t2, e3, r2, n2, i2, a2, s2, o2, l2, u2) {
              const c2 = 10 * t2, h2 = 5 * t2;
              return this.int16[c2 + 0] = e3, this.int16[c2 + 1] = r2, this.int16[c2 + 2] = n2, this.int16[c2 + 3] = i2, this.int16[c2 + 4] = a2, this.int16[c2 + 5] = s2, this.uint32[h2 + 3] = o2, this.uint16[c2 + 8] = l2, this.uint16[c2 + 9] = u2, t2;
            }
          }
          Ci.prototype.bytesPerElement = 20, Mn("StructArrayLayout6i1ul2ui20", Ci);
          class Pi extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3, r2, n2, i2, a2) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t2, e3, r2, n2, i2, a2);
            }
            emplace(t2, e3, r2, n2, i2, a2, s2) {
              const o2 = 6 * t2;
              return this.int16[o2 + 0] = e3, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = a2, this.int16[o2 + 5] = s2, t2;
            }
          }
          Pi.prototype.bytesPerElement = 12, Mn("StructArrayLayout2i2i2i12", Pi);
          class Vi extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3, r2, n2, i2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e3, r2, n2, i2);
            }
            emplace(t2, e3, r2, n2, i2, a2) {
              const s2 = 4 * t2, o2 = 8 * t2;
              return this.float32[s2 + 0] = e3, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = a2, t2;
            }
          }
          Vi.prototype.bytesPerElement = 16, Mn("StructArrayLayout2f1f2i16", Vi);
          class Ei extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e3, r2, n2);
            }
            emplace(t2, e3, r2, n2, i2) {
              const a2 = 12 * t2, s2 = 3 * t2;
              return this.uint8[a2 + 0] = e3, this.uint8[a2 + 1] = r2, this.float32[s2 + 1] = n2, this.float32[s2 + 2] = i2, t2;
            }
          }
          Ei.prototype.bytesPerElement = 12, Mn("StructArrayLayout2ub2f12", Ei);
          class Fi extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e3, r2);
            }
            emplace(t2, e3, r2, n2) {
              const i2 = 3 * t2;
              return this.uint16[i2 + 0] = e3, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
            }
          }
          Fi.prototype.bytesPerElement = 6, Mn("StructArrayLayout3ui6", Fi);
          class Ti extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y3, m2) {
              const g2 = this.length;
              return this.resize(g2 + 1), this.emplace(g2, t2, e3, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y3, m2);
            }
            emplace(t2, e3, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y3, m2, g2) {
              const x3 = 24 * t2, v2 = 12 * t2, b2 = 48 * t2;
              return this.int16[x3 + 0] = e3, this.int16[x3 + 1] = r2, this.uint16[x3 + 2] = n2, this.uint16[x3 + 3] = i2, this.uint32[v2 + 2] = a2, this.uint32[v2 + 3] = s2, this.uint32[v2 + 4] = o2, this.uint16[x3 + 10] = l2, this.uint16[x3 + 11] = u2, this.uint16[x3 + 12] = c2, this.float32[v2 + 7] = h2, this.float32[v2 + 8] = p2, this.uint8[b2 + 36] = f2, this.uint8[b2 + 37] = d2, this.uint8[b2 + 38] = y3, this.uint32[v2 + 10] = m2, this.int16[x3 + 22] = g2, t2;
            }
          }
          Ti.prototype.bytesPerElement = 48, Mn("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Ti);
          class Li extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y3, m2, g2, x3, v2, b2, w2, _2, A2, k2, S2, I2, M2) {
              const z2 = this.length;
              return this.resize(z2 + 1), this.emplace(z2, t2, e3, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y3, m2, g2, x3, v2, b2, w2, _2, A2, k2, S2, I2, M2);
            }
            emplace(t2, e3, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y3, m2, g2, x3, v2, b2, w2, _2, A2, k2, S2, I2, M2, z2) {
              const B3 = 34 * t2, C2 = 17 * t2;
              return this.int16[B3 + 0] = e3, this.int16[B3 + 1] = r2, this.int16[B3 + 2] = n2, this.int16[B3 + 3] = i2, this.int16[B3 + 4] = a2, this.int16[B3 + 5] = s2, this.int16[B3 + 6] = o2, this.int16[B3 + 7] = l2, this.uint16[B3 + 8] = u2, this.uint16[B3 + 9] = c2, this.uint16[B3 + 10] = h2, this.uint16[B3 + 11] = p2, this.uint16[B3 + 12] = f2, this.uint16[B3 + 13] = d2, this.uint16[B3 + 14] = y3, this.uint16[B3 + 15] = m2, this.uint16[B3 + 16] = g2, this.uint16[B3 + 17] = x3, this.uint16[B3 + 18] = v2, this.uint16[B3 + 19] = b2, this.uint16[B3 + 20] = w2, this.uint16[B3 + 21] = _2, this.uint16[B3 + 22] = A2, this.uint32[C2 + 12] = k2, this.float32[C2 + 13] = S2, this.float32[C2 + 14] = I2, this.float32[C2 + 15] = M2, this.float32[C2 + 16] = z2, t2;
            }
          }
          Li.prototype.bytesPerElement = 68, Mn("StructArrayLayout8i15ui1ul4f68", Li);
          class Di extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e3 = this.length;
              return this.resize(e3 + 1), this.emplace(e3, t2);
            }
            emplace(t2, e3) {
              return this.float32[1 * t2 + 0] = e3, t2;
            }
          }
          Di.prototype.bytesPerElement = 4, Mn("StructArrayLayout1f4", Di);
          class $i extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e3, r2);
            }
            emplace(t2, e3, r2, n2) {
              const i2 = 3 * t2;
              return this.int16[i2 + 0] = e3, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
            }
          }
          $i.prototype.bytesPerElement = 6, Mn("StructArrayLayout3i6", $i);
          class Ri extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e3, r2);
            }
            emplace(t2, e3, r2, n2) {
              const i2 = 4 * t2;
              return this.uint32[2 * t2 + 0] = e3, this.uint16[i2 + 2] = r2, this.uint16[i2 + 3] = n2, t2;
            }
          }
          Ri.prototype.bytesPerElement = 8, Mn("StructArrayLayout1ul2ui8", Ri);
          class Oi extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e3);
            }
            emplace(t2, e3, r2) {
              const n2 = 2 * t2;
              return this.uint16[n2 + 0] = e3, this.uint16[n2 + 1] = r2, t2;
            }
          }
          Oi.prototype.bytesPerElement = 4, Mn("StructArrayLayout2ui4", Oi);
          class Ui extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e3 = this.length;
              return this.resize(e3 + 1), this.emplace(e3, t2);
            }
            emplace(t2, e3) {
              return this.uint16[1 * t2 + 0] = e3, t2;
            }
          }
          Ui.prototype.bytesPerElement = 2, Mn("StructArrayLayout1ui2", Ui);
          class qi extends xi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e3, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e3, r2, n2);
            }
            emplace(t2, e3, r2, n2, i2) {
              const a2 = 4 * t2;
              return this.float32[a2 + 0] = e3, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.float32[a2 + 3] = i2, t2;
            }
          }
          qi.prototype.bytesPerElement = 16, Mn("StructArrayLayout4f16", qi);
          class ji extends gi {
            get anchorPointX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorPointY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get x1() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get y1() {
              return this._structArray.int16[this._pos2 + 3];
            }
            get x2() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get y2() {
              return this._structArray.int16[this._pos2 + 5];
            }
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 3];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 8];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 9];
            }
            get anchorPoint() {
              return new S(this.anchorPointX, this.anchorPointY);
            }
          }
          ji.prototype.size = 20;
          class Ni extends Ci {
            get(t2) {
              return new ji(this, t2);
            }
          }
          Mn("CollisionBoxArray", Ni);
          class Zi extends gi {
            get anchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get glyphStartIndex() {
              return this._structArray.uint16[this._pos2 + 2];
            }
            get numGlyphs() {
              return this._structArray.uint16[this._pos2 + 3];
            }
            get vertexStartIndex() {
              return this._structArray.uint32[this._pos4 + 2];
            }
            get lineStartIndex() {
              return this._structArray.uint32[this._pos4 + 3];
            }
            get lineLength() {
              return this._structArray.uint32[this._pos4 + 4];
            }
            get segment() {
              return this._structArray.uint16[this._pos2 + 10];
            }
            get lowerSize() {
              return this._structArray.uint16[this._pos2 + 11];
            }
            get upperSize() {
              return this._structArray.uint16[this._pos2 + 12];
            }
            get lineOffsetX() {
              return this._structArray.float32[this._pos4 + 7];
            }
            get lineOffsetY() {
              return this._structArray.float32[this._pos4 + 8];
            }
            get writingMode() {
              return this._structArray.uint8[this._pos1 + 36];
            }
            get placedOrientation() {
              return this._structArray.uint8[this._pos1 + 37];
            }
            set placedOrientation(t2) {
              this._structArray.uint8[this._pos1 + 37] = t2;
            }
            get hidden() {
              return this._structArray.uint8[this._pos1 + 38];
            }
            set hidden(t2) {
              this._structArray.uint8[this._pos1 + 38] = t2;
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 10];
            }
            set crossTileID(t2) {
              this._structArray.uint32[this._pos4 + 10] = t2;
            }
            get associatedIconIndex() {
              return this._structArray.int16[this._pos2 + 22];
            }
          }
          Zi.prototype.size = 48;
          class Ki extends Ti {
            get(t2) {
              return new Zi(this, t2);
            }
          }
          Mn("PlacedSymbolArray", Ki);
          class Gi extends gi {
            get anchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get rightJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get centerJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 3];
            }
            get leftJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get verticalPlacedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 5];
            }
            get placedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 6];
            }
            get verticalPlacedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 7];
            }
            get key() {
              return this._structArray.uint16[this._pos2 + 8];
            }
            get textBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 9];
            }
            get textBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 10];
            }
            get verticalTextBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 11];
            }
            get verticalTextBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 12];
            }
            get iconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 13];
            }
            get iconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 14];
            }
            get verticalIconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 15];
            }
            get verticalIconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 16];
            }
            get featureIndex() {
              return this._structArray.uint16[this._pos2 + 17];
            }
            get numHorizontalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 18];
            }
            get numVerticalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 19];
            }
            get numIconVertices() {
              return this._structArray.uint16[this._pos2 + 20];
            }
            get numVerticalIconVertices() {
              return this._structArray.uint16[this._pos2 + 21];
            }
            get useRuntimeCollisionCircles() {
              return this._structArray.uint16[this._pos2 + 22];
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 12];
            }
            set crossTileID(t2) {
              this._structArray.uint32[this._pos4 + 12] = t2;
            }
            get textBoxScale() {
              return this._structArray.float32[this._pos4 + 13];
            }
            get textOffset0() {
              return this._structArray.float32[this._pos4 + 14];
            }
            get textOffset1() {
              return this._structArray.float32[this._pos4 + 15];
            }
            get collisionCircleDiameter() {
              return this._structArray.float32[this._pos4 + 16];
            }
          }
          Gi.prototype.size = 68;
          class Ji extends Li {
            get(t2) {
              return new Gi(this, t2);
            }
          }
          Mn("SymbolInstanceArray", Ji);
          class Xi extends Di {
            getoffsetX(t2) {
              return this.float32[1 * t2 + 0];
            }
          }
          Mn("GlyphOffsetArray", Xi);
          class Yi extends $i {
            getx(t2) {
              return this.int16[3 * t2 + 0];
            }
            gety(t2) {
              return this.int16[3 * t2 + 1];
            }
            gettileUnitDistanceFromAnchor(t2) {
              return this.int16[3 * t2 + 2];
            }
          }
          Mn("SymbolLineVertexArray", Yi);
          class Hi extends gi {
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 3];
            }
          }
          Hi.prototype.size = 8;
          class Wi extends Ri {
            get(t2) {
              return new Hi(this, t2);
            }
          }
          Mn("FeatureIndexArray", Wi);
          class Qi extends wi {
          }
          class ta extends wi {
          }
          class ea extends wi {
          }
          class ra extends Ai {
          }
          class na extends ki {
          }
          class ia extends Si {
          }
          class aa extends Ii {
          }
          class sa extends Mi {
          }
          class oa extends zi {
          }
          class la extends Bi {
          }
          class ua extends Pi {
          }
          class ca extends Ei {
          }
          class ha extends Fi {
          }
          class pa extends Oi {
          }
          const fa = vi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: da } = fa;
          class ya {
            constructor(t2 = []) {
              this.segments = t2;
            }
            prepareSegment(t2, e3, r2, n2) {
              let i2 = this.segments[this.segments.length - 1];
              return t2 > ya.MAX_VERTEX_ARRAY_LENGTH && d(`Max vertices per segment is ${ya.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}`), (!i2 || i2.vertexLength + t2 > ya.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e3.length, primitiveOffset: r2.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n2 && (i2.sortKey = n2), this.segments.push(i2)), i2;
            }
            get() {
              return this.segments;
            }
            destroy() {
              for (const t2 of this.segments)
                for (const e3 in t2.vaos)
                  t2.vaos[e3].destroy();
            }
            static simpleSegment(t2, e3, r2, n2) {
              return new ya([{ vertexOffset: t2, primitiveOffset: e3, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
            }
          }
          function ma(t2, e3) {
            return 256 * (t2 = a(Math.floor(t2), 0, 255)) + a(Math.floor(e3), 0, 255);
          }
          ya.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, Mn("SegmentVector", ya);
          const ga = vi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
          var xa = { exports: {} }, va = { exports: {} };
          va.exports = function(t2, e3) {
            var r2, n2, i2, a2, s2, o2, l2, u2;
            for (n2 = t2.length - (r2 = 3 & t2.length), i2 = e3, s2 = 3432918353, o2 = 461845907, u2 = 0; u2 < n2; )
              l2 = 255 & t2.charCodeAt(u2) | (255 & t2.charCodeAt(++u2)) << 8 | (255 & t2.charCodeAt(++u2)) << 16 | (255 & t2.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (a2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * s2 + (((l2 >>> 16) * s2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a2 >>> 16) & 65535) << 16);
            switch (l2 = 0, r2) {
              case 3:
                l2 ^= (255 & t2.charCodeAt(u2 + 2)) << 16;
              case 2:
                l2 ^= (255 & t2.charCodeAt(u2 + 1)) << 8;
              case 1:
                i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t2.charCodeAt(u2))) * s2 + (((l2 >>> 16) * s2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
            }
            return i2 ^= t2.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
          };
          var ba = { exports: {} };
          ba.exports = function(t2, e3) {
            for (var r2, n2 = t2.length, i2 = e3 ^ n2, a2 = 0; n2 >= 4; )
              r2 = 1540483477 * (65535 & (r2 = 255 & t2.charCodeAt(a2) | (255 & t2.charCodeAt(++a2)) << 8 | (255 & t2.charCodeAt(++a2)) << 16 | (255 & t2.charCodeAt(++a2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++a2;
            switch (n2) {
              case 3:
                i2 ^= (255 & t2.charCodeAt(a2 + 2)) << 16;
              case 2:
                i2 ^= (255 & t2.charCodeAt(a2 + 1)) << 8;
              case 1:
                i2 = 1540483477 * (65535 & (i2 ^= 255 & t2.charCodeAt(a2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
            }
            return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
          };
          var wa = va.exports, _a = ba.exports;
          xa.exports = wa, xa.exports.murmur3 = wa, xa.exports.murmur2 = _a;
          class Aa {
            constructor() {
              this.ids = [], this.positions = [], this.indexed = false;
            }
            add(t2, e3, r2, n2) {
              this.ids.push(ka(t2)), this.positions.push(e3, r2, n2);
            }
            getPositions(t2) {
              if (!this.indexed)
                throw new Error("Trying to get index, but feature positions are not indexed");
              const e3 = ka(t2);
              let r2 = 0, n2 = this.ids.length - 1;
              for (; r2 < n2; ) {
                const t3 = r2 + n2 >> 1;
                this.ids[t3] >= e3 ? n2 = t3 : r2 = t3 + 1;
              }
              const i2 = [];
              for (; this.ids[r2] === e3; )
                i2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
              return i2;
            }
            static serialize(t2, e3) {
              const r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
              return Sa(r2, n2, 0, r2.length - 1), e3 && e3.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
            }
            static deserialize(t2) {
              const e3 = new Aa();
              return e3.ids = t2.ids, e3.positions = t2.positions, e3.indexed = true, e3;
            }
          }
          function ka(t2) {
            const e3 = +t2;
            return !isNaN(e3) && e3 <= Number.MAX_SAFE_INTEGER ? e3 : xa.exports(String(t2));
          }
          function Sa(t2, e3, r2, n2) {
            for (; r2 < n2; ) {
              const i2 = t2[r2 + n2 >> 1];
              let a2 = r2 - 1, s2 = n2 + 1;
              for (; ; ) {
                do {
                  a2++;
                } while (t2[a2] < i2);
                do {
                  s2--;
                } while (t2[s2] > i2);
                if (a2 >= s2)
                  break;
                Ia(t2, a2, s2), Ia(e3, 3 * a2, 3 * s2), Ia(e3, 3 * a2 + 1, 3 * s2 + 1), Ia(e3, 3 * a2 + 2, 3 * s2 + 2);
              }
              s2 - r2 < n2 - s2 ? (Sa(t2, e3, r2, s2), r2 = s2 + 1) : (Sa(t2, e3, s2 + 1, n2), n2 = s2);
            }
          }
          function Ia(t2, e3, r2) {
            const n2 = t2[e3];
            t2[e3] = t2[r2], t2[r2] = n2;
          }
          Mn("FeaturePositionMap", Aa);
          class Ma {
            constructor(t2, e3) {
              this.gl = t2.gl, this.location = e3;
            }
          }
          class za extends Ma {
            constructor(t2, e3) {
              super(t2, e3), this.current = 0;
            }
            set(t2) {
              this.current !== t2 && (this.current = t2, this.gl.uniform1f(this.location, t2));
            }
          }
          class Ba extends Ma {
            constructor(t2, e3) {
              super(t2, e3), this.current = [0, 0, 0, 0];
            }
            set(t2) {
              t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] && t2[3] === this.current[3] || (this.current = t2, this.gl.uniform4f(this.location, t2[0], t2[1], t2[2], t2[3]));
            }
          }
          class Ca extends Ma {
            constructor(t2, e3) {
              super(t2, e3), this.current = Ft.transparent;
            }
            set(t2) {
              t2.r === this.current.r && t2.g === this.current.g && t2.b === this.current.b && t2.a === this.current.a || (this.current = t2, this.gl.uniform4f(this.location, t2.r, t2.g, t2.b, t2.a));
            }
          }
          const Pa = new Float32Array(16);
          function Va(t2) {
            return [ma(255 * t2.r, 255 * t2.g), ma(255 * t2.b, 255 * t2.a)];
          }
          class Ea {
            constructor(t2, e3, r2) {
              this.value = t2, this.uniformNames = e3.map((t3) => `u_${t3}`), this.type = r2;
            }
            setUniform(t2, e3, r2) {
              t2.set(r2.constantOr(this.value));
            }
            getBinding(t2, e3, r2) {
              return "color" === this.type ? new Ca(t2, e3) : new za(t2, e3);
            }
          }
          class Fa {
            constructor(t2, e3) {
              this.uniformNames = e3.map((t3) => `u_${t3}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
            }
            setConstantPatternPositions(t2, e3) {
              this.pixelRatioFrom = e3.pixelRatio, this.pixelRatioTo = t2.pixelRatio, this.patternFrom = e3.tlbr, this.patternTo = t2.tlbr;
            }
            setUniform(t2, e3, r2, n2) {
              const i2 = "u_pattern_to" === n2 ? this.patternTo : "u_pattern_from" === n2 ? this.patternFrom : "u_pixel_ratio_to" === n2 ? this.pixelRatioTo : "u_pixel_ratio_from" === n2 ? this.pixelRatioFrom : null;
              i2 && t2.set(i2);
            }
            getBinding(t2, e3, r2) {
              return "u_pattern" === r2.substr(0, 9) ? new Ba(t2, e3) : new za(t2, e3);
            }
          }
          class Ta {
            constructor(t2, e3, r2, n2) {
              this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e3.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
            }
            populatePaintArray(t2, e3, r2, n2, i2) {
              const a2 = this.paintVertexArray.length, s2 = this.expression.evaluate(new Qn(0), e3, {}, n2, [], i2);
              this.paintVertexArray.resize(t2), this._setPaintValue(a2, t2, s2);
            }
            updatePaintArray(t2, e3, r2, n2) {
              const i2 = this.expression.evaluate({ zoom: 0 }, r2, n2);
              this._setPaintValue(t2, e3, i2);
            }
            _setPaintValue(t2, e3, r2) {
              if ("color" === this.type) {
                const n2 = Va(r2);
                for (let r3 = t2; r3 < e3; r3++)
                  this.paintVertexArray.emplace(r3, n2[0], n2[1]);
              } else {
                for (let n2 = t2; n2 < e3; n2++)
                  this.paintVertexArray.emplace(n2, r2);
                this.maxValue = Math.max(this.maxValue, Math.abs(r2));
              }
            }
            upload(t2) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
          }
          class La {
            constructor(t2, e3, r2, n2, i2, a2) {
              this.expression = t2, this.uniformNames = e3.map((t3) => `u_${t3}_t`), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e3.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 })), this.paintVertexArray = new a2();
            }
            populatePaintArray(t2, e3, r2, n2, i2) {
              const a2 = this.expression.evaluate(new Qn(this.zoom), e3, {}, n2, [], i2), s2 = this.expression.evaluate(new Qn(this.zoom + 1), e3, {}, n2, [], i2), o2 = this.paintVertexArray.length;
              this.paintVertexArray.resize(t2), this._setPaintValue(o2, t2, a2, s2);
            }
            updatePaintArray(t2, e3, r2, n2) {
              const i2 = this.expression.evaluate({ zoom: this.zoom }, r2, n2), a2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2);
              this._setPaintValue(t2, e3, i2, a2);
            }
            _setPaintValue(t2, e3, r2, n2) {
              if ("color" === this.type) {
                const i2 = Va(r2), a2 = Va(n2);
                for (let r3 = t2; r3 < e3; r3++)
                  this.paintVertexArray.emplace(r3, i2[0], i2[1], a2[0], a2[1]);
              } else {
                for (let i2 = t2; i2 < e3; i2++)
                  this.paintVertexArray.emplace(i2, r2, n2);
                this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
              }
            }
            upload(t2) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t2, e3) {
              const r2 = this.useIntegerZoom ? Math.floor(e3.zoom) : e3.zoom, n2 = a(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
              t2.set(n2);
            }
            getBinding(t2, e3, r2) {
              return new za(t2, e3);
            }
          }
          class Da {
            constructor(t2, e3, r2, n2, i2, a2) {
              this.expression = t2, this.type = e3, this.useIntegerZoom = r2, this.zoom = n2, this.layerId = a2, this.zoomInPaintVertexArray = new i2(), this.zoomOutPaintVertexArray = new i2();
            }
            populatePaintArray(t2, e3, r2) {
              const n2 = this.zoomInPaintVertexArray.length;
              this.zoomInPaintVertexArray.resize(t2), this.zoomOutPaintVertexArray.resize(t2), this._setPaintValues(n2, t2, e3.patterns && e3.patterns[this.layerId], r2);
            }
            updatePaintArray(t2, e3, r2, n2, i2) {
              this._setPaintValues(t2, e3, r2.patterns && r2.patterns[this.layerId], i2);
            }
            _setPaintValues(t2, e3, r2, n2) {
              if (!n2 || !r2)
                return;
              const { min: i2, mid: a2, max: s2 } = r2, o2 = n2[i2], l2 = n2[a2], u2 = n2[s2];
              if (o2 && l2 && u2)
                for (let r3 = t2; r3 < e3; r3++)
                  this.zoomInPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], o2.tl[0], o2.tl[1], o2.br[0], o2.br[1], l2.pixelRatio, o2.pixelRatio), this.zoomOutPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], u2.tl[0], u2.tl[1], u2.br[0], u2.br[1], l2.pixelRatio, u2.pixelRatio);
            }
            upload(t2) {
              this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t2.createVertexBuffer(this.zoomInPaintVertexArray, ga.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t2.createVertexBuffer(this.zoomOutPaintVertexArray, ga.members, this.expression.isStateDependent));
            }
            destroy() {
              this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
            }
          }
          class $a {
            constructor(t2, e3, r2) {
              this.binders = {}, this._buffers = [];
              const n2 = [];
              for (const i2 in t2.paint._values) {
                if (!r2(i2))
                  continue;
                const a2 = t2.paint.get(i2);
                if (!(a2 instanceof si && br(a2.property.specification)))
                  continue;
                const s2 = Oa(i2, t2.type), o2 = a2.value, l2 = a2.property.specification.type, u2 = a2.property.useIntegerZoom, c2 = a2.property.specification["property-type"], h2 = "cross-faded" === c2 || "cross-faded-data-driven" === c2;
                if ("constant" === o2.kind)
                  this.binders[i2] = h2 ? new Fa(o2.value, s2) : new Ea(o2.value, s2, l2), n2.push(`/u_${i2}`);
                else if ("source" === o2.kind || h2) {
                  const r3 = Ua(i2, l2, "source");
                  this.binders[i2] = h2 ? new Da(o2, l2, u2, e3, r3, t2.id) : new Ta(o2, s2, l2, r3), n2.push(`/a_${i2}`);
                } else {
                  const t3 = Ua(i2, l2, "composite");
                  this.binders[i2] = new La(o2, s2, l2, u2, e3, t3), n2.push(`/z_${i2}`);
                }
              }
              this.cacheKey = n2.sort().join("");
            }
            getMaxValue(t2) {
              const e3 = this.binders[t2];
              return e3 instanceof Ta || e3 instanceof La ? e3.maxValue : 0;
            }
            populatePaintArrays(t2, e3, r2, n2, i2) {
              for (const a2 in this.binders) {
                const s2 = this.binders[a2];
                (s2 instanceof Ta || s2 instanceof La || s2 instanceof Da) && s2.populatePaintArray(t2, e3, r2, n2, i2);
              }
            }
            setConstantPatternPositions(t2, e3) {
              for (const r2 in this.binders) {
                const n2 = this.binders[r2];
                n2 instanceof Fa && n2.setConstantPatternPositions(t2, e3);
              }
            }
            updatePaintArrays(t2, e3, r2, n2, i2) {
              let a2 = false;
              for (const s2 in t2) {
                const o2 = e3.getPositions(s2);
                for (const e4 of o2) {
                  const o3 = r2.feature(e4.index);
                  for (const r3 in this.binders) {
                    const l2 = this.binders[r3];
                    if ((l2 instanceof Ta || l2 instanceof La || l2 instanceof Da) && true === l2.expression.isStateDependent) {
                      const u2 = n2.paint.get(r3);
                      l2.expression = u2.value, l2.updatePaintArray(e4.start, e4.end, o3, t2[s2], i2), a2 = true;
                    }
                  }
                }
              }
              return a2;
            }
            defines() {
              const t2 = [];
              for (const e3 in this.binders) {
                const r2 = this.binders[e3];
                (r2 instanceof Ea || r2 instanceof Fa) && t2.push(...r2.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
              }
              return t2;
            }
            getBinderAttributes() {
              const t2 = [];
              for (const e3 in this.binders) {
                const r2 = this.binders[e3];
                if (r2 instanceof Ta || r2 instanceof La)
                  for (let e4 = 0; e4 < r2.paintVertexAttributes.length; e4++)
                    t2.push(r2.paintVertexAttributes[e4].name);
                else if (r2 instanceof Da)
                  for (let e4 = 0; e4 < ga.members.length; e4++)
                    t2.push(ga.members[e4].name);
              }
              return t2;
            }
            getBinderUniforms() {
              const t2 = [];
              for (const e3 in this.binders) {
                const r2 = this.binders[e3];
                if (r2 instanceof Ea || r2 instanceof Fa || r2 instanceof La)
                  for (const e4 of r2.uniformNames)
                    t2.push(e4);
              }
              return t2;
            }
            getPaintVertexBuffers() {
              return this._buffers;
            }
            getUniforms(t2, e3) {
              const r2 = [];
              for (const n2 in this.binders) {
                const i2 = this.binders[n2];
                if (i2 instanceof Ea || i2 instanceof Fa || i2 instanceof La) {
                  for (const a2 of i2.uniformNames)
                    if (e3[a2]) {
                      const s2 = i2.getBinding(t2, e3[a2], a2);
                      r2.push({ name: a2, property: n2, binding: s2 });
                    }
                }
              }
              return r2;
            }
            setUniforms(t2, e3, r2, n2) {
              for (const { name: t3, property: i2, binding: a2 } of e3)
                this.binders[i2].setUniform(a2, n2, r2.get(i2), t3);
            }
            updatePaintBuffers(t2) {
              this._buffers = [];
              for (const e3 in this.binders) {
                const r2 = this.binders[e3];
                if (t2 && r2 instanceof Da) {
                  const e4 = 2 === t2.fromScale ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
                  e4 && this._buffers.push(e4);
                } else
                  (r2 instanceof Ta || r2 instanceof La) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
              }
            }
            upload(t2) {
              for (const e3 in this.binders) {
                const r2 = this.binders[e3];
                (r2 instanceof Ta || r2 instanceof La || r2 instanceof Da) && r2.upload(t2);
              }
              this.updatePaintBuffers();
            }
            destroy() {
              for (const t2 in this.binders) {
                const e3 = this.binders[t2];
                (e3 instanceof Ta || e3 instanceof La || e3 instanceof Da) && e3.destroy();
              }
            }
          }
          class Ra {
            constructor(t2, e3, r2 = () => true) {
              this.programConfigurations = {};
              for (const n2 of t2)
                this.programConfigurations[n2.id] = new $a(n2, e3, r2);
              this.needsUpload = false, this._featureMap = new Aa(), this._bufferOffset = 0;
            }
            populatePaintArrays(t2, e3, r2, n2, i2, a2) {
              for (const r3 in this.programConfigurations)
                this.programConfigurations[r3].populatePaintArrays(t2, e3, n2, i2, a2);
              void 0 !== e3.id && this._featureMap.add(e3.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
            }
            updatePaintArrays(t2, e3, r2, n2) {
              for (const i2 of r2)
                this.needsUpload = this.programConfigurations[i2.id].updatePaintArrays(t2, this._featureMap, e3, i2, n2) || this.needsUpload;
            }
            get(t2) {
              return this.programConfigurations[t2];
            }
            upload(t2) {
              if (this.needsUpload) {
                for (const e3 in this.programConfigurations)
                  this.programConfigurations[e3].upload(t2);
                this.needsUpload = false;
              }
            }
            destroy() {
              for (const t2 in this.programConfigurations)
                this.programConfigurations[t2].destroy();
            }
          }
          function Oa(t2, e3) {
            return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t2] || [t2.replace(`${e3}-`, "").replace(/-/g, "_")];
          }
          function Ua(t2, e3, r2) {
            const n2 = { color: { source: Si, composite: qi }, number: { source: Di, composite: Si } }, i2 = function(t3) {
              return { "line-pattern": { source: aa, composite: aa }, "fill-pattern": { source: aa, composite: aa }, "fill-extrusion-pattern": { source: aa, composite: aa } }[t3];
            }(t2);
            return i2 && i2[r2] || n2[e3][r2];
          }
          Mn("ConstantBinder", Ea), Mn("CrossFadedConstantBinder", Fa), Mn("SourceExpressionBinder", Ta), Mn("CrossFadedCompositeBinder", Da), Mn("CompositeExpressionBinder", La), Mn("ProgramConfiguration", $a, { omit: ["_buffers"] }), Mn("ProgramConfigurationSet", Ra);
          var qa = 8192;
          const ja = Math.pow(2, 14) - 1, Na = -ja - 1;
          function Za(t2) {
            const e3 = qa / t2.extent, r2 = t2.loadGeometry();
            for (let t3 = 0; t3 < r2.length; t3++) {
              const n2 = r2[t3];
              for (let t4 = 0; t4 < n2.length; t4++) {
                const r3 = n2[t4], i2 = Math.round(r3.x * e3), s2 = Math.round(r3.y * e3);
                r3.x = a(i2, Na, ja), r3.y = a(s2, Na, ja), (i2 < r3.x || i2 > r3.x + 1 || s2 < r3.y || s2 > r3.y + 1) && d("Geometry exceeds allowed extent, reduce your vector tile buffer size");
              }
            }
            return r2;
          }
          function Ka(t2, e3) {
            return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e3 ? Za(t2) : [] };
          }
          function Ga(t2, e3, r2, n2, i2) {
            t2.emplaceBack(2 * e3 + (n2 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
          }
          class Ja {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new ta(), this.indexArray = new ha(), this.segments = new ya(), this.programConfigurations = new Ra(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            populate(t2, e3, r2) {
              const n2 = this.layers[0], i2 = [];
              let a2 = null, s2 = false;
              "circle" === n2.type && (a2 = n2.layout.get("circle-sort-key"), s2 = !a2.isConstant());
              for (const { feature: e4, id: n3, index: o2, sourceLayerIndex: l2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, u2 = Ka(e4, t3);
                if (!this.layers[0]._featureFilter.filter(new Qn(this.zoom), u2, r2))
                  continue;
                const c2 = s2 ? a2.evaluate(u2, {}, r2) : void 0, h2 = { id: n3, properties: e4.properties, type: e4.type, sourceLayerIndex: l2, index: o2, geometry: t3 ? u2.geometry : Za(e4), patterns: {}, sortKey: c2 };
                i2.push(h2);
              }
              s2 && i2.sort((t3, e4) => t3.sortKey - e4.sortKey);
              for (const n3 of i2) {
                const { geometry: i3, index: a3, sourceLayerIndex: s3 } = n3, o2 = t2[a3].feature;
                this.addFeature(n3, i3, a3, r2), e3.featureIndex.insert(o2, i3, a3, s3, this.index);
              }
            }
            update(t2, e3, r2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e3, this.stateDependentLayers, r2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, da), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t2, e3, r2, n2) {
              for (const r3 of e3)
                for (const e4 of r3) {
                  const r4 = e4.x, n3 = e4.y;
                  if (r4 < 0 || r4 >= qa || n3 < 0 || n3 >= qa)
                    continue;
                  const i2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), a2 = i2.vertexLength;
                  Ga(this.layoutVertexArray, r4, n3, -1, -1), Ga(this.layoutVertexArray, r4, n3, 1, -1), Ga(this.layoutVertexArray, r4, n3, 1, 1), Ga(this.layoutVertexArray, r4, n3, -1, 1), this.indexArray.emplaceBack(a2, a2 + 1, a2 + 2), this.indexArray.emplaceBack(a2, a2 + 3, a2 + 2), i2.vertexLength += 4, i2.primitiveLength += 2;
                }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2);
            }
          }
          function Xa(t2, e3) {
            for (let r2 = 0; r2 < t2.length; r2++)
              if (is(e3, t2[r2]))
                return true;
            for (let r2 = 0; r2 < e3.length; r2++)
              if (is(t2, e3[r2]))
                return true;
            return !!Qa(t2, e3);
          }
          function Ya(t2, e3, r2) {
            return !!is(t2, e3) || !!es(e3, t2, r2);
          }
          function Ha(t2, e3) {
            if (1 === t2.length)
              return ns(e3, t2[0]);
            for (let r2 = 0; r2 < e3.length; r2++) {
              const n2 = e3[r2];
              for (let e4 = 0; e4 < n2.length; e4++)
                if (is(t2, n2[e4]))
                  return true;
            }
            for (let r2 = 0; r2 < t2.length; r2++)
              if (ns(e3, t2[r2]))
                return true;
            for (let r2 = 0; r2 < e3.length; r2++)
              if (Qa(t2, e3[r2]))
                return true;
            return false;
          }
          function Wa(t2, e3, r2) {
            if (t2.length > 1) {
              if (Qa(t2, e3))
                return true;
              for (let n2 = 0; n2 < e3.length; n2++)
                if (es(e3[n2], t2, r2))
                  return true;
            }
            for (let n2 = 0; n2 < t2.length; n2++)
              if (es(t2[n2], e3, r2))
                return true;
            return false;
          }
          function Qa(t2, e3) {
            if (0 === t2.length || 0 === e3.length)
              return false;
            for (let r2 = 0; r2 < t2.length - 1; r2++) {
              const n2 = t2[r2], i2 = t2[r2 + 1];
              for (let t3 = 0; t3 < e3.length - 1; t3++)
                if (ts(n2, i2, e3[t3], e3[t3 + 1]))
                  return true;
            }
            return false;
          }
          function ts(t2, e3, r2, n2) {
            return y2(t2, r2, n2) !== y2(e3, r2, n2) && y2(t2, e3, r2) !== y2(t2, e3, n2);
          }
          function es(t2, e3, r2) {
            const n2 = r2 * r2;
            if (1 === e3.length)
              return t2.distSqr(e3[0]) < n2;
            for (let r3 = 1; r3 < e3.length; r3++)
              if (rs(t2, e3[r3 - 1], e3[r3]) < n2)
                return true;
            return false;
          }
          function rs(t2, e3, r2) {
            const n2 = e3.distSqr(r2);
            if (0 === n2)
              return t2.distSqr(e3);
            const i2 = ((t2.x - e3.x) * (r2.x - e3.x) + (t2.y - e3.y) * (r2.y - e3.y)) / n2;
            return t2.distSqr(i2 < 0 ? e3 : i2 > 1 ? r2 : r2.sub(e3)._mult(i2)._add(e3));
          }
          function ns(t2, e3) {
            let r2, n2, i2, a2 = false;
            for (let s2 = 0; s2 < t2.length; s2++) {
              r2 = t2[s2];
              for (let t3 = 0, s3 = r2.length - 1; t3 < r2.length; s3 = t3++)
                n2 = r2[t3], i2 = r2[s3], n2.y > e3.y != i2.y > e3.y && e3.x < (i2.x - n2.x) * (e3.y - n2.y) / (i2.y - n2.y) + n2.x && (a2 = !a2);
            }
            return a2;
          }
          function is(t2, e3) {
            let r2 = false;
            for (let n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
              const a2 = t2[n2], s2 = t2[i2];
              a2.y > e3.y != s2.y > e3.y && e3.x < (s2.x - a2.x) * (e3.y - a2.y) / (s2.y - a2.y) + a2.x && (r2 = !r2);
            }
            return r2;
          }
          function as(t2, e3, r2) {
            const n2 = r2[0], i2 = r2[2];
            if (t2.x < n2.x && e3.x < n2.x || t2.x > i2.x && e3.x > i2.x || t2.y < n2.y && e3.y < n2.y || t2.y > i2.y && e3.y > i2.y)
              return false;
            const a2 = y2(t2, e3, r2[0]);
            return a2 !== y2(t2, e3, r2[1]) || a2 !== y2(t2, e3, r2[2]) || a2 !== y2(t2, e3, r2[3]);
          }
          function ss(t2, e3, r2) {
            const n2 = e3.paint.get(t2).value;
            return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(e3.id).getMaxValue(t2);
          }
          function os(t2) {
            return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
          }
          function ls(t2, e3, r2, n2, i2) {
            if (!e3[0] && !e3[1])
              return t2;
            const a2 = S.convert(e3)._mult(i2);
            "viewport" === r2 && a2._rotate(-n2);
            const s2 = [];
            for (let e4 = 0; e4 < t2.length; e4++)
              s2.push(t2[e4].sub(a2));
            return s2;
          }
          Mn("CircleBucket", Ja, { omit: ["layers"] });
          const us = new fi({ "circle-sort-key": new ui(nt.layout_circle["circle-sort-key"]) });
          var cs = { paint: new fi({ "circle-radius": new ui(nt.paint_circle["circle-radius"]), "circle-color": new ui(nt.paint_circle["circle-color"]), "circle-blur": new ui(nt.paint_circle["circle-blur"]), "circle-opacity": new ui(nt.paint_circle["circle-opacity"]), "circle-translate": new li(nt.paint_circle["circle-translate"]), "circle-translate-anchor": new li(nt.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new li(nt.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new li(nt.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new ui(nt.paint_circle["circle-stroke-width"]), "circle-stroke-color": new ui(nt.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new ui(nt.paint_circle["circle-stroke-opacity"]) }), layout: us }, hs = 1e-6, ps = "undefined" != typeof Float32Array ? Float32Array : Array;
          function fs() {
            var t2 = new ps(9);
            return ps != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
          }
          function ds(t2) {
            return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
          }
          function ys(t2, e3, r2) {
            var n2 = e3[0], i2 = e3[1], a2 = e3[2], s2 = e3[3], o2 = e3[4], l2 = e3[5], u2 = e3[6], c2 = e3[7], h2 = e3[8], p2 = e3[9], f2 = e3[10], d2 = e3[11], y3 = e3[12], m2 = e3[13], g2 = e3[14], x3 = e3[15], v2 = r2[0], b2 = r2[1], w2 = r2[2], _2 = r2[3];
            return t2[0] = v2 * n2 + b2 * o2 + w2 * h2 + _2 * y3, t2[1] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[2] = v2 * a2 + b2 * u2 + w2 * f2 + _2 * g2, t2[3] = v2 * s2 + b2 * c2 + w2 * d2 + _2 * x3, t2[4] = (v2 = r2[4]) * n2 + (b2 = r2[5]) * o2 + (w2 = r2[6]) * h2 + (_2 = r2[7]) * y3, t2[5] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[6] = v2 * a2 + b2 * u2 + w2 * f2 + _2 * g2, t2[7] = v2 * s2 + b2 * c2 + w2 * d2 + _2 * x3, t2[8] = (v2 = r2[8]) * n2 + (b2 = r2[9]) * o2 + (w2 = r2[10]) * h2 + (_2 = r2[11]) * y3, t2[9] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[10] = v2 * a2 + b2 * u2 + w2 * f2 + _2 * g2, t2[11] = v2 * s2 + b2 * c2 + w2 * d2 + _2 * x3, t2[12] = (v2 = r2[12]) * n2 + (b2 = r2[13]) * o2 + (w2 = r2[14]) * h2 + (_2 = r2[15]) * y3, t2[13] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[14] = v2 * a2 + b2 * u2 + w2 * f2 + _2 * g2, t2[15] = v2 * s2 + b2 * c2 + w2 * d2 + _2 * x3, t2;
          }
          Math.hypot || (Math.hypot = function() {
            for (var t2 = 0, e3 = arguments.length; e3--; )
              t2 += arguments[e3] * arguments[e3];
            return Math.sqrt(t2);
          });
          var ms, gs = ys;
          function xs() {
            var t2 = new ps(3);
            return ps != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
          }
          function vs(t2, e3, r2) {
            var n2 = new ps(3);
            return n2[0] = t2, n2[1] = e3, n2[2] = r2, n2;
          }
          function bs(t2, e3, r2) {
            var n2 = e3[0], i2 = e3[1], a2 = e3[2], s2 = e3[3];
            return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * a2 + r2[12] * s2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * a2 + r2[13] * s2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * a2 + r2[14] * s2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * a2 + r2[15] * s2, t2;
          }
          function ws() {
            var t2 = new ps(4);
            return ps != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
          }
          function _s(t2, e3) {
            const r2 = bs([], [t2.x, t2.y, 0, 1], e3);
            return new S(r2[0] / r2[3], r2[1] / r2[3]);
          }
          xs(), ms = new ps(4), ps != Float32Array && (ms[0] = 0, ms[1] = 0, ms[2] = 0, ms[3] = 0), xs(), vs(1, 0, 0), vs(0, 1, 0), ws(), ws(), fs(), function() {
            var t2;
            t2 = new ps(2), ps != Float32Array && (t2[0] = 0, t2[1] = 0);
          }();
          class As extends Ja {
          }
          Mn("HeatmapBucket", As, { omit: ["layers"] });
          var ks = { paint: new fi({ "heatmap-radius": new ui(nt.paint_heatmap["heatmap-radius"]), "heatmap-weight": new ui(nt.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new li(nt.paint_heatmap["heatmap-intensity"]), "heatmap-color": new pi2(nt.paint_heatmap["heatmap-color"]), "heatmap-opacity": new li(nt.paint_heatmap["heatmap-opacity"]) }) };
          function Ss(t2, { width: e3, height: r2 }, n2, i2) {
            if (i2) {
              if (i2 instanceof Uint8ClampedArray)
                i2 = new Uint8Array(i2.buffer);
              else if (i2.length !== e3 * r2 * n2)
                throw new RangeError(`mismatched image size. expected: ${i2.length} but got: ${e3 * r2 * n2}`);
            } else
              i2 = new Uint8Array(e3 * r2 * n2);
            return t2.width = e3, t2.height = r2, t2.data = i2, t2;
          }
          function Is(t2, { width: e3, height: r2 }, n2) {
            if (e3 === t2.width && r2 === t2.height)
              return;
            const i2 = Ss({}, { width: e3, height: r2 }, n2);
            Ms(t2, i2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, e3), height: Math.min(t2.height, r2) }, n2), t2.width = e3, t2.height = r2, t2.data = i2.data;
          }
          function Ms(t2, e3, r2, n2, i2, a2) {
            if (0 === i2.width || 0 === i2.height)
              return e3;
            if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height)
              throw new RangeError("out of range source coordinates for image copy");
            if (i2.width > e3.width || i2.height > e3.height || n2.x > e3.width - i2.width || n2.y > e3.height - i2.height)
              throw new RangeError("out of range destination coordinates for image copy");
            const s2 = t2.data, o2 = e3.data;
            if (s2 === o2)
              throw new Error("srcData equals dstData, so image is already copied");
            for (let l2 = 0; l2 < i2.height; l2++) {
              const u2 = ((r2.y + l2) * t2.width + r2.x) * a2, c2 = ((n2.y + l2) * e3.width + n2.x) * a2;
              for (let t3 = 0; t3 < i2.width * a2; t3++)
                o2[c2 + t3] = s2[u2 + t3];
            }
            return e3;
          }
          class zs {
            constructor(t2, e3) {
              Ss(this, t2, 1, e3);
            }
            resize(t2) {
              Is(this, t2, 1);
            }
            clone() {
              return new zs({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t2, e3, r2, n2, i2) {
              Ms(t2, e3, r2, n2, i2, 1);
            }
          }
          class Bs {
            constructor(t2, e3) {
              Ss(this, t2, 4, e3);
            }
            resize(t2) {
              Is(this, t2, 4);
            }
            replace(t2, e3) {
              e3 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
            }
            clone() {
              return new Bs({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t2, e3, r2, n2, i2) {
              Ms(t2, e3, r2, n2, i2, 4);
            }
          }
          function Cs(t2) {
            const e3 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new Bs({ width: r2, height: n2 });
            if (Math.log(r2) / Math.LN2 % 1 != 0)
              throw new Error(`width is not a power of 2 - ${r2}`);
            const a2 = (r3, n3, a3) => {
              e3[t2.evaluationKey] = a3;
              const s2 = t2.expression.evaluate(e3);
              i2.data[r3 + n3 + 0] = Math.floor(255 * s2.r / s2.a), i2.data[r3 + n3 + 1] = Math.floor(255 * s2.g / s2.a), i2.data[r3 + n3 + 2] = Math.floor(255 * s2.b / s2.a), i2.data[r3 + n3 + 3] = Math.floor(255 * s2.a);
            };
            if (t2.clips)
              for (let e4 = 0, i3 = 0; e4 < n2; ++e4, i3 += 4 * r2)
                for (let n3 = 0, s2 = 0; n3 < r2; n3++, s2 += 4) {
                  const o2 = n3 / (r2 - 1), { start: l2, end: u2 } = t2.clips[e4];
                  a2(i3, s2, l2 * (1 - o2) + u2 * o2);
                }
            else
              for (let t3 = 0, e4 = 0; t3 < r2; t3++, e4 += 4)
                a2(0, e4, t3 / (r2 - 1));
            return i2;
          }
          Mn("AlphaImage", zs), Mn("RGBAImage", Bs);
          var Ps = { paint: new fi({ "hillshade-illumination-direction": new li(nt.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new li(nt.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new li(nt.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new li(nt.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new li(nt.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new li(nt.paint_hillshade["hillshade-accent-color"]) }) };
          const Vs = vi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Es } = Vs;
          var Fs = { exports: {} };
          function Ts(t2, e3, r2) {
            r2 = r2 || 2;
            var n2, i2, a2, s2, o2, l2, u2, c2 = e3 && e3.length, h2 = c2 ? e3[0] * r2 : t2.length, p2 = Ls(t2, 0, h2, r2, true), f2 = [];
            if (!p2 || p2.next === p2.prev)
              return f2;
            if (c2 && (p2 = function(t3, e4, r3, n3) {
              var i3, a3, s3, o3 = [];
              for (i3 = 0, a3 = e4.length; i3 < a3; i3++)
                (s3 = Ls(t3, e4[i3] * n3, i3 < a3 - 1 ? e4[i3 + 1] * n3 : t3.length, n3, false)) === s3.next && (s3.steiner = true), o3.push(Gs(s3));
              for (o3.sort(js), i3 = 0; i3 < o3.length; i3++)
                r3 = Ns(o3[i3], r3);
              return r3;
            }(t2, e3, p2, r2)), t2.length > 80 * r2) {
              n2 = a2 = t2[0], i2 = s2 = t2[1];
              for (var d2 = r2; d2 < h2; d2 += r2)
                (o2 = t2[d2]) < n2 && (n2 = o2), (l2 = t2[d2 + 1]) < i2 && (i2 = l2), o2 > a2 && (a2 = o2), l2 > s2 && (s2 = l2);
              u2 = 0 !== (u2 = Math.max(a2 - n2, s2 - i2)) ? 32767 / u2 : 0;
            }
            return $s(p2, f2, r2, n2, i2, u2, 0), f2;
          }
          function Ls(t2, e3, r2, n2, i2) {
            var a2, s2;
            if (i2 === so(t2, e3, r2, n2) > 0)
              for (a2 = e3; a2 < r2; a2 += n2)
                s2 = no(a2, t2[a2], t2[a2 + 1], s2);
            else
              for (a2 = r2 - n2; a2 >= e3; a2 -= n2)
                s2 = no(a2, t2[a2], t2[a2 + 1], s2);
            return s2 && Hs(s2, s2.next) && (io(s2), s2 = s2.next), s2;
          }
          function Ds(t2, e3) {
            if (!t2)
              return t2;
            e3 || (e3 = t2);
            var r2, n2 = t2;
            do {
              if (r2 = false, n2.steiner || !Hs(n2, n2.next) && 0 !== Ys(n2.prev, n2, n2.next))
                n2 = n2.next;
              else {
                if (io(n2), (n2 = e3 = n2.prev) === n2.next)
                  break;
                r2 = true;
              }
            } while (r2 || n2 !== e3);
            return e3;
          }
          function $s(t2, e3, r2, n2, i2, a2, s2) {
            if (t2) {
              !s2 && a2 && function(t3, e4, r3, n3) {
                var i3 = t3;
                do {
                  0 === i3.z && (i3.z = Ks(i3.x, i3.y, e4, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
                } while (i3 !== t3);
                i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
                  var e6, r4, n4, i4, a3, s3, o3, l3, u3 = 1;
                  do {
                    for (r4 = t4, t4 = null, a3 = null, s3 = 0; r4; ) {
                      for (s3++, n4 = r4, o3 = 0, e6 = 0; e6 < u3 && (o3++, n4 = n4.nextZ); e6++)
                        ;
                      for (l3 = u3; o3 > 0 || l3 > 0 && n4; )
                        0 !== o3 && (0 === l3 || !n4 || r4.z <= n4.z) ? (i4 = r4, r4 = r4.nextZ, o3--) : (i4 = n4, n4 = n4.nextZ, l3--), a3 ? a3.nextZ = i4 : t4 = i4, i4.prevZ = a3, a3 = i4;
                      r4 = n4;
                    }
                    a3.nextZ = null, u3 *= 2;
                  } while (s3 > 1);
                }(i3);
              }(t2, n2, i2, a2);
              for (var o2, l2, u2 = t2; t2.prev !== t2.next; )
                if (o2 = t2.prev, l2 = t2.next, a2 ? Os(t2, n2, i2, a2) : Rs(t2))
                  e3.push(o2.i / r2 | 0), e3.push(t2.i / r2 | 0), e3.push(l2.i / r2 | 0), io(t2), t2 = l2.next, u2 = l2.next;
                else if ((t2 = l2) === u2) {
                  s2 ? 1 === s2 ? $s(t2 = Us(Ds(t2), e3, r2), e3, r2, n2, i2, a2, 2) : 2 === s2 && qs(t2, e3, r2, n2, i2, a2) : $s(Ds(t2), e3, r2, n2, i2, a2, 1);
                  break;
                }
            }
          }
          function Rs(t2) {
            var e3 = t2.prev, r2 = t2, n2 = t2.next;
            if (Ys(e3, r2, n2) >= 0)
              return false;
            for (var i2 = e3.x, a2 = r2.x, s2 = n2.x, o2 = e3.y, l2 = r2.y, u2 = n2.y, c2 = i2 < a2 ? i2 < s2 ? i2 : s2 : a2 < s2 ? a2 : s2, h2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, p2 = i2 > a2 ? i2 > s2 ? i2 : s2 : a2 > s2 ? a2 : s2, f2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, d2 = n2.next; d2 !== e3; ) {
              if (d2.x >= c2 && d2.x <= p2 && d2.y >= h2 && d2.y <= f2 && Js(i2, o2, a2, l2, s2, u2, d2.x, d2.y) && Ys(d2.prev, d2, d2.next) >= 0)
                return false;
              d2 = d2.next;
            }
            return true;
          }
          function Os(t2, e3, r2, n2) {
            var i2 = t2.prev, a2 = t2, s2 = t2.next;
            if (Ys(i2, a2, s2) >= 0)
              return false;
            for (var o2 = i2.x, l2 = a2.x, u2 = s2.x, c2 = i2.y, h2 = a2.y, p2 = s2.y, f2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, d2 = c2 < h2 ? c2 < p2 ? c2 : p2 : h2 < p2 ? h2 : p2, y3 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, m2 = c2 > h2 ? c2 > p2 ? c2 : p2 : h2 > p2 ? h2 : p2, g2 = Ks(f2, d2, e3, r2, n2), x3 = Ks(y3, m2, e3, r2, n2), v2 = t2.prevZ, b2 = t2.nextZ; v2 && v2.z >= g2 && b2 && b2.z <= x3; ) {
              if (v2.x >= f2 && v2.x <= y3 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== s2 && Js(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && Ys(v2.prev, v2, v2.next) >= 0)
                return false;
              if (v2 = v2.prevZ, b2.x >= f2 && b2.x <= y3 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== s2 && Js(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && Ys(b2.prev, b2, b2.next) >= 0)
                return false;
              b2 = b2.nextZ;
            }
            for (; v2 && v2.z >= g2; ) {
              if (v2.x >= f2 && v2.x <= y3 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== s2 && Js(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && Ys(v2.prev, v2, v2.next) >= 0)
                return false;
              v2 = v2.prevZ;
            }
            for (; b2 && b2.z <= x3; ) {
              if (b2.x >= f2 && b2.x <= y3 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== s2 && Js(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && Ys(b2.prev, b2, b2.next) >= 0)
                return false;
              b2 = b2.nextZ;
            }
            return true;
          }
          function Us(t2, e3, r2) {
            var n2 = t2;
            do {
              var i2 = n2.prev, a2 = n2.next.next;
              !Hs(i2, a2) && Ws(i2, n2, n2.next, a2) && eo(i2, a2) && eo(a2, i2) && (e3.push(i2.i / r2 | 0), e3.push(n2.i / r2 | 0), e3.push(a2.i / r2 | 0), io(n2), io(n2.next), n2 = t2 = a2), n2 = n2.next;
            } while (n2 !== t2);
            return Ds(n2);
          }
          function qs(t2, e3, r2, n2, i2, a2) {
            var s2 = t2;
            do {
              for (var o2 = s2.next.next; o2 !== s2.prev; ) {
                if (s2.i !== o2.i && Xs(s2, o2)) {
                  var l2 = ro(s2, o2);
                  return s2 = Ds(s2, s2.next), l2 = Ds(l2, l2.next), $s(s2, e3, r2, n2, i2, a2, 0), void $s(l2, e3, r2, n2, i2, a2, 0);
                }
                o2 = o2.next;
              }
              s2 = s2.next;
            } while (s2 !== t2);
          }
          function js(t2, e3) {
            return t2.x - e3.x;
          }
          function Ns(t2, e3) {
            var r2 = function(t3, e4) {
              var r3, n3 = e4, i2 = t3.x, a2 = t3.y, s2 = -1 / 0;
              do {
                if (a2 <= n3.y && a2 >= n3.next.y && n3.next.y !== n3.y) {
                  var o2 = n3.x + (a2 - n3.y) * (n3.next.x - n3.x) / (n3.next.y - n3.y);
                  if (o2 <= i2 && o2 > s2 && (s2 = o2, r3 = n3.x < n3.next.x ? n3 : n3.next, o2 === i2))
                    return r3;
                }
                n3 = n3.next;
              } while (n3 !== e4);
              if (!r3)
                return null;
              var l2, u2 = r3, c2 = r3.x, h2 = r3.y, p2 = 1 / 0;
              n3 = r3;
              do {
                i2 >= n3.x && n3.x >= c2 && i2 !== n3.x && Js(a2 < h2 ? i2 : s2, a2, c2, h2, a2 < h2 ? s2 : i2, a2, n3.x, n3.y) && (l2 = Math.abs(a2 - n3.y) / (i2 - n3.x), eo(n3, t3) && (l2 < p2 || l2 === p2 && (n3.x > r3.x || n3.x === r3.x && Zs(r3, n3))) && (r3 = n3, p2 = l2)), n3 = n3.next;
              } while (n3 !== u2);
              return r3;
            }(t2, e3);
            if (!r2)
              return e3;
            var n2 = ro(r2, t2);
            return Ds(n2, n2.next), Ds(r2, r2.next);
          }
          function Zs(t2, e3) {
            return Ys(t2.prev, t2, e3.prev) < 0 && Ys(e3.next, t2, t2.next) < 0;
          }
          function Ks(t2, e3, r2, n2, i2) {
            return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e3 = 1431655765 & ((e3 = 858993459 & ((e3 = 252645135 & ((e3 = 16711935 & ((e3 = (e3 - n2) * i2 | 0) | e3 << 8)) | e3 << 4)) | e3 << 2)) | e3 << 1)) << 1;
          }
          function Gs(t2) {
            var e3 = t2, r2 = t2;
            do {
              (e3.x < r2.x || e3.x === r2.x && e3.y < r2.y) && (r2 = e3), e3 = e3.next;
            } while (e3 !== t2);
            return r2;
          }
          function Js(t2, e3, r2, n2, i2, a2, s2, o2) {
            return (i2 - s2) * (e3 - o2) >= (t2 - s2) * (a2 - o2) && (t2 - s2) * (n2 - o2) >= (r2 - s2) * (e3 - o2) && (r2 - s2) * (a2 - o2) >= (i2 - s2) * (n2 - o2);
          }
          function Xs(t2, e3) {
            return t2.next.i !== e3.i && t2.prev.i !== e3.i && !function(t3, e4) {
              var r2 = t3;
              do {
                if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e4.i && r2.next.i !== e4.i && Ws(r2, r2.next, t3, e4))
                  return true;
                r2 = r2.next;
              } while (r2 !== t3);
              return false;
            }(t2, e3) && (eo(t2, e3) && eo(e3, t2) && function(t3, e4) {
              var r2 = t3, n2 = false, i2 = (t3.x + e4.x) / 2, a2 = (t3.y + e4.y) / 2;
              do {
                r2.y > a2 != r2.next.y > a2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (a2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
              } while (r2 !== t3);
              return n2;
            }(t2, e3) && (Ys(t2.prev, t2, e3.prev) || Ys(t2, e3.prev, e3)) || Hs(t2, e3) && Ys(t2.prev, t2, t2.next) > 0 && Ys(e3.prev, e3, e3.next) > 0);
          }
          function Ys(t2, e3, r2) {
            return (e3.y - t2.y) * (r2.x - e3.x) - (e3.x - t2.x) * (r2.y - e3.y);
          }
          function Hs(t2, e3) {
            return t2.x === e3.x && t2.y === e3.y;
          }
          function Ws(t2, e3, r2, n2) {
            var i2 = to(Ys(t2, e3, r2)), a2 = to(Ys(t2, e3, n2)), s2 = to(Ys(r2, n2, t2)), o2 = to(Ys(r2, n2, e3));
            return i2 !== a2 && s2 !== o2 || !(0 !== i2 || !Qs(t2, r2, e3)) || !(0 !== a2 || !Qs(t2, n2, e3)) || !(0 !== s2 || !Qs(r2, t2, n2)) || !(0 !== o2 || !Qs(r2, e3, n2));
          }
          function Qs(t2, e3, r2) {
            return e3.x <= Math.max(t2.x, r2.x) && e3.x >= Math.min(t2.x, r2.x) && e3.y <= Math.max(t2.y, r2.y) && e3.y >= Math.min(t2.y, r2.y);
          }
          function to(t2) {
            return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
          }
          function eo(t2, e3) {
            return Ys(t2.prev, t2, t2.next) < 0 ? Ys(t2, e3, t2.next) >= 0 && Ys(t2, t2.prev, e3) >= 0 : Ys(t2, e3, t2.prev) < 0 || Ys(t2, t2.next, e3) < 0;
          }
          function ro(t2, e3) {
            var r2 = new ao(t2.i, t2.x, t2.y), n2 = new ao(e3.i, e3.x, e3.y), i2 = t2.next, a2 = e3.prev;
            return t2.next = e3, e3.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, a2.next = n2, n2.prev = a2, n2;
          }
          function no(t2, e3, r2, n2) {
            var i2 = new ao(t2, e3, r2);
            return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
          }
          function io(t2) {
            t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
          }
          function ao(t2, e3, r2) {
            this.i = t2, this.x = e3, this.y = r2, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
          }
          function so(t2, e3, r2, n2) {
            for (var i2 = 0, a2 = e3, s2 = r2 - n2; a2 < r2; a2 += n2)
              i2 += (t2[s2] - t2[a2]) * (t2[a2 + 1] + t2[s2 + 1]), s2 = a2;
            return i2;
          }
          function oo(t2, e3, r2, n2, i2) {
            lo(t2, e3, r2 || 0, n2 || t2.length - 1, i2 || co);
          }
          function lo(t2, e3, r2, n2, i2) {
            for (; n2 > r2; ) {
              if (n2 - r2 > 600) {
                var a2 = n2 - r2 + 1, s2 = e3 - r2 + 1, o2 = Math.log(a2), l2 = 0.5 * Math.exp(2 * o2 / 3), u2 = 0.5 * Math.sqrt(o2 * l2 * (a2 - l2) / a2) * (s2 - a2 / 2 < 0 ? -1 : 1);
                lo(t2, e3, Math.max(r2, Math.floor(e3 - s2 * l2 / a2 + u2)), Math.min(n2, Math.floor(e3 + (a2 - s2) * l2 / a2 + u2)), i2);
              }
              var c2 = t2[e3], h2 = r2, p2 = n2;
              for (uo(t2, r2, e3), i2(t2[n2], c2) > 0 && uo(t2, r2, n2); h2 < p2; ) {
                for (uo(t2, h2, p2), h2++, p2--; i2(t2[h2], c2) < 0; )
                  h2++;
                for (; i2(t2[p2], c2) > 0; )
                  p2--;
              }
              0 === i2(t2[r2], c2) ? uo(t2, r2, p2) : uo(t2, ++p2, n2), p2 <= e3 && (r2 = p2 + 1), e3 <= p2 && (n2 = p2 - 1);
            }
          }
          function uo(t2, e3, r2) {
            var n2 = t2[e3];
            t2[e3] = t2[r2], t2[r2] = n2;
          }
          function co(t2, e3) {
            return t2 < e3 ? -1 : t2 > e3 ? 1 : 0;
          }
          function ho(t2, e3) {
            const r2 = t2.length;
            if (r2 <= 1)
              return [t2];
            const n2 = [];
            let i2, a2;
            for (let e4 = 0; e4 < r2; e4++) {
              const r3 = m(t2[e4]);
              0 !== r3 && (t2[e4].area = Math.abs(r3), void 0 === a2 && (a2 = r3 < 0), a2 === r3 < 0 ? (i2 && n2.push(i2), i2 = [t2[e4]]) : i2.push(t2[e4]));
            }
            if (i2 && n2.push(i2), e3 > 1)
              for (let t3 = 0; t3 < n2.length; t3++)
                n2[t3].length <= e3 || (oo(n2[t3], e3, 1, n2[t3].length - 1, po), n2[t3] = n2[t3].slice(0, e3));
            return n2;
          }
          function po(t2, e3) {
            return e3.area - t2.area;
          }
          function fo(t2, e3, r2) {
            const n2 = r2.patternDependencies;
            let i2 = false;
            for (const r3 of e3) {
              const e4 = r3.paint.get(`${t2}-pattern`);
              e4.isConstant() || (i2 = true);
              const a2 = e4.constantOr(null);
              a2 && (i2 = true, n2[a2.to] = true, n2[a2.from] = true);
            }
            return i2;
          }
          function yo(t2, e3, r2, n2, i2) {
            const a2 = i2.patternDependencies;
            for (const s2 of e3) {
              const e4 = s2.paint.get(`${t2}-pattern`).value;
              if ("constant" !== e4.kind) {
                let t3 = e4.evaluate({ zoom: n2 - 1 }, r2, {}, i2.availableImages), o2 = e4.evaluate({ zoom: n2 }, r2, {}, i2.availableImages), l2 = e4.evaluate({ zoom: n2 + 1 }, r2, {}, i2.availableImages);
                t3 = t3 && t3.name ? t3.name : t3, o2 = o2 && o2.name ? o2.name : o2, l2 = l2 && l2.name ? l2.name : l2, a2[t3] = true, a2[o2] = true, a2[l2] = true, r2.patterns[s2.id] = { min: t3, mid: o2, max: l2 };
              }
            }
            return r2;
          }
          Fs.exports = Ts, Fs.exports.default = Ts, Ts.deviation = function(t2, e3, r2, n2) {
            var i2 = e3 && e3.length, a2 = Math.abs(so(t2, 0, i2 ? e3[0] * r2 : t2.length, r2));
            if (i2)
              for (var s2 = 0, o2 = e3.length; s2 < o2; s2++)
                a2 -= Math.abs(so(t2, e3[s2] * r2, s2 < o2 - 1 ? e3[s2 + 1] * r2 : t2.length, r2));
            var l2 = 0;
            for (s2 = 0; s2 < n2.length; s2 += 3) {
              var u2 = n2[s2] * r2, c2 = n2[s2 + 1] * r2, h2 = n2[s2 + 2] * r2;
              l2 += Math.abs((t2[u2] - t2[h2]) * (t2[c2 + 1] - t2[u2 + 1]) - (t2[u2] - t2[c2]) * (t2[h2 + 1] - t2[u2 + 1]));
            }
            return 0 === a2 && 0 === l2 ? 0 : Math.abs((l2 - a2) / a2);
          }, Ts.flatten = function(t2) {
            for (var e3 = t2[0][0].length, r2 = { vertices: [], holes: [], dimensions: e3 }, n2 = 0, i2 = 0; i2 < t2.length; i2++) {
              for (var a2 = 0; a2 < t2[i2].length; a2++)
                for (var s2 = 0; s2 < e3; s2++)
                  r2.vertices.push(t2[i2][a2][s2]);
              i2 > 0 && r2.holes.push(n2 += t2[i2 - 1].length);
            }
            return r2;
          };
          class mo {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new ea(), this.indexArray = new ha(), this.indexArray2 = new pa(), this.programConfigurations = new Ra(t2.layers, t2.zoom), this.segments = new ya(), this.segments2 = new ya(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            populate(t2, e3, r2) {
              this.hasPattern = fo("fill", this.layers, e3);
              const n2 = this.layers[0].layout.get("fill-sort-key"), i2 = !n2.isConstant(), a2 = [];
              for (const { feature: s2, id: o2, index: l2, sourceLayerIndex: u2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, c2 = Ka(s2, t3);
                if (!this.layers[0]._featureFilter.filter(new Qn(this.zoom), c2, r2))
                  continue;
                const h2 = i2 ? n2.evaluate(c2, {}, r2, e3.availableImages) : void 0, p2 = { id: o2, properties: s2.properties, type: s2.type, sourceLayerIndex: u2, index: l2, geometry: t3 ? c2.geometry : Za(s2), patterns: {}, sortKey: h2 };
                a2.push(p2);
              }
              i2 && a2.sort((t3, e4) => t3.sortKey - e4.sortKey);
              for (const n3 of a2) {
                const { geometry: i3, index: a3, sourceLayerIndex: s2 } = n3;
                if (this.hasPattern) {
                  const t3 = yo("fill", this.layers, n3, this.zoom, e3);
                  this.patternFeatures.push(t3);
                } else
                  this.addFeature(n3, i3, a3, r2, {});
                e3.featureIndex.insert(t2[a3].feature, i3, a3, s2, this.index);
              }
            }
            update(t2, e3, r2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e3, this.stateDependentLayers, r2);
            }
            addFeatures(t2, e3, r2) {
              for (const t3 of this.patternFeatures)
                this.addFeature(t3, t3.geometry, t3.index, e3, r2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Es), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
            }
            addFeature(t2, e3, r2, n2, i2) {
              for (const t3 of ho(e3, 500)) {
                let e4 = 0;
                for (const r4 of t3)
                  e4 += r4.length;
                const r3 = this.segments.prepareSegment(e4, this.layoutVertexArray, this.indexArray), n3 = r3.vertexLength, i3 = [], a2 = [];
                for (const e6 of t3) {
                  if (0 === e6.length)
                    continue;
                  e6 !== t3[0] && a2.push(i3.length / 2);
                  const r4 = this.segments2.prepareSegment(e6.length, this.layoutVertexArray, this.indexArray2), n4 = r4.vertexLength;
                  this.layoutVertexArray.emplaceBack(e6[0].x, e6[0].y), this.indexArray2.emplaceBack(n4 + e6.length - 1, n4), i3.push(e6[0].x), i3.push(e6[0].y);
                  for (let t4 = 1; t4 < e6.length; t4++)
                    this.layoutVertexArray.emplaceBack(e6[t4].x, e6[t4].y), this.indexArray2.emplaceBack(n4 + t4 - 1, n4 + t4), i3.push(e6[t4].x), i3.push(e6[t4].y);
                  r4.vertexLength += e6.length, r4.primitiveLength += e6.length;
                }
                const s2 = Fs.exports(i3, a2);
                for (let t4 = 0; t4 < s2.length; t4 += 3)
                  this.indexArray.emplaceBack(n3 + s2[t4], n3 + s2[t4 + 1], n3 + s2[t4 + 2]);
                r3.vertexLength += e4, r3.primitiveLength += s2.length / 3;
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
            }
          }
          Mn("FillBucket", mo, { omit: ["layers", "patternFeatures"] });
          const go = new fi({ "fill-sort-key": new ui(nt.layout_fill["fill-sort-key"]) });
          var xo = { paint: new fi({ "fill-antialias": new li(nt.paint_fill["fill-antialias"]), "fill-opacity": new ui(nt.paint_fill["fill-opacity"]), "fill-color": new ui(nt.paint_fill["fill-color"]), "fill-outline-color": new ui(nt.paint_fill["fill-outline-color"]), "fill-translate": new li(nt.paint_fill["fill-translate"]), "fill-translate-anchor": new li(nt.paint_fill["fill-translate-anchor"]), "fill-pattern": new ci(nt.paint_fill["fill-pattern"]) }), layout: go };
          const vo = vi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), bo = vi([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: wo } = vo;
          var _o = {}, Ao = S, ko = So;
          function So(t2, e3, r2, n2, i2) {
            this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(Io, this, e3);
          }
          function Io(t2, e3, r2) {
            1 == t2 ? e3.id = r2.readVarint() : 2 == t2 ? function(t3, e4) {
              for (var r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
                var n2 = e4._keys[t3.readVarint()], i2 = e4._values[t3.readVarint()];
                e4.properties[n2] = i2;
              }
            }(r2, e3) : 3 == t2 ? e3.type = r2.readVarint() : 4 == t2 && (e3._geometry = r2.pos);
          }
          function Mo(t2) {
            for (var e3, r2, n2 = 0, i2 = 0, a2 = t2.length, s2 = a2 - 1; i2 < a2; s2 = i2++)
              n2 += ((r2 = t2[s2]).x - (e3 = t2[i2]).x) * (e3.y + r2.y);
            return n2;
          }
          So.types = ["Unknown", "Point", "LineString", "Polygon"], So.prototype.loadGeometry = function() {
            var t2 = this._pbf;
            t2.pos = this._geometry;
            for (var e3, r2 = t2.readVarint() + t2.pos, n2 = 1, i2 = 0, a2 = 0, s2 = 0, o2 = []; t2.pos < r2; ) {
              if (i2 <= 0) {
                var l2 = t2.readVarint();
                n2 = 7 & l2, i2 = l2 >> 3;
              }
              if (i2--, 1 === n2 || 2 === n2)
                a2 += t2.readSVarint(), s2 += t2.readSVarint(), 1 === n2 && (e3 && o2.push(e3), e3 = []), e3.push(new Ao(a2, s2));
              else {
                if (7 !== n2)
                  throw new Error("unknown command " + n2);
                e3 && e3.push(e3[0].clone());
              }
            }
            return e3 && o2.push(e3), o2;
          }, So.prototype.bbox = function() {
            var t2 = this._pbf;
            t2.pos = this._geometry;
            for (var e3 = t2.readVarint() + t2.pos, r2 = 1, n2 = 0, i2 = 0, a2 = 0, s2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0; t2.pos < e3; ) {
              if (n2 <= 0) {
                var c2 = t2.readVarint();
                r2 = 7 & c2, n2 = c2 >> 3;
              }
              if (n2--, 1 === r2 || 2 === r2)
                (i2 += t2.readSVarint()) < s2 && (s2 = i2), i2 > o2 && (o2 = i2), (a2 += t2.readSVarint()) < l2 && (l2 = a2), a2 > u2 && (u2 = a2);
              else if (7 !== r2)
                throw new Error("unknown command " + r2);
            }
            return [s2, l2, o2, u2];
          }, So.prototype.toGeoJSON = function(t2, e3, r2) {
            var n2, i2, a2 = this.extent * Math.pow(2, r2), s2 = this.extent * t2, o2 = this.extent * e3, l2 = this.loadGeometry(), u2 = So.types[this.type];
            function c2(t3) {
              for (var e4 = 0; e4 < t3.length; e4++) {
                var r3 = t3[e4];
                t3[e4] = [360 * (r3.x + s2) / a2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + o2) / a2) * Math.PI / 180)) - 90];
              }
            }
            switch (this.type) {
              case 1:
                var h2 = [];
                for (n2 = 0; n2 < l2.length; n2++)
                  h2[n2] = l2[n2][0];
                c2(l2 = h2);
                break;
              case 2:
                for (n2 = 0; n2 < l2.length; n2++)
                  c2(l2[n2]);
                break;
              case 3:
                for (l2 = function(t3) {
                  var e4 = t3.length;
                  if (e4 <= 1)
                    return [t3];
                  for (var r3, n3, i3 = [], a3 = 0; a3 < e4; a3++) {
                    var s3 = Mo(t3[a3]);
                    0 !== s3 && (void 0 === n3 && (n3 = s3 < 0), n3 === s3 < 0 ? (r3 && i3.push(r3), r3 = [t3[a3]]) : r3.push(t3[a3]));
                  }
                  return r3 && i3.push(r3), i3;
                }(l2), n2 = 0; n2 < l2.length; n2++)
                  for (i2 = 0; i2 < l2[n2].length; i2++)
                    c2(l2[n2][i2]);
            }
            1 === l2.length ? l2 = l2[0] : u2 = "Multi" + u2;
            var p2 = { type: "Feature", geometry: { type: u2, coordinates: l2 }, properties: this.properties };
            return "id" in this && (p2.id = this.id), p2;
          };
          var zo = ko, Bo = Co;
          function Co(t2, e3) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(Po, this, e3), this.length = this._features.length;
          }
          function Po(t2, e3, r2) {
            15 === t2 ? e3.version = r2.readVarint() : 1 === t2 ? e3.name = r2.readString() : 5 === t2 ? e3.extent = r2.readVarint() : 2 === t2 ? e3._features.push(r2.pos) : 3 === t2 ? e3._keys.push(r2.readString()) : 4 === t2 && e3._values.push(function(t3) {
              for (var e4 = null, r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
                var n2 = t3.readVarint() >> 3;
                e4 = 1 === n2 ? t3.readString() : 2 === n2 ? t3.readFloat() : 3 === n2 ? t3.readDouble() : 4 === n2 ? t3.readVarint64() : 5 === n2 ? t3.readVarint() : 6 === n2 ? t3.readSVarint() : 7 === n2 ? t3.readBoolean() : null;
              }
              return e4;
            }(r2));
          }
          Co.prototype.feature = function(t2) {
            if (t2 < 0 || t2 >= this._features.length)
              throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t2];
            var e3 = this._pbf.readVarint() + this._pbf.pos;
            return new zo(this._pbf, e3, this.extent, this._keys, this._values);
          };
          var Vo = Bo;
          function Eo(t2, e3, r2) {
            if (3 === t2) {
              var n2 = new Vo(r2, r2.readVarint() + r2.pos);
              n2.length && (e3[n2.name] = n2);
            }
          }
          _o.VectorTile = function(t2, e3) {
            this.layers = t2.readFields(Eo, {}, e3);
          }, _o.VectorTileFeature = ko, _o.VectorTileLayer = Bo;
          const Fo = _o.VectorTileFeature.types, To = Math.pow(2, 13);
          function Lo(t2, e3, r2, n2, i2, a2, s2, o2) {
            t2.emplaceBack(e3, r2, 2 * Math.floor(n2 * To) + s2, i2 * To * 2, a2 * To * 2, Math.round(o2));
          }
          class Do {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new ra(), this.centroidVertexArray = new Qi(), this.indexArray = new ha(), this.programConfigurations = new Ra(t2.layers, t2.zoom), this.segments = new ya(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            populate(t2, e3, r2) {
              this.features = [], this.hasPattern = fo("fill-extrusion", this.layers, e3);
              for (const { feature: n2, id: i2, index: a2, sourceLayerIndex: s2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, o2 = Ka(n2, t3);
                if (!this.layers[0]._featureFilter.filter(new Qn(this.zoom), o2, r2))
                  continue;
                const l2 = { id: i2, sourceLayerIndex: s2, index: a2, geometry: t3 ? o2.geometry : Za(n2), properties: n2.properties, type: n2.type, patterns: {} };
                this.hasPattern ? this.features.push(yo("fill-extrusion", this.layers, l2, this.zoom, e3)) : this.addFeature(l2, l2.geometry, a2, r2, {}), e3.featureIndex.insert(n2, l2.geometry, a2, s2, this.index, true);
              }
            }
            addFeatures(t2, e3, r2) {
              for (const t3 of this.features) {
                const { geometry: n2 } = t3;
                this.addFeature(t3, n2, t3.index, e3, r2);
              }
            }
            update(t2, e3, r2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e3, this.stateDependentLayers, r2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, wo), this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, bo.members, true), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
            }
            addFeature(t2, e3, r2, n2, i2) {
              const a2 = { x: 0, y: 0, vertexCount: 0 };
              for (const r3 of ho(e3, 500)) {
                let e4 = 0;
                for (const t3 of r3)
                  e4 += t3.length;
                let n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
                for (const t3 of r3) {
                  if (0 === t3.length)
                    continue;
                  if (Ro(t3))
                    continue;
                  let e6 = 0;
                  for (let r4 = 0; r4 < t3.length; r4++) {
                    const i4 = t3[r4];
                    if (r4 >= 1) {
                      const s3 = t3[r4 - 1];
                      if (!$o(i4, s3)) {
                        n3.vertexLength + 4 > ya.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                        const t4 = i4.sub(s3)._perp()._unit(), r5 = s3.dist(i4);
                        e6 + r5 > 32768 && (e6 = 0), Lo(this.layoutVertexArray, i4.x, i4.y, t4.x, t4.y, 0, 0, e6), Lo(this.layoutVertexArray, i4.x, i4.y, t4.x, t4.y, 0, 1, e6), a2.x += 2 * i4.x, a2.y += 2 * i4.y, a2.vertexCount += 2, e6 += r5, Lo(this.layoutVertexArray, s3.x, s3.y, t4.x, t4.y, 0, 0, e6), Lo(this.layoutVertexArray, s3.x, s3.y, t4.x, t4.y, 0, 1, e6), a2.x += 2 * s3.x, a2.y += 2 * s3.y, a2.vertexCount += 2;
                        const o3 = n3.vertexLength;
                        this.indexArray.emplaceBack(o3, o3 + 2, o3 + 1), this.indexArray.emplaceBack(o3 + 1, o3 + 2, o3 + 3), n3.vertexLength += 4, n3.primitiveLength += 2;
                      }
                    }
                  }
                }
                if (n3.vertexLength + e4 > ya.MAX_VERTEX_ARRAY_LENGTH && (n3 = this.segments.prepareSegment(e4, this.layoutVertexArray, this.indexArray)), "Polygon" !== Fo[t2.type])
                  continue;
                const i3 = [], s2 = [], o2 = n3.vertexLength;
                for (const t3 of r3)
                  if (0 !== t3.length) {
                    t3 !== r3[0] && s2.push(i3.length / 2);
                    for (let e6 = 0; e6 < t3.length; e6++) {
                      const r4 = t3[e6];
                      Lo(this.layoutVertexArray, r4.x, r4.y, 0, 0, 1, 1, 0), a2.x += r4.x, a2.y += r4.y, a2.vertexCount += 1, i3.push(r4.x), i3.push(r4.y);
                    }
                  }
                const l2 = Fs.exports(i3, s2);
                for (let t3 = 0; t3 < l2.length; t3 += 3)
                  this.indexArray.emplaceBack(o2 + l2[t3], o2 + l2[t3 + 2], o2 + l2[t3 + 1]);
                n3.primitiveLength += l2.length / 3, n3.vertexLength += e4;
              }
              for (let t3 = 0; t3 < a2.vertexCount; t3++)
                this.centroidVertexArray.emplaceBack(Math.floor(a2.x / a2.vertexCount), Math.floor(a2.y / a2.vertexCount));
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
            }
          }
          function $o(t2, e3) {
            return t2.x === e3.x && (t2.x < 0 || t2.x > qa) || t2.y === e3.y && (t2.y < 0 || t2.y > qa);
          }
          function Ro(t2) {
            return t2.every((t3) => t3.x < 0) || t2.every((t3) => t3.x > qa) || t2.every((t3) => t3.y < 0) || t2.every((t3) => t3.y > qa);
          }
          Mn("FillExtrusionBucket", Do, { omit: ["layers", "features"] });
          var Oo = { paint: new fi({ "fill-extrusion-opacity": new li(nt["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new ui(nt["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new li(nt["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new li(nt["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new ci(nt["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new ui(nt["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new ui(nt["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new li(nt["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) };
          function Uo(t2, e3) {
            return t2.x * e3.x + t2.y * e3.y;
          }
          function qo(t2, e3) {
            if (1 === t2.length) {
              let r2 = 0;
              const n2 = e3[r2++];
              let i2;
              for (; !i2 || n2.equals(i2); )
                if (i2 = e3[r2++], !i2)
                  return 1 / 0;
              for (; r2 < e3.length; r2++) {
                const a2 = e3[r2], s2 = t2[0], o2 = i2.sub(n2), l2 = a2.sub(n2), u2 = s2.sub(n2), c2 = Uo(o2, o2), h2 = Uo(o2, l2), p2 = Uo(l2, l2), f2 = Uo(u2, o2), d2 = Uo(u2, l2), y3 = c2 * p2 - h2 * h2, m2 = (p2 * f2 - h2 * d2) / y3, g2 = (c2 * d2 - h2 * f2) / y3, x3 = n2.z * (1 - m2 - g2) + i2.z * m2 + a2.z * g2;
                if (isFinite(x3))
                  return x3;
              }
              return 1 / 0;
            }
            {
              let t3 = 1 / 0;
              for (const r2 of e3)
                t3 = Math.min(t3, r2.z);
              return t3;
            }
          }
          const jo = vi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: No } = jo, Zo = vi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: Ko } = Zo, Go = _o.VectorTileFeature.types, Jo = Math.cos(Math.PI / 180 * 37.5), Xo = Math.pow(2, 14) / 0.5;
          class Yo {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
                this.gradients[t3.id] = {};
              }), this.layoutVertexArray = new na(), this.layoutVertexArray2 = new ia(), this.indexArray = new ha(), this.programConfigurations = new Ra(t2.layers, t2.zoom), this.segments = new ya(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            populate(t2, e3, r2) {
              this.hasPattern = fo("line", this.layers, e3);
              const n2 = this.layers[0].layout.get("line-sort-key"), i2 = !n2.isConstant(), a2 = [];
              for (const { feature: e4, id: s2, index: o2, sourceLayerIndex: l2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, u2 = Ka(e4, t3);
                if (!this.layers[0]._featureFilter.filter(new Qn(this.zoom), u2, r2))
                  continue;
                const c2 = i2 ? n2.evaluate(u2, {}, r2) : void 0, h2 = { id: s2, properties: e4.properties, type: e4.type, sourceLayerIndex: l2, index: o2, geometry: t3 ? u2.geometry : Za(e4), patterns: {}, sortKey: c2 };
                a2.push(h2);
              }
              i2 && a2.sort((t3, e4) => t3.sortKey - e4.sortKey);
              for (const n3 of a2) {
                const { geometry: i3, index: a3, sourceLayerIndex: s2 } = n3;
                if (this.hasPattern) {
                  const t3 = yo("line", this.layers, n3, this.zoom, e3);
                  this.patternFeatures.push(t3);
                } else
                  this.addFeature(n3, i3, a3, r2, {});
                e3.featureIndex.insert(t2[a3].feature, i3, a3, s2, this.index);
              }
            }
            update(t2, e3, r2) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e3, this.stateDependentLayers, r2);
            }
            addFeatures(t2, e3, r2) {
              for (const t3 of this.patternFeatures)
                this.addFeature(t3, t3.geometry, t3.index, e3, r2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, Ko)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, No), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t2) {
              if (t2.properties && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_end"))
                return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
            }
            addFeature(t2, e3, r2, n2, i2) {
              const a2 = this.layers[0].layout, s2 = a2.get("line-join").evaluate(t2, {}), o2 = a2.get("line-cap"), l2 = a2.get("line-miter-limit"), u2 = a2.get("line-round-limit");
              this.lineClips = this.lineFeatureClips(t2);
              for (const r3 of e3)
                this.addLine(r3, t2, s2, o2, l2, u2);
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
            }
            addLine(t2, e3, r2, n2, i2, a2) {
              if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
                this.lineClipsArray.push(this.lineClips);
                for (let e4 = 0; e4 < t2.length - 1; e4++)
                  this.totalDistance += t2[e4].dist(t2[e4 + 1]);
                this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
              }
              const s2 = "Polygon" === Go[e3.type];
              let o2 = t2.length;
              for (; o2 >= 2 && t2[o2 - 1].equals(t2[o2 - 2]); )
                o2--;
              let l2 = 0;
              for (; l2 < o2 - 1 && t2[l2].equals(t2[l2 + 1]); )
                l2++;
              if (o2 < (s2 ? 3 : 2))
                return;
              "bevel" === r2 && (i2 = 1.05);
              const u2 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, c2 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
              let h2, p2, f2, d2, y3;
              this.e1 = this.e2 = -1, s2 && (h2 = t2[o2 - 2], y3 = t2[l2].sub(h2)._unit()._perp());
              for (let e4 = l2; e4 < o2; e4++) {
                if (f2 = e4 === o2 - 1 ? s2 ? t2[l2 + 1] : void 0 : t2[e4 + 1], f2 && t2[e4].equals(f2))
                  continue;
                y3 && (d2 = y3), h2 && (p2 = h2), h2 = t2[e4], y3 = f2 ? f2.sub(h2)._unit()._perp() : d2, d2 = d2 || y3;
                let m2 = d2.add(y3);
                0 === m2.x && 0 === m2.y || m2._unit();
                const g2 = d2.x * y3.x + d2.y * y3.y, x3 = m2.x * y3.x + m2.y * y3.y, v2 = 0 !== x3 ? 1 / x3 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x3), w2 = x3 < Jo && p2 && f2, _2 = d2.x * y3.y - d2.y * y3.x > 0;
                if (w2 && e4 > l2) {
                  const t3 = h2.dist(p2);
                  if (t3 > 2 * u2) {
                    const e6 = h2.sub(h2.sub(p2)._mult(u2 / t3)._round());
                    this.updateDistance(p2, e6), this.addCurrentVertex(e6, d2, 0, 0, c2), p2 = e6;
                  }
                }
                const A2 = p2 && f2;
                let k2 = A2 ? r2 : s2 ? "butt" : n2;
                if (A2 && "round" === k2 && (v2 < a2 ? k2 = "miter" : v2 <= 2 && (k2 = "fakeround")), "miter" === k2 && v2 > i2 && (k2 = "bevel"), "bevel" === k2 && (v2 > 2 && (k2 = "flipbevel"), v2 < i2 && (k2 = "miter")), p2 && this.updateDistance(p2, h2), "miter" === k2)
                  m2._mult(v2), this.addCurrentVertex(h2, m2, 0, 0, c2);
                else if ("flipbevel" === k2) {
                  if (v2 > 100)
                    m2 = y3.mult(-1);
                  else {
                    const t3 = v2 * d2.add(y3).mag() / d2.sub(y3).mag();
                    m2._perp()._mult(t3 * (_2 ? -1 : 1));
                  }
                  this.addCurrentVertex(h2, m2, 0, 0, c2), this.addCurrentVertex(h2, m2.mult(-1), 0, 0, c2);
                } else if ("bevel" === k2 || "fakeround" === k2) {
                  const t3 = -Math.sqrt(v2 * v2 - 1), e6 = _2 ? t3 : 0, r3 = _2 ? 0 : t3;
                  if (p2 && this.addCurrentVertex(h2, d2, e6, r3, c2), "fakeround" === k2) {
                    const t4 = Math.round(180 * b2 / Math.PI / 20);
                    for (let e7 = 1; e7 < t4; e7++) {
                      let r4 = e7 / t4;
                      if (0.5 !== r4) {
                        const t5 = r4 - 0.5;
                        r4 += r4 * t5 * (r4 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t5 * t5 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                      }
                      const n3 = y3.sub(d2)._mult(r4)._add(d2)._unit()._mult(_2 ? -1 : 1);
                      this.addHalfVertex(h2, n3.x, n3.y, false, _2, 0, c2);
                    }
                  }
                  f2 && this.addCurrentVertex(h2, y3, -e6, -r3, c2);
                } else if ("butt" === k2)
                  this.addCurrentVertex(h2, m2, 0, 0, c2);
                else if ("square" === k2) {
                  const t3 = p2 ? 1 : -1;
                  this.addCurrentVertex(h2, m2, t3, t3, c2);
                } else
                  "round" === k2 && (p2 && (this.addCurrentVertex(h2, d2, 0, 0, c2), this.addCurrentVertex(h2, d2, 1, 1, c2, true)), f2 && (this.addCurrentVertex(h2, y3, -1, -1, c2, true), this.addCurrentVertex(h2, y3, 0, 0, c2)));
                if (w2 && e4 < o2 - 1) {
                  const t3 = h2.dist(f2);
                  if (t3 > 2 * u2) {
                    const e6 = h2.add(f2.sub(h2)._mult(u2 / t3)._round());
                    this.updateDistance(h2, e6), this.addCurrentVertex(e6, y3, 0, 0, c2), h2 = e6;
                  }
                }
              }
            }
            addCurrentVertex(t2, e3, r2, n2, i2, a2 = false) {
              const s2 = e3.y * n2 - e3.x, o2 = -e3.y - e3.x * n2;
              this.addHalfVertex(t2, e3.x + e3.y * r2, e3.y - e3.x * r2, a2, false, r2, i2), this.addHalfVertex(t2, s2, o2, a2, true, -n2, i2), this.distance > Xo / 2 && 0 === this.totalDistance && (this.distance = 0, this.addCurrentVertex(t2, e3, r2, n2, i2, a2));
            }
            addHalfVertex({ x: t2, y: e3 }, r2, n2, i2, a2, s2, o2) {
              const l2 = 0.5 * (this.lineClips ? this.scaledDistance * (Xo - 1) : this.scaledDistance);
              this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e3 << 1) + (a2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (0 === s2 ? 0 : s2 < 0 ? -1 : 1) | (63 & l2) << 2, l2 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
              const u2 = o2.vertexLength++;
              this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u2), o2.primitiveLength++), a2 ? this.e2 = u2 : this.e1 = u2;
            }
            updateScaledDistance() {
              this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
            }
            updateDistance(t2, e3) {
              this.distance += t2.dist(e3), this.updateScaledDistance();
            }
          }
          Mn("LineBucket", Yo, { omit: ["layers", "patternFeatures"] });
          const Ho = new fi({ "line-cap": new li(nt.layout_line["line-cap"]), "line-join": new ui(nt.layout_line["line-join"]), "line-miter-limit": new li(nt.layout_line["line-miter-limit"]), "line-round-limit": new li(nt.layout_line["line-round-limit"]), "line-sort-key": new ui(nt.layout_line["line-sort-key"]) });
          var Wo = { paint: new fi({ "line-opacity": new ui(nt.paint_line["line-opacity"]), "line-color": new ui(nt.paint_line["line-color"]), "line-translate": new li(nt.paint_line["line-translate"]), "line-translate-anchor": new li(nt.paint_line["line-translate-anchor"]), "line-width": new ui(nt.paint_line["line-width"]), "line-gap-width": new ui(nt.paint_line["line-gap-width"]), "line-offset": new ui(nt.paint_line["line-offset"]), "line-blur": new ui(nt.paint_line["line-blur"]), "line-dasharray": new hi(nt.paint_line["line-dasharray"]), "line-pattern": new ci(nt.paint_line["line-pattern"]), "line-gradient": new pi2(nt.paint_line["line-gradient"]) }), layout: Ho };
          const Qo = new class extends ui {
            possiblyEvaluate(t2, e3) {
              return e3 = new Qn(Math.floor(e3.zoom), { now: e3.now, fadeDuration: e3.fadeDuration, zoomHistory: e3.zoomHistory, transition: e3.transition }), super.possiblyEvaluate(t2, e3);
            }
            evaluate(t2, e3, r2, n2) {
              return e3 = o({}, e3, { zoom: Math.floor(e3.zoom) }), super.evaluate(t2, e3, r2, n2);
            }
          }(Wo.paint.properties["line-width"].specification);
          function tl(t2, e3) {
            return e3 > 0 ? e3 + 2 * t2 : t2;
          }
          Qo.useIntegerZoom = true;
          const el = vi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), rl = vi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
          vi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
          const nl = vi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]);
          vi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
          const il = vi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), al = vi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
          function sl(t2, e3, r2) {
            return t2.sections.forEach((t3) => {
              t3.text = function(t4, e4, r3) {
                const n2 = e4.layout.get("text-transform").evaluate(r3, {});
                return "uppercase" === n2 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n2 && (t4 = t4.toLocaleLowerCase()), Wn.applyArabicShaping && (t4 = Wn.applyArabicShaping(t4)), t4;
              }(t3.text, e3, r2);
            }), t2;
          }
          vi([{ name: "triangle", components: 3, type: "Uint16" }]), vi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), vi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), vi([{ type: "Float32", name: "offsetX" }]), vi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
          const ol = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
          var ll = 24, ul = pl, cl = function(t2, e3, r2, n2, i2) {
            var a2, s2, o2 = 8 * i2 - n2 - 1, l2 = (1 << o2) - 1, u2 = l2 >> 1, c2 = -7, h2 = r2 ? i2 - 1 : 0, p2 = r2 ? -1 : 1, f2 = t2[e3 + h2];
            for (h2 += p2, a2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += o2; c2 > 0; a2 = 256 * a2 + t2[e3 + h2], h2 += p2, c2 -= 8)
              ;
            for (s2 = a2 & (1 << -c2) - 1, a2 >>= -c2, c2 += n2; c2 > 0; s2 = 256 * s2 + t2[e3 + h2], h2 += p2, c2 -= 8)
              ;
            if (0 === a2)
              a2 = 1 - u2;
            else {
              if (a2 === l2)
                return s2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
              s2 += Math.pow(2, n2), a2 -= u2;
            }
            return (f2 ? -1 : 1) * s2 * Math.pow(2, a2 - n2);
          }, hl = function(t2, e3, r2, n2, i2, a2) {
            var s2, o2, l2, u2 = 8 * a2 - i2 - 1, c2 = (1 << u2) - 1, h2 = c2 >> 1, p2 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : a2 - 1, d2 = n2 ? 1 : -1, y3 = e3 < 0 || 0 === e3 && 1 / e3 < 0 ? 1 : 0;
            for (e3 = Math.abs(e3), isNaN(e3) || e3 === 1 / 0 ? (o2 = isNaN(e3) ? 1 : 0, s2 = c2) : (s2 = Math.floor(Math.log(e3) / Math.LN2), e3 * (l2 = Math.pow(2, -s2)) < 1 && (s2--, l2 *= 2), (e3 += s2 + h2 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h2)) * l2 >= 2 && (s2++, l2 /= 2), s2 + h2 >= c2 ? (o2 = 0, s2 = c2) : s2 + h2 >= 1 ? (o2 = (e3 * l2 - 1) * Math.pow(2, i2), s2 += h2) : (o2 = e3 * Math.pow(2, h2 - 1) * Math.pow(2, i2), s2 = 0)); i2 >= 8; t2[r2 + f2] = 255 & o2, f2 += d2, o2 /= 256, i2 -= 8)
              ;
            for (s2 = s2 << i2 | o2, u2 += i2; u2 > 0; t2[r2 + f2] = 255 & s2, f2 += d2, s2 /= 256, u2 -= 8)
              ;
            t2[r2 + f2 - d2] |= 128 * y3;
          };
          function pl(t2) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          pl.Varint = 0, pl.Fixed64 = 1, pl.Bytes = 2, pl.Fixed32 = 5;
          var fl, dl = 4294967296, yl = 1 / dl, ml = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
          function gl(t2) {
            return t2.type === pl.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
          }
          function xl(t2, e3, r2) {
            return r2 ? 4294967296 * e3 + (t2 >>> 0) : 4294967296 * (e3 >>> 0) + (t2 >>> 0);
          }
          function vl(t2, e3, r2) {
            var n2 = e3 <= 16383 ? 1 : e3 <= 2097151 ? 2 : e3 <= 268435455 ? 3 : Math.floor(Math.log(e3) / (7 * Math.LN2));
            r2.realloc(n2);
            for (var i2 = r2.pos - 1; i2 >= t2; i2--)
              r2.buf[i2 + n2] = r2.buf[i2];
          }
          function bl(t2, e3) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e3.writeVarint(t2[r2]);
          }
          function wl(t2, e3) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e3.writeSVarint(t2[r2]);
          }
          function _l(t2, e3) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e3.writeFloat(t2[r2]);
          }
          function Al(t2, e3) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e3.writeDouble(t2[r2]);
          }
          function kl(t2, e3) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e3.writeBoolean(t2[r2]);
          }
          function Sl(t2, e3) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e3.writeFixed32(t2[r2]);
          }
          function Il(t2, e3) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e3.writeSFixed32(t2[r2]);
          }
          function Ml(t2, e3) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e3.writeFixed64(t2[r2]);
          }
          function zl(t2, e3) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e3.writeSFixed64(t2[r2]);
          }
          function Bl(t2, e3) {
            return (t2[e3] | t2[e3 + 1] << 8 | t2[e3 + 2] << 16) + 16777216 * t2[e3 + 3];
          }
          function Cl(t2, e3, r2) {
            t2[r2] = e3, t2[r2 + 1] = e3 >>> 8, t2[r2 + 2] = e3 >>> 16, t2[r2 + 3] = e3 >>> 24;
          }
          function Pl(t2, e3) {
            return (t2[e3] | t2[e3 + 1] << 8 | t2[e3 + 2] << 16) + (t2[e3 + 3] << 24);
          }
          function Vl(t2, e3, r2) {
            1 === t2 && r2.readMessage(El, e3);
          }
          function El(t2, e3, r2) {
            if (3 === t2) {
              const { id: t3, bitmap: n2, width: i2, height: a2, left: s2, top: o2, advance: l2 } = r2.readMessage(Fl, {});
              e3.push({ id: t3, bitmap: new zs({ width: i2 + 6, height: a2 + 6 }, n2), metrics: { width: i2, height: a2, left: s2, top: o2, advance: l2 } });
            }
          }
          function Fl(t2, e3, r2) {
            1 === t2 ? e3.id = r2.readVarint() : 2 === t2 ? e3.bitmap = r2.readBytes() : 3 === t2 ? e3.width = r2.readVarint() : 4 === t2 ? e3.height = r2.readVarint() : 5 === t2 ? e3.left = r2.readSVarint() : 6 === t2 ? e3.top = r2.readSVarint() : 7 === t2 && (e3.advance = r2.readVarint());
          }
          function Tl(t2) {
            let e3 = 0, r2 = 0;
            for (const n3 of t2)
              e3 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
            t2.sort((t3, e4) => e4.h - t3.h);
            const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e3 / 0.95)), r2), h: 1 / 0 }];
            let i2 = 0, a2 = 0;
            for (const e4 of t2)
              for (let t3 = n2.length - 1; t3 >= 0; t3--) {
                const r3 = n2[t3];
                if (!(e4.w > r3.w || e4.h > r3.h)) {
                  if (e4.x = r3.x, e4.y = r3.y, a2 = Math.max(a2, e4.y + e4.h), i2 = Math.max(i2, e4.x + e4.w), e4.w === r3.w && e4.h === r3.h) {
                    const e6 = n2.pop();
                    t3 < n2.length && (n2[t3] = e6);
                  } else
                    e4.h === r3.h ? (r3.x += e4.w, r3.w -= e4.w) : e4.w === r3.w ? (r3.y += e4.h, r3.h -= e4.h) : (n2.push({ x: r3.x + e4.w, y: r3.y, w: r3.w - e4.w, h: e4.h }), r3.y += e4.h, r3.h -= e4.h);
                  break;
                }
              }
            return { w: i2, h: a2, fill: e3 / (i2 * a2) || 0 };
          }
          pl.prototype = { destroy: function() {
            this.buf = null;
          }, readFields: function(t2, e3, r2) {
            for (r2 = r2 || this.length; this.pos < r2; ) {
              var n2 = this.readVarint(), i2 = n2 >> 3, a2 = this.pos;
              this.type = 7 & n2, t2(i2, e3, this), this.pos === a2 && this.skip(n2);
            }
            return e3;
          }, readMessage: function(t2, e3) {
            return this.readFields(t2, e3, this.readVarint() + this.pos);
          }, readFixed32: function() {
            var t2 = Bl(this.buf, this.pos);
            return this.pos += 4, t2;
          }, readSFixed32: function() {
            var t2 = Pl(this.buf, this.pos);
            return this.pos += 4, t2;
          }, readFixed64: function() {
            var t2 = Bl(this.buf, this.pos) + Bl(this.buf, this.pos + 4) * dl;
            return this.pos += 8, t2;
          }, readSFixed64: function() {
            var t2 = Bl(this.buf, this.pos) + Pl(this.buf, this.pos + 4) * dl;
            return this.pos += 8, t2;
          }, readFloat: function() {
            var t2 = cl(this.buf, this.pos, true, 23, 4);
            return this.pos += 4, t2;
          }, readDouble: function() {
            var t2 = cl(this.buf, this.pos, true, 52, 8);
            return this.pos += 8, t2;
          }, readVarint: function(t2) {
            var e3, r2, n2 = this.buf;
            return e3 = 127 & (r2 = n2[this.pos++]), r2 < 128 ? e3 : (e3 |= (127 & (r2 = n2[this.pos++])) << 7, r2 < 128 ? e3 : (e3 |= (127 & (r2 = n2[this.pos++])) << 14, r2 < 128 ? e3 : (e3 |= (127 & (r2 = n2[this.pos++])) << 21, r2 < 128 ? e3 : function(t3, e4, r3) {
              var n3, i2, a2 = r3.buf;
              if (n3 = (112 & (i2 = a2[r3.pos++])) >> 4, i2 < 128)
                return xl(t3, n3, e4);
              if (n3 |= (127 & (i2 = a2[r3.pos++])) << 3, i2 < 128)
                return xl(t3, n3, e4);
              if (n3 |= (127 & (i2 = a2[r3.pos++])) << 10, i2 < 128)
                return xl(t3, n3, e4);
              if (n3 |= (127 & (i2 = a2[r3.pos++])) << 17, i2 < 128)
                return xl(t3, n3, e4);
              if (n3 |= (127 & (i2 = a2[r3.pos++])) << 24, i2 < 128)
                return xl(t3, n3, e4);
              if (n3 |= (1 & (i2 = a2[r3.pos++])) << 31, i2 < 128)
                return xl(t3, n3, e4);
              throw new Error("Expected varint not more than 10 bytes");
            }(e3 |= (15 & (r2 = n2[this.pos])) << 28, t2, this))));
          }, readVarint64: function() {
            return this.readVarint(true);
          }, readSVarint: function() {
            var t2 = this.readVarint();
            return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
          }, readBoolean: function() {
            return Boolean(this.readVarint());
          }, readString: function() {
            var t2 = this.readVarint() + this.pos, e3 = this.pos;
            return this.pos = t2, t2 - e3 >= 12 && ml ? function(t3, e4, r2) {
              return ml.decode(t3.subarray(e4, r2));
            }(this.buf, e3, t2) : function(t3, e4, r2) {
              for (var n2 = "", i2 = e4; i2 < r2; ) {
                var a2, s2, o2, l2 = t3[i2], u2 = null, c2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
                if (i2 + c2 > r2)
                  break;
                1 === c2 ? l2 < 128 && (u2 = l2) : 2 === c2 ? 128 == (192 & (a2 = t3[i2 + 1])) && (u2 = (31 & l2) << 6 | 63 & a2) <= 127 && (u2 = null) : 3 === c2 ? (s2 = t3[i2 + 2], 128 == (192 & (a2 = t3[i2 + 1])) && 128 == (192 & s2) && ((u2 = (15 & l2) << 12 | (63 & a2) << 6 | 63 & s2) <= 2047 || u2 >= 55296 && u2 <= 57343) && (u2 = null)) : 4 === c2 && (s2 = t3[i2 + 2], o2 = t3[i2 + 3], 128 == (192 & (a2 = t3[i2 + 1])) && 128 == (192 & s2) && 128 == (192 & o2) && ((u2 = (15 & l2) << 18 | (63 & a2) << 12 | (63 & s2) << 6 | 63 & o2) <= 65535 || u2 >= 1114112) && (u2 = null)), null === u2 ? (u2 = 65533, c2 = 1) : u2 > 65535 && (u2 -= 65536, n2 += String.fromCharCode(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), n2 += String.fromCharCode(u2), i2 += c2;
              }
              return n2;
            }(this.buf, e3, t2);
          }, readBytes: function() {
            var t2 = this.readVarint() + this.pos, e3 = this.buf.subarray(this.pos, t2);
            return this.pos = t2, e3;
          }, readPackedVarint: function(t2, e3) {
            if (this.type !== pl.Bytes)
              return t2.push(this.readVarint(e3));
            var r2 = gl(this);
            for (t2 = t2 || []; this.pos < r2; )
              t2.push(this.readVarint(e3));
            return t2;
          }, readPackedSVarint: function(t2) {
            if (this.type !== pl.Bytes)
              return t2.push(this.readSVarint());
            var e3 = gl(this);
            for (t2 = t2 || []; this.pos < e3; )
              t2.push(this.readSVarint());
            return t2;
          }, readPackedBoolean: function(t2) {
            if (this.type !== pl.Bytes)
              return t2.push(this.readBoolean());
            var e3 = gl(this);
            for (t2 = t2 || []; this.pos < e3; )
              t2.push(this.readBoolean());
            return t2;
          }, readPackedFloat: function(t2) {
            if (this.type !== pl.Bytes)
              return t2.push(this.readFloat());
            var e3 = gl(this);
            for (t2 = t2 || []; this.pos < e3; )
              t2.push(this.readFloat());
            return t2;
          }, readPackedDouble: function(t2) {
            if (this.type !== pl.Bytes)
              return t2.push(this.readDouble());
            var e3 = gl(this);
            for (t2 = t2 || []; this.pos < e3; )
              t2.push(this.readDouble());
            return t2;
          }, readPackedFixed32: function(t2) {
            if (this.type !== pl.Bytes)
              return t2.push(this.readFixed32());
            var e3 = gl(this);
            for (t2 = t2 || []; this.pos < e3; )
              t2.push(this.readFixed32());
            return t2;
          }, readPackedSFixed32: function(t2) {
            if (this.type !== pl.Bytes)
              return t2.push(this.readSFixed32());
            var e3 = gl(this);
            for (t2 = t2 || []; this.pos < e3; )
              t2.push(this.readSFixed32());
            return t2;
          }, readPackedFixed64: function(t2) {
            if (this.type !== pl.Bytes)
              return t2.push(this.readFixed64());
            var e3 = gl(this);
            for (t2 = t2 || []; this.pos < e3; )
              t2.push(this.readFixed64());
            return t2;
          }, readPackedSFixed64: function(t2) {
            if (this.type !== pl.Bytes)
              return t2.push(this.readSFixed64());
            var e3 = gl(this);
            for (t2 = t2 || []; this.pos < e3; )
              t2.push(this.readSFixed64());
            return t2;
          }, skip: function(t2) {
            var e3 = 7 & t2;
            if (e3 === pl.Varint)
              for (; this.buf[this.pos++] > 127; )
                ;
            else if (e3 === pl.Bytes)
              this.pos = this.readVarint() + this.pos;
            else if (e3 === pl.Fixed32)
              this.pos += 4;
            else {
              if (e3 !== pl.Fixed64)
                throw new Error("Unimplemented type: " + e3);
              this.pos += 8;
            }
          }, writeTag: function(t2, e3) {
            this.writeVarint(t2 << 3 | e3);
          }, realloc: function(t2) {
            for (var e3 = this.length || 16; e3 < this.pos + t2; )
              e3 *= 2;
            if (e3 !== this.length) {
              var r2 = new Uint8Array(e3);
              r2.set(this.buf), this.buf = r2, this.length = e3;
            }
          }, finish: function() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }, writeFixed32: function(t2) {
            this.realloc(4), Cl(this.buf, t2, this.pos), this.pos += 4;
          }, writeSFixed32: function(t2) {
            this.realloc(4), Cl(this.buf, t2, this.pos), this.pos += 4;
          }, writeFixed64: function(t2) {
            this.realloc(8), Cl(this.buf, -1 & t2, this.pos), Cl(this.buf, Math.floor(t2 * yl), this.pos + 4), this.pos += 8;
          }, writeSFixed64: function(t2) {
            this.realloc(8), Cl(this.buf, -1 & t2, this.pos), Cl(this.buf, Math.floor(t2 * yl), this.pos + 4), this.pos += 8;
          }, writeVarint: function(t2) {
            (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e3) {
              var r2, n2;
              if (t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (r2 = ~(-t3 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552e3 || t3 < -18446744073709552e3)
                throw new Error("Given varint doesn't fit into 10 bytes");
              e3.realloc(10), function(t4, e4, r3) {
                r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, r3.buf[r3.pos] = 127 & (t4 >>>= 7);
              }(r2, 0, e3), function(t4, e4) {
                var r3 = (7 & t4) << 4;
                e4.buf[e4.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), t4 && (e4.buf[e4.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e4.buf[e4.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e4.buf[e4.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e4.buf[e4.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e4.buf[e4.pos++] = 127 & t4)))));
              }(n2, e3);
            }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
          }, writeSVarint: function(t2) {
            this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
          }, writeBoolean: function(t2) {
            this.writeVarint(Boolean(t2));
          }, writeString: function(t2) {
            t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
            var e3 = this.pos;
            this.pos = function(t3, e4, r3) {
              for (var n2, i2, a2 = 0; a2 < e4.length; a2++) {
                if ((n2 = e4.charCodeAt(a2)) > 55295 && n2 < 57344) {
                  if (!i2) {
                    n2 > 56319 || a2 + 1 === e4.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n2;
                    continue;
                  }
                  if (n2 < 56320) {
                    t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n2;
                    continue;
                  }
                  n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
                } else
                  i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
                n2 < 128 ? t3[r3++] = n2 : (n2 < 2048 ? t3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r3++] = n2 >> 12 | 224 : (t3[r3++] = n2 >> 18 | 240, t3[r3++] = n2 >> 12 & 63 | 128), t3[r3++] = n2 >> 6 & 63 | 128), t3[r3++] = 63 & n2 | 128);
              }
              return r3;
            }(this.buf, t2, this.pos);
            var r2 = this.pos - e3;
            r2 >= 128 && vl(e3, r2, this), this.pos = e3 - 1, this.writeVarint(r2), this.pos += r2;
          }, writeFloat: function(t2) {
            this.realloc(4), hl(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
          }, writeDouble: function(t2) {
            this.realloc(8), hl(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
          }, writeBytes: function(t2) {
            var e3 = t2.length;
            this.writeVarint(e3), this.realloc(e3);
            for (var r2 = 0; r2 < e3; r2++)
              this.buf[this.pos++] = t2[r2];
          }, writeRawMessage: function(t2, e3) {
            this.pos++;
            var r2 = this.pos;
            t2(e3, this);
            var n2 = this.pos - r2;
            n2 >= 128 && vl(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
          }, writeMessage: function(t2, e3, r2) {
            this.writeTag(t2, pl.Bytes), this.writeRawMessage(e3, r2);
          }, writePackedVarint: function(t2, e3) {
            e3.length && this.writeMessage(t2, bl, e3);
          }, writePackedSVarint: function(t2, e3) {
            e3.length && this.writeMessage(t2, wl, e3);
          }, writePackedBoolean: function(t2, e3) {
            e3.length && this.writeMessage(t2, kl, e3);
          }, writePackedFloat: function(t2, e3) {
            e3.length && this.writeMessage(t2, _l, e3);
          }, writePackedDouble: function(t2, e3) {
            e3.length && this.writeMessage(t2, Al, e3);
          }, writePackedFixed32: function(t2, e3) {
            e3.length && this.writeMessage(t2, Sl, e3);
          }, writePackedSFixed32: function(t2, e3) {
            e3.length && this.writeMessage(t2, Il, e3);
          }, writePackedFixed64: function(t2, e3) {
            e3.length && this.writeMessage(t2, Ml, e3);
          }, writePackedSFixed64: function(t2, e3) {
            e3.length && this.writeMessage(t2, zl, e3);
          }, writeBytesField: function(t2, e3) {
            this.writeTag(t2, pl.Bytes), this.writeBytes(e3);
          }, writeFixed32Field: function(t2, e3) {
            this.writeTag(t2, pl.Fixed32), this.writeFixed32(e3);
          }, writeSFixed32Field: function(t2, e3) {
            this.writeTag(t2, pl.Fixed32), this.writeSFixed32(e3);
          }, writeFixed64Field: function(t2, e3) {
            this.writeTag(t2, pl.Fixed64), this.writeFixed64(e3);
          }, writeSFixed64Field: function(t2, e3) {
            this.writeTag(t2, pl.Fixed64), this.writeSFixed64(e3);
          }, writeVarintField: function(t2, e3) {
            this.writeTag(t2, pl.Varint), this.writeVarint(e3);
          }, writeSVarintField: function(t2, e3) {
            this.writeTag(t2, pl.Varint), this.writeSVarint(e3);
          }, writeStringField: function(t2, e3) {
            this.writeTag(t2, pl.Bytes), this.writeString(e3);
          }, writeFloatField: function(t2, e3) {
            this.writeTag(t2, pl.Fixed32), this.writeFloat(e3);
          }, writeDoubleField: function(t2, e3) {
            this.writeTag(t2, pl.Fixed64), this.writeDouble(e3);
          }, writeBooleanField: function(t2, e3) {
            this.writeVarintField(t2, Boolean(e3));
          } };
          class Ll {
            constructor(t2, { pixelRatio: e3, version: r2, stretchX: n2, stretchY: i2, content: a2 }) {
              this.paddedRect = t2, this.pixelRatio = e3, this.stretchX = n2, this.stretchY = i2, this.content = a2, this.version = r2;
            }
            get tl() {
              return [this.paddedRect.x + 1, this.paddedRect.y + 1];
            }
            get br() {
              return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
            }
            get tlbr() {
              return this.tl.concat(this.br);
            }
            get displaySize() {
              return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
            }
          }
          class Dl {
            constructor(t2, e3) {
              const r2 = {}, n2 = {};
              this.haveRenderCallbacks = [];
              const i2 = [];
              this.addImages(t2, r2, i2), this.addImages(e3, n2, i2);
              const { w: a2, h: s2 } = Tl(i2), o2 = new Bs({ width: a2 || 1, height: s2 || 1 });
              for (const e4 in t2) {
                const n3 = t2[e4], i3 = r2[e4].paddedRect;
                Bs.copy(n3.data, o2, { x: 0, y: 0 }, { x: i3.x + 1, y: i3.y + 1 }, n3.data);
              }
              for (const t3 in e3) {
                const r3 = e3[t3], i3 = n2[t3].paddedRect, a3 = i3.x + 1, s3 = i3.y + 1, l2 = r3.data.width, u2 = r3.data.height;
                Bs.copy(r3.data, o2, { x: 0, y: 0 }, { x: a3, y: s3 }, r3.data), Bs.copy(r3.data, o2, { x: 0, y: u2 - 1 }, { x: a3, y: s3 - 1 }, { width: l2, height: 1 }), Bs.copy(r3.data, o2, { x: 0, y: 0 }, { x: a3, y: s3 + u2 }, { width: l2, height: 1 }), Bs.copy(r3.data, o2, { x: l2 - 1, y: 0 }, { x: a3 - 1, y: s3 }, { width: 1, height: u2 }), Bs.copy(r3.data, o2, { x: 0, y: 0 }, { x: a3 + l2, y: s3 }, { width: 1, height: u2 });
              }
              this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
            }
            addImages(t2, e3, r2) {
              for (const n2 in t2) {
                const i2 = t2[n2], a2 = { x: 0, y: 0, w: i2.data.width + 2, h: i2.data.height + 2 };
                r2.push(a2), e3[n2] = new Ll(a2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
              }
            }
            patchUpdatedImages(t2, e3) {
              t2.dispatchRenderCallbacks(this.haveRenderCallbacks);
              for (const r2 in t2.updatedImages)
                this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e3), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e3);
            }
            patchUpdatedImage(t2, e3, r2) {
              if (!t2 || !e3)
                return;
              if (t2.version === e3.version)
                return;
              t2.version = e3.version;
              const [n2, i2] = t2.tl;
              r2.update(e3.data, void 0, { x: n2, y: i2 });
            }
          }
          Mn("ImagePosition", Ll), Mn("ImageAtlas", Dl), t.WritingMode = void 0, (fl = t.WritingMode || (t.WritingMode = {}))[fl.none = 0] = "none", fl[fl.horizontal = 1] = "horizontal", fl[fl.vertical = 2] = "vertical", fl[fl.horizontalOnly = 3] = "horizontalOnly";
          const $l = -17;
          class Rl {
            constructor() {
              this.scale = 1, this.fontStack = "", this.imageName = null;
            }
            static forText(t2, e3) {
              const r2 = new Rl();
              return r2.scale = t2 || 1, r2.fontStack = e3, r2;
            }
            static forImage(t2) {
              const e3 = new Rl();
              return e3.imageName = t2, e3;
            }
          }
          class Ol {
            constructor() {
              this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t2, e3) {
              const r2 = new Ol();
              for (let n2 = 0; n2 < t2.sections.length; n2++) {
                const i2 = t2.sections[n2];
                i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e3);
              }
              return r2;
            }
            length() {
              return this.text.length;
            }
            getSection(t2) {
              return this.sections[this.sectionIndex[t2]];
            }
            getSectionIndex(t2) {
              return this.sectionIndex[t2];
            }
            getCharCode(t2) {
              return this.text.charCodeAt(t2);
            }
            verticalizePunctuation() {
              this.text = function(t2) {
                let e3 = "";
                for (let r2 = 0; r2 < t2.length; r2++) {
                  const n2 = t2.charCodeAt(r2 + 1) || null, i2 = t2.charCodeAt(r2 - 1) || null;
                  e3 += n2 && Dn(n2) && !ol[t2[r2 + 1]] || i2 && Dn(i2) && !ol[t2[r2 - 1]] || !ol[t2[r2]] ? t2[r2] : ol[t2[r2]];
                }
                return e3;
              }(this.text);
            }
            trim() {
              let t2 = 0;
              for (let e4 = 0; e4 < this.text.length && ql[this.text.charCodeAt(e4)]; e4++)
                t2++;
              let e3 = this.text.length;
              for (let r2 = this.text.length - 1; r2 >= 0 && r2 >= t2 && ql[this.text.charCodeAt(r2)]; r2--)
                e3--;
              this.text = this.text.substring(t2, e3), this.sectionIndex = this.sectionIndex.slice(t2, e3);
            }
            substring(t2, e3) {
              const r2 = new Ol();
              return r2.text = this.text.substring(t2, e3), r2.sectionIndex = this.sectionIndex.slice(t2, e3), r2.sections = this.sections, r2;
            }
            toString() {
              return this.text;
            }
            getMaxScale() {
              return this.sectionIndex.reduce((t2, e3) => Math.max(t2, this.sections[e3].scale), 0);
            }
            addTextSection(t2, e3) {
              this.text += t2.text, this.sections.push(Rl.forText(t2.scale, t2.fontStack || e3));
              const r2 = this.sections.length - 1;
              for (let e4 = 0; e4 < t2.text.length; ++e4)
                this.sectionIndex.push(r2);
            }
            addImageSection(t2) {
              const e3 = t2.image ? t2.image.name : "";
              if (0 === e3.length)
                return void d("Can't add FormattedSection with an empty image.");
              const r2 = this.getNextImageSectionCharCode();
              r2 ? (this.text += String.fromCharCode(r2), this.sections.push(Rl.forImage(e3)), this.sectionIndex.push(this.sections.length - 1)) : d("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
              return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
          }
          function Ul(e3, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y3, m2) {
            const g2 = Ol.fromFeature(e3, a2);
            let x3;
            p2 === t.WritingMode.vertical && g2.verticalizePunctuation();
            const { processBidirectionalText: v2, processStyledBidirectionalText: b2 } = Wn;
            if (v2 && 1 === g2.sections.length) {
              x3 = [];
              const t2 = v2(g2.toString(), Xl(g2, c2, s2, r2, i2, d2, y3));
              for (const e4 of t2) {
                const t3 = new Ol();
                t3.text = e4, t3.sections = g2.sections;
                for (let r3 = 0; r3 < e4.length; r3++)
                  t3.sectionIndex.push(0);
                x3.push(t3);
              }
            } else if (b2) {
              x3 = [];
              const t2 = b2(g2.text, g2.sectionIndex, Xl(g2, c2, s2, r2, i2, d2, y3));
              for (const e4 of t2) {
                const t3 = new Ol();
                t3.text = e4[0], t3.sectionIndex = e4[1], t3.sections = g2.sections, x3.push(t3);
              }
            } else
              x3 = function(t2, e4) {
                const r3 = [], n3 = t2.text;
                let i3 = 0;
                for (const n4 of e4)
                  r3.push(t2.substring(i3, n4)), i3 = n4;
                return i3 < n3.length && r3.push(t2.substring(i3, n3.length)), r3;
              }(g2, Xl(g2, c2, s2, r2, i2, d2, y3));
            const w2 = [], _2 = { positionedLines: w2, text: g2.toString(), top: h2[1], bottom: h2[1], left: h2[0], right: h2[0], writingMode: p2, iconsInText: false, verticalizable: false };
            return function(e4, r3, n3, i3, a3, s3, o3, l3, u3, c3, h3, p3) {
              let f3 = 0, d3 = $l, y4 = 0, m3 = 0;
              const g3 = "right" === l3 ? 1 : "left" === l3 ? 0 : 0.5;
              let x4 = 0;
              for (const o4 of a3) {
                o4.trim();
                const a4 = o4.getMaxScale(), l4 = (a4 - 1) * ll, b4 = { positionedGlyphs: [], lineOffset: 0 };
                e4.positionedLines[x4] = b4;
                const w4 = b4.positionedGlyphs;
                let _4 = 0;
                if (!o4.length()) {
                  d3 += s3, ++x4;
                  continue;
                }
                for (let s4 = 0; s4 < o4.length(); s4++) {
                  const y5 = o4.getSection(s4), m4 = o4.getSectionIndex(s4), g4 = o4.getCharCode(s4);
                  let x5 = 0, b5 = null, A3 = null, k2 = null, S2 = ll;
                  const I2 = !(u3 === t.WritingMode.horizontal || !h3 && !Ln(g4) || h3 && (ql[g4] || (v3 = g4, Vn.Arabic(v3) || Vn["Arabic Supplement"](v3) || Vn["Arabic Extended-A"](v3) || Vn["Arabic Presentation Forms-A"](v3) || Vn["Arabic Presentation Forms-B"](v3))));
                  if (y5.imageName) {
                    const t2 = i3[y5.imageName];
                    if (!t2)
                      continue;
                    k2 = y5.imageName, e4.iconsInText = e4.iconsInText || true, A3 = t2.paddedRect;
                    const r4 = t2.displaySize;
                    y5.scale = y5.scale * ll / p3, b5 = { width: r4[0], height: r4[1], left: 1, top: -3, advance: I2 ? r4[1] : r4[0] }, x5 = l4 + (ll - r4[1] * y5.scale), S2 = b5.advance;
                    const n4 = I2 ? r4[0] * y5.scale - ll * a4 : r4[1] * y5.scale - ll * a4;
                    n4 > 0 && n4 > _4 && (_4 = n4);
                  } else {
                    const t2 = n3[y5.fontStack], e6 = t2 && t2[g4];
                    if (e6 && e6.rect)
                      A3 = e6.rect, b5 = e6.metrics;
                    else {
                      const t3 = r3[y5.fontStack], e7 = t3 && t3[g4];
                      if (!e7)
                        continue;
                      b5 = e7.metrics;
                    }
                    x5 = (a4 - y5.scale) * ll;
                  }
                  I2 ? (e4.verticalizable = true, w4.push({ glyph: g4, imageName: k2, x: f3, y: d3 + x5, vertical: I2, scale: y5.scale, fontStack: y5.fontStack, sectionIndex: m4, metrics: b5, rect: A3 }), f3 += S2 * y5.scale + c3) : (w4.push({ glyph: g4, imageName: k2, x: f3, y: d3 + x5, vertical: I2, scale: y5.scale, fontStack: y5.fontStack, sectionIndex: m4, metrics: b5, rect: A3 }), f3 += b5.advance * y5.scale + c3);
                }
                0 !== w4.length && (y4 = Math.max(f3 - c3, y4), Hl(w4, 0, w4.length - 1, g3, _4)), f3 = 0;
                const A2 = s3 * a4 + _4;
                b4.lineOffset = Math.max(_4, l4), d3 += A2, m3 = Math.max(A2, m3), ++x4;
              }
              var v3;
              const b3 = d3 - $l, { horizontalAlign: w3, verticalAlign: _3 } = Yl(o3);
              (function(t2, e6, r4, n4, i4, a4, s4, o4, l4) {
                const u4 = (e6 - r4) * i4;
                let c4 = 0;
                c4 = a4 !== s4 ? -o4 * n4 - $l : (-n4 * l4 + 0.5) * s4;
                for (const e7 of t2)
                  for (const t3 of e7.positionedGlyphs)
                    t3.x += u4, t3.y += c4;
              })(e4.positionedLines, g3, w3, _3, y4, m3, s3, b3, a3.length), e4.top += -_3 * b3, e4.bottom = e4.top + b3, e4.left += -w3 * y4, e4.right = e4.left + y4;
            }(_2, r2, n2, i2, x3, o2, l2, u2, p2, c2, f2, m2), !function(t2) {
              for (const e4 of t2)
                if (0 !== e4.positionedGlyphs.length)
                  return false;
              return true;
            }(w2) && _2;
          }
          const ql = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, jl = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
          function Nl(t2, e3, r2, n2, i2, a2) {
            if (e3.imageName) {
              const t3 = n2[e3.imageName];
              return t3 ? t3.displaySize[0] * e3.scale * ll / a2 + i2 : 0;
            }
            {
              const n3 = r2[e3.fontStack], a3 = n3 && n3[t2];
              return a3 ? a3.metrics.advance * e3.scale + i2 : 0;
            }
          }
          function Zl(t2, e3, r2, n2) {
            const i2 = Math.pow(t2 - e3, 2);
            return n2 ? t2 < e3 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
          }
          function Kl(t2, e3, r2) {
            let n2 = 0;
            return 10 === t2 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== t2 && 65288 !== t2 || (n2 += 50), 41 !== e3 && 65289 !== e3 || (n2 += 50), n2;
          }
          function Gl(t2, e3, r2, n2, i2, a2) {
            let s2 = null, o2 = Zl(e3, r2, i2, a2);
            for (const t3 of n2) {
              const n3 = Zl(e3 - t3.x, r2, i2, a2) + t3.badness;
              n3 <= o2 && (s2 = t3, o2 = n3);
            }
            return { index: t2, x: e3, priorBreak: s2, badness: o2 };
          }
          function Jl(t2) {
            return t2 ? Jl(t2.priorBreak).concat(t2.index) : [];
          }
          function Xl(t2, e3, r2, n2, i2, a2, s2) {
            if ("point" !== a2)
              return [];
            if (!t2)
              return [];
            const o2 = [], l2 = function(t3, e4, r3, n3, i3, a3) {
              let s3 = 0;
              for (let r4 = 0; r4 < t3.length(); r4++) {
                const o3 = t3.getSection(r4);
                s3 += Nl(t3.getCharCode(r4), o3, n3, i3, e4, a3);
              }
              return s3 / Math.max(1, Math.ceil(s3 / r3));
            }(t2, e3, r2, n2, i2, s2), u2 = t2.text.indexOf("\u200B") >= 0;
            let c2 = 0;
            for (let r3 = 0; r3 < t2.length(); r3++) {
              const a3 = t2.getSection(r3), p2 = t2.getCharCode(r3);
              if (ql[p2] || (c2 += Nl(p2, a3, n2, i2, e3, s2)), r3 < t2.length() - 1) {
                const e4 = !((h2 = p2) < 11904 || !(Vn["Bopomofo Extended"](h2) || Vn.Bopomofo(h2) || Vn["CJK Compatibility Forms"](h2) || Vn["CJK Compatibility Ideographs"](h2) || Vn["CJK Compatibility"](h2) || Vn["CJK Radicals Supplement"](h2) || Vn["CJK Strokes"](h2) || Vn["CJK Symbols and Punctuation"](h2) || Vn["CJK Unified Ideographs Extension A"](h2) || Vn["CJK Unified Ideographs"](h2) || Vn["Enclosed CJK Letters and Months"](h2) || Vn["Halfwidth and Fullwidth Forms"](h2) || Vn.Hiragana(h2) || Vn["Ideographic Description Characters"](h2) || Vn["Kangxi Radicals"](h2) || Vn["Katakana Phonetic Extensions"](h2) || Vn.Katakana(h2) || Vn["Vertical Forms"](h2) || Vn["Yi Radicals"](h2) || Vn["Yi Syllables"](h2)));
                (jl[p2] || e4 || a3.imageName) && o2.push(Gl(r3 + 1, c2, l2, o2, Kl(p2, t2.getCharCode(r3 + 1), e4 && u2), false));
              }
            }
            var h2;
            return Jl(Gl(t2.length(), c2, l2, o2, 0, true));
          }
          function Yl(t2) {
            let e3 = 0.5, r2 = 0.5;
            switch (t2) {
              case "right":
              case "top-right":
              case "bottom-right":
                e3 = 1;
                break;
              case "left":
              case "top-left":
              case "bottom-left":
                e3 = 0;
            }
            switch (t2) {
              case "bottom":
              case "bottom-right":
              case "bottom-left":
                r2 = 1;
                break;
              case "top":
              case "top-right":
              case "top-left":
                r2 = 0;
            }
            return { horizontalAlign: e3, verticalAlign: r2 };
          }
          function Hl(t2, e3, r2, n2, i2) {
            if (!n2 && !i2)
              return;
            const a2 = t2[r2], s2 = (t2[r2].x + a2.metrics.advance * a2.scale) * n2;
            for (let n3 = e3; n3 <= r2; n3++)
              t2[n3].x -= s2, t2[n3].y += i2;
          }
          function Wl(t2, e3, r2) {
            const { horizontalAlign: n2, verticalAlign: i2 } = Yl(r2), a2 = e3[0] - t2.displaySize[0] * n2, s2 = e3[1] - t2.displaySize[1] * i2;
            return { image: t2, top: s2, bottom: s2 + t2.displaySize[1], left: a2, right: a2 + t2.displaySize[0] };
          }
          function Ql(t2, e3, r2, n2, i2, a2) {
            const s2 = t2.image;
            let o2;
            if (s2.content) {
              const t3 = s2.content, e4 = s2.pixelRatio || 1;
              o2 = [t3[0] / e4, t3[1] / e4, s2.displaySize[0] - t3[2] / e4, s2.displaySize[1] - t3[3] / e4];
            }
            const l2 = e3.left * a2, u2 = e3.right * a2;
            let c2, h2, p2, f2;
            "width" === r2 || "both" === r2 ? (f2 = i2[0] + l2 - n2[3], h2 = i2[0] + u2 + n2[1]) : (f2 = i2[0] + (l2 + u2 - s2.displaySize[0]) / 2, h2 = f2 + s2.displaySize[0]);
            const d2 = e3.top * a2, y3 = e3.bottom * a2;
            return "height" === r2 || "both" === r2 ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + y3 + n2[2]) : (c2 = i2[1] + (d2 + y3 - s2.displaySize[1]) / 2, p2 = c2 + s2.displaySize[1]), { image: s2, top: c2, right: h2, bottom: p2, left: f2, collisionPadding: o2 };
          }
          const tu = 128;
          function eu(t2, e3) {
            const { expression: r2 } = e3;
            if ("constant" === r2.kind)
              return { kind: "constant", layoutSize: r2.evaluate(new Qn(t2 + 1)) };
            if ("source" === r2.kind)
              return { kind: "source" };
            {
              const { zoomStops: e4, interpolationType: n2 } = r2;
              let i2 = 0;
              for (; i2 < e4.length && e4[i2] <= t2; )
                i2++;
              i2 = Math.max(0, i2 - 1);
              let a2 = i2;
              for (; a2 < e4.length && e4[a2] < t2 + 1; )
                a2++;
              a2 = Math.min(e4.length - 1, a2);
              const s2 = e4[i2], o2 = e4[a2];
              return "composite" === r2.kind ? { kind: "composite", minZoom: s2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: s2, maxZoom: o2, minSize: r2.evaluate(new Qn(s2)), maxSize: r2.evaluate(new Qn(o2)), interpolationType: n2 };
            }
          }
          class ru extends S {
            constructor(t2, e3, r2, n2) {
              super(t2, e3), this.angle = r2, void 0 !== n2 && (this.segment = n2);
            }
            clone() {
              return new ru(this.x, this.y, this.angle, this.segment);
            }
          }
          function nu(t2, e3, r2, n2, i2) {
            if (void 0 === e3.segment)
              return true;
            let a2 = e3, s2 = e3.segment + 1, o2 = 0;
            for (; o2 > -r2 / 2; ) {
              if (s2--, s2 < 0)
                return false;
              o2 -= t2[s2].dist(a2), a2 = t2[s2];
            }
            o2 += t2[s2].dist(t2[s2 + 1]), s2++;
            const l2 = [];
            let u2 = 0;
            for (; o2 < r2 / 2; ) {
              const e4 = t2[s2], r3 = t2[s2 + 1];
              if (!r3)
                return false;
              let a3 = t2[s2 - 1].angleTo(e4) - e4.angleTo(r3);
              for (a3 = Math.abs((a3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: a3 }), u2 += a3; o2 - l2[0].distance > n2; )
                u2 -= l2.shift().angleDelta;
              if (u2 > i2)
                return false;
              s2++, o2 += e4.dist(r3);
            }
            return true;
          }
          function iu(t2) {
            let e3 = 0;
            for (let r2 = 0; r2 < t2.length - 1; r2++)
              e3 += t2[r2].dist(t2[r2 + 1]);
            return e3;
          }
          function au(t2, e3, r2) {
            return t2 ? 0.6 * e3 * r2 : 0;
          }
          function su(t2, e3) {
            return Math.max(t2 ? t2.right - t2.left : 0, e3 ? e3.right - e3.left : 0);
          }
          function ou(t2, e3, r2, n2, i2, a2) {
            const s2 = au(r2, i2, a2), o2 = su(r2, n2) * a2;
            let l2 = 0;
            const u2 = iu(t2) / 2;
            for (let r3 = 0; r3 < t2.length - 1; r3++) {
              const n3 = t2[r3], i3 = t2[r3 + 1], a3 = n3.dist(i3);
              if (l2 + a3 > u2) {
                const c2 = (u2 - l2) / a3, h2 = Se(n3.x, i3.x, c2), p2 = Se(n3.y, i3.y, c2), f2 = new ru(h2, p2, i3.angleTo(n3), r3);
                return f2._round(), !s2 || nu(t2, f2, o2, s2, e3) ? f2 : void 0;
              }
              l2 += a3;
            }
          }
          function lu(t2, e3, r2, n2, i2, a2, s2, o2, l2) {
            const u2 = au(n2, a2, s2), c2 = su(n2, i2), h2 = c2 * s2, p2 = 0 === t2[0].x || t2[0].x === l2 || 0 === t2[0].y || t2[0].y === l2;
            return e3 - h2 < e3 / 4 && (e3 = h2 + e3 / 4), uu(t2, p2 ? e3 / 2 * o2 % e3 : (c2 / 2 + 2 * a2) * s2 * o2 % e3, e3, u2, r2, h2, p2, false, l2);
          }
          function uu(t2, e3, r2, n2, i2, a2, s2, o2, l2) {
            const u2 = a2 / 2, c2 = iu(t2);
            let h2 = 0, p2 = e3 - r2, f2 = [];
            for (let e4 = 0; e4 < t2.length - 1; e4++) {
              const s3 = t2[e4], o3 = t2[e4 + 1], d2 = s3.dist(o3), y3 = o3.angleTo(s3);
              for (; p2 + r2 < h2 + d2; ) {
                p2 += r2;
                const m2 = (p2 - h2) / d2, g2 = Se(s3.x, o3.x, m2), x3 = Se(s3.y, o3.y, m2);
                if (g2 >= 0 && g2 < l2 && x3 >= 0 && x3 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
                  const r3 = new ru(g2, x3, y3, e4);
                  r3._round(), n2 && !nu(t2, r3, a2, n2, i2) || f2.push(r3);
                }
              }
              h2 += d2;
            }
            return o2 || f2.length || s2 || (f2 = uu(t2, h2 / 2, r2, n2, i2, a2, s2, true, l2)), f2;
          }
          function cu(t2, e3, r2, n2, i2) {
            const a2 = [];
            for (let s2 = 0; s2 < t2.length; s2++) {
              const o2 = t2[s2];
              let l2;
              for (let t3 = 0; t3 < o2.length - 1; t3++) {
                let s3 = o2[t3], u2 = o2[t3 + 1];
                s3.x < e3 && u2.x < e3 || (s3.x < e3 ? s3 = new S(e3, s3.y + (e3 - s3.x) / (u2.x - s3.x) * (u2.y - s3.y))._round() : u2.x < e3 && (u2 = new S(e3, s3.y + (e3 - s3.x) / (u2.x - s3.x) * (u2.y - s3.y))._round()), s3.y < r2 && u2.y < r2 || (s3.y < r2 ? s3 = new S(s3.x + (r2 - s3.y) / (u2.y - s3.y) * (u2.x - s3.x), r2)._round() : u2.y < r2 && (u2 = new S(s3.x + (r2 - s3.y) / (u2.y - s3.y) * (u2.x - s3.x), r2)._round()), s3.x >= n2 && u2.x >= n2 || (s3.x >= n2 ? s3 = new S(n2, s3.y + (n2 - s3.x) / (u2.x - s3.x) * (u2.y - s3.y))._round() : u2.x >= n2 && (u2 = new S(n2, s3.y + (n2 - s3.x) / (u2.x - s3.x) * (u2.y - s3.y))._round()), s3.y >= i2 && u2.y >= i2 || (s3.y >= i2 ? s3 = new S(s3.x + (i2 - s3.y) / (u2.y - s3.y) * (u2.x - s3.x), i2)._round() : u2.y >= i2 && (u2 = new S(s3.x + (i2 - s3.y) / (u2.y - s3.y) * (u2.x - s3.x), i2)._round()), l2 && s3.equals(l2[l2.length - 1]) || (l2 = [s3], a2.push(l2)), l2.push(u2)))));
              }
            }
            return a2;
          }
          function hu(t2, e3, r2, n2) {
            const i2 = [], a2 = t2.image, s2 = a2.pixelRatio, o2 = a2.paddedRect.w - 2, l2 = a2.paddedRect.h - 2, u2 = t2.right - t2.left, c2 = t2.bottom - t2.top, h2 = a2.stretchX || [[0, o2]], p2 = a2.stretchY || [[0, l2]], f2 = (t3, e4) => t3 + e4[1] - e4[0], d2 = h2.reduce(f2, 0), y3 = p2.reduce(f2, 0), m2 = o2 - d2, g2 = l2 - y3;
            let x3 = 0, v2 = d2, b2 = 0, w2 = y3, _2 = 0, A2 = m2, k2 = 0, I2 = g2;
            if (a2.content && n2) {
              const t3 = a2.content;
              x3 = pu(h2, 0, t3[0]), b2 = pu(p2, 0, t3[1]), v2 = pu(h2, t3[0], t3[2]), w2 = pu(p2, t3[1], t3[3]), _2 = t3[0] - x3, k2 = t3[1] - b2, A2 = t3[2] - t3[0] - v2, I2 = t3[3] - t3[1] - w2;
            }
            const M2 = (n3, i3, o3, l3) => {
              const h3 = du(n3.stretch - x3, v2, u2, t2.left), p3 = yu(n3.fixed - _2, A2, n3.stretch, d2), f3 = du(i3.stretch - b2, w2, c2, t2.top), m3 = yu(i3.fixed - k2, I2, i3.stretch, y3), g3 = du(o3.stretch - x3, v2, u2, t2.left), M3 = yu(o3.fixed - _2, A2, o3.stretch, d2), z2 = du(l3.stretch - b2, w2, c2, t2.top), B3 = yu(l3.fixed - k2, I2, l3.stretch, y3), C2 = new S(h3, f3), P2 = new S(g3, f3), V2 = new S(g3, z2), E2 = new S(h3, z2), F2 = new S(p3 / s2, m3 / s2), T2 = new S(M3 / s2, B3 / s2), L2 = e3 * Math.PI / 180;
              if (L2) {
                const t3 = Math.sin(L2), e4 = Math.cos(L2), r3 = [e4, -t3, t3, e4];
                C2._matMult(r3), P2._matMult(r3), E2._matMult(r3), V2._matMult(r3);
              }
              const D2 = n3.stretch + n3.fixed, $2 = i3.stretch + i3.fixed;
              return { tl: C2, tr: P2, bl: E2, br: V2, tex: { x: a2.paddedRect.x + 1 + D2, y: a2.paddedRect.y + 1 + $2, w: o3.stretch + o3.fixed - D2, h: l3.stretch + l3.fixed - $2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: F2, pixelOffsetBR: T2, minFontScaleX: A2 / s2 / u2, minFontScaleY: I2 / s2 / c2, isSDF: r2 };
            };
            if (n2 && (a2.stretchX || a2.stretchY)) {
              const t3 = fu(h2, m2, d2), e4 = fu(p2, g2, y3);
              for (let r3 = 0; r3 < t3.length - 1; r3++) {
                const n3 = t3[r3], a3 = t3[r3 + 1];
                for (let t4 = 0; t4 < e4.length - 1; t4++)
                  i2.push(M2(n3, e4[t4], a3, e4[t4 + 1]));
              }
            } else
              i2.push(M2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: o2 + 1 }, { fixed: 0, stretch: l2 + 1 }));
            return i2;
          }
          function pu(t2, e3, r2) {
            let n2 = 0;
            for (const i2 of t2)
              n2 += Math.max(e3, Math.min(r2, i2[1])) - Math.max(e3, Math.min(r2, i2[0]));
            return n2;
          }
          function fu(t2, e3, r2) {
            const n2 = [{ fixed: -1, stretch: 0 }];
            for (const [e4, r3] of t2) {
              const t3 = n2[n2.length - 1];
              n2.push({ fixed: e4 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e4 - t3.stretch, stretch: t3.stretch + (r3 - e4) });
            }
            return n2.push({ fixed: e3 + 1, stretch: r2 }), n2;
          }
          function du(t2, e3, r2, n2) {
            return t2 / e3 * r2 + n2;
          }
          function yu(t2, e3, r2, n2) {
            return t2 - e3 * r2 / n2;
          }
          Mn("Anchor", ru);
          class mu {
            constructor(t2, e3, r2, n2, i2, a2, s2, o2, l2, u2) {
              if (this.boxStartIndex = t2.length, l2) {
                let t3 = a2.top, e4 = a2.bottom;
                const r3 = a2.collisionPadding;
                r3 && (t3 -= r3[1], e4 += r3[3]);
                let n3 = e4 - t3;
                n3 > 0 && (n3 = Math.max(10, n3), this.circleDiameter = n3);
              } else {
                let l3 = a2.top * s2 - o2[0], c2 = a2.bottom * s2 + o2[2], h2 = a2.left * s2 - o2[3], p2 = a2.right * s2 + o2[1];
                const f2 = a2.collisionPadding;
                if (f2 && (h2 -= f2[0] * s2, l3 -= f2[1] * s2, p2 += f2[2] * s2, c2 += f2[3] * s2), u2) {
                  const t3 = new S(h2, l3), e4 = new S(p2, l3), r3 = new S(h2, c2), n3 = new S(p2, c2), i3 = u2 * Math.PI / 180;
                  t3._rotate(i3), e4._rotate(i3), r3._rotate(i3), n3._rotate(i3), h2 = Math.min(t3.x, e4.x, r3.x, n3.x), p2 = Math.max(t3.x, e4.x, r3.x, n3.x), l3 = Math.min(t3.y, e4.y, r3.y, n3.y), c2 = Math.max(t3.y, e4.y, r3.y, n3.y);
                }
                t2.emplaceBack(e3.x, e3.y, h2, l3, p2, c2, r2, n2, i2);
              }
              this.boxEndIndex = t2.length;
            }
          }
          class gu {
            constructor(t2 = [], e3 = xu) {
              if (this.data = t2, this.length = this.data.length, this.compare = e3, this.length > 0)
                for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--)
                  this._down(t3);
            }
            push(t2) {
              this.data.push(t2), this.length++, this._up(this.length - 1);
            }
            pop() {
              if (0 === this.length)
                return;
              const t2 = this.data[0], e3 = this.data.pop();
              return this.length--, this.length > 0 && (this.data[0] = e3, this._down(0)), t2;
            }
            peek() {
              return this.data[0];
            }
            _up(t2) {
              const { data: e3, compare: r2 } = this, n2 = e3[t2];
              for (; t2 > 0; ) {
                const i2 = t2 - 1 >> 1, a2 = e3[i2];
                if (r2(n2, a2) >= 0)
                  break;
                e3[t2] = a2, t2 = i2;
              }
              e3[t2] = n2;
            }
            _down(t2) {
              const { data: e3, compare: r2 } = this, n2 = this.length >> 1, i2 = e3[t2];
              for (; t2 < n2; ) {
                let n3 = 1 + (t2 << 1), a2 = e3[n3];
                const s2 = n3 + 1;
                if (s2 < this.length && r2(e3[s2], a2) < 0 && (n3 = s2, a2 = e3[s2]), r2(a2, i2) >= 0)
                  break;
                e3[t2] = a2, t2 = n3;
              }
              e3[t2] = i2;
            }
          }
          function xu(t2, e3) {
            return t2 < e3 ? -1 : t2 > e3 ? 1 : 0;
          }
          function vu(t2, e3 = 1, r2 = false) {
            let n2 = 1 / 0, i2 = 1 / 0, a2 = -1 / 0, s2 = -1 / 0;
            const o2 = t2[0];
            for (let t3 = 0; t3 < o2.length; t3++) {
              const e4 = o2[t3];
              (!t3 || e4.x < n2) && (n2 = e4.x), (!t3 || e4.y < i2) && (i2 = e4.y), (!t3 || e4.x > a2) && (a2 = e4.x), (!t3 || e4.y > s2) && (s2 = e4.y);
            }
            const l2 = Math.min(a2 - n2, s2 - i2);
            let u2 = l2 / 2;
            const c2 = new gu([], bu);
            if (0 === l2)
              return new S(n2, i2);
            for (let e4 = n2; e4 < a2; e4 += l2)
              for (let r3 = i2; r3 < s2; r3 += l2)
                c2.push(new wu(e4 + u2, r3 + u2, u2, t2));
            let h2 = function(t3) {
              let e4 = 0, r3 = 0, n3 = 0;
              const i3 = t3[0];
              for (let t4 = 0, a3 = i3.length, s3 = a3 - 1; t4 < a3; s3 = t4++) {
                const a4 = i3[t4], o3 = i3[s3], l3 = a4.x * o3.y - o3.x * a4.y;
                r3 += (a4.x + o3.x) * l3, n3 += (a4.y + o3.y) * l3, e4 += 3 * l3;
              }
              return new wu(r3 / e4, n3 / e4, 0, t3);
            }(t2), p2 = c2.length;
            for (; c2.length; ) {
              const n3 = c2.pop();
              (n3.d > h2.d || !h2.d) && (h2 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, p2)), n3.max - h2.d <= e3 || (u2 = n3.h / 2, c2.push(new wu(n3.p.x - u2, n3.p.y - u2, u2, t2)), c2.push(new wu(n3.p.x + u2, n3.p.y - u2, u2, t2)), c2.push(new wu(n3.p.x - u2, n3.p.y + u2, u2, t2)), c2.push(new wu(n3.p.x + u2, n3.p.y + u2, u2, t2)), p2 += 4);
            }
            return r2 && (console.log(`num probes: ${p2}`), console.log(`best distance: ${h2.d}`)), h2.p;
          }
          function bu(t2, e3) {
            return e3.max - t2.max;
          }
          function wu(t2, e3, r2, n2) {
            this.p = new S(t2, e3), this.h = r2, this.d = function(t3, e4) {
              let r3 = false, n3 = 1 / 0;
              for (let i2 = 0; i2 < e4.length; i2++) {
                const a2 = e4[i2];
                for (let e6 = 0, i3 = a2.length, s2 = i3 - 1; e6 < i3; s2 = e6++) {
                  const i4 = a2[e6], o2 = a2[s2];
                  i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, rs(t3, i4, o2));
                }
              }
              return (r3 ? 1 : -1) * Math.sqrt(n3);
            }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
          }
          const _u = Number.POSITIVE_INFINITY;
          function Au(t2, e3) {
            return e3[1] !== _u ? function(t3, e4, r2) {
              let n2 = 0, i2 = 0;
              switch (e4 = Math.abs(e4), r2 = Math.abs(r2), t3) {
                case "top-right":
                case "top-left":
                case "top":
                  i2 = r2 - 7;
                  break;
                case "bottom-right":
                case "bottom-left":
                case "bottom":
                  i2 = 7 - r2;
              }
              switch (t3) {
                case "top-right":
                case "bottom-right":
                case "right":
                  n2 = -e4;
                  break;
                case "top-left":
                case "bottom-left":
                case "left":
                  n2 = e4;
              }
              return [n2, i2];
            }(t2, e3[0], e3[1]) : function(t3, e4) {
              let r2 = 0, n2 = 0;
              e4 < 0 && (e4 = 0);
              const i2 = e4 / Math.sqrt(2);
              switch (t3) {
                case "top-right":
                case "top-left":
                  n2 = i2 - 7;
                  break;
                case "bottom-right":
                case "bottom-left":
                  n2 = 7 - i2;
                  break;
                case "bottom":
                  n2 = 7 - e4;
                  break;
                case "top":
                  n2 = e4 - 7;
              }
              switch (t3) {
                case "top-right":
                case "bottom-right":
                  r2 = -i2;
                  break;
                case "top-left":
                case "bottom-left":
                  r2 = i2;
                  break;
                case "left":
                  r2 = e4;
                  break;
                case "right":
                  r2 = -e4;
              }
              return [r2, n2];
            }(t2, e3[0]);
          }
          function ku(t2) {
            switch (t2) {
              case "right":
              case "top-right":
              case "bottom-right":
                return "right";
              case "left":
              case "top-left":
              case "bottom-left":
                return "left";
            }
            return "center";
          }
          function Su(e3, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2) {
            let p2 = s2.textMaxSize.evaluate(r2, {});
            void 0 === p2 && (p2 = o2);
            const f2 = e3.layers[0].layout, y3 = f2.get("icon-offset").evaluate(r2, {}, h2), m2 = zu(n2.horizontal), g2 = o2 / 24, x3 = e3.tilePixelRatio * g2, v2 = e3.tilePixelRatio * p2 / 24, b2 = e3.tilePixelRatio * l2, w2 = e3.tilePixelRatio * f2.get("symbol-spacing"), _2 = f2.get("text-padding") * e3.tilePixelRatio, A2 = function(t2, e4, r3, n3 = 1) {
              const i3 = t2.get("icon-padding").evaluate(e4, {}, r3), a3 = i3 && i3.values;
              return [a3[0] * n3, a3[1] * n3, a3[2] * n3, a3[3] * n3];
            }(f2, r2, h2, e3.tilePixelRatio), k2 = f2.get("text-max-angle") / 180 * Math.PI, S2 = "viewport" !== f2.get("text-rotation-alignment") && "point" !== f2.get("symbol-placement"), I2 = "map" === f2.get("icon-rotation-alignment") && "point" !== f2.get("symbol-placement"), M2 = f2.get("symbol-placement"), z2 = w2 / 2, B3 = f2.get("icon-text-fit");
            let C2;
            i2 && "none" !== B3 && (e3.allowVerticalPlacement && n2.vertical && (C2 = Ql(i2, n2.vertical, B3, f2.get("icon-text-fit-padding"), y3, g2)), m2 && (i2 = Ql(i2, m2, B3, f2.get("icon-text-fit-padding"), y3, g2)));
            const P2 = (l3, p3) => {
              p3.x < 0 || p3.x >= qa || p3.y < 0 || p3.y >= qa || function(e4, r3, n3, i3, a3, s3, o3, l4, u3, c3, h3, p4, f3, y4, m3, g3, x4, v3, b3, w3, _3, A3, k3, S3, I3) {
                const M3 = e4.addToLineVertexArray(r3, n3);
                let z3, B4, C3, P3, V2 = 0, E2 = 0, F2 = 0, T2 = 0, L2 = -1, D2 = -1;
                const $2 = {};
                let R2 = xa.exports(""), O2 = 0, U2 = 0;
                if (void 0 === l4._unevaluatedLayout.getValue("text-radial-offset") ? [O2, U2] = l4.layout.get("text-offset").evaluate(_3, {}, S3).map((t2) => t2 * ll) : (O2 = l4.layout.get("text-radial-offset").evaluate(_3, {}, S3) * ll, U2 = _u), e4.allowVerticalPlacement && i3.vertical) {
                  const t2 = l4.layout.get("text-rotate").evaluate(_3, {}, S3) + 90;
                  C3 = new mu(u3, r3, c3, h3, p4, i3.vertical, f3, y4, m3, t2), o3 && (P3 = new mu(u3, r3, c3, h3, p4, o3, x4, v3, m3, t2));
                }
                if (a3) {
                  const n4 = l4.layout.get("icon-rotate").evaluate(_3, {}), i4 = "none" !== l4.layout.get("icon-text-fit"), s4 = hu(a3, n4, k3, i4), f4 = o3 ? hu(o3, n4, k3, i4) : void 0;
                  B4 = new mu(u3, r3, c3, h3, p4, a3, x4, v3, false, n4), V2 = 4 * s4.length;
                  const y5 = e4.iconSizeData;
                  let m4 = null;
                  "source" === y5.kind ? (m4 = [tu * l4.layout.get("icon-size").evaluate(_3, {})], m4[0] > Iu && d(`${e4.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)) : "composite" === y5.kind && (m4 = [tu * A3.compositeIconSizes[0].evaluate(_3, {}, S3), tu * A3.compositeIconSizes[1].evaluate(_3, {}, S3)], (m4[0] > Iu || m4[1] > Iu) && d(`${e4.layerIds[0]}: Value for "icon-size" is >= 255. Reduce your "icon-size".`)), e4.addSymbols(e4.icon, s4, m4, w3, b3, _3, t.WritingMode.none, r3, M3.lineStartIndex, M3.lineLength, -1, S3), L2 = e4.icon.placedSymbolArray.length - 1, f4 && (E2 = 4 * f4.length, e4.addSymbols(e4.icon, f4, m4, w3, b3, _3, t.WritingMode.vertical, r3, M3.lineStartIndex, M3.lineLength, -1, S3), D2 = e4.icon.placedSymbolArray.length - 1);
                }
                const q2 = Object.keys(i3.horizontal);
                for (const n4 of q2) {
                  const a4 = i3.horizontal[n4];
                  if (!z3) {
                    R2 = xa.exports(a4.text);
                    const t2 = l4.layout.get("text-rotate").evaluate(_3, {}, S3);
                    z3 = new mu(u3, r3, c3, h3, p4, a4, f3, y4, m3, t2);
                  }
                  const o4 = 1 === a4.positionedLines.length;
                  if (F2 += Mu(e4, r3, a4, s3, l4, m3, _3, g3, M3, i3.vertical ? t.WritingMode.horizontal : t.WritingMode.horizontalOnly, o4 ? q2 : [n4], $2, L2, A3, S3), o4)
                    break;
                }
                i3.vertical && (T2 += Mu(e4, r3, i3.vertical, s3, l4, m3, _3, g3, M3, t.WritingMode.vertical, ["vertical"], $2, D2, A3, S3));
                const j2 = z3 ? z3.boxStartIndex : e4.collisionBoxArray.length, N2 = z3 ? z3.boxEndIndex : e4.collisionBoxArray.length, Z2 = C3 ? C3.boxStartIndex : e4.collisionBoxArray.length, K2 = C3 ? C3.boxEndIndex : e4.collisionBoxArray.length, G2 = B4 ? B4.boxStartIndex : e4.collisionBoxArray.length, J2 = B4 ? B4.boxEndIndex : e4.collisionBoxArray.length, X2 = P3 ? P3.boxStartIndex : e4.collisionBoxArray.length, Y2 = P3 ? P3.boxEndIndex : e4.collisionBoxArray.length;
                let H2 = -1;
                const W2 = (t2, e6) => t2 && t2.circleDiameter ? Math.max(t2.circleDiameter, e6) : e6;
                H2 = W2(z3, H2), H2 = W2(C3, H2), H2 = W2(B4, H2), H2 = W2(P3, H2);
                const Q2 = H2 > -1 ? 1 : 0;
                Q2 && (H2 *= I3 / ll), e4.glyphOffsetArray.length >= Du.MAX_GLYPHS && d("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== _3.sortKey && e4.addToSortKeyRanges(e4.symbolInstances.length, _3.sortKey), e4.symbolInstances.emplaceBack(r3.x, r3.y, $2.right >= 0 ? $2.right : -1, $2.center >= 0 ? $2.center : -1, $2.left >= 0 ? $2.left : -1, $2.vertical || -1, L2, D2, R2, j2, N2, Z2, K2, G2, J2, X2, Y2, c3, F2, T2, V2, E2, Q2, 0, f3, O2, U2, H2);
              }(e3, p3, l3, n2, i2, a2, C2, e3.layers[0], e3.collisionBoxArray, r2.index, r2.sourceLayerIndex, e3.index, x3, [_2, _2, _2, _2], S2, u2, b2, A2, I2, y3, r2, s2, c2, h2, o2);
            };
            if ("line" === M2)
              for (const t2 of cu(r2.geometry, 0, 0, qa, qa)) {
                const r3 = lu(t2, w2, k2, n2.vertical || m2, i2, 24, v2, e3.overscaling, qa);
                for (const n3 of r3) {
                  const r4 = m2;
                  r4 && Bu(e3, r4.text, z2, n3) || P2(t2, n3);
                }
              }
            else if ("line-center" === M2) {
              for (const t2 of r2.geometry)
                if (t2.length > 1) {
                  const e4 = ou(t2, k2, n2.vertical || m2, i2, 24, v2);
                  e4 && P2(t2, e4);
                }
            } else if ("Polygon" === r2.type)
              for (const t2 of ho(r2.geometry, 0)) {
                const e4 = vu(t2, 16);
                P2(t2[0], new ru(e4.x, e4.y, 0));
              }
            else if ("LineString" === r2.type)
              for (const t2 of r2.geometry)
                P2(t2, new ru(t2[0].x, t2[0].y, 0));
            else if ("Point" === r2.type)
              for (const t2 of r2.geometry)
                for (const e4 of t2)
                  P2([e4], new ru(e4.x, e4.y, 0));
          }
          const Iu = 32640;
          function Mu(t2, e3, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, y3) {
            const m2 = function(t3, e4, r3, n3, i3, a3, s3, o3) {
              const l3 = n3.layout.get("text-rotate").evaluate(a3, {}) * Math.PI / 180, u3 = [];
              for (const t4 of e4.positionedLines)
                for (const n4 of t4.positionedGlyphs) {
                  if (!n4.rect)
                    continue;
                  const a4 = n4.rect || {};
                  let c3 = 4, h3 = true, p3 = 1, f3 = 0;
                  const d2 = (i3 || o3) && n4.vertical, y4 = n4.metrics.advance * n4.scale / 2;
                  if (o3 && e4.verticalizable) {
                    const e6 = (n4.scale - 1) * ll, r4 = (ll - n4.metrics.width * n4.scale) / 2;
                    f3 = t4.lineOffset / 2 - (n4.imageName ? -r4 : e6);
                  }
                  if (n4.imageName) {
                    const t5 = s3[n4.imageName];
                    h3 = t5.sdf, p3 = t5.pixelRatio, c3 = 1 / p3;
                  }
                  const m3 = i3 ? [n4.x + y4, n4.y] : [0, 0];
                  let g3 = i3 ? [0, 0] : [n4.x + y4 + r3[0], n4.y + r3[1] - f3], x4 = [0, 0];
                  d2 && (x4 = g3, g3 = [0, 0]);
                  const v2 = (n4.metrics.left - c3) * n4.scale - y4 + g3[0], b2 = (-n4.metrics.top - c3) * n4.scale + g3[1], w2 = v2 + a4.w * n4.scale / p3, _2 = b2 + a4.h * n4.scale / p3, A2 = new S(v2, b2), k2 = new S(w2, b2), I2 = new S(v2, _2), M2 = new S(w2, _2);
                  if (d2) {
                    const t5 = new S(-y4, y4 - $l), e6 = -Math.PI / 2, r4 = 12 - y4, i4 = new S(22 - r4, -(n4.imageName ? r4 : 0)), a5 = new S(...x4);
                    A2._rotateAround(e6, t5)._add(i4)._add(a5), k2._rotateAround(e6, t5)._add(i4)._add(a5), I2._rotateAround(e6, t5)._add(i4)._add(a5), M2._rotateAround(e6, t5)._add(i4)._add(a5);
                  }
                  if (l3) {
                    const t5 = Math.sin(l3), e6 = Math.cos(l3), r4 = [e6, -t5, t5, e6];
                    A2._matMult(r4), k2._matMult(r4), I2._matMult(r4), M2._matMult(r4);
                  }
                  const z2 = new S(0, 0), B3 = new S(0, 0);
                  u3.push({ tl: A2, tr: k2, bl: I2, br: M2, tex: a4, writingMode: e4.writingMode, glyphOffset: m3, sectionIndex: n4.sectionIndex, isSDF: h3, pixelOffsetTL: z2, pixelOffsetBR: B3, minFontScaleX: 0, minFontScaleY: 0 });
                }
              return u3;
            }(0, r2, o2, i2, a2, s2, n2, t2.allowVerticalPlacement), g2 = t2.textSizeData;
            let x3 = null;
            "source" === g2.kind ? (x3 = [tu * i2.layout.get("text-size").evaluate(s2, {})], x3[0] > Iu && d(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)) : "composite" === g2.kind && (x3 = [tu * f2.compositeTextSizes[0].evaluate(s2, {}, y3), tu * f2.compositeTextSizes[1].evaluate(s2, {}, y3)], (x3[0] > Iu || x3[1] > Iu) && d(`${t2.layerIds[0]}: Value for "text-size" is >= 255. Reduce your "text-size".`)), t2.addSymbols(t2.text, m2, x3, o2, a2, s2, u2, e3, l2.lineStartIndex, l2.lineLength, p2, y3);
            for (const e4 of c2)
              h2[e4] = t2.text.placedSymbolArray.length - 1;
            return 4 * m2.length;
          }
          function zu(t2) {
            for (const e3 in t2)
              return t2[e3];
            return null;
          }
          function Bu(t2, e3, r2, n2) {
            const i2 = t2.compareText;
            if (e3 in i2) {
              const t3 = i2[e3];
              for (let e4 = t3.length - 1; e4 >= 0; e4--)
                if (n2.dist(t3[e4]) < r2)
                  return true;
            } else
              i2[e3] = [];
            return i2[e3].push(n2), false;
          }
          const Cu = _o.VectorTileFeature.types, Pu = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
          function Vu(t2, e3, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2) {
            const f2 = o2 ? Math.min(Iu, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(Iu, Math.round(o2[1])) : 0;
            t2.emplaceBack(e3, r2, Math.round(32 * n2), Math.round(32 * i2), a2, s2, (f2 << 1) + (l2 ? 1 : 0), d2, 16 * u2, 16 * c2, 256 * h2, 256 * p2);
          }
          function Eu(t2, e3, r2) {
            t2.emplaceBack(e3.x, e3.y, r2), t2.emplaceBack(e3.x, e3.y, r2), t2.emplaceBack(e3.x, e3.y, r2), t2.emplaceBack(e3.x, e3.y, r2);
          }
          function Fu(t2) {
            for (const e3 of t2.sections)
              if (On(e3.text))
                return true;
            return false;
          }
          class Tu {
            constructor(t2) {
              this.layoutVertexArray = new sa(), this.indexArray = new ha(), this.programConfigurations = t2, this.segments = new ya(), this.dynamicLayoutVertexArray = new oa(), this.opacityVertexArray = new la(), this.placedSymbolArray = new Ki();
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
            }
            upload(t2, e3, r2, n2) {
              this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, el.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e3), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, rl.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, Pu, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
            }
          }
          Mn("SymbolBuffers", Tu);
          class Lu {
            constructor(t2, e3, r2) {
              this.layoutVertexArray = new t2(), this.layoutAttributes = e3, this.indexArray = new r2(), this.segments = new ya(), this.collisionVertexArray = new ca();
            }
            upload(t2) {
              this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, nl.members, true);
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
            }
          }
          Mn("CollisionBuffers", Lu);
          class Du {
            constructor(e3) {
              this.collisionBoxArray = e3.collisionBoxArray, this.zoom = e3.zoom, this.overscaling = e3.overscaling, this.layers = e3.layers, this.layerIds = this.layers.map((t2) => t2.id), this.index = e3.index, this.pixelRatio = e3.pixelRatio, this.sourceLayerIndex = e3.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = ds([]), this.placementViewportMatrix = ds([]);
              const r2 = this.layers[0]._unevaluatedLayout._values;
              this.textSizeData = eu(this.zoom, r2["text-size"]), this.iconSizeData = eu(this.zoom, r2["icon-size"]);
              const n2 = this.layers[0].layout, i2 = n2.get("symbol-sort-key"), a2 = n2.get("symbol-z-order");
              this.canOverlap = "never" !== qu(n2, "text-overlap", "text-allow-overlap") || "never" !== qu(n2, "icon-overlap", "icon-allow-overlap") || n2.get("text-ignore-placement") || n2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== a2 && !i2.isConstant(), this.sortFeaturesByY = ("viewport-y" === a2 || "auto" === a2 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n2.get("symbol-placement") && (this.writingModes = n2.get("text-writing-mode").map((e4) => t.WritingMode[e4])), this.stateDependentLayerIds = this.layers.filter((t2) => t2.isStateDependent()).map((t2) => t2.id), this.sourceID = e3.sourceID;
            }
            createArrays() {
              this.text = new Tu(new Ra(this.layers, this.zoom, (t2) => /^text/.test(t2))), this.icon = new Tu(new Ra(this.layers, this.zoom, (t2) => /^icon/.test(t2))), this.glyphOffsetArray = new Xi(), this.lineVertexArray = new Yi(), this.symbolInstances = new Ji();
            }
            calculateGlyphDependencies(t2, e3, r2, n2, i2) {
              for (let a2 = 0; a2 < t2.length; a2++)
                if (e3[t2.charCodeAt(a2)] = true, (r2 || n2) && i2) {
                  const r3 = ol[t2.charAt(a2)];
                  r3 && (e3[r3.charCodeAt(0)] = true);
                }
            }
            populate(e3, r2, n2) {
              const i2 = this.layers[0], a2 = i2.layout, s2 = a2.get("text-font"), o2 = a2.get("text-field"), l2 = a2.get("icon-image"), u2 = ("constant" !== o2.value.kind || o2.value.value instanceof Dt && !o2.value.value.isEmpty() || o2.value.value.toString().length > 0) && ("constant" !== s2.value.kind || s2.value.value.length > 0), c2 = "constant" !== l2.value.kind || !!l2.value.value || Object.keys(l2.parameters).length > 0, h2 = a2.get("symbol-sort-key");
              if (this.features = [], !u2 && !c2)
                return;
              const p2 = r2.iconDependencies, f2 = r2.glyphDependencies, d2 = r2.availableImages, y3 = new Qn(this.zoom);
              for (const { feature: r3, id: o3, index: l3, sourceLayerIndex: m2 } of e3) {
                const e4 = i2._featureFilter.needGeometry, g2 = Ka(r3, e4);
                if (!i2._featureFilter.filter(y3, g2, n2))
                  continue;
                let x3, v2;
                if (e4 || (g2.geometry = Za(r3)), u2) {
                  const t2 = i2.getValueAndResolveTokens("text-field", g2, n2, d2), e6 = Dt.factory(t2);
                  Fu(e6) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === Yn() || this.hasRTLText && Wn.isParsed()) && (x3 = sl(e6, i2, g2));
                }
                if (c2) {
                  const t2 = i2.getValueAndResolveTokens("icon-image", g2, n2, d2);
                  v2 = t2 instanceof Rt ? t2 : Rt.fromString(t2);
                }
                if (!x3 && !v2)
                  continue;
                const b2 = this.sortFeaturesByKey ? h2.evaluate(g2, {}, n2) : void 0;
                if (this.features.push({ id: o3, text: x3, icon: v2, index: l3, sourceLayerIndex: m2, geometry: g2.geometry, properties: r3.properties, type: Cu[r3.type], sortKey: b2 }), v2 && (p2[v2.name] = true), x3) {
                  const e6 = s2.evaluate(g2, {}, n2).join(","), r4 = "viewport" !== a2.get("text-rotation-alignment") && "point" !== a2.get("symbol-placement");
                  this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.WritingMode.vertical) >= 0;
                  for (const t2 of x3.sections)
                    if (t2.image)
                      p2[t2.image.name] = true;
                    else {
                      const n3 = En(x3.toString()), i3 = t2.fontStack || e6, a3 = f2[i3] = f2[i3] || {};
                      this.calculateGlyphDependencies(t2.text, a3, r4, this.allowVerticalPlacement, n3);
                    }
                }
              }
              "line" === a2.get("symbol-placement") && (this.features = function(t2) {
                const e4 = {}, r3 = {}, n3 = [];
                let i3 = 0;
                function a3(e6) {
                  n3.push(t2[e6]), i3++;
                }
                function s3(t3, e6, i4) {
                  const a4 = r3[t3];
                  return delete r3[t3], r3[e6] = a4, n3[a4].geometry[0].pop(), n3[a4].geometry[0] = n3[a4].geometry[0].concat(i4[0]), a4;
                }
                function o3(t3, r4, i4) {
                  const a4 = e4[r4];
                  return delete e4[r4], e4[t3] = a4, n3[a4].geometry[0].shift(), n3[a4].geometry[0] = i4[0].concat(n3[a4].geometry[0]), a4;
                }
                function l3(t3, e6, r4) {
                  const n4 = r4 ? e6[0][e6[0].length - 1] : e6[0][0];
                  return `${t3}:${n4.x}:${n4.y}`;
                }
                for (let u3 = 0; u3 < t2.length; u3++) {
                  const c3 = t2[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
                  if (!p3) {
                    a3(u3);
                    continue;
                  }
                  const f3 = l3(p3, h3), d3 = l3(p3, h3, true);
                  if (f3 in r3 && d3 in e4 && r3[f3] !== e4[d3]) {
                    const t3 = o3(f3, d3, h3), i4 = s3(f3, d3, n3[t3].geometry);
                    delete e4[f3], delete r3[d3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[t3].geometry = null;
                  } else
                    f3 in r3 ? s3(f3, d3, h3) : d3 in e4 ? o3(f3, d3, h3) : (a3(u3), e4[f3] = i3 - 1, r3[d3] = i3 - 1);
                }
                return n3.filter((t3) => t3.geometry);
              }(this.features)), this.sortFeaturesByKey && this.features.sort((t2, e4) => t2.sortKey - e4.sortKey);
            }
            update(t2, e3, r2) {
              this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e3, this.layers, r2), this.icon.programConfigurations.updatePaintArrays(t2, e3, this.layers, r2));
            }
            isEmpty() {
              return 0 === this.symbolInstances.length && !this.hasRTLText;
            }
            uploadPending() {
              return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t2) {
              !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
            }
            destroyDebugData() {
              this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            destroy() {
              this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t2, e3) {
              const r2 = this.lineVertexArray.length;
              if (void 0 !== t2.segment) {
                let r3 = t2.dist(e3[t2.segment + 1]), n2 = t2.dist(e3[t2.segment]);
                const i2 = {};
                for (let n3 = t2.segment + 1; n3 < e3.length; n3++)
                  i2[n3] = { x: e3[n3].x, y: e3[n3].y, tileUnitDistanceFromAnchor: r3 }, n3 < e3.length - 1 && (r3 += e3[n3 + 1].dist(e3[n3]));
                for (let r4 = t2.segment || 0; r4 >= 0; r4--)
                  i2[r4] = { x: e3[r4].x, y: e3[r4].y, tileUnitDistanceFromAnchor: n2 }, r4 > 0 && (n2 += e3[r4 - 1].dist(e3[r4]));
                for (let t3 = 0; t3 < e3.length; t3++) {
                  const e4 = i2[t3];
                  this.lineVertexArray.emplaceBack(e4.x, e4.y, e4.tileUnitDistanceFromAnchor);
                }
              }
              return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
            }
            addSymbols(e3, r2, n2, i2, a2, s2, o2, l2, u2, c2, h2, p2) {
              const f2 = e3.indexArray, d2 = e3.layoutVertexArray, y3 = e3.segments.prepareSegment(4 * r2.length, d2, f2, this.canOverlap ? s2.sortKey : void 0), m2 = this.glyphOffsetArray.length, g2 = y3.vertexLength, x3 = this.allowVerticalPlacement && o2 === t.WritingMode.vertical ? Math.PI / 2 : 0, v2 = s2.text && s2.text.sections;
              for (let t2 = 0; t2 < r2.length; t2++) {
                const { tl: i3, tr: a3, bl: o3, br: u3, tex: c3, pixelOffsetTL: h3, pixelOffsetBR: m3, minFontScaleX: g3, minFontScaleY: b2, glyphOffset: w2, isSDF: _2, sectionIndex: A2 } = r2[t2], k2 = y3.vertexLength, S2 = w2[1];
                Vu(d2, l2.x, l2.y, i3.x, S2 + i3.y, c3.x, c3.y, n2, _2, h3.x, h3.y, g3, b2), Vu(d2, l2.x, l2.y, a3.x, S2 + a3.y, c3.x + c3.w, c3.y, n2, _2, m3.x, h3.y, g3, b2), Vu(d2, l2.x, l2.y, o3.x, S2 + o3.y, c3.x, c3.y + c3.h, n2, _2, h3.x, m3.y, g3, b2), Vu(d2, l2.x, l2.y, u3.x, S2 + u3.y, c3.x + c3.w, c3.y + c3.h, n2, _2, m3.x, m3.y, g3, b2), Eu(e3.dynamicLayoutVertexArray, l2, x3), f2.emplaceBack(k2, k2 + 1, k2 + 2), f2.emplaceBack(k2 + 1, k2 + 2, k2 + 3), y3.vertexLength += 4, y3.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w2[0]), t2 !== r2.length - 1 && A2 === r2[t2 + 1].sectionIndex || e3.programConfigurations.populatePaintArrays(d2.length, s2, s2.index, {}, p2, v2 && v2[A2]);
              }
              e3.placedSymbolArray.emplaceBack(l2.x, l2.y, m2, this.glyphOffsetArray.length - m2, g2, u2, c2, l2.segment, n2 ? n2[0] : 0, n2 ? n2[1] : 0, i2[0], i2[1], o2, 0, false, 0, h2);
            }
            _addCollisionDebugVertex(t2, e3, r2, n2, i2, a2) {
              return e3.emplaceBack(0, 0), t2.emplaceBack(r2.x, r2.y, n2, i2, Math.round(a2.x), Math.round(a2.y));
            }
            addCollisionDebugVertices(t2, e3, r2, n2, i2, a2, s2) {
              const o2 = i2.segments.prepareSegment(4, i2.layoutVertexArray, i2.indexArray), l2 = o2.vertexLength, u2 = i2.layoutVertexArray, c2 = i2.collisionVertexArray, h2 = s2.anchorX, p2 = s2.anchorY;
              this._addCollisionDebugVertex(u2, c2, a2, h2, p2, new S(t2, e3)), this._addCollisionDebugVertex(u2, c2, a2, h2, p2, new S(r2, e3)), this._addCollisionDebugVertex(u2, c2, a2, h2, p2, new S(r2, n2)), this._addCollisionDebugVertex(u2, c2, a2, h2, p2, new S(t2, n2)), o2.vertexLength += 4;
              const f2 = i2.indexArray;
              f2.emplaceBack(l2, l2 + 1), f2.emplaceBack(l2 + 1, l2 + 2), f2.emplaceBack(l2 + 2, l2 + 3), f2.emplaceBack(l2 + 3, l2), o2.primitiveLength += 4;
            }
            addDebugCollisionBoxes(t2, e3, r2, n2) {
              for (let i2 = t2; i2 < e3; i2++) {
                const t3 = this.collisionBoxArray.get(i2);
                this.addCollisionDebugVertices(t3.x1, t3.y1, t3.x2, t3.y2, n2 ? this.textCollisionBox : this.iconCollisionBox, t3.anchorPoint, r2);
              }
            }
            generateCollisionDebugBuffers() {
              this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Lu(ua, il.members, pa), this.iconCollisionBox = new Lu(ua, il.members, pa);
              for (let t2 = 0; t2 < this.symbolInstances.length; t2++) {
                const e3 = this.symbolInstances.get(t2);
                this.addDebugCollisionBoxes(e3.textBoxStartIndex, e3.textBoxEndIndex, e3, true), this.addDebugCollisionBoxes(e3.verticalTextBoxStartIndex, e3.verticalTextBoxEndIndex, e3, true), this.addDebugCollisionBoxes(e3.iconBoxStartIndex, e3.iconBoxEndIndex, e3, false), this.addDebugCollisionBoxes(e3.verticalIconBoxStartIndex, e3.verticalIconBoxEndIndex, e3, false);
              }
            }
            _deserializeCollisionBoxesForSymbol(t2, e3, r2, n2, i2, a2, s2, o2, l2) {
              const u2 = {};
              for (let n3 = e3; n3 < r2; n3++) {
                const e4 = t2.get(n3);
                u2.textBox = { x1: e4.x1, y1: e4.y1, x2: e4.x2, y2: e4.y2, anchorPointX: e4.anchorPointX, anchorPointY: e4.anchorPointY }, u2.textFeatureIndex = e4.featureIndex;
                break;
              }
              for (let e4 = n2; e4 < i2; e4++) {
                const r3 = t2.get(e4);
                u2.verticalTextBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalTextFeatureIndex = r3.featureIndex;
                break;
              }
              for (let e4 = a2; e4 < s2; e4++) {
                const r3 = t2.get(e4);
                u2.iconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.iconFeatureIndex = r3.featureIndex;
                break;
              }
              for (let e4 = o2; e4 < l2; e4++) {
                const r3 = t2.get(e4);
                u2.verticalIconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u2.verticalIconFeatureIndex = r3.featureIndex;
                break;
              }
              return u2;
            }
            deserializeCollisionBoxes(t2) {
              this.collisionArrays = [];
              for (let e3 = 0; e3 < this.symbolInstances.length; e3++) {
                const r2 = this.symbolInstances.get(e3);
                this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
              }
            }
            hasTextData() {
              return this.text.segments.get().length > 0;
            }
            hasIconData() {
              return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
              return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
              return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
              return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            addIndicesForPlacedSymbol(t2, e3) {
              const r2 = t2.placedSymbolArray.get(e3), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
              for (let e4 = r2.vertexStartIndex; e4 < n2; e4 += 4)
                t2.indexArray.emplaceBack(e4, e4 + 1, e4 + 2), t2.indexArray.emplaceBack(e4 + 1, e4 + 2, e4 + 3);
            }
            getSortedSymbolIndexes(t2) {
              if (this.sortedAngle === t2 && void 0 !== this.symbolInstanceIndexes)
                return this.symbolInstanceIndexes;
              const e3 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], a2 = [];
              for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
                a2.push(t3);
                const s2 = this.symbolInstances.get(t3);
                n2.push(0 | Math.round(e3 * s2.anchorX + r2 * s2.anchorY)), i2.push(s2.featureIndex);
              }
              return a2.sort((t3, e4) => n2[t3] - n2[e4] || i2[e4] - i2[t3]), a2;
            }
            addToSortKeyRanges(t2, e3) {
              const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
              r2 && r2.sortKey === e3 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e3, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
            }
            sortFeatures(t2) {
              if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                for (const t3 of this.symbolInstanceIndexes) {
                  const e3 = this.symbolInstances.get(t3);
                  this.featureSortOrder.push(e3.featureIndex), [e3.rightJustifiedTextSymbolIndex, e3.centerJustifiedTextSymbolIndex, e3.leftJustifiedTextSymbolIndex].forEach((t4, e4, r2) => {
                    t4 >= 0 && r2.indexOf(t4) === e4 && this.addIndicesForPlacedSymbol(this.text, t4);
                  }), e3.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e3.verticalPlacedTextSymbolIndex), e3.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e3.placedIconSymbolIndex), e3.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e3.verticalPlacedIconSymbolIndex);
                }
                this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
              }
            }
          }
          Mn("SymbolBucket", Du, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Du.MAX_GLYPHS = 65535, Du.addDynamicAttributes = Eu;
          const $u = new fi({ "symbol-placement": new li(nt.layout_symbol["symbol-placement"]), "symbol-spacing": new li(nt.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new li(nt.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new ui(nt.layout_symbol["symbol-sort-key"]), "symbol-z-order": new li(nt.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new li(nt.layout_symbol["icon-allow-overlap"]), "icon-overlap": new li(nt.layout_symbol["icon-overlap"]), "icon-ignore-placement": new li(nt.layout_symbol["icon-ignore-placement"]), "icon-optional": new li(nt.layout_symbol["icon-optional"]), "icon-rotation-alignment": new li(nt.layout_symbol["icon-rotation-alignment"]), "icon-size": new ui(nt.layout_symbol["icon-size"]), "icon-text-fit": new li(nt.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new li(nt.layout_symbol["icon-text-fit-padding"]), "icon-image": new ui(nt.layout_symbol["icon-image"]), "icon-rotate": new ui(nt.layout_symbol["icon-rotate"]), "icon-padding": new ui(nt.layout_symbol["icon-padding"]), "icon-keep-upright": new li(nt.layout_symbol["icon-keep-upright"]), "icon-offset": new ui(nt.layout_symbol["icon-offset"]), "icon-anchor": new ui(nt.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new li(nt.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new li(nt.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new li(nt.layout_symbol["text-rotation-alignment"]), "text-field": new ui(nt.layout_symbol["text-field"]), "text-font": new ui(nt.layout_symbol["text-font"]), "text-size": new ui(nt.layout_symbol["text-size"]), "text-max-width": new ui(nt.layout_symbol["text-max-width"]), "text-line-height": new li(nt.layout_symbol["text-line-height"]), "text-letter-spacing": new ui(nt.layout_symbol["text-letter-spacing"]), "text-justify": new ui(nt.layout_symbol["text-justify"]), "text-radial-offset": new ui(nt.layout_symbol["text-radial-offset"]), "text-variable-anchor": new li(nt.layout_symbol["text-variable-anchor"]), "text-anchor": new ui(nt.layout_symbol["text-anchor"]), "text-max-angle": new li(nt.layout_symbol["text-max-angle"]), "text-writing-mode": new li(nt.layout_symbol["text-writing-mode"]), "text-rotate": new ui(nt.layout_symbol["text-rotate"]), "text-padding": new li(nt.layout_symbol["text-padding"]), "text-keep-upright": new li(nt.layout_symbol["text-keep-upright"]), "text-transform": new ui(nt.layout_symbol["text-transform"]), "text-offset": new ui(nt.layout_symbol["text-offset"]), "text-allow-overlap": new li(nt.layout_symbol["text-allow-overlap"]), "text-overlap": new li(nt.layout_symbol["text-overlap"]), "text-ignore-placement": new li(nt.layout_symbol["text-ignore-placement"]), "text-optional": new li(nt.layout_symbol["text-optional"]) });
          var Ru = { paint: new fi({ "icon-opacity": new ui(nt.paint_symbol["icon-opacity"]), "icon-color": new ui(nt.paint_symbol["icon-color"]), "icon-halo-color": new ui(nt.paint_symbol["icon-halo-color"]), "icon-halo-width": new ui(nt.paint_symbol["icon-halo-width"]), "icon-halo-blur": new ui(nt.paint_symbol["icon-halo-blur"]), "icon-translate": new li(nt.paint_symbol["icon-translate"]), "icon-translate-anchor": new li(nt.paint_symbol["icon-translate-anchor"]), "text-opacity": new ui(nt.paint_symbol["text-opacity"]), "text-color": new ui(nt.paint_symbol["text-color"], { runtimeType: yt, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new ui(nt.paint_symbol["text-halo-color"]), "text-halo-width": new ui(nt.paint_symbol["text-halo-width"]), "text-halo-blur": new ui(nt.paint_symbol["text-halo-blur"]), "text-translate": new li(nt.paint_symbol["text-translate"]), "text-translate-anchor": new li(nt.paint_symbol["text-translate-anchor"]) }), layout: $u };
          class Ou {
            constructor(t2) {
              if (void 0 === t2.property.overrides)
                throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
              this.type = t2.property.overrides ? t2.property.overrides.runtimeType : ht, this.defaultValue = t2;
            }
            evaluate(t2) {
              if (t2.formattedSection) {
                const e3 = this.defaultValue.property.overrides;
                if (e3 && e3.hasOverride(t2.formattedSection))
                  return e3.getOverride(t2.formattedSection);
              }
              return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t2) {
              this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return null;
            }
          }
          Mn("FormatSectionOverride", Ou, { omit: ["defaultValue"] });
          class Uu extends yi {
            constructor(t2) {
              super(t2, Ru);
            }
            recalculate(t2, e3) {
              if (super.recalculate(t2, e3), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
                const t3 = this.layout.get("text-writing-mode");
                if (t3) {
                  const e4 = [];
                  for (const r2 of t3)
                    e4.indexOf(r2) < 0 && e4.push(r2);
                  this.layout._values["text-writing-mode"] = e4;
                } else
                  this.layout._values["text-writing-mode"] = ["horizontal"];
              }
              this._setPaintOverrides();
            }
            getValueAndResolveTokens(t2, e3, r2, n2) {
              const i2 = this.layout.get(t2).evaluate(e3, {}, r2, n2), a2 = this._unevaluatedLayout._values[t2];
              return a2.isDataDriven() || Er(a2.value) || !i2 ? i2 : function(t3, e4) {
                return e4.replace(/{([^{}]+)}/g, (e6, r3) => r3 in t3 ? String(t3[r3]) : "");
              }(e3.properties, i2);
            }
            createBucket(t2) {
              return new Du(t2);
            }
            queryRadius() {
              return 0;
            }
            queryIntersectsFeature() {
              throw new Error("Should take a different path in FeatureIndex");
            }
            _setPaintOverrides() {
              for (const t2 of Ru.paint.overridableProperties) {
                if (!Uu.hasPaintOverride(this.layout, t2))
                  continue;
                const e3 = this.paint.get(t2), r2 = new Ou(e3), n2 = new Vr(r2, e3.property.specification);
                let i2 = null;
                i2 = "constant" === e3.value.kind || "source" === e3.value.kind ? new Tr("source", n2) : new Lr("composite", n2, e3.value.zoomStops), this.paint._values[t2] = new si(e3.property, i2, e3.parameters);
              }
            }
            _handleOverridablePaintPropertyUpdate(t2, e3, r2) {
              return !(!this.layout || e3.isDataDriven() || r2.isDataDriven()) && Uu.hasPaintOverride(this.layout, t2);
            }
            static hasPaintOverride(t2, e3) {
              const r2 = t2.get("text-field"), n2 = Ru.paint.properties[e3];
              let i2 = false;
              const a2 = (t3) => {
                for (const e4 of t3)
                  if (n2.overrides && n2.overrides.hasOverride(e4))
                    return void (i2 = true);
              };
              if ("constant" === r2.value.kind && r2.value.value instanceof Dt)
                a2(r2.value.value.sections);
              else if ("source" === r2.value.kind) {
                const t3 = (e6) => {
                  i2 || (e6 instanceof Nt && qt(e6.value) === vt ? a2(e6.value.sections) : e6 instanceof cr ? a2(e6.sections) : e6.eachChild(t3));
                }, e4 = r2.value;
                e4._styleExpression && t3(e4._styleExpression.expression);
              }
              return i2;
            }
          }
          function qu(t2, e3, r2) {
            let n2 = "never";
            const i2 = t2.get(e3);
            return i2 ? n2 = i2 : t2.get(r2) && (n2 = "always"), n2;
          }
          var ju = { paint: new fi({ "background-color": new li(nt.paint_background["background-color"]), "background-pattern": new hi(nt.paint_background["background-pattern"]), "background-opacity": new li(nt.paint_background["background-opacity"]) }) }, Nu = { paint: new fi({ "raster-opacity": new li(nt.paint_raster["raster-opacity"]), "raster-hue-rotate": new li(nt.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new li(nt.paint_raster["raster-brightness-min"]), "raster-brightness-max": new li(nt.paint_raster["raster-brightness-max"]), "raster-saturation": new li(nt.paint_raster["raster-saturation"]), "raster-contrast": new li(nt.paint_raster["raster-contrast"]), "raster-resampling": new li(nt.paint_raster["raster-resampling"]), "raster-fade-duration": new li(nt.paint_raster["raster-fade-duration"]) }) };
          class Zu extends yi {
            constructor(t2) {
              super(t2, {}), this.onAdd = (t3) => {
                this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
              }, this.onRemove = (t3) => {
                this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
              }, this.implementation = t2;
            }
            is3D() {
              return "3d" === this.implementation.renderingMode;
            }
            hasOffscreenPass() {
              return void 0 !== this.implementation.prerender;
            }
            recalculate() {
            }
            updateTransitions() {
            }
            hasTransition() {
              return false;
            }
            serialize() {
              throw new Error("Custom layers cannot be serialized");
            }
          }
          const Ku = { circle: class extends yi {
            constructor(t2) {
              super(t2, cs);
            }
            createBucket(t2) {
              return new Ja(t2);
            }
            queryRadius(t2) {
              const e3 = t2;
              return ss("circle-radius", this, e3) + ss("circle-stroke-width", this, e3) + os(this.paint.get("circle-translate"));
            }
            queryIntersectsFeature(t2, e3, r2, n2, i2, a2, s2, o2) {
              const l2 = ls(t2, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a2.angle, s2), u2 = this.paint.get("circle-radius").evaluate(e3, r2) + this.paint.get("circle-stroke-width").evaluate(e3, r2), c2 = "map" === this.paint.get("circle-pitch-alignment"), h2 = c2 ? l2 : function(t3, e4) {
                return t3.map((t4) => _s(t4, e4));
              }(l2, o2), p2 = c2 ? u2 * s2 : u2;
              for (const t3 of n2)
                for (const e4 of t3) {
                  const t4 = c2 ? e4 : _s(e4, o2);
                  let r3 = p2;
                  const n3 = bs([], [e4.x, e4.y, 0, 1], o2);
                  if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? r3 *= n3[3] / a2.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (r3 *= a2.cameraToCenterDistance / n3[3]), Ya(h2, t4, r3))
                    return true;
                }
              return false;
            }
          }, heatmap: class extends yi {
            constructor(t2) {
              super(t2, ks), this._updateColorRamp();
            }
            createBucket(t2) {
              return new As(t2);
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              "heatmap-color" === t2 && this._updateColorRamp();
            }
            _updateColorRamp() {
              this.colorRamp = Cs({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
            }
            resize() {
              this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
            }
            queryRadius() {
              return 0;
            }
            queryIntersectsFeature() {
              return false;
            }
            hasOffscreenPass() {
              return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
            }
          }, hillshade: class extends yi {
            constructor(t2) {
              super(t2, Ps);
            }
            hasOffscreenPass() {
              return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
            }
          }, fill: class extends yi {
            constructor(t2) {
              super(t2, xo);
            }
            recalculate(t2, e3) {
              super.recalculate(t2, e3);
              const r2 = this.paint._values["fill-outline-color"];
              "constant" === r2.value.kind && void 0 === r2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
            }
            createBucket(t2) {
              return new mo(t2);
            }
            queryRadius() {
              return os(this.paint.get("fill-translate"));
            }
            queryIntersectsFeature(t2, e3, r2, n2, i2, a2, s2) {
              return Ha(ls(t2, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a2.angle, s2), n2);
            }
            isTileClipped() {
              return true;
            }
          }, "fill-extrusion": class extends yi {
            constructor(t2) {
              super(t2, Oo);
            }
            createBucket(t2) {
              return new Do(t2);
            }
            queryRadius() {
              return os(this.paint.get("fill-extrusion-translate"));
            }
            is3D() {
              return true;
            }
            queryIntersectsFeature(t2, e3, r2, n2, i2, a2, s2, o2) {
              const l2 = ls(t2, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a2.angle, s2), u2 = this.paint.get("fill-extrusion-height").evaluate(e3, r2), c2 = this.paint.get("fill-extrusion-base").evaluate(e3, r2), h2 = function(t3, e4, r3, n3) {
                const i3 = [];
                for (const r4 of t3) {
                  const t4 = [r4.x, r4.y, 0, 1];
                  bs(t4, t4, e4), i3.push(new S(t4[0] / t4[3], t4[1] / t4[3]));
                }
                return i3;
              }(l2, o2), p2 = function(t3, e4, r3, n3) {
                const i3 = [], a3 = [], s3 = n3[8] * e4, o3 = n3[9] * e4, l3 = n3[10] * e4, u3 = n3[11] * e4, c3 = n3[8] * r3, h3 = n3[9] * r3, p3 = n3[10] * r3, f2 = n3[11] * r3;
                for (const e6 of t3) {
                  const t4 = [], r4 = [];
                  for (const i4 of e6) {
                    const e7 = i4.x, a4 = i4.y, d2 = n3[0] * e7 + n3[4] * a4 + n3[12], y3 = n3[1] * e7 + n3[5] * a4 + n3[13], m2 = n3[2] * e7 + n3[6] * a4 + n3[14], g2 = n3[3] * e7 + n3[7] * a4 + n3[15], x3 = m2 + l3, v2 = g2 + u3, b2 = d2 + c3, w2 = y3 + h3, _2 = m2 + p3, A2 = g2 + f2, k2 = new S((d2 + s3) / v2, (y3 + o3) / v2);
                    k2.z = x3 / v2, t4.push(k2);
                    const I2 = new S(b2 / A2, w2 / A2);
                    I2.z = _2 / A2, r4.push(I2);
                  }
                  i3.push(t4), a3.push(r4);
                }
                return [i3, a3];
              }(n2, c2, u2, o2);
              return function(t3, e4, r3) {
                let n3 = 1 / 0;
                Ha(r3, e4) && (n3 = qo(r3, e4[0]));
                for (let i3 = 0; i3 < e4.length; i3++) {
                  const a3 = e4[i3], s3 = t3[i3];
                  for (let t4 = 0; t4 < a3.length - 1; t4++) {
                    const e6 = a3[t4], i4 = [e6, a3[t4 + 1], s3[t4 + 1], s3[t4], e6];
                    Xa(r3, i4) && (n3 = Math.min(n3, qo(r3, i4)));
                  }
                }
                return n3 !== 1 / 0 && n3;
              }(p2[0], p2[1], h2);
            }
          }, line: class extends yi {
            constructor(t2) {
              super(t2, Wo), this.gradientVersion = 0;
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              "line-gradient" === t2 && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof ke, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER);
            }
            gradientExpression() {
              return this._transitionablePaint._values["line-gradient"].value.expression;
            }
            recalculate(t2, e3) {
              super.recalculate(t2, e3), this.paint._values["line-floorwidth"] = Qo.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
            }
            createBucket(t2) {
              return new Yo(t2);
            }
            queryRadius(t2) {
              const e3 = t2, r2 = tl(ss("line-width", this, e3), ss("line-gap-width", this, e3)), n2 = ss("line-offset", this, e3);
              return r2 / 2 + Math.abs(n2) + os(this.paint.get("line-translate"));
            }
            queryIntersectsFeature(t2, e3, r2, n2, i2, a2, s2) {
              const o2 = ls(t2, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a2.angle, s2), l2 = s2 / 2 * tl(this.paint.get("line-width").evaluate(e3, r2), this.paint.get("line-gap-width").evaluate(e3, r2)), u2 = this.paint.get("line-offset").evaluate(e3, r2);
              return u2 && (n2 = function(t3, e4) {
                const r3 = [];
                for (let n3 = 0; n3 < t3.length; n3++) {
                  const i3 = t3[n3], a3 = [];
                  for (let t4 = 0; t4 < i3.length; t4++) {
                    const r4 = i3[t4 - 1], n4 = i3[t4], s3 = i3[t4 + 1], o3 = 0 === t4 ? new S(0, 0) : n4.sub(r4)._unit()._perp(), l3 = t4 === i3.length - 1 ? new S(0, 0) : s3.sub(n4)._unit()._perp(), u3 = o3._add(l3)._unit(), c2 = u3.x * l3.x + u3.y * l3.y;
                    0 !== c2 && u3._mult(1 / c2), a3.push(u3._mult(e4)._add(n4));
                  }
                  r3.push(a3);
                }
                return r3;
              }(n2, u2 * s2)), function(t3, e4, r3) {
                for (let n3 = 0; n3 < e4.length; n3++) {
                  const i3 = e4[n3];
                  if (t3.length >= 3) {
                    for (let e6 = 0; e6 < i3.length; e6++)
                      if (is(t3, i3[e6]))
                        return true;
                  }
                  if (Wa(t3, i3, r3))
                    return true;
                }
                return false;
              }(o2, n2, l2);
            }
            isTileClipped() {
              return true;
            }
          }, symbol: Uu, background: class extends yi {
            constructor(t2) {
              super(t2, ju);
            }
          }, raster: class extends yi {
            constructor(t2) {
              super(t2, Nu);
            }
          } };
          class Gu {
            constructor(t2) {
              this._callback = t2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
                this._triggered = false, this._callback();
              });
            }
            trigger() {
              this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
                this._triggered = false, this._callback();
              }, 0));
            }
            remove() {
              delete this._channel, this._callback = () => {
              };
            }
          }
          const Ju = 63710088e-1;
          class Xu {
            constructor(t2, e3) {
              if (isNaN(t2) || isNaN(e3))
                throw new Error(`Invalid LngLat object: (${t2}, ${e3})`);
              if (this.lng = +t2, this.lat = +e3, this.lat > 90 || this.lat < -90)
                throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
              return new Xu(s(this.lng, -180, 180), this.lat);
            }
            toArray() {
              return [this.lng, this.lat];
            }
            toString() {
              return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t2) {
              const e3 = Math.PI / 180, r2 = this.lat * e3, n2 = t2.lat * e3, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e3);
              return Ju * Math.acos(Math.min(i2, 1));
            }
            toBounds(t2 = 0) {
              const e3 = 360 * t2 / 40075017, r2 = e3 / Math.cos(Math.PI / 180 * this.lat);
              return new Yu(new Xu(this.lng - r2, this.lat - e3), new Xu(this.lng + r2, this.lat + e3));
            }
            static convert(t2) {
              if (t2 instanceof Xu)
                return t2;
              if (Array.isArray(t2) && (2 === t2.length || 3 === t2.length))
                return new Xu(Number(t2[0]), Number(t2[1]));
              if (!Array.isArray(t2) && "object" == typeof t2 && null !== t2)
                return new Xu(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
              throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
          }
          class Yu {
            constructor(t2, e3) {
              t2 && (e3 ? this.setSouthWest(t2).setNorthEast(e3) : 4 === t2.length ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1]));
            }
            setNorthEast(t2) {
              return this._ne = t2 instanceof Xu ? new Xu(t2.lng, t2.lat) : Xu.convert(t2), this;
            }
            setSouthWest(t2) {
              return this._sw = t2 instanceof Xu ? new Xu(t2.lng, t2.lat) : Xu.convert(t2), this;
            }
            extend(t2) {
              const e3 = this._sw, r2 = this._ne;
              let n2, i2;
              if (t2 instanceof Xu)
                n2 = t2, i2 = t2;
              else {
                if (!(t2 instanceof Yu))
                  return Array.isArray(t2) ? 4 === t2.length || t2.every(Array.isArray) ? this.extend(Yu.convert(t2)) : this.extend(Xu.convert(t2)) : this;
                if (n2 = t2._sw, i2 = t2._ne, !n2 || !i2)
                  return this;
              }
              return e3 || r2 ? (e3.lng = Math.min(n2.lng, e3.lng), e3.lat = Math.min(n2.lat, e3.lat), r2.lng = Math.max(i2.lng, r2.lng), r2.lat = Math.max(i2.lat, r2.lat)) : (this._sw = new Xu(n2.lng, n2.lat), this._ne = new Xu(i2.lng, i2.lat)), this;
            }
            getCenter() {
              return new Xu((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
              return this._sw;
            }
            getNorthEast() {
              return this._ne;
            }
            getNorthWest() {
              return new Xu(this.getWest(), this.getNorth());
            }
            getSouthEast() {
              return new Xu(this.getEast(), this.getSouth());
            }
            getWest() {
              return this._sw.lng;
            }
            getSouth() {
              return this._sw.lat;
            }
            getEast() {
              return this._ne.lng;
            }
            getNorth() {
              return this._ne.lat;
            }
            toArray() {
              return [this._sw.toArray(), this._ne.toArray()];
            }
            toString() {
              return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
              return !(this._sw && this._ne);
            }
            contains(t2) {
              const { lng: e3, lat: r2 } = Xu.convert(t2);
              let n2 = this._sw.lng <= e3 && e3 <= this._ne.lng;
              return this._sw.lng > this._ne.lng && (n2 = this._sw.lng >= e3 && e3 >= this._ne.lng), this._sw.lat <= r2 && r2 <= this._ne.lat && n2;
            }
            static convert(t2) {
              return t2 instanceof Yu ? t2 : t2 ? new Yu(t2) : t2;
            }
          }
          const Hu = 2 * Math.PI * Ju;
          function Wu(t2) {
            return Hu * Math.cos(t2 * Math.PI / 180);
          }
          function Qu(t2) {
            return (180 + t2) / 360;
          }
          function tc(t2) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
          }
          function ec(t2, e3) {
            return t2 / Wu(e3);
          }
          function rc(t2) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
          }
          class nc {
            constructor(t2, e3, r2 = 0) {
              this.x = +t2, this.y = +e3, this.z = +r2;
            }
            static fromLngLat(t2, e3 = 0) {
              const r2 = Xu.convert(t2);
              return new nc(Qu(r2.lng), tc(r2.lat), ec(e3, r2.lat));
            }
            toLngLat() {
              return new Xu(360 * this.x - 180, rc(this.y));
            }
            toAltitude() {
              return this.z * Wu(rc(this.y));
            }
            meterInMercatorCoordinateUnits() {
              return 1 / Hu * (t2 = rc(this.y), 1 / Math.cos(t2 * Math.PI / 180));
              var t2;
            }
          }
          function ic(t2, e3, r2) {
            var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
            return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e3 * n2 - 2 * Math.PI * 6378137 / 2];
          }
          class ac {
            constructor(t2, e3, r2) {
              if (t2 < 0 || t2 > 25 || r2 < 0 || r2 >= Math.pow(2, t2) || e3 < 0 || e3 >= Math.pow(2, t2))
                throw new Error(`x=${e3}, y=${r2}, z=${t2} outside of bounds. 0<=x<${Math.pow(2, t2)}, 0<=y<${Math.pow(2, t2)} 0<=z<=25 `);
              this.z = t2, this.x = e3, this.y = r2, this.key = lc(0, t2, t2, e3, r2);
            }
            equals(t2) {
              return this.z === t2.z && this.x === t2.x && this.y === t2.y;
            }
            url(t2, e3, r2) {
              const n2 = (a2 = this.y, s2 = this.z, o2 = ic(256 * (i2 = this.x), 256 * (a2 = Math.pow(2, s2) - a2 - 1), s2), l2 = ic(256 * (i2 + 1), 256 * (a2 + 1), s2), o2[0] + "," + o2[1] + "," + l2[0] + "," + l2[1]);
              var i2, a2, s2, o2, l2;
              const u2 = function(t3, e4, r3) {
                let n3, i3 = "";
                for (let a3 = t3; a3 > 0; a3--)
                  n3 = 1 << a3 - 1, i3 += (e4 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
                return i3;
              }(this.z, this.x, this.y);
              return t2[(this.x + this.y) % t2.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e3 > 1 ? "@2x" : "").replace(/{quadkey}/g, u2).replace(/{bbox-epsg-3857}/g, n2);
            }
            isChildOf(t2) {
              const e3 = this.z - t2.z;
              return e3 > 0 && t2.x === this.x >> e3 && t2.y === this.y >> e3;
            }
            getTilePoint(t2) {
              const e3 = Math.pow(2, this.z);
              return new S((t2.x * e3 - this.x) * qa, (t2.y * e3 - this.y) * qa);
            }
            toString() {
              return `${this.z}/${this.x}/${this.y}`;
            }
          }
          class sc {
            constructor(t2, e3) {
              this.wrap = t2, this.canonical = e3, this.key = lc(t2, e3.z, e3.z, e3.x, e3.y);
            }
          }
          class oc {
            constructor(t2, e3, r2, n2, i2) {
              if (t2 < r2)
                throw new Error(`overscaledZ should be >= z; overscaledZ = ${t2}; z = ${r2}`);
              this.overscaledZ = t2, this.wrap = e3, this.canonical = new ac(r2, +n2, +i2), this.key = lc(e3, t2, r2, n2, i2);
            }
            clone() {
              return new oc(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            equals(t2) {
              return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
            }
            scaledTo(t2) {
              if (t2 > this.overscaledZ)
                throw new Error(`targetZ > this.overscaledZ; targetZ = ${t2}; overscaledZ = ${this.overscaledZ}`);
              const e3 = this.canonical.z - t2;
              return t2 > this.canonical.z ? new oc(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new oc(t2, this.wrap, t2, this.canonical.x >> e3, this.canonical.y >> e3);
            }
            calculateScaledKey(t2, e3) {
              if (t2 > this.overscaledZ)
                throw new Error(`targetZ > this.overscaledZ; targetZ = ${t2}; overscaledZ = ${this.overscaledZ}`);
              const r2 = this.canonical.z - t2;
              return t2 > this.canonical.z ? lc(this.wrap * +e3, t2, this.canonical.z, this.canonical.x, this.canonical.y) : lc(this.wrap * +e3, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
            }
            isChildOf(t2) {
              if (t2.wrap !== this.wrap)
                return false;
              const e3 = this.canonical.z - t2.canonical.z;
              return 0 === t2.overscaledZ || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e3 && t2.canonical.y === this.canonical.y >> e3;
            }
            children(t2) {
              if (this.overscaledZ >= t2)
                return [new oc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
              const e3 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
              return [new oc(e3, this.wrap, e3, r2, n2), new oc(e3, this.wrap, e3, r2 + 1, n2), new oc(e3, this.wrap, e3, r2, n2 + 1), new oc(e3, this.wrap, e3, r2 + 1, n2 + 1)];
            }
            isLessThan(t2) {
              return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
            }
            wrapped() {
              return new oc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t2) {
              return new oc(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
              return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
              return new sc(this.wrap, this.canonical);
            }
            toString() {
              return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
            getTilePoint(t2) {
              return this.canonical.getTilePoint(new nc(t2.x - this.wrap, t2.y));
            }
          }
          function lc(t2, e3, r2, n2, i2) {
            (t2 *= 2) < 0 && (t2 = -1 * t2 - 1);
            const a2 = 1 << r2;
            return (a2 * a2 * t2 + a2 * i2 + n2).toString(36) + r2.toString(36) + e3.toString(36);
          }
          Mn("CanonicalTileID", ac), Mn("OverscaledTileID", oc, { omit: ["posMatrix"] });
          class uc {
            constructor(t2, e3, r2) {
              if (this.uid = t2, e3.height !== e3.width)
                throw new RangeError("DEM tiles must be square");
              if (r2 && "mapbox" !== r2 && "terrarium" !== r2)
                return void d(`"${r2}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
              this.stride = e3.height;
              const n2 = this.dim = e3.height - 2;
              this.data = new Uint32Array(e3.data.buffer), this.encoding = r2 || "mapbox";
              for (let t3 = 0; t3 < n2; t3++)
                this.data[this._idx(-1, t3)] = this.data[this._idx(0, t3)], this.data[this._idx(n2, t3)] = this.data[this._idx(n2 - 1, t3)], this.data[this._idx(t3, -1)] = this.data[this._idx(t3, 0)], this.data[this._idx(t3, n2)] = this.data[this._idx(t3, n2 - 1)];
              this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(n2, -1)] = this.data[this._idx(n2 - 1, 0)], this.data[this._idx(-1, n2)] = this.data[this._idx(0, n2 - 1)], this.data[this._idx(n2, n2)] = this.data[this._idx(n2 - 1, n2 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
              for (let t3 = 0; t3 < n2; t3++)
                for (let e4 = 0; e4 < n2; e4++) {
                  const r3 = this.get(t3, e4);
                  r3 > this.max && (this.max = r3), r3 < this.min && (this.min = r3);
                }
            }
            get(t2, e3) {
              const r2 = new Uint8Array(this.data.buffer), n2 = 4 * this._idx(t2, e3);
              return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(r2[n2], r2[n2 + 1], r2[n2 + 2]);
            }
            getUnpackVector() {
              return "terrarium" === this.encoding ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, 0.1, 1e4];
            }
            _idx(t2, e3) {
              if (t2 < -1 || t2 >= this.dim + 1 || e3 < -1 || e3 >= this.dim + 1)
                throw new RangeError("out of range source coordinates for DEM data");
              return (e3 + 1) * this.stride + (t2 + 1);
            }
            _unpackMapbox(t2, e3, r2) {
              return (256 * t2 * 256 + 256 * e3 + r2) / 10 - 1e4;
            }
            _unpackTerrarium(t2, e3, r2) {
              return 256 * t2 + e3 + r2 / 256 - 32768;
            }
            getPixels() {
              return new Bs({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
            }
            backfillBorder(t2, e3, r2) {
              if (this.dim !== t2.dim)
                throw new Error("dem dimension mismatch");
              let n2 = e3 * this.dim, i2 = e3 * this.dim + this.dim, a2 = r2 * this.dim, s2 = r2 * this.dim + this.dim;
              switch (e3) {
                case -1:
                  n2 = i2 - 1;
                  break;
                case 1:
                  i2 = n2 + 1;
              }
              switch (r2) {
                case -1:
                  a2 = s2 - 1;
                  break;
                case 1:
                  s2 = a2 + 1;
              }
              const o2 = -e3 * this.dim, l2 = -r2 * this.dim;
              for (let e4 = a2; e4 < s2; e4++)
                for (let r3 = n2; r3 < i2; r3++)
                  this.data[this._idx(r3, e4)] = t2.data[this._idx(r3 + o2, e4 + l2)];
            }
          }
          Mn("DEMData", uc);
          class cc {
            constructor(t2) {
              this._stringToNumber = {}, this._numberToString = [];
              for (let e3 = 0; e3 < t2.length; e3++) {
                const r2 = t2[e3];
                this._stringToNumber[r2] = e3, this._numberToString[e3] = r2;
              }
            }
            encode(t2) {
              return this._stringToNumber[t2];
            }
            decode(t2) {
              if (t2 >= this._numberToString.length)
                throw new Error(`Out of bounds. Index requested n=${t2} can't be >= this._numberToString.length ${this._numberToString.length}`);
              return this._numberToString[t2];
            }
          }
          class hc {
            constructor(t2, e3, r2, n2, i2) {
              this.type = "Feature", this._vectorTileFeature = t2, t2._z = e3, t2._x = r2, t2._y = n2, this.properties = t2.properties, this.id = i2;
            }
            get geometry() {
              return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
            }
            set geometry(t2) {
              this._geometry = t2;
            }
            toJSON() {
              const t2 = { geometry: this.geometry };
              for (const e3 in this)
                "_geometry" !== e3 && "_vectorTileFeature" !== e3 && (t2[e3] = this[e3]);
              return t2;
            }
          }
          class pc {
            constructor(t2, e3) {
              this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new Sn(qa, 16, 0), this.grid3D = new Sn(qa, 16, 0), this.featureIndexArray = new Wi(), this.promoteId = e3;
            }
            insert(t2, e3, r2, n2, i2, a2) {
              const s2 = this.featureIndexArray.length;
              this.featureIndexArray.emplaceBack(r2, n2, i2);
              const o2 = a2 ? this.grid3D : this.grid;
              for (let t3 = 0; t3 < e3.length; t3++) {
                const r3 = e3[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (let t4 = 0; t4 < r3.length; t4++) {
                  const e4 = r3[t4];
                  n3[0] = Math.min(n3[0], e4.x), n3[1] = Math.min(n3[1], e4.y), n3[2] = Math.max(n3[2], e4.x), n3[3] = Math.max(n3[3], e4.y);
                }
                n3[0] < qa && n3[1] < qa && n3[2] >= 0 && n3[3] >= 0 && o2.insert(s2, n3[0], n3[1], n3[2], n3[3]);
              }
            }
            loadVTLayers() {
              return this.vtLayers || (this.vtLayers = new _o.VectorTile(new ul(this.rawTileData)).layers, this.sourceLayerCoder = new cc(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
            }
            query(t2, e3, r2, n2) {
              this.loadVTLayers();
              const i2 = t2.params || {}, a2 = qa / t2.tileSize / t2.scale, s2 = Jr(i2.filter), o2 = t2.queryGeometry, l2 = t2.queryPadding * a2, u2 = dc(o2), c2 = this.grid.query(u2.minX - l2, u2.minY - l2, u2.maxX + l2, u2.maxY + l2), h2 = dc(t2.cameraQueryGeometry), p2 = this.grid3D.query(h2.minX - l2, h2.minY - l2, h2.maxX + l2, h2.maxY + l2, (e4, r3, n3, i3) => function(t3, e6, r4, n4, i4) {
                for (const a4 of t3)
                  if (e6 <= a4.x && r4 <= a4.y && n4 >= a4.x && i4 >= a4.y)
                    return true;
                const a3 = [new S(e6, r4), new S(e6, i4), new S(n4, i4), new S(n4, r4)];
                if (t3.length > 2) {
                  for (const e7 of a3)
                    if (is(t3, e7))
                      return true;
                }
                for (let e7 = 0; e7 < t3.length - 1; e7++)
                  if (as(t3[e7], t3[e7 + 1], a3))
                    return true;
                return false;
              }(t2.cameraQueryGeometry, e4 - l2, r3 - l2, n3 + l2, i3 + l2));
              for (const t3 of p2)
                c2.push(t3);
              c2.sort(yc);
              const f2 = {};
              let d2;
              for (let l3 = 0; l3 < c2.length; l3++) {
                const u3 = c2[l3];
                if (u3 === d2)
                  continue;
                d2 = u3;
                const h3 = this.featureIndexArray.get(u3);
                let p3 = null;
                this.loadMatchingFeature(f2, h3.bucketIndex, h3.sourceLayerIndex, h3.featureIndex, s2, i2.layers, i2.availableImages, e3, r2, n2, (e4, r3, n3) => (p3 || (p3 = Za(e4)), r3.queryIntersectsFeature(o2, e4, n3, p3, this.z, t2.transform, a2, t2.pixelPosMatrix)));
              }
              return f2;
            }
            loadMatchingFeature(t2, e3, r2, n2, i2, a2, s2, l2, u2, c2, h2) {
              const p2 = this.bucketLayerIDs[e3];
              if (a2 && !function(t3, e4) {
                for (let r3 = 0; r3 < t3.length; r3++)
                  if (e4.indexOf(t3[r3]) >= 0)
                    return true;
                return false;
              }(a2, p2))
                return;
              const f2 = this.sourceLayerCoder.decode(r2), d2 = this.vtLayers[f2].feature(n2);
              if (i2.needGeometry) {
                const t3 = Ka(d2, true);
                if (!i2.filter(new Qn(this.tileID.overscaledZ), t3, this.tileID.canonical))
                  return;
              } else if (!i2.filter(new Qn(this.tileID.overscaledZ), d2))
                return;
              const y3 = this.getId(d2, f2);
              for (let e4 = 0; e4 < p2.length; e4++) {
                const r3 = p2[e4];
                if (a2 && a2.indexOf(r3) < 0)
                  continue;
                const i3 = l2[r3];
                if (!i3)
                  continue;
                let f3 = {};
                y3 && c2 && (f3 = c2.getState(i3.sourceLayer || "_geojsonTileLayer", y3));
                const m2 = o({}, u2[r3]);
                m2.paint = fc(m2.paint, i3.paint, d2, f3, s2), m2.layout = fc(m2.layout, i3.layout, d2, f3, s2);
                const g2 = !h2 || h2(d2, i3, f3);
                if (!g2)
                  continue;
                const x3 = new hc(d2, this.z, this.x, this.y, y3);
                x3.layer = m2;
                let v2 = t2[r3];
                void 0 === v2 && (v2 = t2[r3] = []), v2.push({ featureIndex: n2, feature: x3, intersectionZ: g2 });
              }
            }
            lookupSymbolFeatures(t2, e3, r2, n2, i2, a2, s2, o2) {
              const l2 = {};
              this.loadVTLayers();
              const u2 = Jr(i2);
              for (const i3 of t2)
                this.loadMatchingFeature(l2, r2, n2, i3, u2, a2, s2, o2, e3);
              return l2;
            }
            hasLayer(t2) {
              for (const e3 of this.bucketLayerIDs)
                for (const r2 of e3)
                  if (t2 === r2)
                    return true;
              return false;
            }
            getId(t2, e3) {
              let r2 = t2.id;
              return this.promoteId && (r2 = t2.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e3]], "boolean" == typeof r2 && (r2 = Number(r2))), r2;
            }
          }
          function fc(t2, e3, r2, n2, i2) {
            return c(t2, (t3, a2) => {
              const s2 = e3 instanceof oi ? e3.get(a2) : null;
              return s2 && s2.evaluate ? s2.evaluate(r2, n2, i2) : s2;
            });
          }
          function dc(t2) {
            let e3 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
            for (const a2 of t2)
              e3 = Math.min(e3, a2.x), r2 = Math.min(r2, a2.y), n2 = Math.max(n2, a2.x), i2 = Math.max(i2, a2.y);
            return { minX: e3, minY: r2, maxX: n2, maxY: i2 };
          }
          function yc(t2, e3) {
            return e3 - t2;
          }
          var mc;
          Mn("FeatureIndex", pc, { omit: ["rawTileData", "sourceLayerCoder"] }), t.PerformanceMarkers = void 0, (mc = t.PerformanceMarkers || (t.PerformanceMarkers = {})).create = "create", mc.load = "load", mc.fullLoad = "fullLoad";
          let gc = null, xc = [];
          const vc = 1e3 / 30, bc = { mark(t2) {
            performance.mark(t2);
          }, frame(t2) {
            const e3 = t2;
            null != gc && xc.push(e3 - gc), gc = e3;
          }, clearMetrics() {
            gc = null, xc = [], performance.clearMeasures("loadTime"), performance.clearMeasures("fullLoadTime");
            for (const e3 in t.PerformanceMarkers)
              performance.clearMarks(t.PerformanceMarkers[e3]);
          }, getPerformanceMetrics() {
            performance.measure("loadTime", t.PerformanceMarkers.create, t.PerformanceMarkers.load), performance.measure("fullLoadTime", t.PerformanceMarkers.create, t.PerformanceMarkers.fullLoad);
            const e3 = performance.getEntriesByName("loadTime")[0].duration, r2 = performance.getEntriesByName("fullLoadTime")[0].duration, n2 = xc.length, i2 = 1 / (xc.reduce((t2, e4) => t2 + e4, 0) / n2 / 1e3), a2 = xc.filter((t2) => t2 > vc).reduce((t2, e4) => t2 + (e4 - vc) / vc, 0);
            return { loadTime: e3, fullLoadTime: r2, fps: i2, percentDroppedFrames: a2 / (n2 + a2) * 100 };
          } };
          t.AJAXError = q, t.ARRAY_TYPE = ps, t.Actor = class {
            constructor(t2, e3, r2) {
              this.target = t2, this.parent = e3, this.mapId = r2, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, u(["receive", "process"], this), this.invoker = new Gu(this.process), this.target.addEventListener("message", this.receive, false), this.globalScope = g() ? t2 : window;
            }
            send(t2, e3, r2, n2, i2 = false) {
              const a2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
              r2 && (this.callbacks[a2] = r2);
              const s2 = _(this.globalScope) ? void 0 : [];
              return this.target.postMessage({ id: a2, type: t2, hasCallback: !!r2, targetMapId: n2, mustQueue: i2, sourceMapId: this.mapId, data: Bn(e3, s2) }, s2), { cancel: () => {
                r2 && delete this.callbacks[a2], this.target.postMessage({ id: a2, type: "<cancel>", targetMapId: n2, sourceMapId: this.mapId });
              } };
            }
            receive(t2) {
              const e3 = t2.data, r2 = e3.id;
              if (r2 && (!e3.targetMapId || this.mapId === e3.targetMapId))
                if ("<cancel>" === e3.type) {
                  delete this.tasks[r2];
                  const t3 = this.cancelCallbacks[r2];
                  delete this.cancelCallbacks[r2], t3 && t3();
                } else
                  g() || e3.mustQueue ? (this.tasks[r2] = e3, this.taskQueue.push(r2), this.invoker.trigger()) : this.processTask(r2, e3);
            }
            process() {
              if (!this.taskQueue.length)
                return;
              const t2 = this.taskQueue.shift(), e3 = this.tasks[t2];
              delete this.tasks[t2], this.taskQueue.length && this.invoker.trigger(), e3 && this.processTask(t2, e3);
            }
            processTask(t2, e3) {
              if ("<response>" === e3.type) {
                const r2 = this.callbacks[t2];
                delete this.callbacks[t2], r2 && (e3.error ? r2(Cn(e3.error)) : r2(null, Cn(e3.data)));
              } else {
                let r2 = false;
                const n2 = _(this.globalScope) ? void 0 : [], i2 = e3.hasCallback ? (e4, i3) => {
                  r2 = true, delete this.cancelCallbacks[t2], this.target.postMessage({ id: t2, type: "<response>", sourceMapId: this.mapId, error: e4 ? Bn(e4) : null, data: Bn(i3, n2) }, n2);
                } : (t3) => {
                  r2 = true;
                };
                let a2 = null;
                const s2 = Cn(e3.data);
                if (this.parent[e3.type])
                  a2 = this.parent[e3.type](e3.sourceMapId, s2, i2);
                else if (this.parent.getWorkerSource) {
                  const t3 = e3.type.split(".");
                  a2 = this.parent.getWorkerSource(e3.sourceMapId, t3[0], s2.source)[t3[1]](s2, i2);
                } else
                  i2(new Error(`Could not find function ${e3.type}`));
                !r2 && a2 && a2.cancel && (this.cancelCallbacks[t2] = a2.cancel);
              }
            }
            remove() {
              this.invoker.remove(), this.target.removeEventListener("message", this.receive, false);
            }
          }, t.AlphaImage = zs, t.CanonicalTileID = ac, t.CollisionBoxArray = Ni, t.CollisionCircleLayoutArray = class extends Vi {
          }, t.Color = Ft, t.DEMData = uc, t.DataConstantProperty = li, t.DictionaryCoder = cc, t.EXTENT = qa, t.ErrorEvent = et, t.EvaluationParameters = Qn, t.Event = tt, t.Evented = rt, t.FeatureIndex = pc, t.FillBucket = mo, t.FillExtrusionBucket = Do, t.GeoJSONFeature = hc, t.ImageAtlas = Dl, t.ImagePosition = Ll, t.LineBucket = Yo, t.LineStripIndexArray = class extends Ui {
          }, t.LngLat = Xu, t.LngLatBounds = Yu, t.MercatorCoordinate = nc, t.ONE_EM = ll, t.OverscaledTileID = oc, t.PerformanceUtils = bc, t.PosArray = Qi, t.Properties = fi, t.QuadTriangleArray = class extends Fi {
          }, t.RGBAImage = Bs, t.RasterBoundsArray = class extends _i {
          }, t.RequestPerformance = class {
            constructor(t2) {
              this._marks = { start: [t2.url, "start"].join("#"), end: [t2.url, "end"].join("#"), measure: t2.url.toString() }, performance.mark(this._marks.start);
            }
            finish() {
              performance.mark(this._marks.end);
              let t2 = performance.getEntriesByName(this._marks.measure);
              return 0 === t2.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t2 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t2;
            }
          }, t.ResourceType = U, t.SegmentVector = ya, t.SymbolBucket = Du, t.Transitionable = ri, t.TriangleIndexArray = ha, t.Uniform1f = za, t.Uniform1i = class extends Ma {
            constructor(t2, e3) {
              super(t2, e3), this.current = 0;
            }
            set(t2) {
              this.current !== t2 && (this.current = t2, this.gl.uniform1i(this.location, t2));
            }
          }, t.Uniform2f = class extends Ma {
            constructor(t2, e3) {
              super(t2, e3), this.current = [0, 0];
            }
            set(t2) {
              t2[0] === this.current[0] && t2[1] === this.current[1] || (this.current = t2, this.gl.uniform2f(this.location, t2[0], t2[1]));
            }
          }, t.Uniform3f = class extends Ma {
            constructor(t2, e3) {
              super(t2, e3), this.current = [0, 0, 0];
            }
            set(t2) {
              t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] || (this.current = t2, this.gl.uniform3f(this.location, t2[0], t2[1], t2[2]));
            }
          }, t.Uniform4f = Ba, t.UniformColor = Ca, t.UniformMatrix4f = class extends Ma {
            constructor(t2, e3) {
              super(t2, e3), this.current = Pa;
            }
            set(t2) {
              if (t2[12] !== this.current[12] || t2[0] !== this.current[0])
                return this.current = t2, void this.gl.uniformMatrix4fv(this.location, false, t2);
              for (let e3 = 1; e3 < 16; e3++)
                if (t2[e3] !== this.current[e3]) {
                  this.current = t2, this.gl.uniformMatrix4fv(this.location, false, t2);
                  break;
                }
            }
          }, t.UnwrappedTileID = sc, t.ValidationError = it, t.ZoomHistory = Pn, t.add = function(t2, e3, r2) {
            return t2[0] = e3[0] + r2[0], t2[1] = e3[1] + r2[1], t2[2] = e3[2] + r2[2], t2;
          }, t.addDynamicAttributes = Eu, t.asyncAll = function(t2, e3, r2) {
            if (!t2.length)
              return r2(null, []);
            let n2 = t2.length;
            const i2 = new Array(t2.length);
            let a2 = null;
            t2.forEach((t3, s2) => {
              e3(t3, (t4, e4) => {
                t4 && (a2 = t4), i2[s2] = e4, 0 == --n2 && r2(a2, i2);
              });
            });
          }, t.bezier = n, t.bindAll = u, t.cacheEntryPossiblyAdded = function(t2) {
            F++, F > V && (t2.getActor().send("enforceCacheSizeLimit", P), F = 0);
          }, t.clamp = a, t.clearTileCache = function(t2) {
            const e3 = caches.delete(z);
            t2 && e3.catch(t2).then(() => t2());
          }, t.clipLine = cu, t.clone = function(t2) {
            var e3 = new ps(16);
            return e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3[3] = t2[3], e3[4] = t2[4], e3[5] = t2[5], e3[6] = t2[6], e3[7] = t2[7], e3[8] = t2[8], e3[9] = t2[9], e3[10] = t2[10], e3[11] = t2[11], e3[12] = t2[12], e3[13] = t2[13], e3[14] = t2[14], e3[15] = t2[15], e3;
          }, t.clone$1 = p, t.clone$2 = function(t2) {
            var e3 = new ps(3);
            return e3[0] = t2[0], e3[1] = t2[1], e3[2] = t2[2], e3;
          }, t.collisionCircleLayout = al, t.config = M, t.copy = function(t2, e3) {
            return t2[0] = e3[0], t2[1] = e3[1], t2[2] = e3[2], t2[3] = e3[3], t2[4] = e3[4], t2[5] = e3[5], t2[6] = e3[6], t2[7] = e3[7], t2[8] = e3[8], t2[9] = e3[9], t2[10] = e3[10], t2[11] = e3[11], t2[12] = e3[12], t2[13] = e3[13], t2[14] = e3[14], t2[15] = e3[15], t2;
          }, t.create = function() {
            var t2 = new ps(16);
            return ps != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
          }, t.create$1 = fs, t.createExpression = Fr, t.createFilter = Jr, t.createLayout = vi, t.createStyleLayer = function(t2) {
            return "custom" === t2.type ? new Zu(t2) : new Ku[t2.type](t2);
          }, t.cross = function(t2, e3, r2) {
            var n2 = e3[0], i2 = e3[1], a2 = e3[2], s2 = r2[0], o2 = r2[1], l2 = r2[2];
            return t2[0] = i2 * l2 - a2 * o2, t2[1] = a2 * s2 - n2 * l2, t2[2] = n2 * o2 - i2 * s2, t2;
          }, t.dot = function(t2, e3) {
            return t2[0] * e3[0] + t2[1] * e3[1] + t2[2] * e3[2];
          }, t.dot$1 = function(t2, e3) {
            return t2[0] * e3[0] + t2[1] * e3[1] + t2[2] * e3[2] + t2[3] * e3[3];
          }, t.ease = i, t.emitValidationErrors = kn, t.enforceCacheSizeLimit = function(t2) {
            E(), B2 && B2.then((e3) => {
              e3.keys().then((r2) => {
                for (let n2 = 0; n2 < r2.length - t2; n2++)
                  e3.delete(r2[n2]);
              });
            });
          }, t.equals = function(t2, e3) {
            var r2 = t2[0], n2 = t2[1], i2 = t2[2], a2 = t2[3], s2 = t2[4], o2 = t2[5], l2 = t2[6], u2 = t2[7], c2 = t2[8], h2 = t2[9], p2 = t2[10], f2 = t2[11], d2 = t2[12], y3 = t2[13], m2 = t2[14], g2 = t2[15], x3 = e3[0], v2 = e3[1], b2 = e3[2], w2 = e3[3], _2 = e3[4], A2 = e3[5], k2 = e3[6], S2 = e3[7], I2 = e3[8], M2 = e3[9], z2 = e3[10], B3 = e3[11], C2 = e3[12], P2 = e3[13], V2 = e3[14], E2 = e3[15];
            return Math.abs(r2 - x3) <= hs * Math.max(1, Math.abs(r2), Math.abs(x3)) && Math.abs(n2 - v2) <= hs * Math.max(1, Math.abs(n2), Math.abs(v2)) && Math.abs(i2 - b2) <= hs * Math.max(1, Math.abs(i2), Math.abs(b2)) && Math.abs(a2 - w2) <= hs * Math.max(1, Math.abs(a2), Math.abs(w2)) && Math.abs(s2 - _2) <= hs * Math.max(1, Math.abs(s2), Math.abs(_2)) && Math.abs(o2 - A2) <= hs * Math.max(1, Math.abs(o2), Math.abs(A2)) && Math.abs(l2 - k2) <= hs * Math.max(1, Math.abs(l2), Math.abs(k2)) && Math.abs(u2 - S2) <= hs * Math.max(1, Math.abs(u2), Math.abs(S2)) && Math.abs(c2 - I2) <= hs * Math.max(1, Math.abs(c2), Math.abs(I2)) && Math.abs(h2 - M2) <= hs * Math.max(1, Math.abs(h2), Math.abs(M2)) && Math.abs(p2 - z2) <= hs * Math.max(1, Math.abs(p2), Math.abs(z2)) && Math.abs(f2 - B3) <= hs * Math.max(1, Math.abs(f2), Math.abs(B3)) && Math.abs(d2 - C2) <= hs * Math.max(1, Math.abs(d2), Math.abs(C2)) && Math.abs(y3 - P2) <= hs * Math.max(1, Math.abs(y3), Math.abs(P2)) && Math.abs(m2 - V2) <= hs * Math.max(1, Math.abs(m2), Math.abs(V2)) && Math.abs(g2 - E2) <= hs * Math.max(1, Math.abs(g2), Math.abs(E2));
          }, t.evaluateSizeForFeature = function(t2, { uSize: e3, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
            return "source" === t2.kind ? n2 / tu : "composite" === t2.kind ? Se(n2 / tu, i2 / tu, r2) : e3;
          }, t.evaluateSizeForZoom = function(t2, e3) {
            let r2 = 0, n2 = 0;
            if ("constant" === t2.kind)
              n2 = t2.layoutSize;
            else if ("source" !== t2.kind) {
              const { interpolationType: i2, minZoom: s2, maxZoom: o2 } = t2, l2 = i2 ? a(Ne.interpolationFactor(i2, e3, s2, o2), 0, 1) : 0;
              "camera" === t2.kind ? n2 = Se(t2.minSize, t2.maxSize, l2) : r2 = l2;
            }
            return { uSizeT: r2, uSize: n2 };
          }, t.evaluateVariableOffset = Au, t.evented = Xn, t.exported = k, t.exported$1 = T, t.extend = o, t.filterObject = h, t.fromRotation = function(t2, e3) {
            var r2 = Math.sin(e3), n2 = Math.cos(e3);
            return t2[0] = n2, t2[1] = r2, t2[2] = 0, t2[3] = -r2, t2[4] = n2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
          }, t.fromScaling = function(t2, e3) {
            return t2[0] = e3[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e3[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e3[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
          }, t.getAnchorAlignment = Yl, t.getAnchorJustification = ku, t.getArrayBuffer = K, t.getImage = H, t.getJSON = function(t2, e3) {
            return Z(o(t2, { type: "json" }), e3);
          }, t.getOverlapMode = qu, t.getRTLTextPluginStatus = Yn, t.getReferrer = j, t.getVideo = function(t2, e3) {
            const r2 = window.document.createElement("video");
            r2.muted = true, r2.onloadstart = function() {
              e3(null, r2);
            };
            for (let e4 = 0; e4 < t2.length; e4++) {
              const n2 = window.document.createElement("source");
              G(t2[e4]) || (r2.crossOrigin = "Anonymous"), n2.src = t2[e4], r2.appendChild(n2);
            }
            return { cancel: () => {
            } };
          }, t.identity = ds, t.invert = function(t2, e3) {
            var r2 = e3[0], n2 = e3[1], i2 = e3[2], a2 = e3[3], s2 = e3[4], o2 = e3[5], l2 = e3[6], u2 = e3[7], c2 = e3[8], h2 = e3[9], p2 = e3[10], f2 = e3[11], d2 = e3[12], y3 = e3[13], m2 = e3[14], g2 = e3[15], x3 = r2 * o2 - n2 * s2, v2 = r2 * l2 - i2 * s2, b2 = r2 * u2 - a2 * s2, w2 = n2 * l2 - i2 * o2, _2 = n2 * u2 - a2 * o2, A2 = i2 * u2 - a2 * l2, k2 = c2 * y3 - h2 * d2, S2 = c2 * m2 - p2 * d2, I2 = c2 * g2 - f2 * d2, M2 = h2 * m2 - p2 * y3, z2 = h2 * g2 - f2 * y3, B3 = p2 * g2 - f2 * m2, C2 = x3 * B3 - v2 * z2 + b2 * M2 + w2 * I2 - _2 * S2 + A2 * k2;
            return C2 ? (t2[0] = (o2 * B3 - l2 * z2 + u2 * M2) * (C2 = 1 / C2), t2[1] = (i2 * z2 - n2 * B3 - a2 * M2) * C2, t2[2] = (y3 * A2 - m2 * _2 + g2 * w2) * C2, t2[3] = (p2 * _2 - h2 * A2 - f2 * w2) * C2, t2[4] = (l2 * I2 - s2 * B3 - u2 * S2) * C2, t2[5] = (r2 * B3 - i2 * I2 + a2 * S2) * C2, t2[6] = (m2 * b2 - d2 * A2 - g2 * v2) * C2, t2[7] = (c2 * A2 - p2 * b2 + f2 * v2) * C2, t2[8] = (s2 * z2 - o2 * I2 + u2 * k2) * C2, t2[9] = (n2 * I2 - r2 * z2 - a2 * k2) * C2, t2[10] = (d2 * _2 - y3 * b2 + g2 * x3) * C2, t2[11] = (h2 * b2 - c2 * _2 - f2 * x3) * C2, t2[12] = (o2 * S2 - s2 * M2 - l2 * k2) * C2, t2[13] = (r2 * M2 - n2 * S2 + i2 * k2) * C2, t2[14] = (y3 * v2 - d2 * w2 - m2 * x3) * C2, t2[15] = (c2 * w2 - h2 * v2 + p2 * x3) * C2, t2) : null;
          }, t.isImageBitmap = A, t.isSafari = _, t.isWorker = g, t.keysDifference = function(t2, e3) {
            const r2 = [];
            for (const n2 in t2)
              n2 in e3 || r2.push(n2);
            return r2;
          }, t.lazyLoadRTLTextPlugin = function() {
            Wn.isLoading() || Wn.isLoaded() || "deferred" !== Yn() || Hn();
          }, t.makeRequest = Z, t.mapObject = c, t.mercatorXfromLng = Qu, t.mercatorYfromLat = tc, t.mercatorZfromAltitude = ec, t.mul = gs, t.mul$1 = function(t2, e3, r2) {
            return t2[0] = e3[0] * r2[0], t2[1] = e3[1] * r2[1], t2[2] = e3[2] * r2[2], t2[3] = e3[3] * r2[3], t2;
          }, t.multiply = ys, t.nextPowerOfTwo = function(t2) {
            return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
          }, t.normalize = function(t2, e3) {
            var r2 = e3[0], n2 = e3[1], i2 = e3[2], a2 = r2 * r2 + n2 * n2 + i2 * i2;
            return a2 > 0 && (a2 = 1 / Math.sqrt(a2)), t2[0] = e3[0] * a2, t2[1] = e3[1] * a2, t2[2] = e3[2] * a2, t2;
          }, t.number = Se, t.ortho = function(t2, e3, r2, n2, i2, a2, s2) {
            var o2 = 1 / (e3 - r2), l2 = 1 / (n2 - i2), u2 = 1 / (a2 - s2);
            return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (e3 + r2) * o2, t2[13] = (i2 + n2) * l2, t2[14] = (s2 + a2) * u2, t2[15] = 1, t2;
          }, t.parseCacheControl = x2, t.parseGlyphPbf = function(t2) {
            return new ul(t2).readFields(Vl, []);
          }, t.pbf = ul, t.performSymbolLayout = function(e3) {
            e3.bucket.createArrays(), e3.bucket.tilePixelRatio = qa / (512 * e3.bucket.overscaling), e3.bucket.compareText = {}, e3.bucket.iconsNeedLinear = false;
            const r2 = e3.bucket.layers[0].layout, n2 = e3.bucket.layers[0]._unevaluatedLayout._values, i2 = { layoutIconSize: n2["icon-size"].possiblyEvaluate(new Qn(e3.bucket.zoom + 1), e3.canonical), layoutTextSize: n2["text-size"].possiblyEvaluate(new Qn(e3.bucket.zoom + 1), e3.canonical), textMaxSize: n2["text-size"].possiblyEvaluate(new Qn(18)) };
            if ("composite" === e3.bucket.textSizeData.kind) {
              const { minZoom: t2, maxZoom: r3 } = e3.bucket.textSizeData;
              i2.compositeTextSizes = [n2["text-size"].possiblyEvaluate(new Qn(t2), e3.canonical), n2["text-size"].possiblyEvaluate(new Qn(r3), e3.canonical)];
            }
            if ("composite" === e3.bucket.iconSizeData.kind) {
              const { minZoom: t2, maxZoom: r3 } = e3.bucket.iconSizeData;
              i2.compositeIconSizes = [n2["icon-size"].possiblyEvaluate(new Qn(t2), e3.canonical), n2["icon-size"].possiblyEvaluate(new Qn(r3), e3.canonical)];
            }
            const a2 = r2.get("text-line-height") * ll, s2 = "viewport" !== r2.get("text-rotation-alignment") && "point" !== r2.get("symbol-placement"), o2 = r2.get("text-keep-upright"), l2 = r2.get("text-size");
            for (const n3 of e3.bucket.features) {
              const u2 = r2.get("text-font").evaluate(n3, {}, e3.canonical).join(","), c2 = l2.evaluate(n3, {}, e3.canonical), h2 = i2.layoutTextSize.evaluate(n3, {}, e3.canonical), p2 = i2.layoutIconSize.evaluate(n3, {}, e3.canonical), f2 = { horizontal: {}, vertical: void 0 }, y3 = n3.text;
              let m2, g2 = [0, 0];
              if (y3) {
                const i3 = y3.toString(), l3 = r2.get("text-letter-spacing").evaluate(n3, {}, e3.canonical) * ll, p3 = Fn(i3) ? l3 : 0, d2 = r2.get("text-anchor").evaluate(n3, {}, e3.canonical), m3 = r2.get("text-variable-anchor");
                if (!m3) {
                  const t2 = r2.get("text-radial-offset").evaluate(n3, {}, e3.canonical);
                  g2 = t2 ? Au(d2, [t2 * ll, _u]) : r2.get("text-offset").evaluate(n3, {}, e3.canonical).map((t3) => t3 * ll);
                }
                let x4 = s2 ? "center" : r2.get("text-justify").evaluate(n3, {}, e3.canonical);
                const v3 = r2.get("symbol-placement"), b2 = "point" === v3 ? r2.get("text-max-width").evaluate(n3, {}, e3.canonical) * ll : 0, w2 = () => {
                  e3.bucket.allowVerticalPlacement && En(i3) && (f2.vertical = Ul(y3, e3.glyphMap, e3.glyphPositions, e3.imagePositions, u2, b2, a2, d2, "left", p3, g2, t.WritingMode.vertical, true, v3, h2, c2));
                };
                if (!s2 && m3) {
                  const r3 = "auto" === x4 ? m3.map((t2) => ku(t2)) : [x4];
                  let n4 = false;
                  for (let i4 = 0; i4 < r3.length; i4++) {
                    const s3 = r3[i4];
                    if (!f2.horizontal[s3])
                      if (n4)
                        f2.horizontal[s3] = f2.horizontal[0];
                      else {
                        const r4 = Ul(y3, e3.glyphMap, e3.glyphPositions, e3.imagePositions, u2, b2, a2, "center", s3, p3, g2, t.WritingMode.horizontal, false, v3, h2, c2);
                        r4 && (f2.horizontal[s3] = r4, n4 = 1 === r4.positionedLines.length);
                      }
                  }
                  w2();
                } else {
                  "auto" === x4 && (x4 = ku(d2));
                  const r3 = Ul(y3, e3.glyphMap, e3.glyphPositions, e3.imagePositions, u2, b2, a2, d2, x4, p3, g2, t.WritingMode.horizontal, false, v3, h2, c2);
                  r3 && (f2.horizontal[x4] = r3), w2(), En(i3) && s2 && o2 && (f2.vertical = Ul(y3, e3.glyphMap, e3.glyphPositions, e3.imagePositions, u2, b2, a2, d2, x4, p3, g2, t.WritingMode.vertical, false, v3, h2, c2));
                }
              }
              let x3 = false;
              if (n3.icon && n3.icon.name) {
                const t2 = e3.imageMap[n3.icon.name];
                t2 && (m2 = Wl(e3.imagePositions[n3.icon.name], r2.get("icon-offset").evaluate(n3, {}, e3.canonical), r2.get("icon-anchor").evaluate(n3, {}, e3.canonical)), x3 = !!t2.sdf, void 0 === e3.bucket.sdfIcons ? e3.bucket.sdfIcons = x3 : e3.bucket.sdfIcons !== x3 && d("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t2.pixelRatio !== e3.bucket.pixelRatio || 0 !== r2.get("icon-rotate").constantOr(1)) && (e3.bucket.iconsNeedLinear = true));
              }
              const v2 = zu(f2.horizontal) || f2.vertical;
              e3.bucket.iconsInText = !!v2 && v2.iconsInText, (v2 || m2) && Su(e3.bucket, n3, f2, m2, e3.imageMap, i2, h2, p2, g2, x3, e3.canonical);
            }
            e3.showCollisionBoxes && e3.bucket.generateCollisionDebugBuffers();
          }, t.perspective = function(t2, e3, r2, n2, i2) {
            var a2, s2 = 1 / Math.tan(e3 / 2);
            return t2[0] = s2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = s2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != i2 && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (a2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * a2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
          }, t.pick = function(t2, e3) {
            const r2 = {};
            for (let n2 = 0; n2 < e3.length; n2++) {
              const i2 = e3[n2];
              i2 in t2 && (r2[i2] = t2[i2]);
            }
            return r2;
          }, t.plugin = Wn, t.pointGeometry = S, t.polygonIntersectsPolygon = Xa, t.potpack = Tl, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.register = Mn, t.registerForPluginStateChange = function(t2) {
            return t2({ pluginStatus: Zn, pluginURL: Kn }), Xn.on("pluginStateChange", t2), t2;
          }, t.renderColorRamp = Cs, t.rotateX = function(t2, e3, r2) {
            var n2 = Math.sin(r2), i2 = Math.cos(r2), a2 = e3[4], s2 = e3[5], o2 = e3[6], l2 = e3[7], u2 = e3[8], c2 = e3[9], h2 = e3[10], p2 = e3[11];
            return e3 !== t2 && (t2[0] = e3[0], t2[1] = e3[1], t2[2] = e3[2], t2[3] = e3[3], t2[12] = e3[12], t2[13] = e3[13], t2[14] = e3[14], t2[15] = e3[15]), t2[4] = a2 * i2 + u2 * n2, t2[5] = s2 * i2 + c2 * n2, t2[6] = o2 * i2 + h2 * n2, t2[7] = l2 * i2 + p2 * n2, t2[8] = u2 * i2 - a2 * n2, t2[9] = c2 * i2 - s2 * n2, t2[10] = h2 * i2 - o2 * n2, t2[11] = p2 * i2 - l2 * n2, t2;
          }, t.rotateZ = function(t2, e3, r2) {
            var n2 = Math.sin(r2), i2 = Math.cos(r2), a2 = e3[0], s2 = e3[1], o2 = e3[2], l2 = e3[3], u2 = e3[4], c2 = e3[5], h2 = e3[6], p2 = e3[7];
            return e3 !== t2 && (t2[8] = e3[8], t2[9] = e3[9], t2[10] = e3[10], t2[11] = e3[11], t2[12] = e3[12], t2[13] = e3[13], t2[14] = e3[14], t2[15] = e3[15]), t2[0] = a2 * i2 + u2 * n2, t2[1] = s2 * i2 + c2 * n2, t2[2] = o2 * i2 + h2 * n2, t2[3] = l2 * i2 + p2 * n2, t2[4] = u2 * i2 - a2 * n2, t2[5] = c2 * i2 - s2 * n2, t2[6] = h2 * i2 - o2 * n2, t2[7] = p2 * i2 - l2 * n2, t2;
          }, t.scale = function(t2, e3, r2) {
            var n2 = r2[0], i2 = r2[1], a2 = r2[2];
            return t2[0] = e3[0] * n2, t2[1] = e3[1] * n2, t2[2] = e3[2] * n2, t2[3] = e3[3] * n2, t2[4] = e3[4] * i2, t2[5] = e3[5] * i2, t2[6] = e3[6] * i2, t2[7] = e3[7] * i2, t2[8] = e3[8] * a2, t2[9] = e3[9] * a2, t2[10] = e3[10] * a2, t2[11] = e3[11] * a2, t2[12] = e3[12], t2[13] = e3[13], t2[14] = e3[14], t2[15] = e3[15], t2;
          }, t.scale$1 = function(t2, e3, r2) {
            return t2[0] = e3[0] * r2, t2[1] = e3[1] * r2, t2[2] = e3[2] * r2, t2;
          }, t.setCacheLimits = function(t2, e3) {
            P = t2, V = e3;
          }, t.setRTLTextPlugin = function(t2, e3, r2 = false) {
            if (Zn === Un || Zn === qn || Zn === jn)
              throw new Error("setRTLTextPlugin cannot be called multiple times.");
            Kn = k.resolveURL(t2), Zn = Un, Nn = e3, Jn(), r2 || Hn();
          }, t.spec = nt, t.sphericalToCartesian = function([t2, e3, r2]) {
            return e3 += 90, e3 *= Math.PI / 180, r2 *= Math.PI / 180, { x: t2 * Math.cos(e3) * Math.sin(r2), y: t2 * Math.sin(e3) * Math.sin(r2), z: t2 * Math.cos(r2) };
          }, t.sqrLen = function(t2) {
            var e3 = t2[0], r2 = t2[1];
            return e3 * e3 + r2 * r2;
          }, t.sub = function(t2, e3, r2) {
            return t2[0] = e3[0] - r2[0], t2[1] = e3[1] - r2[1], t2[2] = e3[2] - r2[2], t2;
          }, t.toEvaluationFeature = Ka, t.transformMat3 = function(t2, e3, r2) {
            var n2 = e3[0], i2 = e3[1], a2 = e3[2];
            return t2[0] = n2 * r2[0] + i2 * r2[3] + a2 * r2[6], t2[1] = n2 * r2[1] + i2 * r2[4] + a2 * r2[7], t2[2] = n2 * r2[2] + i2 * r2[5] + a2 * r2[8], t2;
          }, t.transformMat4 = bs, t.transformMat4$1 = function(t2, e3, r2) {
            var n2 = e3[0], i2 = e3[1];
            return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[12], t2[1] = r2[1] * n2 + r2[5] * i2 + r2[13], t2;
          }, t.translate = function(t2, e3, r2) {
            var n2, i2, a2, s2, o2, l2, u2, c2, h2, p2, f2, d2, y3 = r2[0], m2 = r2[1], g2 = r2[2];
            return e3 === t2 ? (t2[12] = e3[0] * y3 + e3[4] * m2 + e3[8] * g2 + e3[12], t2[13] = e3[1] * y3 + e3[5] * m2 + e3[9] * g2 + e3[13], t2[14] = e3[2] * y3 + e3[6] * m2 + e3[10] * g2 + e3[14], t2[15] = e3[3] * y3 + e3[7] * m2 + e3[11] * g2 + e3[15]) : (i2 = e3[1], a2 = e3[2], s2 = e3[3], o2 = e3[4], l2 = e3[5], u2 = e3[6], c2 = e3[7], h2 = e3[8], p2 = e3[9], f2 = e3[10], d2 = e3[11], t2[0] = n2 = e3[0], t2[1] = i2, t2[2] = a2, t2[3] = s2, t2[4] = o2, t2[5] = l2, t2[6] = u2, t2[7] = c2, t2[8] = h2, t2[9] = p2, t2[10] = f2, t2[11] = d2, t2[12] = n2 * y3 + o2 * m2 + h2 * g2 + e3[12], t2[13] = i2 * y3 + l2 * m2 + p2 * g2 + e3[13], t2[14] = a2 * y3 + u2 * m2 + f2 * g2 + e3[14], t2[15] = s2 * y3 + c2 * m2 + d2 * g2 + e3[15]), t2;
          }, t.triggerPluginCompletionEvent = Gn, t.unicodeBlockLookup = Vn, t.uniqueId = function() {
            return l++;
          }, t.validateCustomStyleLayer = function(t2) {
            const e3 = [], r2 = t2.id;
            return void 0 === r2 && e3.push({ message: `layers.${r2}: missing required property "id"` }), void 0 === t2.render && e3.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && "2d" !== t2.renderingMode && "3d" !== t2.renderingMode && e3.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e3;
          }, t.validateLight = wn, t.validateStyle = bn, t.vectorTile = _o, t.warnOnce = d, t.wrap = s;
        });
        define2(["./shared"], function(e) {
          "use strict";
          function t(e3) {
            const o2 = typeof e3;
            if ("number" === o2 || "boolean" === o2 || "string" === o2 || null == e3)
              return JSON.stringify(e3);
            if (Array.isArray(e3)) {
              let o3 = "[";
              for (const i3 of e3)
                o3 += `${t(i3)},`;
              return `${o3}]`;
            }
            const i2 = Object.keys(e3).sort();
            let r2 = "{";
            for (let o3 = 0; o3 < i2.length; o3++)
              r2 += `${JSON.stringify(i2[o3])}:${t(e3[i2[o3]])},`;
            return `${r2}}`;
          }
          function o(o2) {
            let i2 = "";
            for (const r2 of e.refProperties)
              i2 += `/${t(o2[r2])}`;
            return i2;
          }
          class i {
            constructor(e3) {
              this.keyCache = {}, e3 && this.replace(e3);
            }
            replace(e3) {
              this._layerConfigs = {}, this._layers = {}, this.update(e3, []);
            }
            update(t2, i2) {
              for (const o2 of t2) {
                this._layerConfigs[o2.id] = o2;
                const t3 = this._layers[o2.id] = e.createStyleLayer(o2);
                t3._featureFilter = e.createFilter(t3.filter), this.keyCache[o2.id] && delete this.keyCache[o2.id];
              }
              for (const e3 of i2)
                delete this.keyCache[e3], delete this._layerConfigs[e3], delete this._layers[e3];
              this.familiesBySource = {};
              const r2 = function(e3, t3) {
                const i3 = {};
                for (let r4 = 0; r4 < e3.length; r4++) {
                  const n2 = t3 && t3[e3[r4].id] || o(e3[r4]);
                  t3 && (t3[e3[r4].id] = n2);
                  let s2 = i3[n2];
                  s2 || (s2 = i3[n2] = []), s2.push(e3[r4]);
                }
                const r3 = [];
                for (const e4 in i3)
                  r3.push(i3[e4]);
                return r3;
              }(Object.values(this._layerConfigs), this.keyCache);
              for (const e3 of r2) {
                const t3 = e3.map((e4) => this._layers[e4.id]), o2 = t3[0];
                if ("none" === o2.visibility)
                  continue;
                const i3 = o2.source || "";
                let r3 = this.familiesBySource[i3];
                r3 || (r3 = this.familiesBySource[i3] = {});
                const n2 = o2.sourceLayer || "_geojsonTileLayer";
                let s2 = r3[n2];
                s2 || (s2 = r3[n2] = []), s2.push(t3);
              }
            }
          }
          class r {
            constructor(t2) {
              const o2 = {}, i2 = [];
              for (const e3 in t2) {
                const r3 = t2[e3], n3 = o2[e3] = {};
                for (const e4 in r3) {
                  const t3 = r3[+e4];
                  if (!t3 || 0 === t3.bitmap.width || 0 === t3.bitmap.height)
                    continue;
                  const o3 = { x: 0, y: 0, w: t3.bitmap.width + 2, h: t3.bitmap.height + 2 };
                  i2.push(o3), n3[e4] = { rect: o3, metrics: t3.metrics };
                }
              }
              const { w: r2, h: n2 } = e.potpack(i2), s2 = new e.AlphaImage({ width: r2 || 1, height: n2 || 1 });
              for (const i3 in t2) {
                const r3 = t2[i3];
                for (const t3 in r3) {
                  const n3 = r3[+t3];
                  if (!n3 || 0 === n3.bitmap.width || 0 === n3.bitmap.height)
                    continue;
                  const a2 = o2[i3][t3].rect;
                  e.AlphaImage.copy(n3.bitmap, s2, { x: 0, y: 0 }, { x: a2.x + 1, y: a2.y + 1 }, n3.bitmap);
                }
              }
              this.image = s2, this.positions = o2;
            }
          }
          e.register("GlyphAtlas", r);
          class n {
            constructor(t2) {
              this.tileID = new e.OverscaledTileID(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.uid = t2.uid, this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId;
            }
            parse(t2, o2, i2, n2, a2) {
              this.status = "parsing", this.data = t2, this.collisionBoxArray = new e.CollisionBoxArray();
              const l2 = new e.DictionaryCoder(Object.keys(t2.layers).sort()), c2 = new e.FeatureIndex(this.tileID, this.promoteId);
              c2.bucketLayerIDs = [];
              const u2 = {}, h2 = { featureIndex: c2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: i2 }, p2 = o2.familiesBySource[this.source];
              for (const o3 in p2) {
                const r2 = t2.layers[o3];
                if (!r2)
                  continue;
                1 === r2.version && e.warnOnce(`Vector tile source "${this.source}" layer "${o3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const n3 = l2.encode(o3), a3 = [];
                for (let e3 = 0; e3 < r2.length; e3++) {
                  const t3 = r2.feature(e3), i3 = c2.getId(t3, o3);
                  a3.push({ feature: t3, id: i3, index: e3, sourceLayerIndex: n3 });
                }
                for (const t3 of p2[o3]) {
                  const o4 = t3[0];
                  o4.source !== this.source && e.warnOnce(`layer.source = ${o4.source} does not equal this.source = ${this.source}`), o4.minzoom && this.zoom < Math.floor(o4.minzoom) || o4.maxzoom && this.zoom >= o4.maxzoom || "none" !== o4.visibility && (s(t3, this.zoom, i2), (u2[o4.id] = o4.createBucket({ index: c2.bucketLayerIDs.length, layers: t3, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n3, sourceID: this.source })).populate(a3, h2, this.tileID.canonical), c2.bucketLayerIDs.push(t3.map((e3) => e3.id)));
                }
              }
              let f2, d2, g2, m2;
              const y3 = e.mapObject(h2.glyphDependencies, (e3) => Object.keys(e3).map(Number));
              Object.keys(y3).length ? n2.send("getGlyphs", { uid: this.uid, stacks: y3 }, (e3, t3) => {
                f2 || (f2 = e3, d2 = t3, w2.call(this));
              }) : d2 = {};
              const v2 = Object.keys(h2.iconDependencies);
              v2.length ? n2.send("getImages", { icons: v2, source: this.source, tileID: this.tileID, type: "icons" }, (e3, t3) => {
                f2 || (f2 = e3, g2 = t3, w2.call(this));
              }) : g2 = {};
              const x3 = Object.keys(h2.patternDependencies);
              function w2() {
                if (f2)
                  return a2(f2);
                if (d2 && g2 && m2) {
                  const t3 = new r(d2), o3 = new e.ImageAtlas(g2, m2);
                  for (const r2 in u2) {
                    const n3 = u2[r2];
                    n3 instanceof e.SymbolBucket ? (s(n3.layers, this.zoom, i2), e.performSymbolLayout({ bucket: n3, glyphMap: d2, glyphPositions: t3.positions, imageMap: g2, imagePositions: o3.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : n3.hasPattern && (n3 instanceof e.LineBucket || n3 instanceof e.FillBucket || n3 instanceof e.FillExtrusionBucket) && (s(n3.layers, this.zoom, i2), n3.addFeatures(h2, this.tileID.canonical, o3.patternPositions));
                  }
                  this.status = "done", a2(null, { buckets: Object.values(u2).filter((e3) => !e3.isEmpty()), featureIndex: c2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t3.image, imageAtlas: o3, glyphMap: this.returnDependencies ? d2 : null, iconMap: this.returnDependencies ? g2 : null, glyphPositions: this.returnDependencies ? t3.positions : null });
                }
              }
              x3.length ? n2.send("getImages", { icons: x3, source: this.source, tileID: this.tileID, type: "patterns" }, (e3, t3) => {
                f2 || (f2 = e3, m2 = t3, w2.call(this));
              }) : m2 = {}, w2.call(this);
            }
          }
          function s(t2, o2, i2) {
            const r2 = new e.EvaluationParameters(o2);
            for (const e3 of t2)
              e3.recalculate(r2, i2);
          }
          function a(t2, o2) {
            const i2 = e.getArrayBuffer(t2.request, (t3, i3, r2, n2) => {
              t3 ? o2(t3) : i3 && o2(null, { vectorTile: new e.vectorTile.VectorTile(new e.pbf(i3)), rawData: i3, cacheControl: r2, expires: n2 });
            });
            return () => {
              i2.cancel(), o2();
            };
          }
          class l {
            constructor(e3, t2, o2, i2) {
              this.actor = e3, this.layerIndex = t2, this.availableImages = o2, this.loadVectorData = i2 || a, this.loading = {}, this.loaded = {};
            }
            loadTile(t2, o2) {
              const i2 = t2.uid;
              this.loading || (this.loading = {});
              const r2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.RequestPerformance(t2.request), s2 = this.loading[i2] = new n(t2);
              s2.abort = this.loadVectorData(t2, (t3, n2) => {
                if (delete this.loading[i2], t3 || !n2)
                  return s2.status = "done", this.loaded[i2] = s2, o2(t3);
                const a2 = n2.rawData, l2 = {};
                n2.expires && (l2.expires = n2.expires), n2.cacheControl && (l2.cacheControl = n2.cacheControl);
                const c2 = {};
                if (r2) {
                  const e3 = r2.finish();
                  e3 && (c2.resourceTiming = JSON.parse(JSON.stringify(e3)));
                }
                s2.vectorTile = n2.vectorTile, s2.parse(n2.vectorTile, this.layerIndex, this.availableImages, this.actor, (t4, i3) => {
                  if (t4 || !i3)
                    return o2(t4);
                  o2(null, e.extend({ rawTileData: a2.slice(0) }, i3, l2, c2));
                }), this.loaded = this.loaded || {}, this.loaded[i2] = s2;
              });
            }
            reloadTile(e3, t2) {
              const o2 = this.loaded, i2 = e3.uid, r2 = this;
              if (o2 && o2[i2]) {
                const n2 = o2[i2];
                n2.showCollisionBoxes = e3.showCollisionBoxes;
                const s2 = (e4, o3) => {
                  const i3 = n2.reloadCallback;
                  i3 && (delete n2.reloadCallback, n2.parse(n2.vectorTile, r2.layerIndex, this.availableImages, r2.actor, i3)), t2(e4, o3);
                };
                "parsing" === n2.status ? n2.reloadCallback = s2 : "done" === n2.status && (n2.vectorTile ? n2.parse(n2.vectorTile, this.layerIndex, this.availableImages, this.actor, s2) : s2());
              }
            }
            abortTile(e3, t2) {
              const o2 = this.loading, i2 = e3.uid;
              o2 && o2[i2] && o2[i2].abort && (o2[i2].abort(), delete o2[i2]), t2();
            }
            removeTile(e3, t2) {
              const o2 = this.loaded, i2 = e3.uid;
              o2 && o2[i2] && delete o2[i2], t2();
            }
          }
          class c {
            constructor() {
              this.loaded = {};
            }
            loadTile(t2, o2) {
              const { uid: i2, encoding: r2, rawImageData: n2 } = t2, s2 = e.isImageBitmap(n2) ? this.getImageData(n2) : n2, a2 = new e.DEMData(i2, s2, r2);
              this.loaded = this.loaded || {}, this.loaded[i2] = a2, o2(null, a2);
            }
            getImageData(t2) {
              this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t2.width, t2.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = t2.width, this.offscreenCanvas.height = t2.height, this.offscreenCanvasContext.drawImage(t2, 0, 0, t2.width, t2.height);
              const o2 = this.offscreenCanvasContext.getImageData(-1, -1, t2.width + 2, t2.height + 2);
              return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e.RGBAImage({ width: o2.width, height: o2.height }, o2.data);
            }
            removeTile(e3) {
              const t2 = this.loaded, o2 = e3.uid;
              t2 && t2[o2] && delete t2[o2];
            }
          }
          var u = function e3(t2, o2) {
            var i2, r2 = t2 && t2.type;
            if ("FeatureCollection" === r2)
              for (i2 = 0; i2 < t2.features.length; i2++)
                e3(t2.features[i2], o2);
            else if ("GeometryCollection" === r2)
              for (i2 = 0; i2 < t2.geometries.length; i2++)
                e3(t2.geometries[i2], o2);
            else if ("Feature" === r2)
              e3(t2.geometry, o2);
            else if ("Polygon" === r2)
              h(t2.coordinates, o2);
            else if ("MultiPolygon" === r2)
              for (i2 = 0; i2 < t2.coordinates.length; i2++)
                h(t2.coordinates[i2], o2);
            return t2;
          };
          function h(e3, t2) {
            if (0 !== e3.length) {
              p(e3[0], t2);
              for (var o2 = 1; o2 < e3.length; o2++)
                p(e3[o2], !t2);
            }
          }
          function p(e3, t2) {
            for (var o2 = 0, i2 = 0, r2 = 0, n2 = e3.length, s2 = n2 - 1; r2 < n2; s2 = r2++) {
              var a2 = (e3[r2][0] - e3[s2][0]) * (e3[s2][1] + e3[r2][1]), l2 = o2 + a2;
              i2 += Math.abs(o2) >= Math.abs(a2) ? o2 - l2 + a2 : a2 - l2 + o2, o2 = l2;
            }
            o2 + i2 >= 0 != !!t2 && e3.reverse();
          }
          const f = e.vectorTile.VectorTileFeature.prototype.toGeoJSON;
          class d {
            constructor(t2) {
              this._feature = t2, this.extent = e.EXTENT, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
            }
            loadGeometry() {
              if (1 === this._feature.type) {
                const t2 = [];
                for (const o2 of this._feature.geometry)
                  t2.push([new e.pointGeometry(o2[0], o2[1])]);
                return t2;
              }
              {
                const t2 = [];
                for (const o2 of this._feature.geometry) {
                  const i2 = [];
                  for (const t3 of o2)
                    i2.push(new e.pointGeometry(t3[0], t3[1]));
                  t2.push(i2);
                }
                return t2;
              }
            }
            toGeoJSON(e3, t2, o2) {
              return f.call(this, e3, t2, o2);
            }
          }
          class g {
            constructor(t2) {
              this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t2.length, this._features = t2;
            }
            feature(e3) {
              return new d(this._features[e3]);
            }
          }
          var m = { exports: {} }, y2 = e.pointGeometry, v = e.vectorTile.VectorTileFeature, x2 = w;
          function w(e3, t2) {
            this.options = t2 || {}, this.features = e3, this.length = e3.length;
          }
          function S(e3, t2) {
            this.id = "number" == typeof e3.id ? e3.id : void 0, this.type = e3.type, this.rawGeometry = 1 === e3.type ? [e3.geometry] : e3.geometry, this.properties = e3.tags, this.extent = t2 || 4096;
          }
          w.prototype.feature = function(e3) {
            return new S(this.features[e3], this.options.extent);
          }, S.prototype.loadGeometry = function() {
            var e3 = this.rawGeometry;
            this.geometry = [];
            for (var t2 = 0; t2 < e3.length; t2++) {
              for (var o2 = e3[t2], i2 = [], r2 = 0; r2 < o2.length; r2++)
                i2.push(new y2(o2[r2][0], o2[r2][1]));
              this.geometry.push(i2);
            }
            return this.geometry;
          }, S.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for (var e3 = this.geometry, t2 = 1 / 0, o2 = -1 / 0, i2 = 1 / 0, r2 = -1 / 0, n2 = 0; n2 < e3.length; n2++)
              for (var s2 = e3[n2], a2 = 0; a2 < s2.length; a2++) {
                var l2 = s2[a2];
                t2 = Math.min(t2, l2.x), o2 = Math.max(o2, l2.x), i2 = Math.min(i2, l2.y), r2 = Math.max(r2, l2.y);
              }
            return [t2, i2, o2, r2];
          }, S.prototype.toGeoJSON = v.prototype.toGeoJSON;
          var M = e.pbf, I = x2;
          function b(e3) {
            var t2 = new M();
            return function(e4, t3) {
              for (var o2 in e4.layers)
                t3.writeMessage(3, k, e4.layers[o2]);
            }(e3, t2), t2.finish();
          }
          function k(e3, t2) {
            var o2;
            t2.writeVarintField(15, e3.version || 1), t2.writeStringField(1, e3.name || ""), t2.writeVarintField(5, e3.extent || 4096);
            var i2 = { keys: [], values: [], keycache: {}, valuecache: {} };
            for (o2 = 0; o2 < e3.length; o2++)
              i2.feature = e3.feature(o2), t2.writeMessage(2, P, i2);
            var r2 = i2.keys;
            for (o2 = 0; o2 < r2.length; o2++)
              t2.writeStringField(3, r2[o2]);
            var n2 = i2.values;
            for (o2 = 0; o2 < n2.length; o2++)
              t2.writeMessage(4, L, n2[o2]);
          }
          function P(e3, t2) {
            var o2 = e3.feature;
            void 0 !== o2.id && t2.writeVarintField(1, o2.id), t2.writeMessage(2, T, e3), t2.writeVarintField(3, o2.type), t2.writeMessage(4, D, o2);
          }
          function T(e3, t2) {
            var o2 = e3.feature, i2 = e3.keys, r2 = e3.values, n2 = e3.keycache, s2 = e3.valuecache;
            for (var a2 in o2.properties) {
              var l2 = o2.properties[a2], c2 = n2[a2];
              if (null !== l2) {
                void 0 === c2 && (i2.push(a2), n2[a2] = c2 = i2.length - 1), t2.writeVarint(c2);
                var u2 = typeof l2;
                "string" !== u2 && "boolean" !== u2 && "number" !== u2 && (l2 = JSON.stringify(l2));
                var h2 = u2 + ":" + l2, p2 = s2[h2];
                void 0 === p2 && (r2.push(l2), s2[h2] = p2 = r2.length - 1), t2.writeVarint(p2);
              }
            }
          }
          function C(e3, t2) {
            return (t2 << 3) + (7 & e3);
          }
          function _(e3) {
            return e3 << 1 ^ e3 >> 31;
          }
          function D(e3, t2) {
            for (var o2 = e3.loadGeometry(), i2 = e3.type, r2 = 0, n2 = 0, s2 = o2.length, a2 = 0; a2 < s2; a2++) {
              var l2 = o2[a2], c2 = 1;
              1 === i2 && (c2 = l2.length), t2.writeVarint(C(1, c2));
              for (var u2 = 3 === i2 ? l2.length - 1 : l2.length, h2 = 0; h2 < u2; h2++) {
                1 === h2 && 1 !== i2 && t2.writeVarint(C(2, u2 - 1));
                var p2 = l2[h2].x - r2, f2 = l2[h2].y - n2;
                t2.writeVarint(_(p2)), t2.writeVarint(_(f2)), r2 += p2, n2 += f2;
              }
              3 === i2 && t2.writeVarint(C(7, 1));
            }
          }
          function L(e3, t2) {
            var o2 = typeof e3;
            "string" === o2 ? t2.writeStringField(1, e3) : "boolean" === o2 ? t2.writeBooleanField(7, e3) : "number" === o2 && (e3 % 1 != 0 ? t2.writeDoubleField(3, e3) : e3 < 0 ? t2.writeSVarintField(6, e3) : t2.writeVarintField(5, e3));
          }
          function z(e3, t2, o2, i2, r2, n2) {
            if (r2 - i2 <= o2)
              return;
            const s2 = i2 + r2 >> 1;
            O(e3, t2, s2, i2, r2, n2 % 2), z(e3, t2, o2, i2, s2 - 1, n2 + 1), z(e3, t2, o2, s2 + 1, r2, n2 + 1);
          }
          function O(e3, t2, o2, i2, r2, n2) {
            for (; r2 > i2; ) {
              if (r2 - i2 > 600) {
                const s3 = r2 - i2 + 1, a3 = o2 - i2 + 1, l3 = Math.log(s3), c2 = 0.5 * Math.exp(2 * l3 / 3), u2 = 0.5 * Math.sqrt(l3 * c2 * (s3 - c2) / s3) * (a3 - s3 / 2 < 0 ? -1 : 1);
                O(e3, t2, o2, Math.max(i2, Math.floor(o2 - a3 * c2 / s3 + u2)), Math.min(r2, Math.floor(o2 + (s3 - a3) * c2 / s3 + u2)), n2);
              }
              const s2 = t2[2 * o2 + n2];
              let a2 = i2, l2 = r2;
              for (E(e3, t2, i2, o2), t2[2 * r2 + n2] > s2 && E(e3, t2, i2, r2); a2 < l2; ) {
                for (E(e3, t2, a2, l2), a2++, l2--; t2[2 * a2 + n2] < s2; )
                  a2++;
                for (; t2[2 * l2 + n2] > s2; )
                  l2--;
              }
              t2[2 * i2 + n2] === s2 ? E(e3, t2, i2, l2) : (l2++, E(e3, t2, l2, r2)), l2 <= o2 && (i2 = l2 + 1), o2 <= l2 && (r2 = l2 - 1);
            }
          }
          function E(e3, t2, o2, i2) {
            F(e3, o2, i2), F(t2, 2 * o2, 2 * i2), F(t2, 2 * o2 + 1, 2 * i2 + 1);
          }
          function F(e3, t2, o2) {
            const i2 = e3[t2];
            e3[t2] = e3[o2], e3[o2] = i2;
          }
          function N(e3, t2, o2, i2) {
            const r2 = e3 - o2, n2 = t2 - i2;
            return r2 * r2 + n2 * n2;
          }
          m.exports = b, m.exports.fromVectorTileJs = b, m.exports.fromGeojsonVt = function(e3, t2) {
            t2 = t2 || {};
            var o2 = {};
            for (var i2 in e3)
              o2[i2] = new I(e3[i2].features, t2), o2[i2].name = i2, o2[i2].version = t2.version, o2[i2].extent = t2.extent;
            return b({ layers: o2 });
          }, m.exports.GeoJSONWrapper = I;
          const A = (e3) => e3[0], B2 = (e3) => e3[1];
          class J {
            constructor(e3, t2 = A, o2 = B2, i2 = 64, r2 = Float64Array) {
              this.nodeSize = i2, this.points = e3;
              const n2 = e3.length < 65536 ? Uint16Array : Uint32Array, s2 = this.ids = new n2(e3.length), a2 = this.coords = new r2(2 * e3.length);
              for (let i3 = 0; i3 < e3.length; i3++)
                s2[i3] = i3, a2[2 * i3] = t2(e3[i3]), a2[2 * i3 + 1] = o2(e3[i3]);
              z(s2, a2, i2, 0, s2.length - 1, 0);
            }
            range(e3, t2, o2, i2) {
              return function(e4, t3, o3, i3, r2, n2, s2) {
                const a2 = [0, e4.length - 1, 0], l2 = [];
                let c2, u2;
                for (; a2.length; ) {
                  const h2 = a2.pop(), p2 = a2.pop(), f2 = a2.pop();
                  if (p2 - f2 <= s2) {
                    for (let s3 = f2; s3 <= p2; s3++)
                      c2 = t3[2 * s3], u2 = t3[2 * s3 + 1], c2 >= o3 && c2 <= r2 && u2 >= i3 && u2 <= n2 && l2.push(e4[s3]);
                    continue;
                  }
                  const d2 = Math.floor((f2 + p2) / 2);
                  c2 = t3[2 * d2], u2 = t3[2 * d2 + 1], c2 >= o3 && c2 <= r2 && u2 >= i3 && u2 <= n2 && l2.push(e4[d2]);
                  const g2 = (h2 + 1) % 2;
                  (0 === h2 ? o3 <= c2 : i3 <= u2) && (a2.push(f2), a2.push(d2 - 1), a2.push(g2)), (0 === h2 ? r2 >= c2 : n2 >= u2) && (a2.push(d2 + 1), a2.push(p2), a2.push(g2));
                }
                return l2;
              }(this.ids, this.coords, e3, t2, o2, i2, this.nodeSize);
            }
            within(e3, t2, o2) {
              return function(e4, t3, o3, i2, r2, n2) {
                const s2 = [0, e4.length - 1, 0], a2 = [], l2 = r2 * r2;
                for (; s2.length; ) {
                  const c2 = s2.pop(), u2 = s2.pop(), h2 = s2.pop();
                  if (u2 - h2 <= n2) {
                    for (let r3 = h2; r3 <= u2; r3++)
                      N(t3[2 * r3], t3[2 * r3 + 1], o3, i2) <= l2 && a2.push(e4[r3]);
                    continue;
                  }
                  const p2 = Math.floor((h2 + u2) / 2), f2 = t3[2 * p2], d2 = t3[2 * p2 + 1];
                  N(f2, d2, o3, i2) <= l2 && a2.push(e4[p2]);
                  const g2 = (c2 + 1) % 2;
                  (0 === c2 ? o3 - r2 <= f2 : i2 - r2 <= d2) && (s2.push(h2), s2.push(p2 - 1), s2.push(g2)), (0 === c2 ? o3 + r2 >= f2 : i2 + r2 >= d2) && (s2.push(p2 + 1), s2.push(u2), s2.push(g2));
                }
                return a2;
              }(this.ids, this.coords, e3, t2, o2, this.nodeSize);
            }
          }
          const Z = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e3) => e3 }, G = Math.fround || (j = new Float32Array(1), (e3) => (j[0] = +e3, j[0]));
          var j;
          class Y {
            constructor(e3) {
              this.options = H(Object.create(Z), e3), this.trees = new Array(this.options.maxZoom + 1);
            }
            load(e3) {
              const { log: t2, minZoom: o2, maxZoom: i2, nodeSize: r2 } = this.options;
              t2 && console.time("total time");
              const n2 = `prepare ${e3.length} points`;
              t2 && console.time(n2), this.points = e3;
              let s2 = [];
              for (let t3 = 0; t3 < e3.length; t3++)
                e3[t3].geometry && s2.push(X(e3[t3], t3));
              this.trees[i2 + 1] = new J(s2, K, Q, r2, Float32Array), t2 && console.timeEnd(n2);
              for (let e4 = i2; e4 >= o2; e4--) {
                const o3 = +Date.now();
                s2 = this._cluster(s2, e4), this.trees[e4] = new J(s2, K, Q, r2, Float32Array), t2 && console.log("z%d: %d clusters in %dms", e4, s2.length, +Date.now() - o3);
              }
              return t2 && console.timeEnd("total time"), this;
            }
            getClusters(e3, t2) {
              let o2 = ((e3[0] + 180) % 360 + 360) % 360 - 180;
              const i2 = Math.max(-90, Math.min(90, e3[1]));
              let r2 = 180 === e3[2] ? 180 : ((e3[2] + 180) % 360 + 360) % 360 - 180;
              const n2 = Math.max(-90, Math.min(90, e3[3]));
              if (e3[2] - e3[0] >= 360)
                o2 = -180, r2 = 180;
              else if (o2 > r2) {
                const e4 = this.getClusters([o2, i2, 180, n2], t2), s3 = this.getClusters([-180, i2, r2, n2], t2);
                return e4.concat(s3);
              }
              const s2 = this.trees[this._limitZoom(t2)], a2 = s2.range($(o2), q(n2), $(r2), q(i2)), l2 = [];
              for (const e4 of a2) {
                const t3 = s2.points[e4];
                l2.push(t3.numPoints ? R(t3) : this.points[t3.index]);
              }
              return l2;
            }
            getChildren(e3) {
              const t2 = this._getOriginId(e3), o2 = this._getOriginZoom(e3), i2 = "No cluster with the specified id.", r2 = this.trees[o2];
              if (!r2)
                throw new Error(i2);
              const n2 = r2.points[t2];
              if (!n2)
                throw new Error(i2);
              const s2 = this.options.radius / (this.options.extent * Math.pow(2, o2 - 1)), a2 = r2.within(n2.x, n2.y, s2), l2 = [];
              for (const t3 of a2) {
                const o3 = r2.points[t3];
                o3.parentId === e3 && l2.push(o3.numPoints ? R(o3) : this.points[o3.index]);
              }
              if (0 === l2.length)
                throw new Error(i2);
              return l2;
            }
            getLeaves(e3, t2, o2) {
              const i2 = [];
              return this._appendLeaves(i2, e3, t2 = t2 || 10, o2 = o2 || 0, 0), i2;
            }
            getTile(e3, t2, o2) {
              const i2 = this.trees[this._limitZoom(e3)], r2 = Math.pow(2, e3), { extent: n2, radius: s2 } = this.options, a2 = s2 / n2, l2 = (o2 - a2) / r2, c2 = (o2 + 1 + a2) / r2, u2 = { features: [] };
              return this._addTileFeatures(i2.range((t2 - a2) / r2, l2, (t2 + 1 + a2) / r2, c2), i2.points, t2, o2, r2, u2), 0 === t2 && this._addTileFeatures(i2.range(1 - a2 / r2, l2, 1, c2), i2.points, r2, o2, r2, u2), t2 === r2 - 1 && this._addTileFeatures(i2.range(0, l2, a2 / r2, c2), i2.points, -1, o2, r2, u2), u2.features.length ? u2 : null;
            }
            getClusterExpansionZoom(e3) {
              let t2 = this._getOriginZoom(e3) - 1;
              for (; t2 <= this.options.maxZoom; ) {
                const o2 = this.getChildren(e3);
                if (t2++, 1 !== o2.length)
                  break;
                e3 = o2[0].properties.cluster_id;
              }
              return t2;
            }
            _appendLeaves(e3, t2, o2, i2, r2) {
              const n2 = this.getChildren(t2);
              for (const t3 of n2) {
                const n3 = t3.properties;
                if (n3 && n3.cluster ? r2 + n3.point_count <= i2 ? r2 += n3.point_count : r2 = this._appendLeaves(e3, n3.cluster_id, o2, i2, r2) : r2 < i2 ? r2++ : e3.push(t3), e3.length === o2)
                  break;
              }
              return r2;
            }
            _addTileFeatures(e3, t2, o2, i2, r2, n2) {
              for (const s2 of e3) {
                const e4 = t2[s2], a2 = e4.numPoints;
                let l2, c2, u2;
                if (a2)
                  l2 = W(e4), c2 = e4.x, u2 = e4.y;
                else {
                  const t3 = this.points[e4.index];
                  l2 = t3.properties, c2 = $(t3.geometry.coordinates[0]), u2 = q(t3.geometry.coordinates[1]);
                }
                const h2 = { type: 1, geometry: [[Math.round(this.options.extent * (c2 * r2 - o2)), Math.round(this.options.extent * (u2 * r2 - i2))]], tags: l2 };
                let p2;
                a2 ? p2 = e4.id : this.options.generateId ? p2 = e4.index : this.points[e4.index].id && (p2 = this.points[e4.index].id), void 0 !== p2 && (h2.id = p2), n2.features.push(h2);
              }
            }
            _limitZoom(e3) {
              return Math.max(this.options.minZoom, Math.min(Math.floor(+e3), this.options.maxZoom + 1));
            }
            _cluster(e3, t2) {
              const o2 = [], { radius: i2, extent: r2, reduce: n2, minPoints: s2 } = this.options, a2 = i2 / (r2 * Math.pow(2, t2));
              for (let i3 = 0; i3 < e3.length; i3++) {
                const r3 = e3[i3];
                if (r3.zoom <= t2)
                  continue;
                r3.zoom = t2;
                const l2 = this.trees[t2 + 1], c2 = l2.within(r3.x, r3.y, a2), u2 = r3.numPoints || 1;
                let h2 = u2;
                for (const e4 of c2) {
                  const o3 = l2.points[e4];
                  o3.zoom > t2 && (h2 += o3.numPoints || 1);
                }
                if (h2 > u2 && h2 >= s2) {
                  let e4 = r3.x * u2, s3 = r3.y * u2, a3 = n2 && u2 > 1 ? this._map(r3, true) : null;
                  const p2 = (i3 << 5) + (t2 + 1) + this.points.length;
                  for (const o3 of c2) {
                    const i4 = l2.points[o3];
                    if (i4.zoom <= t2)
                      continue;
                    i4.zoom = t2;
                    const c3 = i4.numPoints || 1;
                    e4 += i4.x * c3, s3 += i4.y * c3, i4.parentId = p2, n2 && (a3 || (a3 = this._map(r3, true)), n2(a3, this._map(i4)));
                  }
                  r3.parentId = p2, o2.push(V(e4 / h2, s3 / h2, p2, h2, a3));
                } else if (o2.push(r3), h2 > 1)
                  for (const e4 of c2) {
                    const i4 = l2.points[e4];
                    i4.zoom <= t2 || (i4.zoom = t2, o2.push(i4));
                  }
              }
              return o2;
            }
            _getOriginId(e3) {
              return e3 - this.points.length >> 5;
            }
            _getOriginZoom(e3) {
              return (e3 - this.points.length) % 32;
            }
            _map(e3, t2) {
              if (e3.numPoints)
                return t2 ? H({}, e3.properties) : e3.properties;
              const o2 = this.points[e3.index].properties, i2 = this.options.map(o2);
              return t2 && i2 === o2 ? H({}, i2) : i2;
            }
          }
          function V(e3, t2, o2, i2, r2) {
            return { x: G(e3), y: G(t2), zoom: 1 / 0, id: o2, parentId: -1, numPoints: i2, properties: r2 };
          }
          function X(e3, t2) {
            const [o2, i2] = e3.geometry.coordinates;
            return { x: G($(o2)), y: G(q(i2)), zoom: 1 / 0, index: t2, parentId: -1 };
          }
          function R(e3) {
            return { type: "Feature", id: e3.id, properties: W(e3), geometry: { type: "Point", coordinates: [(t2 = e3.x, 360 * (t2 - 0.5)), U(e3.y)] } };
            var t2;
          }
          function W(e3) {
            const t2 = e3.numPoints, o2 = t2 >= 1e4 ? `${Math.round(t2 / 1e3)}k` : t2 >= 1e3 ? Math.round(t2 / 100) / 10 + "k" : t2;
            return H(H({}, e3.properties), { cluster: true, cluster_id: e3.id, point_count: t2, point_count_abbreviated: o2 });
          }
          function $(e3) {
            return e3 / 360 + 0.5;
          }
          function q(e3) {
            const t2 = Math.sin(e3 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
            return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
          }
          function U(e3) {
            const t2 = (180 - 360 * e3) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
          }
          function H(e3, t2) {
            for (const o2 in t2)
              e3[o2] = t2[o2];
            return e3;
          }
          function K(e3) {
            return e3.x;
          }
          function Q(e3) {
            return e3.y;
          }
          function ee(e3, t2, o2, i2) {
            for (var r2, n2 = i2, s2 = o2 - t2 >> 1, a2 = o2 - t2, l2 = e3[t2], c2 = e3[t2 + 1], u2 = e3[o2], h2 = e3[o2 + 1], p2 = t2 + 3; p2 < o2; p2 += 3) {
              var f2 = te(e3[p2], e3[p2 + 1], l2, c2, u2, h2);
              if (f2 > n2)
                r2 = p2, n2 = f2;
              else if (f2 === n2) {
                var d2 = Math.abs(p2 - s2);
                d2 < a2 && (r2 = p2, a2 = d2);
              }
            }
            n2 > i2 && (r2 - t2 > 3 && ee(e3, t2, r2, i2), e3[r2 + 2] = n2, o2 - r2 > 3 && ee(e3, r2, o2, i2));
          }
          function te(e3, t2, o2, i2, r2, n2) {
            var s2 = r2 - o2, a2 = n2 - i2;
            if (0 !== s2 || 0 !== a2) {
              var l2 = ((e3 - o2) * s2 + (t2 - i2) * a2) / (s2 * s2 + a2 * a2);
              l2 > 1 ? (o2 = r2, i2 = n2) : l2 > 0 && (o2 += s2 * l2, i2 += a2 * l2);
            }
            return (s2 = e3 - o2) * s2 + (a2 = t2 - i2) * a2;
          }
          function oe(e3, t2, o2, i2) {
            var r2 = { id: void 0 === e3 ? null : e3, type: t2, geometry: o2, tags: i2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
            return function(e4) {
              var t3 = e4.geometry, o3 = e4.type;
              if ("Point" === o3 || "MultiPoint" === o3 || "LineString" === o3)
                ie(e4, t3);
              else if ("Polygon" === o3 || "MultiLineString" === o3)
                for (var i3 = 0; i3 < t3.length; i3++)
                  ie(e4, t3[i3]);
              else if ("MultiPolygon" === o3)
                for (i3 = 0; i3 < t3.length; i3++)
                  for (var r3 = 0; r3 < t3[i3].length; r3++)
                    ie(e4, t3[i3][r3]);
            }(r2), r2;
          }
          function ie(e3, t2) {
            for (var o2 = 0; o2 < t2.length; o2 += 3)
              e3.minX = Math.min(e3.minX, t2[o2]), e3.minY = Math.min(e3.minY, t2[o2 + 1]), e3.maxX = Math.max(e3.maxX, t2[o2]), e3.maxY = Math.max(e3.maxY, t2[o2 + 1]);
          }
          function re(e3, t2, o2, i2) {
            if (t2.geometry) {
              var r2 = t2.geometry.coordinates, n2 = t2.geometry.type, s2 = Math.pow(o2.tolerance / ((1 << o2.maxZoom) * o2.extent), 2), a2 = [], l2 = t2.id;
              if (o2.promoteId ? l2 = t2.properties[o2.promoteId] : o2.generateId && (l2 = i2 || 0), "Point" === n2)
                ne(r2, a2);
              else if ("MultiPoint" === n2)
                for (var c2 = 0; c2 < r2.length; c2++)
                  ne(r2[c2], a2);
              else if ("LineString" === n2)
                se(r2, a2, s2, false);
              else if ("MultiLineString" === n2) {
                if (o2.lineMetrics) {
                  for (c2 = 0; c2 < r2.length; c2++)
                    se(r2[c2], a2 = [], s2, false), e3.push(oe(l2, "LineString", a2, t2.properties));
                  return;
                }
                ae(r2, a2, s2, false);
              } else if ("Polygon" === n2)
                ae(r2, a2, s2, true);
              else {
                if ("MultiPolygon" !== n2) {
                  if ("GeometryCollection" === n2) {
                    for (c2 = 0; c2 < t2.geometry.geometries.length; c2++)
                      re(e3, { id: l2, geometry: t2.geometry.geometries[c2], properties: t2.properties }, o2, i2);
                    return;
                  }
                  throw new Error("Input data is not a valid GeoJSON object.");
                }
                for (c2 = 0; c2 < r2.length; c2++) {
                  var u2 = [];
                  ae(r2[c2], u2, s2, true), a2.push(u2);
                }
              }
              e3.push(oe(l2, n2, a2, t2.properties));
            }
          }
          function ne(e3, t2) {
            t2.push(le(e3[0])), t2.push(ce(e3[1])), t2.push(0);
          }
          function se(e3, t2, o2, i2) {
            for (var r2, n2, s2 = 0, a2 = 0; a2 < e3.length; a2++) {
              var l2 = le(e3[a2][0]), c2 = ce(e3[a2][1]);
              t2.push(l2), t2.push(c2), t2.push(0), a2 > 0 && (s2 += i2 ? (r2 * c2 - l2 * n2) / 2 : Math.sqrt(Math.pow(l2 - r2, 2) + Math.pow(c2 - n2, 2))), r2 = l2, n2 = c2;
            }
            var u2 = t2.length - 3;
            t2[2] = 1, ee(t2, 0, u2, o2), t2[u2 + 2] = 1, t2.size = Math.abs(s2), t2.start = 0, t2.end = t2.size;
          }
          function ae(e3, t2, o2, i2) {
            for (var r2 = 0; r2 < e3.length; r2++) {
              var n2 = [];
              se(e3[r2], n2, o2, i2), t2.push(n2);
            }
          }
          function le(e3) {
            return e3 / 360 + 0.5;
          }
          function ce(e3) {
            var t2 = Math.sin(e3 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
            return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
          }
          function ue(e3, t2, o2, i2, r2, n2, s2, a2) {
            if (i2 /= t2, n2 >= (o2 /= t2) && s2 < i2)
              return e3;
            if (s2 < o2 || n2 >= i2)
              return null;
            for (var l2 = [], c2 = 0; c2 < e3.length; c2++) {
              var u2 = e3[c2], h2 = u2.geometry, p2 = u2.type, f2 = 0 === r2 ? u2.minX : u2.minY, d2 = 0 === r2 ? u2.maxX : u2.maxY;
              if (f2 >= o2 && d2 < i2)
                l2.push(u2);
              else if (!(d2 < o2 || f2 >= i2)) {
                var g2 = [];
                if ("Point" === p2 || "MultiPoint" === p2)
                  he(h2, g2, o2, i2, r2);
                else if ("LineString" === p2)
                  pe(h2, g2, o2, i2, r2, false, a2.lineMetrics);
                else if ("MultiLineString" === p2)
                  de(h2, g2, o2, i2, r2, false);
                else if ("Polygon" === p2)
                  de(h2, g2, o2, i2, r2, true);
                else if ("MultiPolygon" === p2)
                  for (var m2 = 0; m2 < h2.length; m2++) {
                    var y3 = [];
                    de(h2[m2], y3, o2, i2, r2, true), y3.length && g2.push(y3);
                  }
                if (g2.length) {
                  if (a2.lineMetrics && "LineString" === p2) {
                    for (m2 = 0; m2 < g2.length; m2++)
                      l2.push(oe(u2.id, p2, g2[m2], u2.tags));
                    continue;
                  }
                  "LineString" !== p2 && "MultiLineString" !== p2 || (1 === g2.length ? (p2 = "LineString", g2 = g2[0]) : p2 = "MultiLineString"), "Point" !== p2 && "MultiPoint" !== p2 || (p2 = 3 === g2.length ? "Point" : "MultiPoint"), l2.push(oe(u2.id, p2, g2, u2.tags));
                }
              }
            }
            return l2.length ? l2 : null;
          }
          function he(e3, t2, o2, i2, r2) {
            for (var n2 = 0; n2 < e3.length; n2 += 3) {
              var s2 = e3[n2 + r2];
              s2 >= o2 && s2 <= i2 && (t2.push(e3[n2]), t2.push(e3[n2 + 1]), t2.push(e3[n2 + 2]));
            }
          }
          function pe(e3, t2, o2, i2, r2, n2, s2) {
            for (var a2, l2, c2 = fe(e3), u2 = 0 === r2 ? me : ye, h2 = e3.start, p2 = 0; p2 < e3.length - 3; p2 += 3) {
              var f2 = e3[p2], d2 = e3[p2 + 1], g2 = e3[p2 + 2], m2 = e3[p2 + 3], y3 = e3[p2 + 4], v2 = 0 === r2 ? f2 : d2, x3 = 0 === r2 ? m2 : y3, w2 = false;
              s2 && (a2 = Math.sqrt(Math.pow(f2 - m2, 2) + Math.pow(d2 - y3, 2))), v2 < o2 ? x3 > o2 && (l2 = u2(c2, f2, d2, m2, y3, o2), s2 && (c2.start = h2 + a2 * l2)) : v2 > i2 ? x3 < i2 && (l2 = u2(c2, f2, d2, m2, y3, i2), s2 && (c2.start = h2 + a2 * l2)) : ge(c2, f2, d2, g2), x3 < o2 && v2 >= o2 && (l2 = u2(c2, f2, d2, m2, y3, o2), w2 = true), x3 > i2 && v2 <= i2 && (l2 = u2(c2, f2, d2, m2, y3, i2), w2 = true), !n2 && w2 && (s2 && (c2.end = h2 + a2 * l2), t2.push(c2), c2 = fe(e3)), s2 && (h2 += a2);
            }
            var S2 = e3.length - 3;
            f2 = e3[S2], d2 = e3[S2 + 1], g2 = e3[S2 + 2], (v2 = 0 === r2 ? f2 : d2) >= o2 && v2 <= i2 && ge(c2, f2, d2, g2), S2 = c2.length - 3, n2 && S2 >= 3 && (c2[S2] !== c2[0] || c2[S2 + 1] !== c2[1]) && ge(c2, c2[0], c2[1], c2[2]), c2.length && t2.push(c2);
          }
          function fe(e3) {
            var t2 = [];
            return t2.size = e3.size, t2.start = e3.start, t2.end = e3.end, t2;
          }
          function de(e3, t2, o2, i2, r2, n2) {
            for (var s2 = 0; s2 < e3.length; s2++)
              pe(e3[s2], t2, o2, i2, r2, n2, false);
          }
          function ge(e3, t2, o2, i2) {
            e3.push(t2), e3.push(o2), e3.push(i2);
          }
          function me(e3, t2, o2, i2, r2, n2) {
            var s2 = (n2 - t2) / (i2 - t2);
            return e3.push(n2), e3.push(o2 + (r2 - o2) * s2), e3.push(1), s2;
          }
          function ye(e3, t2, o2, i2, r2, n2) {
            var s2 = (n2 - o2) / (r2 - o2);
            return e3.push(t2 + (i2 - t2) * s2), e3.push(n2), e3.push(1), s2;
          }
          function ve(e3, t2) {
            for (var o2 = [], i2 = 0; i2 < e3.length; i2++) {
              var r2, n2 = e3[i2], s2 = n2.type;
              if ("Point" === s2 || "MultiPoint" === s2 || "LineString" === s2)
                r2 = xe(n2.geometry, t2);
              else if ("MultiLineString" === s2 || "Polygon" === s2) {
                r2 = [];
                for (var a2 = 0; a2 < n2.geometry.length; a2++)
                  r2.push(xe(n2.geometry[a2], t2));
              } else if ("MultiPolygon" === s2)
                for (r2 = [], a2 = 0; a2 < n2.geometry.length; a2++) {
                  for (var l2 = [], c2 = 0; c2 < n2.geometry[a2].length; c2++)
                    l2.push(xe(n2.geometry[a2][c2], t2));
                  r2.push(l2);
                }
              o2.push(oe(n2.id, s2, r2, n2.tags));
            }
            return o2;
          }
          function xe(e3, t2) {
            var o2 = [];
            o2.size = e3.size, void 0 !== e3.start && (o2.start = e3.start, o2.end = e3.end);
            for (var i2 = 0; i2 < e3.length; i2 += 3)
              o2.push(e3[i2] + t2, e3[i2 + 1], e3[i2 + 2]);
            return o2;
          }
          function we(e3, t2) {
            if (e3.transformed)
              return e3;
            var o2, i2, r2, n2 = 1 << e3.z, s2 = e3.x, a2 = e3.y;
            for (o2 = 0; o2 < e3.features.length; o2++) {
              var l2 = e3.features[o2], c2 = l2.geometry, u2 = l2.type;
              if (l2.geometry = [], 1 === u2)
                for (i2 = 0; i2 < c2.length; i2 += 2)
                  l2.geometry.push(Se(c2[i2], c2[i2 + 1], t2, n2, s2, a2));
              else
                for (i2 = 0; i2 < c2.length; i2++) {
                  var h2 = [];
                  for (r2 = 0; r2 < c2[i2].length; r2 += 2)
                    h2.push(Se(c2[i2][r2], c2[i2][r2 + 1], t2, n2, s2, a2));
                  l2.geometry.push(h2);
                }
            }
            return e3.transformed = true, e3;
          }
          function Se(e3, t2, o2, i2, r2, n2) {
            return [Math.round(o2 * (e3 * i2 - r2)), Math.round(o2 * (t2 * i2 - n2))];
          }
          function Me(e3, t2, o2, i2, r2) {
            for (var n2 = t2 === r2.maxZoom ? 0 : r2.tolerance / ((1 << t2) * r2.extent), s2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: o2, y: i2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a2 = 0; a2 < e3.length; a2++) {
              s2.numFeatures++, Ie(s2, e3[a2], n2, r2);
              var l2 = e3[a2].minX, c2 = e3[a2].minY, u2 = e3[a2].maxX, h2 = e3[a2].maxY;
              l2 < s2.minX && (s2.minX = l2), c2 < s2.minY && (s2.minY = c2), u2 > s2.maxX && (s2.maxX = u2), h2 > s2.maxY && (s2.maxY = h2);
            }
            return s2;
          }
          function Ie(e3, t2, o2, i2) {
            var r2 = t2.geometry, n2 = t2.type, s2 = [];
            if ("Point" === n2 || "MultiPoint" === n2)
              for (var a2 = 0; a2 < r2.length; a2 += 3)
                s2.push(r2[a2]), s2.push(r2[a2 + 1]), e3.numPoints++, e3.numSimplified++;
            else if ("LineString" === n2)
              be(s2, r2, e3, o2, false, false);
            else if ("MultiLineString" === n2 || "Polygon" === n2)
              for (a2 = 0; a2 < r2.length; a2++)
                be(s2, r2[a2], e3, o2, "Polygon" === n2, 0 === a2);
            else if ("MultiPolygon" === n2)
              for (var l2 = 0; l2 < r2.length; l2++) {
                var c2 = r2[l2];
                for (a2 = 0; a2 < c2.length; a2++)
                  be(s2, c2[a2], e3, o2, true, 0 === a2);
              }
            if (s2.length) {
              var u2 = t2.tags || null;
              if ("LineString" === n2 && i2.lineMetrics) {
                for (var h2 in u2 = {}, t2.tags)
                  u2[h2] = t2.tags[h2];
                u2.mapbox_clip_start = r2.start / r2.size, u2.mapbox_clip_end = r2.end / r2.size;
              }
              var p2 = { geometry: s2, type: "Polygon" === n2 || "MultiPolygon" === n2 ? 3 : "LineString" === n2 || "MultiLineString" === n2 ? 2 : 1, tags: u2 };
              null !== t2.id && (p2.id = t2.id), e3.features.push(p2);
            }
          }
          function be(e3, t2, o2, i2, r2, n2) {
            var s2 = i2 * i2;
            if (i2 > 0 && t2.size < (r2 ? s2 : i2))
              o2.numPoints += t2.length / 3;
            else {
              for (var a2 = [], l2 = 0; l2 < t2.length; l2 += 3)
                (0 === i2 || t2[l2 + 2] > s2) && (o2.numSimplified++, a2.push(t2[l2]), a2.push(t2[l2 + 1])), o2.numPoints++;
              r2 && function(e4, t3) {
                for (var o3 = 0, i3 = 0, r3 = e4.length, n3 = r3 - 2; i3 < r3; n3 = i3, i3 += 2)
                  o3 += (e4[i3] - e4[n3]) * (e4[i3 + 1] + e4[n3 + 1]);
                if (o3 > 0 === t3)
                  for (i3 = 0, r3 = e4.length; i3 < r3 / 2; i3 += 2) {
                    var s3 = e4[i3], a3 = e4[i3 + 1];
                    e4[i3] = e4[r3 - 2 - i3], e4[i3 + 1] = e4[r3 - 1 - i3], e4[r3 - 2 - i3] = s3, e4[r3 - 1 - i3] = a3;
                  }
              }(a2, n2), e3.push(a2);
            }
          }
          function ke(e3, t2) {
            var o2 = (t2 = this.options = function(e4, t3) {
              for (var o3 in t3)
                e4[o3] = t3[o3];
              return e4;
            }(Object.create(this.options), t2)).debug;
            if (o2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24)
              throw new Error("maxZoom should be in the 0-24 range");
            if (t2.promoteId && t2.generateId)
              throw new Error("promoteId and generateId cannot be used together.");
            var i2 = function(e4, t3) {
              var o3 = [];
              if ("FeatureCollection" === e4.type)
                for (var i3 = 0; i3 < e4.features.length; i3++)
                  re(o3, e4.features[i3], t3, i3);
              else
                re(o3, "Feature" === e4.type ? e4 : { geometry: e4 }, t3);
              return o3;
            }(e3, t2);
            this.tiles = {}, this.tileCoords = [], o2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i2 = function(e4, t3) {
              var o3 = t3.buffer / t3.extent, i3 = e4, r2 = ue(e4, 1, -1 - o3, o3, 0, -1, 2, t3), n2 = ue(e4, 1, 1 - o3, 2 + o3, 0, -1, 2, t3);
              return (r2 || n2) && (i3 = ue(e4, 1, -o3, 1 + o3, 0, -1, 2, t3) || [], r2 && (i3 = ve(r2, 1).concat(i3)), n2 && (i3 = i3.concat(ve(n2, -1)))), i3;
            }(i2, t2), i2.length && this.splitTile(i2, 0, 0, 0), o2 && (i2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          function Pe(e3, t2, o2) {
            return 32 * ((1 << e3) * o2 + t2) + e3;
          }
          function Te(e3, t2) {
            const o2 = e3.tileID.canonical;
            if (!this._geoJSONIndex)
              return t2(null, null);
            const i2 = this._geoJSONIndex.getTile(o2.z, o2.x, o2.y);
            if (!i2)
              return t2(null, null);
            const r2 = new g(i2.features);
            let n2 = m.exports(r2);
            0 === n2.byteOffset && n2.byteLength === n2.buffer.byteLength || (n2 = new Uint8Array(n2)), t2(null, { vectorTile: r2, rawData: n2.buffer });
          }
          ke.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, ke.prototype.splitTile = function(e3, t2, o2, i2, r2, n2, s2) {
            for (var a2 = [e3, t2, o2, i2], l2 = this.options, c2 = l2.debug; a2.length; ) {
              i2 = a2.pop(), o2 = a2.pop(), t2 = a2.pop(), e3 = a2.pop();
              var u2 = 1 << t2, h2 = Pe(t2, o2, i2), p2 = this.tiles[h2];
              if (!p2 && (c2 > 1 && console.time("creation"), p2 = this.tiles[h2] = Me(e3, t2, o2, i2, l2), this.tileCoords.push({ z: t2, x: o2, y: i2 }), c2)) {
                c2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, o2, i2, p2.numFeatures, p2.numPoints, p2.numSimplified), console.timeEnd("creation"));
                var f2 = "z" + t2;
                this.stats[f2] = (this.stats[f2] || 0) + 1, this.total++;
              }
              if (p2.source = e3, r2) {
                if (t2 === l2.maxZoom || t2 === r2)
                  continue;
                var d2 = 1 << r2 - t2;
                if (o2 !== Math.floor(n2 / d2) || i2 !== Math.floor(s2 / d2))
                  continue;
              } else if (t2 === l2.indexMaxZoom || p2.numPoints <= l2.indexMaxPoints)
                continue;
              if (p2.source = null, 0 !== e3.length) {
                c2 > 1 && console.time("clipping");
                var g2, m2, y3, v2, x3, w2, S2 = 0.5 * l2.buffer / l2.extent, M2 = 0.5 - S2, I2 = 0.5 + S2, b2 = 1 + S2;
                g2 = m2 = y3 = v2 = null, x3 = ue(e3, u2, o2 - S2, o2 + I2, 0, p2.minX, p2.maxX, l2), w2 = ue(e3, u2, o2 + M2, o2 + b2, 0, p2.minX, p2.maxX, l2), e3 = null, x3 && (g2 = ue(x3, u2, i2 - S2, i2 + I2, 1, p2.minY, p2.maxY, l2), m2 = ue(x3, u2, i2 + M2, i2 + b2, 1, p2.minY, p2.maxY, l2), x3 = null), w2 && (y3 = ue(w2, u2, i2 - S2, i2 + I2, 1, p2.minY, p2.maxY, l2), v2 = ue(w2, u2, i2 + M2, i2 + b2, 1, p2.minY, p2.maxY, l2), w2 = null), c2 > 1 && console.timeEnd("clipping"), a2.push(g2 || [], t2 + 1, 2 * o2, 2 * i2), a2.push(m2 || [], t2 + 1, 2 * o2, 2 * i2 + 1), a2.push(y3 || [], t2 + 1, 2 * o2 + 1, 2 * i2), a2.push(v2 || [], t2 + 1, 2 * o2 + 1, 2 * i2 + 1);
              }
            }
          }, ke.prototype.getTile = function(e3, t2, o2) {
            var i2 = this.options, r2 = i2.extent, n2 = i2.debug;
            if (e3 < 0 || e3 > 24)
              return null;
            var s2 = 1 << e3, a2 = Pe(e3, t2 = (t2 % s2 + s2) % s2, o2);
            if (this.tiles[a2])
              return we(this.tiles[a2], r2);
            n2 > 1 && console.log("drilling down to z%d-%d-%d", e3, t2, o2);
            for (var l2, c2 = e3, u2 = t2, h2 = o2; !l2 && c2 > 0; )
              c2--, u2 = Math.floor(u2 / 2), h2 = Math.floor(h2 / 2), l2 = this.tiles[Pe(c2, u2, h2)];
            return l2 && l2.source ? (n2 > 1 && console.log("found parent tile z%d-%d-%d", c2, u2, h2), n2 > 1 && console.time("drilling down"), this.splitTile(l2.source, c2, u2, h2, e3, t2, o2), n2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? we(this.tiles[a2], r2) : null) : null;
          };
          class Ce extends l {
            constructor(e3, t2, o2, i2) {
              super(e3, t2, o2, Te), i2 && (this.loadGeoJSON = i2);
            }
            loadData(t2, o2) {
              var i2;
              null === (i2 = this._pendingRequest) || void 0 === i2 || i2.cancel(), this._pendingCallback && this._pendingCallback(null, { abandoned: true });
              const r2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.RequestPerformance(t2.request);
              this._pendingCallback = o2, this._pendingRequest = this.loadGeoJSON(t2, (i3, n2) => {
                if (delete this._pendingCallback, delete this._pendingRequest, i3 || !n2)
                  return o2(i3);
                if ("object" != typeof n2)
                  return o2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
                {
                  u(n2, true);
                  try {
                    if (t2.filter) {
                      const o3 = e.createExpression(t2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                      if ("error" === o3.result)
                        throw new Error(o3.value.map((e3) => `${e3.key}: ${e3.message}`).join(", "));
                      const i4 = n2.features.filter((e3) => o3.value.evaluate({ zoom: 0 }, e3));
                      n2 = { type: "FeatureCollection", features: i4 };
                    }
                    this._geoJSONIndex = t2.cluster ? new Y(function({ superclusterOptions: t3, clusterProperties: o3 }) {
                      if (!o3 || !t3)
                        return t3;
                      const i4 = {}, r3 = {}, n3 = { accumulated: null, zoom: 0 }, s3 = { properties: null }, a2 = Object.keys(o3);
                      for (const t4 of a2) {
                        const [n4, s4] = o3[t4], a3 = e.createExpression(s4), l2 = e.createExpression("string" == typeof n4 ? [n4, ["accumulated"], ["get", t4]] : n4);
                        i4[t4] = a3.value, r3[t4] = l2.value;
                      }
                      return t3.map = (e3) => {
                        s3.properties = e3;
                        const t4 = {};
                        for (const e4 of a2)
                          t4[e4] = i4[e4].evaluate(n3, s3);
                        return t4;
                      }, t3.reduce = (e3, t4) => {
                        s3.properties = t4;
                        for (const t5 of a2)
                          n3.accumulated = e3[t5], e3[t5] = r3[t5].evaluate(n3, s3);
                      }, t3;
                    }(t2)).load(n2.features) : function(e3, t3) {
                      return new ke(e3, t3);
                    }(n2, t2.geojsonVtOptions);
                  } catch (i4) {
                    return o2(i4);
                  }
                  this.loaded = {};
                  const s2 = {};
                  if (r2) {
                    const e3 = r2.finish();
                    e3 && (s2.resourceTiming = {}, s2.resourceTiming[t2.source] = JSON.parse(JSON.stringify(e3)));
                  }
                  o2(null, s2);
                }
              });
            }
            reloadTile(e3, t2) {
              const o2 = this.loaded;
              return o2 && o2[e3.uid] ? super.reloadTile(e3, t2) : this.loadTile(e3, t2);
            }
            loadGeoJSON(t2, o2) {
              if (t2.request)
                return e.getJSON(t2.request, o2);
              if ("string" == typeof t2.data)
                try {
                  o2(null, JSON.parse(t2.data));
                } catch (e3) {
                  o2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
                }
              else
                o2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
              return { cancel: () => {
              } };
            }
            removeSource(e3, t2) {
              this._pendingCallback && this._pendingCallback(null, { abandoned: true }), t2();
            }
            getClusterExpansionZoom(e3, t2) {
              try {
                t2(null, this._geoJSONIndex.getClusterExpansionZoom(e3.clusterId));
              } catch (e4) {
                t2(e4);
              }
            }
            getClusterChildren(e3, t2) {
              try {
                t2(null, this._geoJSONIndex.getChildren(e3.clusterId));
              } catch (e4) {
                t2(e4);
              }
            }
            getClusterLeaves(e3, t2) {
              try {
                t2(null, this._geoJSONIndex.getLeaves(e3.clusterId, e3.limit, e3.offset));
              } catch (e4) {
                t2(e4);
              }
            }
          }
          class _e {
            constructor(t2) {
              this.self = t2, this.actor = new e.Actor(t2, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: l, geojson: Ce }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e3, t3) => {
                if (this.workerSourceTypes[e3])
                  throw new Error(`Worker source with name "${e3}" already registered.`);
                this.workerSourceTypes[e3] = t3;
              }, this.self.registerRTLTextPlugin = (t3) => {
                if (e.plugin.isParsed())
                  throw new Error("RTL text plugin already registered.");
                e.plugin.applyArabicShaping = t3.applyArabicShaping, e.plugin.processBidirectionalText = t3.processBidirectionalText, e.plugin.processStyledBidirectionalText = t3.processStyledBidirectionalText;
              };
            }
            setReferrer(e3, t2) {
              this.referrer = t2;
            }
            setImages(e3, t2, o2) {
              this.availableImages[e3] = t2;
              for (const o3 in this.workerSources[e3]) {
                const i2 = this.workerSources[e3][o3];
                for (const e4 in i2)
                  i2[e4].availableImages = t2;
              }
              o2();
            }
            setLayers(e3, t2, o2) {
              this.getLayerIndex(e3).replace(t2), o2();
            }
            updateLayers(e3, t2, o2) {
              this.getLayerIndex(e3).update(t2.layers, t2.removedIds), o2();
            }
            loadTile(e3, t2, o2) {
              this.getWorkerSource(e3, t2.type, t2.source).loadTile(t2, o2);
            }
            loadDEMTile(e3, t2, o2) {
              this.getDEMWorkerSource(e3, t2.source).loadTile(t2, o2);
            }
            reloadTile(e3, t2, o2) {
              this.getWorkerSource(e3, t2.type, t2.source).reloadTile(t2, o2);
            }
            abortTile(e3, t2, o2) {
              this.getWorkerSource(e3, t2.type, t2.source).abortTile(t2, o2);
            }
            removeTile(e3, t2, o2) {
              this.getWorkerSource(e3, t2.type, t2.source).removeTile(t2, o2);
            }
            removeDEMTile(e3, t2) {
              this.getDEMWorkerSource(e3, t2.source).removeTile(t2);
            }
            removeSource(e3, t2, o2) {
              if (!this.workerSources[e3] || !this.workerSources[e3][t2.type] || !this.workerSources[e3][t2.type][t2.source])
                return;
              const i2 = this.workerSources[e3][t2.type][t2.source];
              delete this.workerSources[e3][t2.type][t2.source], void 0 !== i2.removeSource ? i2.removeSource(t2, o2) : o2();
            }
            loadWorkerSource(e3, t2, o2) {
              try {
                this.self.importScripts(t2.url), o2();
              } catch (e4) {
                o2(e4.toString());
              }
            }
            syncRTLPluginState(t2, o2, i2) {
              try {
                e.plugin.setState(o2);
                const t3 = e.plugin.getPluginURL();
                if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != t3) {
                  this.self.importScripts(t3);
                  const o3 = e.plugin.isParsed();
                  i2(o3 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t3}`), o3);
                }
              } catch (e3) {
                i2(e3.toString());
              }
            }
            getAvailableImages(e3) {
              let t2 = this.availableImages[e3];
              return t2 || (t2 = []), t2;
            }
            getLayerIndex(e3) {
              let t2 = this.layerIndexes[e3];
              return t2 || (t2 = this.layerIndexes[e3] = new i()), t2;
            }
            getWorkerSource(e3, t2, o2) {
              if (this.workerSources[e3] || (this.workerSources[e3] = {}), this.workerSources[e3][t2] || (this.workerSources[e3][t2] = {}), !this.workerSources[e3][t2][o2]) {
                const i2 = { send: (t3, o3, i3) => {
                  this.actor.send(t3, o3, i3, e3);
                } };
                this.workerSources[e3][t2][o2] = new this.workerSourceTypes[t2](i2, this.getLayerIndex(e3), this.getAvailableImages(e3));
              }
              return this.workerSources[e3][t2][o2];
            }
            getDEMWorkerSource(e3, t2) {
              return this.demWorkerSources[e3] || (this.demWorkerSources[e3] = {}), this.demWorkerSources[e3][t2] || (this.demWorkerSources[e3][t2] = new c()), this.demWorkerSources[e3][t2];
            }
            enforceCacheSizeLimit(t2, o2) {
              e.enforceCacheSizeLimit(o2);
            }
          }
          return e.isWorker() && (self.worker = new _e(self)), _e;
        });
        define2(["./shared"], function(t) {
          "use strict";
          var e = i;
          function i(t2) {
            return !function(t3) {
              return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
                if (!("Worker" in window && "Blob" in window && "URL" in window))
                  return false;
                var t4, e4, i2 = new Blob([""], { type: "text/javascript" }), o2 = URL.createObjectURL(i2);
                try {
                  e4 = new Worker(o2), t4 = true;
                } catch (e6) {
                  t4 = false;
                }
                return e4 && e4.terminate(), URL.revokeObjectURL(o2), t4;
              }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
                var t4 = document.createElement("canvas");
                t4.width = t4.height = 1;
                var e4 = t4.getContext("2d");
                if (!e4)
                  return false;
                var i2 = e4.getImageData(0, 0, 1, 1);
                return i2 && i2.width === t4.width;
              }() ? (void 0 === o[e3 = t3 && t3.failIfMajorPerformanceCaveat] && (o[e3] = function(t4) {
                var e4, o2 = function(t5) {
                  var e6 = document.createElement("canvas"), o3 = Object.create(i.webGLContextAttributes);
                  return o3.failIfMajorPerformanceCaveat = t5, e6.getContext("webgl", o3) || e6.getContext("experimental-webgl", o3);
                }(t4);
                if (!o2)
                  return false;
                try {
                  e4 = o2.createShader(o2.VERTEX_SHADER);
                } catch (t5) {
                  return false;
                }
                return !(!e4 || o2.isContextLost()) && (o2.shaderSource(e4, "void main() {}"), o2.compileShader(e4), true === o2.getShaderParameter(e4, o2.COMPILE_STATUS));
              }(e3)), o[e3] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
              var e3;
            }(t2);
          }
          var o = {};
          function a(t2, e3) {
            if (Array.isArray(t2)) {
              if (!Array.isArray(e3) || t2.length !== e3.length)
                return false;
              for (let i2 = 0; i2 < t2.length; i2++)
                if (!a(t2[i2], e3[i2]))
                  return false;
              return true;
            }
            if ("object" == typeof t2 && null !== t2 && null !== e3) {
              if ("object" != typeof e3)
                return false;
              if (Object.keys(t2).length !== Object.keys(e3).length)
                return false;
              for (const i2 in t2)
                if (!a(t2[i2], e3[i2]))
                  return false;
              return true;
            }
            return t2 === e3;
          }
          i.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
          class r {
            static testProp(t2) {
              if (!r.docStyle)
                return t2[0];
              for (let e3 = 0; e3 < t2.length; e3++)
                if (t2[e3] in r.docStyle)
                  return t2[e3];
              return t2[0];
            }
            static create(t2, e3, i2) {
              const o2 = window.document.createElement(t2);
              return void 0 !== e3 && (o2.className = e3), i2 && i2.appendChild(o2), o2;
            }
            static createNS(t2, e3) {
              return window.document.createElementNS(t2, e3);
            }
            static disableDrag() {
              r.docStyle && r.selectProp && (r.userSelect = r.docStyle[r.selectProp], r.docStyle[r.selectProp] = "none");
            }
            static enableDrag() {
              r.docStyle && r.selectProp && (r.docStyle[r.selectProp] = r.userSelect);
            }
            static setTransform(t2, e3) {
              t2.style[r.transformProp] = e3;
            }
            static addEventListener(t2, e3, i2, o2 = {}) {
              t2.addEventListener(e3, i2, "passive" in o2 ? o2 : o2.capture);
            }
            static removeEventListener(t2, e3, i2, o2 = {}) {
              t2.removeEventListener(e3, i2, "passive" in o2 ? o2 : o2.capture);
            }
            static suppressClickInternal(t2) {
              t2.preventDefault(), t2.stopPropagation(), window.removeEventListener("click", r.suppressClickInternal, true);
            }
            static suppressClick() {
              window.addEventListener("click", r.suppressClickInternal, true), window.setTimeout(() => {
                window.removeEventListener("click", r.suppressClickInternal, true);
              }, 0);
            }
            static mousePos(e3, i2) {
              const o2 = e3.getBoundingClientRect();
              return new t.pointGeometry(i2.clientX - o2.left - e3.clientLeft, i2.clientY - o2.top - e3.clientTop);
            }
            static touchPos(e3, i2) {
              const o2 = e3.getBoundingClientRect(), a2 = [];
              for (let r2 = 0; r2 < i2.length; r2++)
                a2.push(new t.pointGeometry(i2[r2].clientX - o2.left - e3.clientLeft, i2[r2].clientY - o2.top - e3.clientTop));
              return a2;
            }
            static mouseButton(t2) {
              return t2.button;
            }
            static remove(t2) {
              t2.parentNode && t2.parentNode.removeChild(t2);
            }
          }
          r.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, r.selectProp = r.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), r.transformProp = r.testProp(["transform", "WebkitTransform"]);
          class s {
            constructor(t2) {
              this._transformRequestFn = t2;
            }
            transformRequest(t2, e3) {
              return this._transformRequestFn && this._transformRequestFn(t2, e3) || { url: t2 };
            }
            normalizeSpriteURL(t2, e3, i2) {
              const o2 = function(t3) {
                const e4 = t3.match(n);
                if (!e4)
                  throw new Error(`Unable to parse URL "${t3}"`);
                return { protocol: e4[1], authority: e4[2], path: e4[3] || "/", params: e4[4] ? e4[4].split("&") : [] };
              }(t2);
              return o2.path += `${e3}${i2}`, function(t3) {
                const e4 = t3.params.length ? `?${t3.params.join("&")}` : "";
                return `${t3.protocol}://${t3.authority}${t3.path}${e4}`;
              }(o2);
            }
            setTransformRequest(t2) {
              this._transformRequestFn = t2;
            }
          }
          const n = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
          class l {
            constructor(t2, e3, i2, o2) {
              this.context = t2, this.format = i2, this.texture = t2.gl.createTexture(), this.update(e3, o2);
            }
            update(e3, i2, o2) {
              const { width: a2, height: r2 } = e3, s2 = !(this.size && this.size[0] === a2 && this.size[1] === r2 || o2), { context: n2 } = this, { gl: l2 } = n2;
              if (this.useMipmap = Boolean(i2 && i2.useMipmap), l2.bindTexture(l2.TEXTURE_2D, this.texture), n2.pixelStoreUnpackFlipY.set(false), n2.pixelStoreUnpack.set(1), n2.pixelStoreUnpackPremultiplyAlpha.set(this.format === l2.RGBA && (!i2 || false !== i2.premultiply)), s2)
                this.size = [a2, r2], e3 instanceof HTMLImageElement || e3 instanceof HTMLCanvasElement || e3 instanceof HTMLVideoElement || e3 instanceof ImageData || t.isImageBitmap(e3) ? l2.texImage2D(l2.TEXTURE_2D, 0, this.format, this.format, l2.UNSIGNED_BYTE, e3) : l2.texImage2D(l2.TEXTURE_2D, 0, this.format, a2, r2, 0, this.format, l2.UNSIGNED_BYTE, e3.data);
              else {
                const { x: i3, y: s3 } = o2 || { x: 0, y: 0 };
                e3 instanceof HTMLImageElement || e3 instanceof HTMLCanvasElement || e3 instanceof HTMLVideoElement || e3 instanceof ImageData || t.isImageBitmap(e3) ? l2.texSubImage2D(l2.TEXTURE_2D, 0, i3, s3, l2.RGBA, l2.UNSIGNED_BYTE, e3) : l2.texSubImage2D(l2.TEXTURE_2D, 0, i3, s3, a2, r2, l2.RGBA, l2.UNSIGNED_BYTE, e3.data);
              }
              this.useMipmap && this.isSizePowerOfTwo() && l2.generateMipmap(l2.TEXTURE_2D);
            }
            bind(t2, e3, i2) {
              const { context: o2 } = this, { gl: a2 } = o2;
              a2.bindTexture(a2.TEXTURE_2D, this.texture), i2 !== a2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i2 = a2.LINEAR), t2 !== this.filter && (a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MAG_FILTER, t2), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_MIN_FILTER, i2 || t2), this.filter = t2), e3 !== this.wrap && (a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_S, e3), a2.texParameteri(a2.TEXTURE_2D, a2.TEXTURE_WRAP_T, e3), this.wrap = e3);
            }
            isSizePowerOfTwo() {
              return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
            }
            destroy() {
              const { gl: t2 } = this.context;
              t2.deleteTexture(this.texture), this.texture = null;
            }
          }
          function c(t2) {
            const { userImage: e3 } = t2;
            return !!(e3 && e3.render && e3.render()) && (t2.data.replace(new Uint8Array(e3.data.buffer)), true);
          }
          class h extends t.Evented {
            constructor() {
              super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
            }
            isLoaded() {
              return this.loaded;
            }
            setLoaded(t2) {
              if (this.loaded !== t2 && (this.loaded = t2, t2)) {
                for (const { ids: t3, callback: e3 } of this.requestors)
                  this._notify(t3, e3);
                this.requestors = [];
              }
            }
            getImage(t2) {
              return this.images[t2];
            }
            addImage(t2, e3) {
              if (this.images[t2])
                throw new Error(`Image id ${t2} already exist, use updateImage instead`);
              this._validate(t2, e3) && (this.images[t2] = e3);
            }
            _validate(e3, i2) {
              let o2 = true;
              return this._validateStretch(i2.stretchX, i2.data && i2.data.width) || (this.fire(new t.ErrorEvent(new Error(`Image "${e3}" has invalid "stretchX" value`))), o2 = false), this._validateStretch(i2.stretchY, i2.data && i2.data.height) || (this.fire(new t.ErrorEvent(new Error(`Image "${e3}" has invalid "stretchY" value`))), o2 = false), this._validateContent(i2.content, i2) || (this.fire(new t.ErrorEvent(new Error(`Image "${e3}" has invalid "content" value`))), o2 = false), o2;
            }
            _validateStretch(t2, e3) {
              if (!t2)
                return true;
              let i2 = 0;
              for (const o2 of t2) {
                if (o2[0] < i2 || o2[1] < o2[0] || e3 < o2[1])
                  return false;
                i2 = o2[1];
              }
              return true;
            }
            _validateContent(t2, e3) {
              return !(t2 && (4 !== t2.length || t2[0] < 0 || e3.data.width < t2[0] || t2[1] < 0 || e3.data.height < t2[1] || t2[2] < 0 || e3.data.width < t2[2] || t2[3] < 0 || e3.data.height < t2[3] || t2[2] < t2[0] || t2[3] < t2[1]));
            }
            updateImage(t2, e3) {
              const i2 = this.images[t2];
              if (i2.data.width !== e3.data.width || i2.data.height !== e3.data.height)
                throw new Error(`size mismatch between old image (${i2.data.width}x${i2.data.height}) and new image (${e3.data.width}x${e3.data.height}).`);
              e3.version = i2.version + 1, this.images[t2] = e3, this.updatedImages[t2] = true;
            }
            removeImage(t2) {
              const e3 = this.images[t2];
              delete this.images[t2], delete this.patterns[t2], e3.userImage && e3.userImage.onRemove && e3.userImage.onRemove();
            }
            listImages() {
              return Object.keys(this.images);
            }
            getImages(t2, e3) {
              let i2 = true;
              if (!this.isLoaded())
                for (const e4 of t2)
                  this.images[e4] || (i2 = false);
              this.isLoaded() || i2 ? this._notify(t2, e3) : this.requestors.push({ ids: t2, callback: e3 });
            }
            _notify(e3, i2) {
              const o2 = {};
              for (const i3 of e3) {
                this.images[i3] || this.fire(new t.Event("styleimagemissing", { id: i3 }));
                const e4 = this.images[i3];
                e4 ? o2[i3] = { data: e4.data.clone(), pixelRatio: e4.pixelRatio, sdf: e4.sdf, version: e4.version, stretchX: e4.stretchX, stretchY: e4.stretchY, content: e4.content, hasRenderCallback: Boolean(e4.userImage && e4.userImage.render) } : t.warnOnce(`Image "${i3}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
              }
              i2(null, o2);
            }
            getPixelSize() {
              const { width: t2, height: e3 } = this.atlasImage;
              return { width: t2, height: e3 };
            }
            getPattern(e3) {
              const i2 = this.patterns[e3], o2 = this.getImage(e3);
              if (!o2)
                return null;
              if (i2 && i2.position.version === o2.version)
                return i2.position;
              if (i2)
                i2.position.version = o2.version;
              else {
                const i3 = { w: o2.data.width + 2, h: o2.data.height + 2, x: 0, y: 0 }, a2 = new t.ImagePosition(i3, o2);
                this.patterns[e3] = { bin: i3, position: a2 };
              }
              return this._updatePatternAtlas(), this.patterns[e3].position;
            }
            bind(t2) {
              const e3 = t2.gl;
              this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new l(t2, this.atlasImage, e3.RGBA), this.atlasTexture.bind(e3.LINEAR, e3.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas() {
              const e3 = [];
              for (const t2 in this.patterns)
                e3.push(this.patterns[t2].bin);
              const { w: i2, h: o2 } = t.potpack(e3), a2 = this.atlasImage;
              a2.resize({ width: i2 || 1, height: o2 || 1 });
              for (const e4 in this.patterns) {
                const { bin: i3 } = this.patterns[e4], o3 = i3.x + 1, r2 = i3.y + 1, s2 = this.images[e4].data, n2 = s2.width, l2 = s2.height;
                t.RGBAImage.copy(s2, a2, { x: 0, y: 0 }, { x: o3, y: r2 }, { width: n2, height: l2 }), t.RGBAImage.copy(s2, a2, { x: 0, y: l2 - 1 }, { x: o3, y: r2 - 1 }, { width: n2, height: 1 }), t.RGBAImage.copy(s2, a2, { x: 0, y: 0 }, { x: o3, y: r2 + l2 }, { width: n2, height: 1 }), t.RGBAImage.copy(s2, a2, { x: n2 - 1, y: 0 }, { x: o3 - 1, y: r2 }, { width: 1, height: l2 }), t.RGBAImage.copy(s2, a2, { x: 0, y: 0 }, { x: o3 + n2, y: r2 }, { width: 1, height: l2 });
              }
              this.dirty = true;
            }
            beginFrame() {
              this.callbackDispatchedThisFrame = {};
            }
            dispatchRenderCallbacks(e3) {
              for (const i2 of e3) {
                if (this.callbackDispatchedThisFrame[i2])
                  continue;
                this.callbackDispatchedThisFrame[i2] = true;
                const e4 = this.images[i2];
                e4 || t.warnOnce(`Image with ID: "${i2}" was not found`), c(e4) && this.updateImage(i2, e4);
              }
            }
          }
          const u = 1e20;
          function d(t2, e3, i2, o2, a2, r2, s2, n2, l2) {
            for (let c2 = e3; c2 < e3 + o2; c2++)
              m(t2, i2 * r2 + c2, r2, a2, s2, n2, l2);
            for (let c2 = i2; c2 < i2 + a2; c2++)
              m(t2, c2 * r2 + e3, 1, o2, s2, n2, l2);
          }
          function m(t2, e3, i2, o2, a2, r2, s2) {
            r2[0] = 0, s2[0] = -u, s2[1] = u, a2[0] = t2[e3];
            for (let n2 = 1, l2 = 0, c2 = 0; n2 < o2; n2++) {
              a2[n2] = t2[e3 + n2 * i2];
              const o3 = n2 * n2;
              do {
                const t3 = r2[l2];
                c2 = (a2[n2] - a2[t3] + o3 - t3 * t3) / (n2 - t3) / 2;
              } while (c2 <= s2[l2] && --l2 > -1);
              l2++, r2[l2] = n2, s2[l2] = c2, s2[l2 + 1] = u;
            }
            for (let n2 = 0, l2 = 0; n2 < o2; n2++) {
              for (; s2[l2 + 1] < n2; )
                l2++;
              const o3 = r2[l2], c2 = n2 - o3;
              t2[e3 + n2 * i2] = a2[o3] + c2 * c2;
            }
          }
          class _ {
            constructor(t2, e3) {
              this.requestManager = t2, this.localIdeographFontFamily = e3, this.entries = {};
            }
            setURL(t2) {
              this.url = t2;
            }
            getGlyphs(e3, i2) {
              const o2 = [];
              for (const t2 in e3)
                for (const i3 of e3[t2])
                  o2.push({ stack: t2, id: i3 });
              t.asyncAll(o2, ({ stack: t2, id: e4 }, i3) => {
                let o3 = this.entries[t2];
                o3 || (o3 = this.entries[t2] = { glyphs: {}, requests: {}, ranges: {} });
                let a2 = o3.glyphs[e4];
                if (void 0 !== a2)
                  return void i3(null, { stack: t2, id: e4, glyph: a2 });
                if (a2 = this._tinySDF(o3, t2, e4), a2)
                  return o3.glyphs[e4] = a2, void i3(null, { stack: t2, id: e4, glyph: a2 });
                const r2 = Math.floor(e4 / 256);
                if (256 * r2 > 65535)
                  return void i3(new Error("glyphs > 65535 not supported"));
                if (o3.ranges[r2])
                  return void i3(null, { stack: t2, id: e4, glyph: a2 });
                let s2 = o3.requests[r2];
                s2 || (s2 = o3.requests[r2] = [], _.loadGlyphRange(t2, r2, this.url, this.requestManager, (t3, e6) => {
                  if (e6) {
                    for (const t4 in e6)
                      this._doesCharSupportLocalGlyph(+t4) || (o3.glyphs[+t4] = e6[+t4]);
                    o3.ranges[r2] = true;
                  }
                  for (const i4 of s2)
                    i4(t3, e6);
                  delete o3.requests[r2];
                })), s2.push((o4, a3) => {
                  o4 ? i3(o4) : a3 && i3(null, { stack: t2, id: e4, glyph: a3[e4] || null });
                });
              }, (t2, e4) => {
                if (t2)
                  i2(t2);
                else if (e4) {
                  const t3 = {};
                  for (const { stack: i3, id: o3, glyph: a2 } of e4)
                    (t3[i3] || (t3[i3] = {}))[o3] = a2 && { id: a2.id, bitmap: a2.bitmap.clone(), metrics: a2.metrics };
                  i2(null, t3);
                }
              });
            }
            _doesCharSupportLocalGlyph(e3) {
              return !!this.localIdeographFontFamily && (t.unicodeBlockLookup["CJK Unified Ideographs"](e3) || t.unicodeBlockLookup["Hangul Syllables"](e3) || t.unicodeBlockLookup.Hiragana(e3) || t.unicodeBlockLookup.Katakana(e3));
            }
            _tinySDF(e3, i2, o2) {
              const a2 = this.localIdeographFontFamily;
              if (!a2)
                return;
              if (!this._doesCharSupportLocalGlyph(o2))
                return;
              let r2 = e3.tinySDF;
              if (!r2) {
                let t2 = "400";
                /bold/i.test(i2) ? t2 = "900" : /medium/i.test(i2) ? t2 = "500" : /light/i.test(i2) && (t2 = "200"), r2 = e3.tinySDF = new _.TinySDF({ fontSize: 24, buffer: 3, radius: 8, cutoff: 0.25, fontFamily: a2, fontWeight: t2 });
              }
              const s2 = r2.draw(String.fromCharCode(o2));
              return { id: o2, bitmap: new t.AlphaImage({ width: s2.width || 30, height: s2.height || 30 }, s2.data), metrics: { width: s2.glyphWidth || 24, height: s2.glyphHeight || 24, left: s2.glyphLeft || 0, top: s2.glyphTop - 27 || -8, advance: s2.glyphAdvance || 24 } };
            }
          }
          _.loadGlyphRange = function(e3, i2, o2, a2, r2) {
            const s2 = 256 * i2, n2 = s2 + 255, l2 = a2.transformRequest(o2.replace("{fontstack}", e3).replace("{range}", `${s2}-${n2}`), t.ResourceType.Glyphs);
            t.getArrayBuffer(l2, (e4, i3) => {
              if (e4)
                r2(e4);
              else if (i3) {
                const e6 = {};
                for (const o3 of t.parseGlyphPbf(i3))
                  e6[o3.id] = o3;
                r2(null, e6);
              }
            });
          }, _.TinySDF = class {
            constructor({ fontSize: t2 = 24, buffer: e3 = 3, radius: i2 = 8, cutoff: o2 = 0.25, fontFamily: a2 = "sans-serif", fontWeight: r2 = "normal", fontStyle: s2 = "normal" } = {}) {
              this.buffer = e3, this.cutoff = o2, this.radius = i2;
              const n2 = this.size = t2 + 4 * e3, l2 = this._createCanvas(n2), c2 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
              c2.font = `${s2} ${r2} ${t2}px ${a2}`, c2.textBaseline = "alphabetic", c2.textAlign = "left", c2.fillStyle = "black", this.gridOuter = new Float64Array(n2 * n2), this.gridInner = new Float64Array(n2 * n2), this.f = new Float64Array(n2), this.z = new Float64Array(n2 + 1), this.v = new Uint16Array(n2);
            }
            _createCanvas(t2) {
              const e3 = document.createElement("canvas");
              return e3.width = e3.height = t2, e3;
            }
            draw(t2) {
              const { width: e3, actualBoundingBoxAscent: i2, actualBoundingBoxDescent: o2, actualBoundingBoxLeft: a2, actualBoundingBoxRight: r2 } = this.ctx.measureText(t2), s2 = Math.ceil(i2), n2 = Math.min(this.size - this.buffer, Math.ceil(r2 - a2)), l2 = Math.min(this.size - this.buffer, s2 + Math.ceil(o2)), c2 = n2 + 2 * this.buffer, h2 = l2 + 2 * this.buffer, m2 = Math.max(c2 * h2, 0), _2 = new Uint8ClampedArray(m2), p2 = { data: _2, width: c2, height: h2, glyphWidth: n2, glyphHeight: l2, glyphTop: s2, glyphLeft: 0, glyphAdvance: e3 };
              if (0 === n2 || 0 === l2)
                return p2;
              const { ctx: f2, buffer: g2, gridInner: x3, gridOuter: v2 } = this;
              f2.clearRect(g2, g2, n2, l2), f2.fillText(t2, g2, g2 + s2);
              const y3 = f2.getImageData(g2, g2, n2, l2);
              v2.fill(u, 0, m2), x3.fill(0, 0, m2);
              for (let t3 = 0; t3 < l2; t3++)
                for (let e4 = 0; e4 < n2; e4++) {
                  const i3 = y3.data[4 * (t3 * n2 + e4) + 3] / 255;
                  if (0 === i3)
                    continue;
                  const o3 = (t3 + g2) * c2 + e4 + g2;
                  if (1 === i3)
                    v2[o3] = 0, x3[o3] = u;
                  else {
                    const t4 = 0.5 - i3;
                    v2[o3] = t4 > 0 ? t4 * t4 : 0, x3[o3] = t4 < 0 ? t4 * t4 : 0;
                  }
                }
              d(v2, 0, 0, c2, h2, c2, this.f, this.v, this.z), d(x3, g2, g2, n2, l2, c2, this.f, this.v, this.z);
              for (let t3 = 0; t3 < m2; t3++) {
                const e4 = Math.sqrt(v2[t3]) - Math.sqrt(x3[t3]);
                _2[t3] = Math.round(255 - 255 * (e4 / this.radius + this.cutoff));
              }
              return p2;
            }
          };
          const p = new t.Properties({ anchor: new t.DataConstantProperty(t.spec.light.anchor), position: new class {
            constructor() {
              this.specification = t.spec.light.position;
            }
            possiblyEvaluate(e3, i2) {
              return t.sphericalToCartesian(e3.expression.evaluate(i2));
            }
            interpolate(e3, i2, o2) {
              return { x: t.number(e3.x, i2.x, o2), y: t.number(e3.y, i2.y, o2), z: t.number(e3.z, i2.z, o2) };
            }
          }(), color: new t.DataConstantProperty(t.spec.light.color), intensity: new t.DataConstantProperty(t.spec.light.intensity) }), f = "-transition";
          class g extends t.Evented {
            constructor(e3) {
              super(), this._transitionable = new t.Transitionable(p), this.setLight(e3), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
              return this._transitionable.serialize();
            }
            setLight(e3, i2 = {}) {
              if (!this._validate(t.validateLight, e3, i2))
                for (const t2 in e3) {
                  const i3 = e3[t2];
                  t2.endsWith(f) ? this._transitionable.setTransition(t2.slice(0, -f.length), i3) : this._transitionable.setValue(t2, i3);
                }
            }
            updateTransitions(t2) {
              this._transitioning = this._transitionable.transitioned(t2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(t2) {
              this.properties = this._transitioning.possiblyEvaluate(t2);
            }
            _validate(e3, i2, o2) {
              return (!o2 || false !== o2.validate) && t.emitValidationErrors(this, e3.call(t.validateStyle, t.extend({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: t.spec })));
            }
          }
          class x2 {
            constructor(t2, e3) {
              this.width = t2, this.height = e3, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
            }
            getDash(t2, e3) {
              const i2 = t2.join(",") + String(e3);
              return this.dashEntry[i2] || (this.dashEntry[i2] = this.addDash(t2, e3)), this.dashEntry[i2];
            }
            getDashRanges(t2, e3, i2) {
              const o2 = [];
              let a2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * i2 : 0, r2 = t2[0] * i2, s2 = true;
              o2.push({ left: a2, right: r2, isDash: s2, zeroLength: 0 === t2[0] });
              let n2 = t2[0];
              for (let e4 = 1; e4 < t2.length; e4++) {
                s2 = !s2;
                const l2 = t2[e4];
                a2 = n2 * i2, n2 += l2, r2 = n2 * i2, o2.push({ left: a2, right: r2, isDash: s2, zeroLength: 0 === l2 });
              }
              return o2;
            }
            addRoundDash(t2, e3, i2) {
              const o2 = e3 / 2;
              for (let e4 = -i2; e4 <= i2; e4++) {
                const a2 = this.width * (this.nextRow + i2 + e4);
                let r2 = 0, s2 = t2[r2];
                for (let n2 = 0; n2 < this.width; n2++) {
                  n2 / s2.right > 1 && (s2 = t2[++r2]);
                  const l2 = Math.abs(n2 - s2.left), c2 = Math.abs(n2 - s2.right), h2 = Math.min(l2, c2);
                  let u2;
                  const d2 = e4 / i2 * (o2 + 1);
                  if (s2.isDash) {
                    const t3 = o2 - Math.abs(d2);
                    u2 = Math.sqrt(h2 * h2 + t3 * t3);
                  } else
                    u2 = o2 - Math.sqrt(h2 * h2 + d2 * d2);
                  this.data[a2 + n2] = Math.max(0, Math.min(255, u2 + 128));
                }
              }
            }
            addRegularDash(t2) {
              for (let e4 = t2.length - 1; e4 >= 0; --e4) {
                const i3 = t2[e4], o3 = t2[e4 + 1];
                i3.zeroLength ? t2.splice(e4, 1) : o3 && o3.isDash === i3.isDash && (o3.left = i3.left, t2.splice(e4, 1));
              }
              const e3 = t2[0], i2 = t2[t2.length - 1];
              e3.isDash === i2.isDash && (e3.left = i2.left - this.width, i2.right = e3.right + this.width);
              const o2 = this.width * this.nextRow;
              let a2 = 0, r2 = t2[a2];
              for (let e4 = 0; e4 < this.width; e4++) {
                e4 / r2.right > 1 && (r2 = t2[++a2]);
                const i3 = Math.abs(e4 - r2.left), s2 = Math.abs(e4 - r2.right), n2 = Math.min(i3, s2);
                this.data[o2 + e4] = Math.max(0, Math.min(255, (r2.isDash ? n2 : -n2) + 128));
              }
            }
            addDash(e3, i2) {
              const o2 = i2 ? 7 : 0, a2 = 2 * o2 + 1;
              if (this.nextRow + a2 > this.height)
                return t.warnOnce("LineAtlas out of space"), null;
              let r2 = 0;
              for (let t2 = 0; t2 < e3.length; t2++)
                r2 += e3[t2];
              if (0 !== r2) {
                const t2 = this.width / r2, a3 = this.getDashRanges(e3, this.width, t2);
                i2 ? this.addRoundDash(a3, t2, o2) : this.addRegularDash(a3);
              }
              const s2 = { y: (this.nextRow + o2 + 0.5) / this.height, height: 2 * o2 / this.height, width: r2 };
              return this.nextRow += a2, this.dirty = true, s2;
            }
            bind(t2) {
              const e3 = t2.gl;
              this.texture ? (e3.bindTexture(e3.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, e3.texSubImage2D(e3.TEXTURE_2D, 0, 0, 0, this.width, this.height, e3.ALPHA, e3.UNSIGNED_BYTE, this.data))) : (this.texture = e3.createTexture(), e3.bindTexture(e3.TEXTURE_2D, this.texture), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_WRAP_S, e3.REPEAT), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_WRAP_T, e3.REPEAT), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_MIN_FILTER, e3.LINEAR), e3.texParameteri(e3.TEXTURE_2D, e3.TEXTURE_MAG_FILTER, e3.LINEAR), e3.texImage2D(e3.TEXTURE_2D, 0, e3.ALPHA, this.width, this.height, 0, e3.ALPHA, e3.UNSIGNED_BYTE, this.data));
            }
          }
          class v {
            constructor(e3, i2) {
              this.workerPool = e3, this.actors = [], this.currentActor = 0, this.id = t.uniqueId();
              const o2 = this.workerPool.acquire(this.id);
              for (let t2 = 0; t2 < o2.length; t2++) {
                const e4 = new v.Actor(o2[t2], i2, this.id);
                e4.name = `Worker ${t2}`, this.actors.push(e4);
              }
              if (!this.actors.length)
                throw new Error("No actors found");
            }
            broadcast(e3, i2, o2) {
              t.asyncAll(this.actors, (t2, o3) => {
                t2.send(e3, i2, o3);
              }, o2 = o2 || function() {
              });
            }
            getActor() {
              return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove() {
              this.actors.forEach((t2) => {
                t2.remove();
              }), this.actors = [], this.workerPool.release(this.id);
            }
          }
          function y2(e3, i2, o2) {
            const a2 = function(i3, a3) {
              if (i3)
                return o2(i3);
              if (a3) {
                const i4 = t.pick(t.extend(a3, e3), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
                a3.vector_layers && (i4.vectorLayers = a3.vector_layers, i4.vectorLayerIds = i4.vectorLayers.map((t2) => t2.id)), o2(null, i4);
              }
            };
            return e3.url ? t.getJSON(i2.transformRequest(e3.url, t.ResourceType.Source), a2) : t.exported.frame(() => a2(null, e3));
          }
          v.Actor = t.Actor;
          class b {
            constructor(e3, i2, o2) {
              this.bounds = t.LngLatBounds.convert(this.validateBounds(e3)), this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
            }
            validateBounds(t2) {
              return Array.isArray(t2) && 4 === t2.length ? [Math.max(-180, t2[0]), Math.max(-90, t2[1]), Math.min(180, t2[2]), Math.min(90, t2[3])] : [-180, -90, 180, 90];
            }
            contains(e3) {
              const i2 = Math.pow(2, e3.z), o2 = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * i2), a2 = Math.floor(t.mercatorYfromLat(this.bounds.getNorth()) * i2), r2 = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * i2), s2 = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * i2);
              return e3.x >= o2 && e3.x < r2 && e3.y >= a2 && e3.y < s2;
            }
          }
          class w extends t.Evented {
            constructor(e3, i2, o2, a2) {
              if (super(), this.id = e3, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t.extend(this, t.pick(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.extend({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, 512 !== this.tileSize)
                throw new Error("vector tile sources must have a tileSize of 512");
              this.setEventedParent(a2);
            }
            load() {
              this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = y2(this._options, this.map._requestManager, (e3, i2) => {
                this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e3 ? this.fire(new t.ErrorEvent(e3)) : i2 && (t.extend(this, i2), i2.bounds && (this.tileBounds = new b(i2.bounds, this.minzoom, this.maxzoom)), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
              });
            }
            loaded() {
              return this._loaded;
            }
            hasTile(t2) {
              return !this.tileBounds || this.tileBounds.contains(t2.canonical);
            }
            onAdd(t2) {
              this.map = t2, this.load();
            }
            setSourceProperty(t2) {
              this._tileJSONRequest && this._tileJSONRequest.cancel(), t2(), this.load();
            }
            setTiles(t2) {
              return this.setSourceProperty(() => {
                this._options.tiles = t2;
              }), this;
            }
            setUrl(t2) {
              return this.setSourceProperty(() => {
                this.url = t2, this._options.url = t2;
              }), this;
            }
            onRemove() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
            serialize() {
              return t.extend({}, this._options);
            }
            loadTile(e3, i2) {
              const o2 = e3.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a2 = { request: this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), uid: e3.uid, tileID: e3.tileID, zoom: e3.tileID.overscaledZ, tileSize: this.tileSize * e3.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
              function r2(o3, a3) {
                return delete e3.request, e3.aborted ? i2(null) : o3 && 404 !== o3.status ? i2(o3) : (a3 && a3.resourceTiming && (e3.resourceTiming = a3.resourceTiming), this.map._refreshExpiredTiles && a3 && e3.setExpiryData(a3), e3.loadVectorData(a3, this.map.painter), t.cacheEntryPossiblyAdded(this.dispatcher), i2(null), void (e3.reloadCallback && (this.loadTile(e3, e3.reloadCallback), e3.reloadCallback = null)));
              }
              a2.request.collectResourceTiming = this._collectResourceTiming, e3.actor && "expired" !== e3.state ? "loading" === e3.state ? e3.reloadCallback = i2 : e3.request = e3.actor.send("reloadTile", a2, r2.bind(this)) : (e3.actor = this.dispatcher.getActor(), e3.request = e3.actor.send("loadTile", a2, r2.bind(this)));
            }
            abortTile(t2) {
              t2.request && (t2.request.cancel(), delete t2.request), t2.actor && t2.actor.send("abortTile", { uid: t2.uid, type: this.type, source: this.id }, void 0);
            }
            unloadTile(t2) {
              t2.unloadVectorData(), t2.actor && t2.actor.send("removeTile", { uid: t2.uid, type: this.type, source: this.id }, void 0);
            }
            hasTransition() {
              return false;
            }
          }
          class T extends t.Evented {
            constructor(e3, i2, o2, a2) {
              super(), this.id = e3, this.dispatcher = o2, this.setEventedParent(a2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t.extend({ type: "raster" }, i2), t.extend(this, t.pick(i2, ["url", "scheme", "tileSize"]));
            }
            load() {
              this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = y2(this._options, this.map._requestManager, (e3, i2) => {
                this._tileJSONRequest = null, this._loaded = true, e3 ? this.fire(new t.ErrorEvent(e3)) : i2 && (t.extend(this, i2), i2.bounds && (this.tileBounds = new b(i2.bounds, this.minzoom, this.maxzoom)), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
              });
            }
            loaded() {
              return this._loaded;
            }
            onAdd(t2) {
              this.map = t2, this.load();
            }
            onRemove() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
            serialize() {
              return t.extend({}, this._options);
            }
            hasTile(t2) {
              return !this.tileBounds || this.tileBounds.contains(t2.canonical);
            }
            loadTile(e3, i2) {
              const o2 = e3.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              e3.request = t.getImage(this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), (o3, a2, r2) => {
                if (delete e3.request, e3.aborted)
                  e3.state = "unloaded", i2(null);
                else if (o3)
                  e3.state = "errored", i2(o3);
                else if (a2) {
                  this.map._refreshExpiredTiles && e3.setExpiryData(r2);
                  const o4 = this.map.painter.context, s2 = o4.gl;
                  e3.texture = this.map.painter.getTileTexture(a2.width), e3.texture ? e3.texture.update(a2, { useMipmap: true }) : (e3.texture = new l(o4, a2, s2.RGBA, { useMipmap: true }), e3.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST), o4.extTextureFilterAnisotropic && s2.texParameterf(s2.TEXTURE_2D, o4.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, o4.extTextureFilterAnisotropicMax)), e3.state = "loaded", t.cacheEntryPossiblyAdded(this.dispatcher), i2(null);
                }
              });
            }
            abortTile(t2, e3) {
              t2.request && (t2.request.cancel(), delete t2.request), e3();
            }
            unloadTile(t2, e3) {
              t2.texture && this.map.painter.saveTileTexture(t2.texture), e3();
            }
            hasTransition() {
              return false;
            }
          }
          let E;
          class I extends T {
            constructor(e3, i2, o2, a2) {
              super(e3, i2, o2, a2), this.type = "raster-dem", this.maxzoom = 22, this._options = t.extend({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox";
            }
            serialize() {
              return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding };
            }
            loadTile(e3, i2) {
              const o2 = e3.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              function a2(t2, o3) {
                t2 && (e3.state = "errored", i2(t2)), o3 && (e3.dem = o3, e3.needsHillshadePrepare = true, e3.needsTerrainPrepare = true, e3.state = "loaded", i2(null));
              }
              e3.request = t.getImage(this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), function(o3, r2) {
                if (delete e3.request, e3.aborted)
                  e3.state = "unloaded", i2(null);
                else if (o3)
                  e3.state = "errored", i2(o3);
                else if (r2) {
                  this.map._refreshExpiredTiles && e3.setExpiryData(r2), delete r2.cacheControl, delete r2.expires;
                  const i3 = t.isImageBitmap(r2) && (null == E && (E = "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), E) ? r2 : t.exported.getImageData(r2, 1), o4 = { uid: e3.uid, coord: e3.tileID, source: this.id, rawImageData: i3, encoding: this.encoding };
                  e3.actor && "expired" !== e3.state || (e3.actor = this.dispatcher.getActor(), e3.actor.send("loadDEMTile", o4, a2.bind(this)));
                }
              }.bind(this)), e3.neighboringTiles = this._getNeighboringTiles(e3.tileID);
            }
            _getNeighboringTiles(e3) {
              const i2 = e3.canonical, o2 = Math.pow(2, i2.z), a2 = (i2.x - 1 + o2) % o2, r2 = 0 === i2.x ? e3.wrap - 1 : e3.wrap, s2 = (i2.x + 1 + o2) % o2, n2 = i2.x + 1 === o2 ? e3.wrap + 1 : e3.wrap, l2 = {};
              return l2[new t.OverscaledTileID(e3.overscaledZ, r2, i2.z, a2, i2.y).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, n2, i2.z, s2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new t.OverscaledTileID(e3.overscaledZ, r2, i2.z, a2, i2.y - 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, e3.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, n2, i2.z, s2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < o2 && (l2[new t.OverscaledTileID(e3.overscaledZ, r2, i2.z, a2, i2.y + 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, e3.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, n2, i2.z, s2, i2.y + 1).key] = { backfilled: false }), l2;
            }
            unloadTile(t2) {
              t2.demTexture && this.map.painter.saveTileTexture(t2.demTexture), t2.fbo && (t2.fbo.destroy(), delete t2.fbo), t2.dem && delete t2.dem, delete t2.neighboringTiles, t2.state = "unloaded", t2.actor && t2.actor.send("removeDEMTile", { uid: t2.uid, source: this.id });
            }
          }
          class C extends t.Evented {
            constructor(e3, i2, o2, a2) {
              super(), this.id = e3, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = o2.getActor(), this.setEventedParent(a2), this._data = i2.data, this._options = t.extend({}, i2), this._collectResourceTiming = i2.collectResourceTiming, void 0 !== i2.maxzoom && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
              const r2 = t.EXTENT / this.tileSize;
              this.workerOptions = t.extend({ source: this.id, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i2.buffer ? i2.buffer : 128) * r2, tolerance: (void 0 !== i2.tolerance ? i2.tolerance : 0.375) * r2, extent: t.EXTENT, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i2.clusterMaxZoom ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: t.EXTENT, radius: (i2.clusterRadius || 50) * r2, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions);
            }
            load() {
              this._updateWorkerData("metadata");
            }
            onAdd(t2) {
              this.map = t2, this.load();
            }
            setData(t2) {
              return this._data = t2, this._updateWorkerData("content"), this;
            }
            getClusterExpansionZoom(t2, e3) {
              return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: t2, source: this.id }, e3), this;
            }
            getClusterChildren(t2, e3) {
              return this.actor.send("geojson.getClusterChildren", { clusterId: t2, source: this.id }, e3), this;
            }
            getClusterLeaves(t2, e3, i2, o2) {
              return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: t2, limit: e3, offset: i2 }, o2), this;
            }
            _updateWorkerData(e3) {
              const i2 = t.extend({}, this.workerOptions), o2 = this._data;
              "string" == typeof o2 ? (i2.request = this.map._requestManager.transformRequest(t.exported.resolveURL(o2), t.ResourceType.Source), i2.request.collectResourceTiming = this._collectResourceTiming) : i2.data = JSON.stringify(o2), this._pendingLoads++, this.fire(new t.Event("dataloading", { dataType: "source" })), this.actor.send(`${this.type}.loadData`, i2, (i3, o3) => {
                if (this._pendingLoads--, this._removed || o3 && o3.abandoned)
                  return void this.fire(new t.Event("dataabort", { dataType: "source", sourceDataType: e3 }));
                let a2 = null;
                if (o3 && o3.resourceTiming && o3.resourceTiming[this.id] && (a2 = o3.resourceTiming[this.id].slice(0)), i3)
                  return void this.fire(new t.ErrorEvent(i3));
                const r2 = { dataType: "source", sourceDataType: e3 };
                this._collectResourceTiming && a2 && a2.length > 0 && t.extend(r2, { resourceTiming: a2 }), this.fire(new t.Event("data", r2));
              });
            }
            loaded() {
              return 0 === this._pendingLoads;
            }
            loadTile(t2, e3) {
              const i2 = t2.actor ? "reloadTile" : "loadTile";
              t2.actor = this.actor;
              const o2 = { type: this.type, uid: t2.uid, tileID: t2.tileID, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
              t2.request = this.actor.send(i2, o2, (o3, a2) => (delete t2.request, t2.unloadVectorData(), t2.aborted ? e3(null) : o3 ? e3(o3) : (t2.loadVectorData(a2, this.map.painter, "reloadTile" === i2), e3(null))));
            }
            abortTile(t2) {
              t2.request && (t2.request.cancel(), delete t2.request), t2.aborted = true;
            }
            unloadTile(t2) {
              t2.unloadVectorData(), this.actor.send("removeTile", { uid: t2.uid, type: this.type, source: this.id });
            }
            onRemove() {
              this._removed = true, this.actor.send("removeSource", { type: this.type, source: this.id });
            }
            serialize() {
              return t.extend({}, this._options, { type: this.type, data: this._data });
            }
            hasTransition() {
              return false;
            }
          }
          var S = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
          class D extends t.Evented {
            constructor(t2, e3, i2, o2) {
              super(), this.id = t2, this.dispatcher = i2, this.coordinates = e3.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(o2), this.options = e3;
            }
            load(e3, i2) {
              this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this.url = this.options.url, t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), (o2, a2) => {
                this._loaded = true, o2 ? this.fire(new t.ErrorEvent(o2)) : a2 && (this.image = a2, e3 && (this.coordinates = e3), i2 && i2(), this._finishLoading());
              });
            }
            loaded() {
              return this._loaded;
            }
            updateImage(t2) {
              return this.image && t2.url ? (this.options.url = t2.url, this.load(t2.coordinates, () => {
                this.texture = null;
              }), this) : this;
            }
            _finishLoading() {
              this.map && (this.setCoordinates(this.coordinates), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })));
            }
            onAdd(t2) {
              this.map = t2, this.load();
            }
            setCoordinates(e3) {
              this.coordinates = e3;
              const i2 = e3.map(t.MercatorCoordinate.fromLngLat);
              this.tileID = function(e4) {
                let i3 = 1 / 0, o3 = 1 / 0, a2 = -1 / 0, r2 = -1 / 0;
                for (const t2 of e4)
                  i3 = Math.min(i3, t2.x), o3 = Math.min(o3, t2.y), a2 = Math.max(a2, t2.x), r2 = Math.max(r2, t2.y);
                const s2 = Math.max(a2 - i3, r2 - o3), n2 = Math.max(0, Math.floor(-Math.log(s2) / Math.LN2)), l2 = Math.pow(2, n2);
                return new t.CanonicalTileID(n2, Math.floor((i3 + a2) / 2 * l2), Math.floor((o3 + r2) / 2 * l2));
              }(i2), this.minzoom = this.maxzoom = this.tileID.z;
              const o2 = i2.map((t2) => this.tileID.getTilePoint(t2)._round());
              return this._boundsArray = new t.RasterBoundsArray(), this._boundsArray.emplaceBack(o2[0].x, o2[0].y, 0, 0), this._boundsArray.emplaceBack(o2[1].x, o2[1].y, t.EXTENT, 0), this._boundsArray.emplaceBack(o2[3].x, o2[3].y, 0, t.EXTENT), this._boundsArray.emplaceBack(o2[2].x, o2[2].y, t.EXTENT, t.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })), this;
            }
            prepare() {
              if (0 === Object.keys(this.tiles).length || !this.image)
                return;
              const e3 = this.map.painter.context, i2 = e3.gl;
              this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, S.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new l(e3, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
              for (const t2 in this.tiles) {
                const e4 = this.tiles[t2];
                "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture);
              }
            }
            loadTile(t2, e3) {
              this.tileID && this.tileID.equals(t2.tileID.canonical) ? (this.tiles[String(t2.tileID.wrap)] = t2, t2.buckets = {}, e3(null)) : (t2.state = "errored", e3(null));
            }
            serialize() {
              return { type: "image", url: this.options.url, coordinates: this.coordinates };
            }
            hasTransition() {
              return false;
            }
          }
          class z extends D {
            constructor(t2, e3, i2, o2) {
              super(t2, e3, i2, o2), this.roundZoom = true, this.type = "video", this.options = e3;
            }
            load() {
              this._loaded = false;
              const e3 = this.options;
              this.urls = [];
              for (const i2 of e3.urls)
                this.urls.push(this.map._requestManager.transformRequest(i2, t.ResourceType.Source).url);
              t.getVideo(this.urls, (e4, i2) => {
                this._loaded = true, e4 ? this.fire(new t.ErrorEvent(e4)) : i2 && (this.video = i2, this.video.loop = true, this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading());
              });
            }
            pause() {
              this.video && this.video.pause();
            }
            play() {
              this.video && this.video.play();
            }
            seek(e3) {
              if (this.video) {
                const i2 = this.video.seekable;
                e3 < i2.start(0) || e3 > i2.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = e3;
              }
            }
            getVideo() {
              return this.video;
            }
            onAdd(t2) {
              this.map || (this.map = t2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
            }
            prepare() {
              if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
                return;
              const e3 = this.map.painter.context, i2 = e3.gl;
              this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, S.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new l(e3, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
              for (const t2 in this.tiles) {
                const e4 = this.tiles[t2];
                "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture);
              }
            }
            serialize() {
              return { type: "video", urls: this.urls, coordinates: this.coordinates };
            }
            hasTransition() {
              return this.video && !this.video.paused;
            }
          }
          class P extends D {
            constructor(e3, i2, o2, a2) {
              super(e3, i2, o2, a2), i2.coordinates ? Array.isArray(i2.coordinates) && 4 === i2.coordinates.length && !i2.coordinates.some((t2) => !Array.isArray(t2) || 2 !== t2.length || t2.some((t3) => "number" != typeof t3)) || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e3}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e3}`, null, 'missing required property "coordinates"'))), i2.animate && "boolean" != typeof i2.animate && this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e3}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? "string" == typeof i2.canvas || i2.canvas instanceof HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e3}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.ErrorEvent(new t.ValidationError(`sources.${e3}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = void 0 === i2.animate || i2.animate;
            }
            load() {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            }
            getCanvas() {
              return this.canvas;
            }
            onAdd(t2) {
              this.map = t2, this.load(), this.canvas && this.animate && this.play();
            }
            onRemove() {
              this.pause();
            }
            prepare() {
              let e3 = false;
              if (this.canvas.width !== this.width && (this.width = this.canvas.width, e3 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e3 = true), this._hasInvalidDimensions())
                return;
              if (0 === Object.keys(this.tiles).length)
                return;
              const i2 = this.map.painter.context, o2 = i2.gl;
              this.boundsBuffer || (this.boundsBuffer = i2.createVertexBuffer(this._boundsArray, S.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e3 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new l(i2, this.canvas, o2.RGBA, { premultiply: true });
              for (const t2 in this.tiles) {
                const e4 = this.tiles[t2];
                "loaded" !== e4.state && (e4.state = "loaded", e4.texture = this.texture);
              }
            }
            serialize() {
              return { type: "canvas", coordinates: this.coordinates };
            }
            hasTransition() {
              return this._playing;
            }
            _hasInvalidDimensions() {
              for (const t2 of [this.canvas.width, this.canvas.height])
                if (isNaN(t2) || t2 <= 0)
                  return true;
              return false;
            }
          }
          const M = { vector: w, raster: T, "raster-dem": I, geojson: C, video: z, image: D, canvas: P };
          function A(e3, i2) {
            const o2 = t.create();
            return t.translate(o2, o2, [1, 1, 0]), t.scale(o2, o2, [0.5 * e3.width, 0.5 * e3.height, 1]), t.multiply(o2, o2, e3.calculatePosMatrix(i2.toUnwrapped()));
          }
          function L(t2, e3, i2, o2, a2, r2) {
            const s2 = function(t3, e4, i3) {
              if (t3)
                for (const o3 of t3) {
                  const t4 = e4[o3];
                  if (t4 && t4.source === i3 && "fill-extrusion" === t4.type)
                    return true;
                }
              else
                for (const t4 in e4) {
                  const o3 = e4[t4];
                  if (o3.source === i3 && "fill-extrusion" === o3.type)
                    return true;
                }
              return false;
            }(a2 && a2.layers, e3, t2.id), n2 = r2.maxPitchScaleFactor(), l2 = t2.tilesIn(o2, n2, s2);
            l2.sort(R);
            const c2 = [];
            for (const o3 of l2)
              c2.push({ wrappedTileID: o3.tileID.wrapped().key, queryResults: o3.tile.queryRenderedFeatures(e3, i2, t2._state, o3.queryGeometry, o3.cameraQueryGeometry, o3.scale, a2, r2, n2, A(t2.transform, o3.tileID)) });
            const h2 = function(t3) {
              const e4 = {}, i3 = {};
              for (const o3 of t3) {
                const t4 = o3.queryResults, a3 = o3.wrappedTileID, r3 = i3[a3] = i3[a3] || {};
                for (const i4 in t4) {
                  const o4 = t4[i4], a4 = r3[i4] = r3[i4] || {}, s3 = e4[i4] = e4[i4] || [];
                  for (const t5 of o4)
                    a4[t5.featureIndex] || (a4[t5.featureIndex] = true, s3.push(t5));
                }
              }
              return e4;
            }(c2);
            for (const e4 in h2)
              h2[e4].forEach((e6) => {
                const i3 = e6.feature, o3 = t2.getFeatureState(i3.layer["source-layer"], i3.id);
                i3.source = i3.layer.source, i3.layer["source-layer"] && (i3.sourceLayer = i3.layer["source-layer"]), i3.state = o3;
              });
            return h2;
          }
          function R(t2, e3) {
            const i2 = t2.tileID, o2 = e3.tileID;
            return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
          }
          class k {
            constructor(e3, i2) {
              this.tileID = e3, this.uid = t.uniqueId(), this.uses = 0, this.tileSize = i2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.textures = [], this.textureCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
            }
            registerFadeDuration(e3) {
              const i2 = e3 + this.timeAdded;
              i2 < t.exported.now() || this.fadeEndTime && i2 < this.fadeEndTime || (this.fadeEndTime = i2);
            }
            wasRequested() {
              return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
            }
            clearTextures(t2) {
              this.demTexture && t2.saveTileTexture(this.demTexture), this.textures.forEach((e3) => t2.saveTileTexture(e3)), this.demTexture = null, this.textures = [], this.textureCoords = {};
            }
            loadVectorData(e3, i2, o2) {
              if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e3) {
                e3.featureIndex && (this.latestFeatureIndex = e3.featureIndex, e3.rawTileData ? (this.latestRawTileData = e3.rawTileData, this.latestFeatureIndex.rawTileData = e3.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e3.collisionBoxArray, this.buckets = function(t2, e4) {
                  const i3 = {};
                  if (!e4)
                    return i3;
                  for (const o3 of t2) {
                    const t3 = o3.layerIds.map((t4) => e4.getLayer(t4)).filter(Boolean);
                    if (0 !== t3.length) {
                      o3.layers = t3, o3.stateDependentLayerIds && (o3.stateDependentLayers = o3.stateDependentLayerIds.map((e6) => t3.filter((t4) => t4.id === e6)[0]));
                      for (const e6 of t3)
                        i3[e6.id] = o3;
                    }
                  }
                  return i3;
                }(e3.buckets, i2.style), this.hasSymbolBuckets = false;
                for (const e4 in this.buckets) {
                  const i3 = this.buckets[e4];
                  if (i3 instanceof t.SymbolBucket) {
                    if (this.hasSymbolBuckets = true, !o2)
                      break;
                    i3.justReloaded = true;
                  }
                }
                if (this.hasRTLText = false, this.hasSymbolBuckets)
                  for (const e4 in this.buckets) {
                    const i3 = this.buckets[e4];
                    if (i3 instanceof t.SymbolBucket && i3.hasRTLText) {
                      this.hasRTLText = true, t.lazyLoadRTLTextPlugin();
                      break;
                    }
                  }
                this.queryPadding = 0;
                for (const t2 in this.buckets) {
                  const e4 = this.buckets[t2];
                  this.queryPadding = Math.max(this.queryPadding, i2.style.getLayer(t2).queryRadius(e4));
                }
                e3.imageAtlas && (this.imageAtlas = e3.imageAtlas), e3.glyphAtlasImage && (this.glyphAtlasImage = e3.glyphAtlasImage);
              } else
                this.collisionBoxArray = new t.CollisionBoxArray();
            }
            unloadVectorData() {
              for (const t2 in this.buckets)
                this.buckets[t2].destroy();
              this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
            }
            getBucket(t2) {
              return this.buckets[t2.id];
            }
            upload(t2) {
              for (const e4 in this.buckets) {
                const i2 = this.buckets[e4];
                i2.uploadPending() && i2.upload(t2);
              }
              const e3 = t2.gl;
              this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new l(t2, this.imageAtlas.image, e3.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new l(t2, this.glyphAtlasImage, e3.ALPHA), this.glyphAtlasImage = null);
            }
            prepare(t2) {
              this.imageAtlas && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture);
            }
            queryRenderedFeatures(t2, e3, i2, o2, a2, r2, s2, n2, l2, c2) {
              return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: o2, cameraQueryGeometry: a2, scale: r2, tileSize: this.tileSize, pixelPosMatrix: c2, transform: n2, params: s2, queryPadding: this.queryPadding * l2 }, t2, e3, i2) : {};
            }
            querySourceFeatures(e3, i2) {
              const o2 = this.latestFeatureIndex;
              if (!o2 || !o2.rawTileData)
                return;
              const a2 = o2.loadVTLayers(), r2 = i2 ? i2.sourceLayer : "", s2 = a2._geojsonTileLayer || a2[r2];
              if (!s2)
                return;
              const n2 = t.createFilter(i2 && i2.filter), { z: l2, x: c2, y: h2 } = this.tileID.canonical, u2 = { z: l2, x: c2, y: h2 };
              for (let i3 = 0; i3 < s2.length; i3++) {
                const a3 = s2.feature(i3);
                if (n2.needGeometry) {
                  const e4 = t.toEvaluationFeature(a3, true);
                  if (!n2.filter(new t.EvaluationParameters(this.tileID.overscaledZ), e4, this.tileID.canonical))
                    continue;
                } else if (!n2.filter(new t.EvaluationParameters(this.tileID.overscaledZ), a3))
                  continue;
                const d2 = o2.getId(a3, r2), m2 = new t.GeoJSONFeature(a3, l2, c2, h2, d2);
                m2.tile = u2, e3.push(m2);
              }
            }
            hasData() {
              return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
            }
            patternsLoaded() {
              return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
            }
            setExpiryData(e3) {
              const i2 = this.expirationTime;
              if (e3.cacheControl) {
                const i3 = t.parseCacheControl(e3.cacheControl);
                i3["max-age"] && (this.expirationTime = Date.now() + 1e3 * i3["max-age"]);
              } else
                e3.expires && (this.expirationTime = new Date(e3.expires).getTime());
              if (this.expirationTime) {
                const t2 = Date.now();
                let e4 = false;
                if (this.expirationTime > t2)
                  e4 = false;
                else if (i2)
                  if (this.expirationTime < i2)
                    e4 = true;
                  else {
                    const o2 = this.expirationTime - i2;
                    o2 ? this.expirationTime = t2 + Math.max(o2, 3e4) : e4 = true;
                  }
                else
                  e4 = true;
                e4 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
              }
            }
            getExpiryTimeout() {
              if (this.expirationTime)
                return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
            }
            setFeatureState(t2, e3) {
              if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t2).length)
                return;
              const i2 = this.latestFeatureIndex.loadVTLayers();
              for (const o2 in this.buckets) {
                if (!e3.style.hasLayer(o2))
                  continue;
                const a2 = this.buckets[o2], r2 = a2.layers[0].sourceLayer || "_geojsonTileLayer", s2 = i2[r2], n2 = t2[r2];
                if (!s2 || !n2 || 0 === Object.keys(n2).length)
                  continue;
                a2.update(n2, s2, this.imageAtlas && this.imageAtlas.patternPositions || {});
                const l2 = e3 && e3.style && e3.style.getLayer(o2);
                l2 && (this.queryPadding = Math.max(this.queryPadding, l2.queryRadius(a2)));
              }
            }
            holdingForFade() {
              return void 0 !== this.symbolFadeHoldUntil;
            }
            symbolFadeFinished() {
              return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < t.exported.now();
            }
            clearFadeHold() {
              this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(e3) {
              this.symbolFadeHoldUntil = t.exported.now() + e3;
            }
            setDependencies(t2, e3) {
              const i2 = {};
              for (const t3 of e3)
                i2[t3] = true;
              this.dependencies[t2] = i2;
            }
            hasDependency(t2, e3) {
              for (const i2 of t2) {
                const t3 = this.dependencies[i2];
                if (t3) {
                  for (const i3 of e3)
                    if (t3[i3])
                      return true;
                }
              }
              return false;
            }
          }
          class B2 {
            constructor(t2, e3) {
              this.max = t2, this.onRemove = e3, this.reset();
            }
            reset() {
              for (const t2 in this.data)
                for (const e3 of this.data[t2])
                  e3.timeout && clearTimeout(e3.timeout), this.onRemove(e3.value);
              return this.data = {}, this.order = [], this;
            }
            add(t2, e3, i2) {
              const o2 = t2.wrapped().key;
              void 0 === this.data[o2] && (this.data[o2] = []);
              const a2 = { value: e3, timeout: void 0 };
              if (void 0 !== i2 && (a2.timeout = setTimeout(() => {
                this.remove(t2, a2);
              }, i2)), this.data[o2].push(a2), this.order.push(o2), this.order.length > this.max) {
                const t3 = this._getAndRemoveByKey(this.order[0]);
                t3 && this.onRemove(t3);
              }
              return this;
            }
            has(t2) {
              return t2.wrapped().key in this.data;
            }
            getAndRemove(t2) {
              return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
            }
            _getAndRemoveByKey(t2) {
              const e3 = this.data[t2].shift();
              return e3.timeout && clearTimeout(e3.timeout), 0 === this.data[t2].length && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e3.value;
            }
            getByKey(t2) {
              const e3 = this.data[t2];
              return e3 ? e3[0].value : null;
            }
            get(t2) {
              return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
            }
            remove(t2, e3) {
              if (!this.has(t2))
                return this;
              const i2 = t2.wrapped().key, o2 = void 0 === e3 ? 0 : this.data[i2].indexOf(e3), a2 = this.data[i2][o2];
              return this.data[i2].splice(o2, 1), a2.timeout && clearTimeout(a2.timeout), 0 === this.data[i2].length && delete this.data[i2], this.onRemove(a2.value), this.order.splice(this.order.indexOf(i2), 1), this;
            }
            setMaxSize(t2) {
              for (this.max = t2; this.order.length > this.max; ) {
                const t3 = this._getAndRemoveByKey(this.order[0]);
                t3 && this.onRemove(t3);
              }
              return this;
            }
            filter(t2) {
              const e3 = [];
              for (const i2 in this.data)
                for (const o2 of this.data[i2])
                  t2(o2.value) || e3.push(o2);
              for (const t3 of e3)
                this.remove(t3.value.tileID, t3);
            }
          }
          class F {
            constructor() {
              this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }
            updateState(e3, i2, o2) {
              const a2 = String(i2);
              if (this.stateChanges[e3] = this.stateChanges[e3] || {}, this.stateChanges[e3][a2] = this.stateChanges[e3][a2] || {}, t.extend(this.stateChanges[e3][a2], o2), null === this.deletedStates[e3]) {
                this.deletedStates[e3] = {};
                for (const t2 in this.state[e3])
                  t2 !== a2 && (this.deletedStates[e3][t2] = null);
              } else if (this.deletedStates[e3] && null === this.deletedStates[e3][a2]) {
                this.deletedStates[e3][a2] = {};
                for (const t2 in this.state[e3][a2])
                  o2[t2] || (this.deletedStates[e3][a2][t2] = null);
              } else
                for (const t2 in o2)
                  this.deletedStates[e3] && this.deletedStates[e3][a2] && null === this.deletedStates[e3][a2][t2] && delete this.deletedStates[e3][a2][t2];
            }
            removeFeatureState(t2, e3, i2) {
              if (null === this.deletedStates[t2])
                return;
              const o2 = String(e3);
              if (this.deletedStates[t2] = this.deletedStates[t2] || {}, i2 && void 0 !== e3)
                null !== this.deletedStates[t2][o2] && (this.deletedStates[t2][o2] = this.deletedStates[t2][o2] || {}, this.deletedStates[t2][o2][i2] = null);
              else if (void 0 !== e3)
                if (this.stateChanges[t2] && this.stateChanges[t2][o2])
                  for (i2 in this.deletedStates[t2][o2] = {}, this.stateChanges[t2][o2])
                    this.deletedStates[t2][o2][i2] = null;
                else
                  this.deletedStates[t2][o2] = null;
              else
                this.deletedStates[t2] = null;
            }
            getState(e3, i2) {
              const o2 = String(i2), a2 = t.extend({}, (this.state[e3] || {})[o2], (this.stateChanges[e3] || {})[o2]);
              if (null === this.deletedStates[e3])
                return {};
              if (this.deletedStates[e3]) {
                const t2 = this.deletedStates[e3][i2];
                if (null === t2)
                  return {};
                for (const e4 in t2)
                  delete a2[e4];
              }
              return a2;
            }
            initializeTileState(t2, e3) {
              t2.setFeatureState(this.state, e3);
            }
            coalesceChanges(e3, i2) {
              const o2 = {};
              for (const e4 in this.stateChanges) {
                this.state[e4] = this.state[e4] || {};
                const i3 = {};
                for (const o3 in this.stateChanges[e4])
                  this.state[e4][o3] || (this.state[e4][o3] = {}), t.extend(this.state[e4][o3], this.stateChanges[e4][o3]), i3[o3] = this.state[e4][o3];
                o2[e4] = i3;
              }
              for (const e4 in this.deletedStates) {
                this.state[e4] = this.state[e4] || {};
                const i3 = {};
                if (null === this.deletedStates[e4])
                  for (const t2 in this.state[e4])
                    i3[t2] = {}, this.state[e4][t2] = {};
                else
                  for (const t2 in this.deletedStates[e4]) {
                    if (null === this.deletedStates[e4][t2])
                      this.state[e4][t2] = {};
                    else
                      for (const i4 of Object.keys(this.deletedStates[e4][t2]))
                        delete this.state[e4][t2][i4];
                    i3[t2] = this.state[e4][t2];
                  }
                o2[e4] = o2[e4] || {}, t.extend(o2[e4], i3);
              }
              if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(o2).length)
                for (const t2 in e3)
                  e3[t2].setFeatureState(o2, i2);
            }
          }
          class O extends t.Evented {
            constructor(e3, i2, o2) {
              super(), this.id = e3, this.dispatcher = o2, this.on("data", (t2) => {
                "source" === t2.dataType && "metadata" === t2.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === t2.dataType && "content" === t2.sourceDataType && (this.reload(), this.transform && this.update(this.transform, this.terrain));
              }), this.on("dataloading", () => {
                this._sourceErrored = false;
              }), this.on("error", () => {
                this._sourceErrored = this._source.loaded();
              }), this._source = function(e4, i3, o3, a2) {
                const r2 = new M[i3.type](e4, i3, o3, a2);
                if (r2.id !== e4)
                  throw new Error(`Expected Source id to be ${e4} instead of ${r2.id}`);
                return t.bindAll(["load", "abort", "unload", "serialize", "prepare"], r2), r2;
              }(e3, i2, o2, this), this._tiles = {}, this._cache = new B2(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new F();
            }
            onAdd(t2) {
              this.map = t2, this._maxTileCacheSize = t2 ? t2._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(t2);
            }
            onRemove(t2) {
              this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t2);
            }
            loaded() {
              if (this._sourceErrored)
                return true;
              if (!this._sourceLoaded)
                return false;
              if (!this._source.loaded())
                return false;
              for (const t2 in this._tiles) {
                const e3 = this._tiles[t2];
                if ("loaded" !== e3.state && "errored" !== e3.state)
                  return false;
              }
              return true;
            }
            getSource() {
              return this._source;
            }
            pause() {
              this._paused = true;
            }
            resume() {
              if (!this._paused)
                return;
              const t2 = this._shouldReloadOnResume;
              this._paused = false, this._shouldReloadOnResume = false, t2 && this.reload(), this.transform && this.update(this.transform, this.terrain);
            }
            _loadTile(t2, e3) {
              return this._source.loadTile(t2, e3);
            }
            _unloadTile(t2) {
              if (this._source.unloadTile)
                return this._source.unloadTile(t2, () => {
                });
            }
            _abortTile(e3) {
              this._source.abortTile && this._source.abortTile(e3, () => {
              }), this._source.fire(new t.Event("dataabort", { tile: e3, coord: e3.tileID, dataType: "source" }));
            }
            serialize() {
              return this._source.serialize();
            }
            prepare(t2) {
              this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
              for (const e3 in this._tiles) {
                const i2 = this._tiles[e3];
                i2.upload(t2), i2.prepare(this.map.style.imageManager);
              }
            }
            getIds() {
              return Object.values(this._tiles).map((t2) => t2.tileID).sort(U).map((t2) => t2.key);
            }
            getRenderableIds(e3) {
              const i2 = [];
              for (const t2 in this._tiles)
                this._isIdRenderable(t2, e3) && i2.push(this._tiles[t2]);
              return e3 ? i2.sort((e4, i3) => {
                const o2 = e4.tileID, a2 = i3.tileID, r2 = new t.pointGeometry(o2.canonical.x, o2.canonical.y)._rotate(this.transform.angle), s2 = new t.pointGeometry(a2.canonical.x, a2.canonical.y)._rotate(this.transform.angle);
                return o2.overscaledZ - a2.overscaledZ || s2.y - r2.y || s2.x - r2.x;
              }).map((t2) => t2.tileID.key) : i2.map((t2) => t2.tileID).sort(U).map((t2) => t2.key);
            }
            hasRenderableParent(t2) {
              const e3 = this.findLoadedParent(t2, 0);
              return !!e3 && this._isIdRenderable(e3.tileID.key);
            }
            _isIdRenderable(t2, e3) {
              return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e3 || !this._tiles[t2].holdingForFade());
            }
            reload() {
              if (this._paused)
                this._shouldReloadOnResume = true;
              else {
                this._cache.reset();
                for (const t2 in this._tiles)
                  "errored" !== this._tiles[t2].state && this._reloadTile(t2, "reloading");
              }
            }
            _reloadTile(t2, e3) {
              const i2 = this._tiles[t2];
              i2 && ("loading" !== i2.state && (i2.state = e3), this._loadTile(i2, this._tileLoaded.bind(this, i2, t2, e3)));
            }
            _tileLoaded(e3, i2, o2, a2) {
              if (a2)
                return e3.state = "errored", void (404 !== a2.status ? this._source.fire(new t.ErrorEvent(a2, { tile: e3 })) : this.update(this.transform, this.terrain));
              e3.timeAdded = t.exported.now(), "expired" === o2 && (e3.refreshedUponExpiration = true), this._setTileReloadTimer(i2, e3), "raster-dem" === this.getSource().type && e3.dem && this._backfillDEM(e3), this._state.initializeTileState(e3, this.map ? this.map.painter : null), e3.aborted || this._source.fire(new t.Event("data", { dataType: "source", tile: e3, coord: e3.tileID }));
            }
            _backfillDEM(t2) {
              const e3 = this.getRenderableIds();
              for (let o2 = 0; o2 < e3.length; o2++) {
                const a2 = e3[o2];
                if (t2.neighboringTiles && t2.neighboringTiles[a2]) {
                  const e4 = this.getTileByID(a2);
                  i2(t2, e4), i2(e4, t2);
                }
              }
              function i2(t3, e4) {
                t3.needsHillshadePrepare = true, t3.needsTerrainPrepare = true;
                let i3 = e4.tileID.canonical.x - t3.tileID.canonical.x;
                const o2 = e4.tileID.canonical.y - t3.tileID.canonical.y, a2 = Math.pow(2, t3.tileID.canonical.z), r2 = e4.tileID.key;
                0 === i3 && 0 === o2 || Math.abs(o2) > 1 || (Math.abs(i3) > 1 && (1 === Math.abs(i3 + a2) ? i3 += a2 : 1 === Math.abs(i3 - a2) && (i3 -= a2)), e4.dem && t3.dem && (t3.dem.backfillBorder(e4.dem, i3, o2), t3.neighboringTiles && t3.neighboringTiles[r2] && (t3.neighboringTiles[r2].backfilled = true)));
              }
            }
            getTile(t2) {
              return this.getTileByID(t2.key);
            }
            getTileByID(t2) {
              return this._tiles[t2];
            }
            _retainLoadedChildren(t2, e3, i2, o2) {
              for (const a2 in this._tiles) {
                let r2 = this._tiles[a2];
                if (o2[a2] || !r2.hasData() || r2.tileID.overscaledZ <= e3 || r2.tileID.overscaledZ > i2)
                  continue;
                let s2 = r2.tileID;
                for (; r2 && r2.tileID.overscaledZ > e3 + 1; ) {
                  const t3 = r2.tileID.scaledTo(r2.tileID.overscaledZ - 1);
                  r2 = this._tiles[t3.key], r2 && r2.hasData() && (s2 = t3);
                }
                let n2 = s2;
                for (; n2.overscaledZ > e3; )
                  if (n2 = n2.scaledTo(n2.overscaledZ - 1), t2[n2.key]) {
                    o2[s2.key] = s2;
                    break;
                  }
              }
            }
            findLoadedParent(t2, e3) {
              if (t2.key in this._loadedParentTiles) {
                const i2 = this._loadedParentTiles[t2.key];
                return i2 && i2.tileID.overscaledZ >= e3 ? i2 : null;
              }
              for (let i2 = t2.overscaledZ - 1; i2 >= e3; i2--) {
                const e4 = t2.scaledTo(i2), o2 = this._getLoadedTile(e4);
                if (o2)
                  return o2;
              }
            }
            _getLoadedTile(t2) {
              const e3 = this._tiles[t2.key];
              return e3 && e3.hasData() ? e3 : this._cache.getByKey(t2.wrapped().key);
            }
            updateCacheSize(t2) {
              const e3 = Math.ceil(t2.width / this._source.tileSize) + 1, i2 = Math.ceil(t2.height / this._source.tileSize) + 1, o2 = Math.floor(e3 * i2 * 5), a2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o2) : o2;
              this._cache.setMaxSize(a2);
            }
            handleWrapJump(t2) {
              const e3 = Math.round((t2 - (void 0 === this._prevLng ? t2 : this._prevLng)) / 360);
              if (this._prevLng = t2, e3) {
                const t3 = {};
                for (const i2 in this._tiles) {
                  const o2 = this._tiles[i2];
                  o2.tileID = o2.tileID.unwrapTo(o2.tileID.wrap + e3), t3[o2.tileID.key] = o2;
                }
                this._tiles = t3;
                for (const t4 in this._timers)
                  clearTimeout(this._timers[t4]), delete this._timers[t4];
                for (const t4 in this._tiles)
                  this._setTileReloadTimer(t4, this._tiles[t4]);
              }
            }
            update(e3, i2) {
              if (this.transform = e3, this.terrain = i2, !this._sourceLoaded || this._paused)
                return;
              let o2;
              this.updateCacheSize(e3), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? o2 = e3.getVisibleUnwrappedCoordinates(this._source.tileID).map((e4) => new t.OverscaledTileID(e4.canonical.z, e4.wrap, e4.canonical.z, e4.canonical.x, e4.canonical.y)) : (o2 = e3.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i2 }), this._source.hasTile && (o2 = o2.filter((t2) => this._source.hasTile(t2)))) : o2 = [];
              const a2 = e3.coveringZoomLevel(this._source), r2 = Math.max(a2 - O.maxOverzooming, this._source.minzoom), s2 = Math.max(a2 + O.maxUnderzooming, this._source.minzoom);
              if (this.usedForTerrain) {
                const t2 = {};
                for (const e4 of o2)
                  if (e4.canonical.z > this._source.minzoom) {
                    const i3 = e4.scaledTo(e4.canonical.z - 1);
                    t2[i3.key] = i3;
                    const o3 = e4.scaledTo(Math.max(this._source.minzoom, Math.min(e4.canonical.z, 5)));
                    t2[o3.key] = o3;
                  }
                o2 = o2.concat(Object.values(t2));
              }
              const n2 = this._updateRetainedTiles(o2, a2);
              if (N(this._source.type)) {
                const e4 = {}, l3 = {}, c2 = Object.keys(n2);
                for (const i3 of c2) {
                  const o3 = n2[i3], a3 = this._tiles[i3];
                  if (!a3 || a3.fadeEndTime && a3.fadeEndTime <= t.exported.now())
                    continue;
                  const s3 = this.findLoadedParent(o3, r2);
                  s3 && (this._addTile(s3.tileID), e4[s3.tileID.key] = s3.tileID), l3[i3] = o3;
                }
                this._retainLoadedChildren(l3, a2, s2, n2);
                for (const t2 in e4)
                  n2[t2] || (this._coveredTiles[t2] = true, n2[t2] = e4[t2]);
                if (i2) {
                  const t2 = {}, e6 = {};
                  for (const i3 of o2)
                    this._tiles[i3.key].hasData() ? t2[i3.key] = i3 : e6[i3.key] = i3;
                  for (const i3 in e6) {
                    const o3 = e6[i3].children(this._source.maxzoom);
                    this._tiles[o3[0].key] && this._tiles[o3[1].key] && this._tiles[o3[2].key] && this._tiles[o3[3].key] && (t2[o3[0].key] = n2[o3[0].key] = o3[0], t2[o3[1].key] = n2[o3[1].key] = o3[1], t2[o3[2].key] = n2[o3[2].key] = o3[2], t2[o3[3].key] = n2[o3[3].key] = o3[3], delete e6[i3]);
                  }
                  for (const i3 in e6) {
                    const o3 = this.findLoadedParent(e6[i3], this._source.minzoom);
                    if (o3) {
                      t2[o3.tileID.key] = n2[o3.tileID.key] = o3.tileID;
                      for (const e7 in t2)
                        t2[e7].isChildOf(o3.tileID) && delete t2[e7];
                    }
                  }
                  for (const e7 in this._tiles)
                    t2[e7] || (this._coveredTiles[e7] = true);
                }
              }
              for (const t2 in n2)
                this._tiles[t2].clearFadeHold();
              const l2 = t.keysDifference(this._tiles, n2);
              for (const t2 of l2) {
                const e4 = this._tiles[t2];
                e4.hasSymbolBuckets && !e4.holdingForFade() ? e4.setHoldDuration(this.map._fadeDuration) : e4.hasSymbolBuckets && !e4.symbolFadeFinished() || this._removeTile(t2);
              }
              this._updateLoadedParentTileCache();
            }
            releaseSymbolFadeTiles() {
              for (const t2 in this._tiles)
                this._tiles[t2].holdingForFade() && this._removeTile(t2);
            }
            _updateRetainedTiles(t2, e3) {
              const i2 = {}, o2 = {}, a2 = Math.max(e3 - O.maxOverzooming, this._source.minzoom), r2 = Math.max(e3 + O.maxUnderzooming, this._source.minzoom), s2 = {};
              for (const o3 of t2) {
                const t3 = this._addTile(o3);
                i2[o3.key] = o3, t3.hasData() || e3 < this._source.maxzoom && (s2[o3.key] = o3);
              }
              this._retainLoadedChildren(s2, e3, r2, i2);
              for (const r3 of t2) {
                let t3 = this._tiles[r3.key];
                if (t3.hasData())
                  continue;
                if (e3 + 1 > this._source.maxzoom) {
                  const t4 = r3.children(this._source.maxzoom)[0], e4 = this.getTile(t4);
                  if (e4 && e4.hasData()) {
                    i2[t4.key] = t4;
                    continue;
                  }
                } else {
                  const t4 = r3.children(this._source.maxzoom);
                  if (i2[t4[0].key] && i2[t4[1].key] && i2[t4[2].key] && i2[t4[3].key])
                    continue;
                }
                let s3 = t3.wasRequested();
                for (let e4 = r3.overscaledZ - 1; e4 >= a2; --e4) {
                  const a3 = r3.scaledTo(e4);
                  if (o2[a3.key])
                    break;
                  if (o2[a3.key] = true, t3 = this.getTile(a3), !t3 && s3 && (t3 = this._addTile(a3)), t3 && (i2[a3.key] = a3, s3 = t3.wasRequested(), t3.hasData()))
                    break;
                }
              }
              return i2;
            }
            _updateLoadedParentTileCache() {
              this._loadedParentTiles = {};
              for (const t2 in this._tiles) {
                const e3 = [];
                let i2, o2 = this._tiles[t2].tileID;
                for (; o2.overscaledZ > 0; ) {
                  if (o2.key in this._loadedParentTiles) {
                    i2 = this._loadedParentTiles[o2.key];
                    break;
                  }
                  e3.push(o2.key);
                  const t3 = o2.scaledTo(o2.overscaledZ - 1);
                  if (i2 = this._getLoadedTile(t3), i2)
                    break;
                  o2 = t3;
                }
                for (const t3 of e3)
                  this._loadedParentTiles[t3] = i2;
              }
            }
            _addTile(e3) {
              let i2 = this._tiles[e3.key];
              if (i2)
                return i2;
              i2 = this._cache.getAndRemove(e3), i2 && (this._setTileReloadTimer(e3.key, i2), i2.tileID = e3, this._state.initializeTileState(i2, this.map ? this.map.painter : null), this._cacheTimers[e3.key] && (clearTimeout(this._cacheTimers[e3.key]), delete this._cacheTimers[e3.key], this._setTileReloadTimer(e3.key, i2)));
              const o2 = i2;
              return i2 || (i2 = new k(e3, this._source.tileSize * e3.overscaleFactor()), this._loadTile(i2, this._tileLoaded.bind(this, i2, e3.key, i2.state))), i2.uses++, this._tiles[e3.key] = i2, o2 || this._source.fire(new t.Event("dataloading", { tile: i2, coord: i2.tileID, dataType: "source" })), i2;
            }
            _setTileReloadTimer(t2, e3) {
              t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
              const i2 = e3.getExpiryTimeout();
              i2 && (this._timers[t2] = setTimeout(() => {
                this._reloadTile(t2, "expired"), delete this._timers[t2];
              }, i2));
            }
            _removeTile(t2) {
              const e3 = this._tiles[t2];
              e3 && (e3.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e3.uses > 0 || (e3.hasData() && "reloading" !== e3.state ? this._cache.add(e3.tileID, e3, e3.getExpiryTimeout()) : (e3.aborted = true, this._abortTile(e3), this._unloadTile(e3))));
            }
            clearTiles() {
              this._shouldReloadOnResume = false, this._paused = false;
              for (const t2 in this._tiles)
                this._removeTile(t2);
              this._cache.reset();
            }
            tilesIn(e3, i2, o2) {
              const a2 = [], r2 = this.transform;
              if (!r2)
                return a2;
              const s2 = o2 ? r2.getCameraQueryGeometry(e3) : e3, n2 = e3.map((t2) => r2.pointCoordinate(t2, this.terrain)), l2 = s2.map((t2) => r2.pointCoordinate(t2, this.terrain)), c2 = this.getIds();
              let h2 = 1 / 0, u2 = 1 / 0, d2 = -1 / 0, m2 = -1 / 0;
              for (const t2 of l2)
                h2 = Math.min(h2, t2.x), u2 = Math.min(u2, t2.y), d2 = Math.max(d2, t2.x), m2 = Math.max(m2, t2.y);
              for (let e4 = 0; e4 < c2.length; e4++) {
                const o3 = this._tiles[c2[e4]];
                if (o3.holdingForFade())
                  continue;
                const s3 = o3.tileID, _2 = Math.pow(2, r2.zoom - o3.tileID.overscaledZ), p2 = i2 * o3.queryPadding * t.EXTENT / o3.tileSize / _2, f2 = [s3.getTilePoint(new t.MercatorCoordinate(h2, u2)), s3.getTilePoint(new t.MercatorCoordinate(d2, m2))];
                if (f2[0].x - p2 < t.EXTENT && f2[0].y - p2 < t.EXTENT && f2[1].x + p2 >= 0 && f2[1].y + p2 >= 0) {
                  const t2 = n2.map((t3) => s3.getTilePoint(t3)), e6 = l2.map((t3) => s3.getTilePoint(t3));
                  a2.push({ tile: o3, tileID: s3, queryGeometry: t2, cameraQueryGeometry: e6, scale: _2 });
                }
              }
              return a2;
            }
            getVisibleCoordinates(t2) {
              const e3 = this.getRenderableIds(t2).map((t3) => this._tiles[t3].tileID);
              for (const t3 of e3)
                t3.posMatrix = this.transform.calculatePosMatrix(t3.toUnwrapped());
              return e3;
            }
            hasTransition() {
              if (this._source.hasTransition())
                return true;
              if (N(this._source.type))
                for (const e3 in this._tiles) {
                  const i2 = this._tiles[e3];
                  if (void 0 !== i2.fadeEndTime && i2.fadeEndTime >= t.exported.now())
                    return true;
                }
              return false;
            }
            setFeatureState(t2, e3, i2) {
              this._state.updateState(t2 = t2 || "_geojsonTileLayer", e3, i2);
            }
            removeFeatureState(t2, e3, i2) {
              this._state.removeFeatureState(t2 = t2 || "_geojsonTileLayer", e3, i2);
            }
            getFeatureState(t2, e3) {
              return this._state.getState(t2 = t2 || "_geojsonTileLayer", e3);
            }
            setDependencies(t2, e3, i2) {
              const o2 = this._tiles[t2];
              o2 && o2.setDependencies(e3, i2);
            }
            reloadTilesForDependencies(t2, e3) {
              for (const i2 in this._tiles)
                this._tiles[i2].hasDependency(t2, e3) && this._reloadTile(i2, "reloading");
              this._cache.filter((i2) => !i2.hasDependency(t2, e3));
            }
          }
          function U(t2, e3) {
            const i2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), o2 = Math.abs(2 * e3.wrap) - +(e3.wrap < 0);
            return t2.overscaledZ - e3.overscaledZ || o2 - i2 || e3.canonical.y - t2.canonical.y || e3.canonical.x - t2.canonical.x;
          }
          function N(t2) {
            return "raster" === t2 || "image" === t2 || "video" === t2;
          }
          O.maxOverzooming = 10, O.maxUnderzooming = 3;
          const G = "mapboxgl_preloaded_worker_pool";
          class Z {
            constructor() {
              this.active = {};
            }
            acquire(t2) {
              if (!this.workers)
                for (this.workers = []; this.workers.length < Z.workerCount; )
                  this.workers.push(new Worker(ba.workerUrl));
              return this.active[t2] = true, this.workers.slice();
            }
            release(t2) {
              delete this.active[t2], 0 === this.numActive() && (this.workers.forEach((t3) => {
                t3.terminate();
              }), this.workers = null);
            }
            isPreloaded() {
              return !!this.active[G];
            }
            numActive() {
              return Object.keys(this.active).length;
            }
          }
          const V = Math.floor(t.exported.hardwareConcurrency / 2);
          let q;
          function j() {
            return q || (q = new Z()), q;
          }
          function $(e3, i2) {
            const o2 = {};
            for (const t2 in e3)
              "ref" !== t2 && (o2[t2] = e3[t2]);
            return t.refProperties.forEach((t2) => {
              t2 in i2 && (o2[t2] = i2[t2]);
            }), o2;
          }
          function X(t2) {
            t2 = t2.slice();
            const e3 = /* @__PURE__ */ Object.create(null);
            for (let i2 = 0; i2 < t2.length; i2++)
              e3[t2[i2].id] = t2[i2];
            for (let i2 = 0; i2 < t2.length; i2++)
              "ref" in t2[i2] && (t2[i2] = $(t2[i2], e3[t2[i2].ref]));
            return t2;
          }
          Z.workerCount = Math.max(Math.min(V, 6), 1);
          const W = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
          function H(t2, e3, i2) {
            i2.push({ command: W.addSource, args: [t2, e3[t2]] });
          }
          function K(t2, e3, i2) {
            e3.push({ command: W.removeSource, args: [t2] }), i2[t2] = true;
          }
          function Y(t2, e3, i2, o2) {
            K(t2, i2, o2), H(t2, e3, i2);
          }
          function J(t2, e3, i2) {
            let o2;
            for (o2 in t2[i2])
              if (Object.prototype.hasOwnProperty.call(t2[i2], o2) && "data" !== o2 && !a(t2[i2][o2], e3[i2][o2]))
                return false;
            for (o2 in e3[i2])
              if (Object.prototype.hasOwnProperty.call(e3[i2], o2) && "data" !== o2 && !a(t2[i2][o2], e3[i2][o2]))
                return false;
            return true;
          }
          function Q(t2, e3, i2, o2, r2, s2) {
            let n2;
            for (n2 in e3 = e3 || {}, t2 = t2 || {})
              Object.prototype.hasOwnProperty.call(t2, n2) && (a(t2[n2], e3[n2]) || i2.push({ command: s2, args: [o2, n2, e3[n2], r2] }));
            for (n2 in e3)
              Object.prototype.hasOwnProperty.call(e3, n2) && !Object.prototype.hasOwnProperty.call(t2, n2) && (a(t2[n2], e3[n2]) || i2.push({ command: s2, args: [o2, n2, e3[n2], r2] }));
          }
          function tt(t2) {
            return t2.id;
          }
          function et(t2, e3) {
            return t2[e3.id] = e3, t2;
          }
          class it {
            constructor(t2, e3) {
              this.reset(t2, e3);
            }
            reset(t2, e3) {
              this.points = t2 || [], this._distances = [0];
              for (let t3 = 1; t3 < this.points.length; t3++)
                this._distances[t3] = this._distances[t3 - 1] + this.points[t3].dist(this.points[t3 - 1]);
              this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e3 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(e3) {
              if (1 === this.points.length)
                return this.points[0];
              e3 = t.clamp(e3, 0, 1);
              let i2 = 1, o2 = this._distances[i2];
              const a2 = e3 * this.paddedLength + this.padding;
              for (; o2 < a2 && i2 < this._distances.length; )
                o2 = this._distances[++i2];
              const r2 = i2 - 1, s2 = this._distances[r2], n2 = o2 - s2, l2 = n2 > 0 ? (a2 - s2) / n2 : 0;
              return this.points[r2].mult(1 - l2).add(this.points[i2].mult(l2));
            }
          }
          function ot(t2, e3) {
            let i2 = true;
            return "always" === t2 || "never" !== t2 && "never" !== e3 || (i2 = false), i2;
          }
          class at {
            constructor(t2, e3, i2) {
              const o2 = this.boxCells = [], a2 = this.circleCells = [];
              this.xCellCount = Math.ceil(t2 / i2), this.yCellCount = Math.ceil(e3 / i2);
              for (let t3 = 0; t3 < this.xCellCount * this.yCellCount; t3++)
                o2.push([]), a2.push([]);
              this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t2, this.height = e3, this.xScale = this.xCellCount / t2, this.yScale = this.yCellCount / e3, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
              return this.boxKeys.length + this.circleKeys.length;
            }
            insert(t2, e3, i2, o2, a2) {
              this._forEachCell(e3, i2, o2, a2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t2), this.bboxes.push(e3), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(a2);
            }
            insertCircle(t2, e3, i2, o2) {
              this._forEachCell(e3 - o2, i2 - o2, e3 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t2), this.circles.push(e3), this.circles.push(i2), this.circles.push(o2);
            }
            _insertBoxCell(t2, e3, i2, o2, a2, r2) {
              this.boxCells[a2].push(r2);
            }
            _insertCircleCell(t2, e3, i2, o2, a2, r2) {
              this.circleCells[a2].push(r2);
            }
            _query(t2, e3, i2, o2, a2, r2, s2) {
              if (i2 < 0 || t2 > this.width || o2 < 0 || e3 > this.height)
                return [];
              const n2 = [];
              if (t2 <= 0 && e3 <= 0 && this.width <= i2 && this.height <= o2) {
                if (a2)
                  return [{ key: null, x1: t2, y1: e3, x2: i2, y2: o2 }];
                for (let t3 = 0; t3 < this.boxKeys.length; t3++)
                  n2.push({ key: this.boxKeys[t3], x1: this.bboxes[4 * t3], y1: this.bboxes[4 * t3 + 1], x2: this.bboxes[4 * t3 + 2], y2: this.bboxes[4 * t3 + 3] });
                for (let t3 = 0; t3 < this.circleKeys.length; t3++) {
                  const e4 = this.circles[3 * t3], i3 = this.circles[3 * t3 + 1], o3 = this.circles[3 * t3 + 2];
                  n2.push({ key: this.circleKeys[t3], x1: e4 - o3, y1: i3 - o3, x2: e4 + o3, y2: i3 + o3 });
                }
              } else
                this._forEachCell(t2, e3, i2, o2, this._queryCell, n2, { hitTest: a2, overlapMode: r2, seenUids: { box: {}, circle: {} } }, s2);
              return n2;
            }
            query(t2, e3, i2, o2) {
              return this._query(t2, e3, i2, o2, false, null);
            }
            hitTest(t2, e3, i2, o2, a2, r2) {
              return this._query(t2, e3, i2, o2, true, a2, r2).length > 0;
            }
            hitTestCircle(t2, e3, i2, o2, a2) {
              const r2 = t2 - i2, s2 = t2 + i2, n2 = e3 - i2, l2 = e3 + i2;
              if (s2 < 0 || r2 > this.width || l2 < 0 || n2 > this.height)
                return false;
              const c2 = [];
              return this._forEachCell(r2, n2, s2, l2, this._queryCellCircle, c2, { hitTest: true, overlapMode: o2, circle: { x: t2, y: e3, radius: i2 }, seenUids: { box: {}, circle: {} } }, a2), c2.length > 0;
            }
            _queryCell(t2, e3, i2, o2, a2, r2, s2, n2) {
              const { seenUids: l2, hitTest: c2, overlapMode: h2 } = s2, u2 = this.boxCells[a2];
              if (null !== u2) {
                const a3 = this.bboxes;
                for (const s3 of u2)
                  if (!l2.box[s3]) {
                    l2.box[s3] = true;
                    const u3 = 4 * s3, d3 = this.boxKeys[s3];
                    if (t2 <= a3[u3 + 2] && e3 <= a3[u3 + 3] && i2 >= a3[u3 + 0] && o2 >= a3[u3 + 1] && (!n2 || n2(d3)) && (!c2 || !ot(h2, d3.overlapMode)) && (r2.push({ key: d3, x1: a3[u3], y1: a3[u3 + 1], x2: a3[u3 + 2], y2: a3[u3 + 3] }), c2))
                      return true;
                  }
              }
              const d2 = this.circleCells[a2];
              if (null !== d2) {
                const a3 = this.circles;
                for (const s3 of d2)
                  if (!l2.circle[s3]) {
                    l2.circle[s3] = true;
                    const u3 = 3 * s3, d3 = this.circleKeys[s3];
                    if (this._circleAndRectCollide(a3[u3], a3[u3 + 1], a3[u3 + 2], t2, e3, i2, o2) && (!n2 || n2(d3)) && (!c2 || !ot(h2, d3.overlapMode))) {
                      const t3 = a3[u3], e4 = a3[u3 + 1], i3 = a3[u3 + 2];
                      if (r2.push({ key: d3, x1: t3 - i3, y1: e4 - i3, x2: t3 + i3, y2: e4 + i3 }), c2)
                        return true;
                    }
                  }
              }
              return false;
            }
            _queryCellCircle(t2, e3, i2, o2, a2, r2, s2, n2) {
              const { circle: l2, seenUids: c2, overlapMode: h2 } = s2, u2 = this.boxCells[a2];
              if (null !== u2) {
                const t3 = this.bboxes;
                for (const e4 of u2)
                  if (!c2.box[e4]) {
                    c2.box[e4] = true;
                    const i3 = 4 * e4, o3 = this.boxKeys[e4];
                    if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, t3[i3 + 0], t3[i3 + 1], t3[i3 + 2], t3[i3 + 3]) && (!n2 || n2(o3)) && !ot(h2, o3.overlapMode))
                      return r2.push(true), true;
                  }
              }
              const d2 = this.circleCells[a2];
              if (null !== d2) {
                const t3 = this.circles;
                for (const e4 of d2)
                  if (!c2.circle[e4]) {
                    c2.circle[e4] = true;
                    const i3 = 3 * e4, o3 = this.circleKeys[e4];
                    if (this._circlesCollide(t3[i3], t3[i3 + 1], t3[i3 + 2], l2.x, l2.y, l2.radius) && (!n2 || n2(o3)) && !ot(h2, o3.overlapMode))
                      return r2.push(true), true;
                  }
              }
            }
            _forEachCell(t2, e3, i2, o2, a2, r2, s2, n2) {
              const l2 = this._convertToXCellCoord(t2), c2 = this._convertToYCellCoord(e3), h2 = this._convertToXCellCoord(i2), u2 = this._convertToYCellCoord(o2);
              for (let d2 = l2; d2 <= h2; d2++)
                for (let l3 = c2; l3 <= u2; l3++)
                  if (a2.call(this, t2, e3, i2, o2, this.xCellCount * l3 + d2, r2, s2, n2))
                    return;
            }
            _convertToXCellCoord(t2) {
              return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t2 * this.xScale)));
            }
            _convertToYCellCoord(t2) {
              return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t2 * this.yScale)));
            }
            _circlesCollide(t2, e3, i2, o2, a2, r2) {
              const s2 = o2 - t2, n2 = a2 - e3, l2 = i2 + r2;
              return l2 * l2 > s2 * s2 + n2 * n2;
            }
            _circleAndRectCollide(t2, e3, i2, o2, a2, r2, s2) {
              const n2 = (r2 - o2) / 2, l2 = Math.abs(t2 - (o2 + n2));
              if (l2 > n2 + i2)
                return false;
              const c2 = (s2 - a2) / 2, h2 = Math.abs(e3 - (a2 + c2));
              if (h2 > c2 + i2)
                return false;
              if (l2 <= n2 || h2 <= c2)
                return true;
              const u2 = l2 - n2, d2 = h2 - c2;
              return u2 * u2 + d2 * d2 <= i2 * i2;
            }
          }
          function rt(e3, i2, o2, a2, r2) {
            const s2 = t.create();
            return i2 ? (t.scale(s2, s2, [1 / r2, 1 / r2, 1]), o2 || t.rotateZ(s2, s2, a2.angle)) : t.multiply(s2, a2.labelPlaneMatrix, e3), s2;
          }
          function st(e3, i2, o2, a2, r2) {
            if (i2) {
              const i3 = t.clone(e3);
              return t.scale(i3, i3, [r2, r2, 1]), o2 || t.rotateZ(i3, i3, -a2.angle), i3;
            }
            return a2.glCoordMatrix;
          }
          function nt(e3, i2, o2) {
            let a2;
            o2 ? (a2 = [e3.x, e3.y, o2(e3.x, e3.y), 1], t.transformMat4(a2, a2, i2)) : (a2 = [e3.x, e3.y, 0, 1], xt(a2, a2, i2));
            const r2 = a2[3];
            return { point: new t.pointGeometry(a2[0] / r2, a2[1] / r2), signedDistanceFromCamera: r2 };
          }
          function lt(t2, e3) {
            return 0.5 + t2 / e3 * 0.5;
          }
          function ct(t2, e3) {
            const i2 = t2[0] / t2[3], o2 = t2[1] / t2[3];
            return i2 >= -e3[0] && i2 <= e3[0] && o2 >= -e3[1] && o2 <= e3[1];
          }
          function ht(e3, i2, o2, a2, r2, s2, n2, l2, c2, h2) {
            const u2 = a2 ? e3.textSizeData : e3.iconSizeData, d2 = t.evaluateSizeForZoom(u2, o2.transform.zoom), m2 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], _2 = a2 ? e3.text.dynamicLayoutVertexArray : e3.icon.dynamicLayoutVertexArray;
            _2.clear();
            const p2 = e3.lineVertexArray, f2 = a2 ? e3.text.placedSymbolArray : e3.icon.placedSymbolArray, g2 = o2.transform.width / o2.transform.height;
            let x3 = false;
            for (let a3 = 0; a3 < f2.length; a3++) {
              const v2 = f2.get(a3);
              if (v2.hidden || v2.writingMode === t.WritingMode.vertical && !x3) {
                gt(v2.numGlyphs, _2);
                continue;
              }
              let y3;
              if (x3 = false, h2 ? (y3 = [v2.anchorX, v2.anchorY, h2(v2.anchorX, v2.anchorY), 1], t.transformMat4(y3, y3, i2)) : (y3 = [v2.anchorX, v2.anchorY, 0, 1], xt(y3, y3, i2)), !ct(y3, m2)) {
                gt(v2.numGlyphs, _2);
                continue;
              }
              const b2 = lt(o2.transform.cameraToCenterDistance, y3[3]), w2 = t.evaluateSizeForFeature(u2, d2, v2), T2 = n2 ? w2 / b2 : w2 * b2, E2 = new t.pointGeometry(v2.anchorX, v2.anchorY), I2 = nt(E2, r2, h2).point, C2 = {}, S2 = mt(v2, T2, false, l2, i2, r2, s2, e3.glyphOffsetArray, p2, _2, I2, E2, C2, g2, c2, h2);
              x3 = S2.useVertical, (S2.notEnoughRoom || x3 || S2.needsFlipping && mt(v2, T2, true, l2, i2, r2, s2, e3.glyphOffsetArray, p2, _2, I2, E2, C2, g2, c2, h2).notEnoughRoom) && gt(v2.numGlyphs, _2);
            }
            a2 ? e3.text.dynamicLayoutVertexBuffer.updateData(_2) : e3.icon.dynamicLayoutVertexBuffer.updateData(_2);
          }
          function ut(t2, e3, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2, d2) {
            const m2 = n2.glyphStartIndex + n2.numGlyphs, _2 = n2.lineStartIndex, p2 = n2.lineStartIndex + n2.lineLength, f2 = e3.getoffsetX(n2.glyphStartIndex), g2 = e3.getoffsetX(m2 - 1), x3 = pt(t2 * f2, i2, o2, a2, r2, s2, n2.segment, _2, p2, l2, c2, h2, u2, d2);
            if (!x3)
              return null;
            const v2 = pt(t2 * g2, i2, o2, a2, r2, s2, n2.segment, _2, p2, l2, c2, h2, u2, d2);
            return v2 ? { first: x3, last: v2 } : null;
          }
          function dt(e3, i2, o2, a2) {
            return e3 === t.WritingMode.horizontal && Math.abs(o2.y - i2.y) > Math.abs(o2.x - i2.x) * a2 ? { useVertical: true } : (e3 === t.WritingMode.vertical ? i2.y < o2.y : i2.x > o2.x) ? { needsFlipping: true } : null;
          }
          function mt(e3, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2, d2, m2, _2, p2, f2) {
            const g2 = i2 / 24, x3 = e3.lineOffsetX * g2, v2 = e3.lineOffsetY * g2;
            let y3;
            if (e3.numGlyphs > 1) {
              const t2 = e3.glyphStartIndex + e3.numGlyphs, i3 = e3.lineStartIndex, r3 = e3.lineStartIndex + e3.lineLength, h3 = ut(g2, l2, x3, v2, o2, u2, d2, e3, c2, s2, m2, p2, f2);
              if (!h3)
                return { notEnoughRoom: true };
              const b2 = nt(h3.first.point, n2, f2).point, w2 = nt(h3.last.point, n2, f2).point;
              if (a2 && !o2) {
                const t3 = dt(e3.writingMode, b2, w2, _2);
                if (t3)
                  return t3;
              }
              y3 = [h3.first];
              for (let a3 = e3.glyphStartIndex + 1; a3 < t2 - 1; a3++)
                y3.push(pt(g2 * l2.getoffsetX(a3), x3, v2, o2, u2, d2, e3.segment, i3, r3, c2, s2, m2, p2, f2));
              y3.push(h3.last);
            } else {
              if (a2 && !o2) {
                const i4 = nt(d2, r2, f2).point, o3 = e3.lineStartIndex + e3.segment + 1, a3 = new t.pointGeometry(c2.getx(o3), c2.gety(o3)), s3 = nt(a3, r2, f2), n3 = s3.signedDistanceFromCamera > 0 ? s3.point : _t(d2, a3, i4, 1, r2, f2), l3 = dt(e3.writingMode, i4, n3, _2);
                if (l3)
                  return l3;
              }
              const i3 = pt(g2 * l2.getoffsetX(e3.glyphStartIndex), x3, v2, o2, u2, d2, e3.segment, e3.lineStartIndex, e3.lineStartIndex + e3.lineLength, c2, s2, m2, p2, f2);
              if (!i3)
                return { notEnoughRoom: true };
              y3 = [i3];
            }
            for (const e4 of y3)
              t.addDynamicAttributes(h2, e4.point, e4.angle);
            return {};
          }
          function _t(t2, e3, i2, o2, a2, r2) {
            const s2 = nt(t2.add(t2.sub(e3)._unit()), a2, r2).point, n2 = i2.sub(s2);
            return i2.add(n2._mult(o2 / n2.mag()));
          }
          function pt(e3, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2, d2, m2, _2) {
            const p2 = a2 ? e3 - i2 : e3 + i2;
            let f2 = p2 > 0 ? 1 : -1, g2 = 0;
            a2 && (f2 *= -1, g2 = Math.PI), f2 < 0 && (g2 += Math.PI);
            let x3 = f2 > 0 ? l2 + n2 : l2 + n2 + 1, v2 = r2, y3 = r2, b2 = 0, w2 = 0;
            const T2 = Math.abs(p2), E2 = [];
            for (; b2 + w2 <= T2; ) {
              if (x3 += f2, x3 < l2 || x3 >= c2)
                return null;
              if (y3 = v2, E2.push(v2), v2 = d2[x3], void 0 === v2) {
                const e4 = new t.pointGeometry(h2.getx(x3), h2.gety(x3)), i3 = nt(e4, u2, _2);
                if (i3.signedDistanceFromCamera > 0)
                  v2 = d2[x3] = i3.point;
                else {
                  const i4 = x3 - f2;
                  v2 = _t(0 === b2 ? s2 : new t.pointGeometry(h2.getx(i4), h2.gety(i4)), e4, y3, T2 - b2 + 1, u2, _2);
                }
              }
              b2 += w2, w2 = y3.dist(v2);
            }
            const I2 = (T2 - b2) / w2, C2 = v2.sub(y3), S2 = C2.mult(I2)._add(y3);
            S2._add(C2._unit()._perp()._mult(o2 * f2));
            const D2 = g2 + Math.atan2(v2.y - y3.y, v2.x - y3.x);
            return E2.push(S2), { point: S2, angle: m2 ? D2 : 0, path: E2 };
          }
          const ft = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
          function gt(t2, e3) {
            for (let i2 = 0; i2 < t2; i2++) {
              const t3 = e3.length;
              e3.resize(t3 + 4), e3.float32.set(ft, 3 * t3);
            }
          }
          function xt(t2, e3, i2) {
            const o2 = e3[0], a2 = e3[1];
            return t2[0] = i2[0] * o2 + i2[4] * a2 + i2[12], t2[1] = i2[1] * o2 + i2[5] * a2 + i2[13], t2[3] = i2[3] * o2 + i2[7] * a2 + i2[15], t2;
          }
          const vt = 100;
          class yt {
            constructor(t2, e3 = new at(t2.width + 200, t2.height + 200, 25), i2 = new at(t2.width + 200, t2.height + 200, 25)) {
              this.transform = t2, this.grid = e3, this.ignoredGrid = i2, this.pitchfactor = Math.cos(t2._pitch) * t2.cameraToCenterDistance, this.screenRightBoundary = t2.width + vt, this.screenBottomBoundary = t2.height + vt, this.gridRightBoundary = t2.width + 200, this.gridBottomBoundary = t2.height + 200, this.perspectiveRatioCutoff = 0.6;
            }
            placeCollisionBox(t2, e3, i2, o2, a2, r2) {
              const s2 = this.projectAndGetPerspectiveRatio(o2, t2.anchorPointX, t2.anchorPointY, r2), n2 = i2 * s2.perspectiveRatio, l2 = t2.x1 * n2 + s2.point.x, c2 = t2.y1 * n2 + s2.point.y, h2 = t2.x2 * n2 + s2.point.x, u2 = t2.y2 * n2 + s2.point.y;
              return !this.isInsideGrid(l2, c2, h2, u2) || "always" !== e3 && this.grid.hitTest(l2, c2, h2, u2, e3, a2) || s2.perspectiveRatio < this.perspectiveRatioCutoff ? { box: [], offscreen: false } : { box: [l2, c2, h2, u2], offscreen: this.isOffscreen(l2, c2, h2, u2) };
            }
            placeCollisionCircles(e3, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2, d2, m2, _2) {
              const p2 = [], f2 = new t.pointGeometry(i2.anchorX, i2.anchorY), g2 = nt(f2, s2, _2), x3 = lt(this.transform.cameraToCenterDistance, g2.signedDistanceFromCamera), v2 = (h2 ? r2 / x3 : r2 * x3) / t.ONE_EM, y3 = nt(f2, n2, _2).point, b2 = ut(v2, a2, i2.lineOffsetX * v2, i2.lineOffsetY * v2, false, y3, f2, i2, o2, n2, {}, false, _2);
              let w2 = false, T2 = false, E2 = true;
              if (b2) {
                const i3 = 0.5 * d2 * x3 + m2, o3 = new t.pointGeometry(-100, -100), a3 = new t.pointGeometry(this.screenRightBoundary, this.screenBottomBoundary), r3 = new it(), s3 = b2.first, n3 = b2.last;
                let h3 = [];
                for (let t2 = s3.path.length - 1; t2 >= 1; t2--)
                  h3.push(s3.path[t2]);
                for (let t2 = 1; t2 < n3.path.length; t2++)
                  h3.push(n3.path[t2]);
                const f3 = 2.5 * i3;
                if (l2) {
                  const t2 = h3.map((t3) => nt(t3, l2, _2));
                  h3 = t2.some((t3) => t3.signedDistanceFromCamera <= 0) ? [] : t2.map((t3) => t3.point);
                }
                let g3 = [];
                if (h3.length > 0) {
                  const e4 = h3[0].clone(), i4 = h3[0].clone();
                  for (let t2 = 1; t2 < h3.length; t2++)
                    e4.x = Math.min(e4.x, h3[t2].x), e4.y = Math.min(e4.y, h3[t2].y), i4.x = Math.max(i4.x, h3[t2].x), i4.y = Math.max(i4.y, h3[t2].y);
                  g3 = e4.x >= o3.x && i4.x <= a3.x && e4.y >= o3.y && i4.y <= a3.y ? [h3] : i4.x < o3.x || e4.x > a3.x || i4.y < o3.y || e4.y > a3.y ? [] : t.clipLine([h3], o3.x, o3.y, a3.x, a3.y);
                }
                for (const t2 of g3) {
                  r3.reset(t2, 0.25 * i3);
                  let o4 = 0;
                  o4 = r3.length <= 0.5 * i3 ? 1 : Math.ceil(r3.paddedLength / f3) + 1;
                  for (let t3 = 0; t3 < o4; t3++) {
                    const a4 = t3 / Math.max(o4 - 1, 1), s4 = r3.lerp(a4), n4 = s4.x + vt, l3 = s4.y + vt;
                    p2.push(n4, l3, i3, 0);
                    const h4 = n4 - i3, d3 = l3 - i3, m3 = n4 + i3, _3 = l3 + i3;
                    if (E2 = E2 && this.isOffscreen(h4, d3, m3, _3), T2 = T2 || this.isInsideGrid(h4, d3, m3, _3), "always" !== e3 && this.grid.hitTestCircle(n4, l3, i3, e3, u2) && (w2 = true, !c2))
                      return { circles: [], offscreen: false, collisionDetected: w2 };
                  }
                }
              }
              return { circles: !c2 && w2 || !T2 || x3 < this.perspectiveRatioCutoff ? [] : p2, offscreen: E2, collisionDetected: w2 };
            }
            queryRenderedSymbols(e3) {
              if (0 === e3.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
                return {};
              const i2 = [];
              let o2 = 1 / 0, a2 = 1 / 0, r2 = -1 / 0, s2 = -1 / 0;
              for (const n3 of e3) {
                const e4 = new t.pointGeometry(n3.x + vt, n3.y + vt);
                o2 = Math.min(o2, e4.x), a2 = Math.min(a2, e4.y), r2 = Math.max(r2, e4.x), s2 = Math.max(s2, e4.y), i2.push(e4);
              }
              const n2 = this.grid.query(o2, a2, r2, s2).concat(this.ignoredGrid.query(o2, a2, r2, s2)), l2 = {}, c2 = {};
              for (const e4 of n2) {
                const o3 = e4.key;
                if (void 0 === l2[o3.bucketInstanceId] && (l2[o3.bucketInstanceId] = {}), l2[o3.bucketInstanceId][o3.featureIndex])
                  continue;
                const a3 = [new t.pointGeometry(e4.x1, e4.y1), new t.pointGeometry(e4.x2, e4.y1), new t.pointGeometry(e4.x2, e4.y2), new t.pointGeometry(e4.x1, e4.y2)];
                t.polygonIntersectsPolygon(i2, a3) && (l2[o3.bucketInstanceId][o3.featureIndex] = true, void 0 === c2[o3.bucketInstanceId] && (c2[o3.bucketInstanceId] = []), c2[o3.bucketInstanceId].push(o3.featureIndex));
              }
              return c2;
            }
            insertCollisionBox(t2, e3, i2, o2, a2, r2) {
              (i2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: o2, featureIndex: a2, collisionGroupID: r2, overlapMode: e3 }, t2[0], t2[1], t2[2], t2[3]);
            }
            insertCollisionCircles(t2, e3, i2, o2, a2, r2) {
              const s2 = i2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: o2, featureIndex: a2, collisionGroupID: r2, overlapMode: e3 };
              for (let e4 = 0; e4 < t2.length; e4 += 4)
                s2.insertCircle(n2, t2[e4], t2[e4 + 1], t2[e4 + 2]);
            }
            projectAndGetPerspectiveRatio(e3, i2, o2, a2) {
              let r2;
              return a2 ? (r2 = [i2, o2, a2(i2, o2), 1], t.transformMat4(r2, r2, e3)) : (r2 = [i2, o2, 0, 1], xt(r2, r2, e3)), { point: new t.pointGeometry((r2[0] / r2[3] + 1) / 2 * this.transform.width + vt, (-r2[1] / r2[3] + 1) / 2 * this.transform.height + vt), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / r2[3] * 0.5 };
            }
            isOffscreen(t2, e3, i2, o2) {
              return i2 < vt || t2 >= this.screenRightBoundary || o2 < vt || e3 > this.screenBottomBoundary;
            }
            isInsideGrid(t2, e3, i2, o2) {
              return i2 >= 0 && t2 < this.gridRightBoundary && o2 >= 0 && e3 < this.gridBottomBoundary;
            }
            getViewportMatrix() {
              const e3 = t.identity([]);
              return t.translate(e3, e3, [-100, -100, 0]), e3;
            }
          }
          function bt(e3, i2, o2) {
            return i2 * (t.EXTENT / (e3.tileSize * Math.pow(2, o2 - e3.tileID.overscaledZ)));
          }
          class wt {
            constructor(t2, e3, i2, o2) {
              this.opacity = t2 ? Math.max(0, Math.min(1, t2.opacity + (t2.placed ? e3 : -e3))) : o2 && i2 ? 1 : 0, this.placed = i2;
            }
            isHidden() {
              return 0 === this.opacity && !this.placed;
            }
          }
          class Tt {
            constructor(t2, e3, i2, o2, a2) {
              this.text = new wt(t2 ? t2.text : null, e3, i2, a2), this.icon = new wt(t2 ? t2.icon : null, e3, o2, a2);
            }
            isHidden() {
              return this.text.isHidden() && this.icon.isHidden();
            }
          }
          class Et {
            constructor(t2, e3, i2) {
              this.text = t2, this.icon = e3, this.skipFade = i2;
            }
          }
          class It {
            constructor() {
              this.invProjMatrix = t.create(), this.viewportMatrix = t.create(), this.circles = [];
            }
          }
          class Ct {
            constructor(t2, e3, i2, o2, a2) {
              this.bucketInstanceId = t2, this.featureIndex = e3, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = a2;
            }
          }
          class St {
            constructor(t2) {
              this.crossSourceCollisions = t2, this.maxGroupID = 0, this.collisionGroups = {};
            }
            get(t2) {
              if (this.crossSourceCollisions)
                return { ID: 0, predicate: null };
              if (!this.collisionGroups[t2]) {
                const e3 = ++this.maxGroupID;
                this.collisionGroups[t2] = { ID: e3, predicate: (t3) => t3.collisionGroupID === e3 };
              }
              return this.collisionGroups[t2];
            }
          }
          function Dt(e3, i2, o2, a2, r2) {
            const { horizontalAlign: s2, verticalAlign: n2 } = t.getAnchorAlignment(e3), l2 = -(s2 - 0.5) * i2, c2 = -(n2 - 0.5) * o2, h2 = t.evaluateVariableOffset(e3, a2);
            return new t.pointGeometry(l2 + h2[0] * r2, c2 + h2[1] * r2);
          }
          function zt(e3, i2, o2, a2, r2, s2) {
            const { x1: n2, x2: l2, y1: c2, y2: h2, anchorPointX: u2, anchorPointY: d2 } = e3, m2 = new t.pointGeometry(i2, o2);
            return a2 && m2._rotate(r2 ? s2 : -s2), { x1: n2 + m2.x, y1: c2 + m2.y, x2: l2 + m2.x, y2: h2 + m2.y, anchorPointX: u2, anchorPointY: d2 };
          }
          class Pt {
            constructor(t2, e3, i2, o2, a2) {
              this.transform = t2.clone(), this.terrain = e3, this.collisionIndex = new yt(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i2, this.retainedQueryData = {}, this.collisionGroups = new St(o2), this.collisionCircleArrays = {}, this.prevPlacement = a2, a2 && (a2.prevPlacement = void 0), this.placedOrientations = {};
            }
            getBucketParts(e3, i2, o2, a2) {
              const r2 = o2.getBucket(i2), s2 = o2.latestFeatureIndex;
              if (!r2 || !s2 || i2.id !== r2.layerIds[0])
                return;
              const n2 = o2.collisionBoxArray, l2 = r2.layers[0].layout, c2 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), h2 = o2.tileSize / t.EXTENT, u2 = this.transform.calculatePosMatrix(o2.tileID.toUnwrapped()), d2 = "map" === l2.get("text-pitch-alignment"), m2 = "map" === l2.get("text-rotation-alignment"), _2 = bt(o2, 1, this.transform.zoom), p2 = rt(u2, d2, m2, this.transform, _2);
              let f2 = null;
              if (d2) {
                const e4 = st(u2, d2, m2, this.transform, _2);
                f2 = t.multiply([], this.transform.labelPlaneMatrix, e4);
              }
              this.retainedQueryData[r2.bucketInstanceId] = new Ct(r2.bucketInstanceId, s2, r2.sourceLayerIndex, r2.index, o2.tileID);
              const g2 = { bucket: r2, layout: l2, posMatrix: u2, textLabelPlaneMatrix: p2, labelToScreenMatrix: f2, scale: c2, textPixelRatio: h2, holdingForFade: o2.holdingForFade(), collisionBoxArray: n2, partiallyEvaluatedTextSize: t.evaluateSizeForZoom(r2.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(r2.sourceID) };
              if (a2)
                for (const t2 of r2.sortKeyRanges) {
                  const { sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: a3 } = t2;
                  e3.push({ sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: a3, parameters: g2 });
                }
              else
                e3.push({ symbolInstanceStart: 0, symbolInstanceEnd: r2.symbolInstances.length, parameters: g2 });
            }
            attemptAnchorPlacement(t2, e3, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2, d2, m2, _2, p2) {
              const f2 = [u2.textOffset0, u2.textOffset1], g2 = Dt(t2, i2, o2, f2, a2), x3 = this.collisionIndex.placeCollisionBox(zt(e3, g2.x, g2.y, r2, s2, this.transform.angle), h2, n2, l2, c2.predicate, p2);
              if ((!_2 || 0 !== this.collisionIndex.placeCollisionBox(zt(_2, g2.x, g2.y, r2, s2, this.transform.angle), h2, n2, l2, c2.predicate, p2).box.length) && x3.box.length > 0) {
                let e4;
                if (this.prevPlacement && this.prevPlacement.variableOffsets[u2.crossTileID] && this.prevPlacement.placements[u2.crossTileID] && this.prevPlacement.placements[u2.crossTileID].text && (e4 = this.prevPlacement.variableOffsets[u2.crossTileID].anchor), 0 === u2.crossTileID)
                  throw new Error("symbolInstance.crossTileID can't be 0");
                return this.variableOffsets[u2.crossTileID] = { textOffset: f2, width: i2, height: o2, anchor: t2, textBoxScale: a2, prevAnchor: e4 }, this.markUsedJustification(d2, t2, u2, m2), d2.allowVerticalPlacement && (this.markUsedOrientation(d2, m2, u2), this.placedOrientations[u2.crossTileID] = m2), { shift: g2, placedGlyphBoxes: x3 };
              }
            }
            placeLayerBucketPart(e3, i2, o2) {
              const { bucket: a2, layout: r2, posMatrix: s2, textLabelPlaneMatrix: n2, labelToScreenMatrix: l2, textPixelRatio: c2, holdingForFade: h2, collisionBoxArray: u2, partiallyEvaluatedTextSize: d2, collisionGroup: m2 } = e3.parameters, _2 = r2.get("text-optional"), p2 = r2.get("icon-optional"), f2 = t.getOverlapMode(r2, "text-overlap", "text-allow-overlap"), g2 = "always" === f2, x3 = t.getOverlapMode(r2, "icon-overlap", "icon-allow-overlap"), v2 = "always" === x3, y3 = "map" === r2.get("text-rotation-alignment"), b2 = "map" === r2.get("text-pitch-alignment"), w2 = "none" !== r2.get("icon-text-fit"), T2 = "viewport-y" === r2.get("symbol-z-order"), E2 = g2 && (v2 || !a2.hasIconData() || p2), I2 = v2 && (g2 || !a2.hasTextData() || _2);
              !a2.collisionArrays && u2 && a2.deserializeCollisionBoxes(u2);
              const C2 = (e4, u3) => {
                if (i2[e4.crossTileID])
                  return;
                if (h2)
                  return void (this.placements[e4.crossTileID] = new Et(false, false, false));
                let v3 = false, T3 = false, C3 = true, S2 = null, D2 = { box: null, offscreen: null }, z2 = { box: null, offscreen: null }, P2 = null, M2 = null, A2 = null, L2 = 0, R2 = 0, k2 = 0;
                u3.textFeatureIndex ? L2 = u3.textFeatureIndex : e4.useRuntimeCollisionCircles && (L2 = e4.featureIndex), u3.verticalTextFeatureIndex && (R2 = u3.verticalTextFeatureIndex);
                const B3 = this.retainedQueryData[a2.bucketInstanceId].tileID, F2 = this.terrain ? (t2, e6) => this.terrain.getElevation(B3, t2, e6) : null;
                for (const t2 of ["textBox", "verticalTextBox", "iconBox", "verticalIconBox"]) {
                  const e6 = u3[t2];
                  e6 && (e6.elevation = F2 ? F2(e6.anchorPointX, e6.anchorPointY) : 0);
                }
                const O2 = u3.textBox;
                if (O2) {
                  const i3 = (i4) => {
                    let o4 = t.WritingMode.horizontal;
                    if (a2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                      const t2 = this.prevPlacement.placedOrientations[e4.crossTileID];
                      t2 && (this.placedOrientations[e4.crossTileID] = t2, o4 = t2, this.markUsedOrientation(a2, o4, e4));
                    }
                    return o4;
                  }, o3 = (i4, o4) => {
                    if (a2.allowVerticalPlacement && e4.numVerticalGlyphVertices > 0 && u3.verticalTextBox) {
                      for (const e6 of a2.writingModes)
                        if (e6 === t.WritingMode.vertical ? (D2 = o4(), z2 = D2) : D2 = i4(), D2 && D2.box && D2.box.length)
                          break;
                    } else
                      D2 = i4();
                  };
                  if (r2.get("text-variable-anchor")) {
                    let n3 = r2.get("text-variable-anchor");
                    if (this.prevPlacement && this.prevPlacement.variableOffsets[e4.crossTileID]) {
                      const t2 = this.prevPlacement.variableOffsets[e4.crossTileID];
                      n3.indexOf(t2.anchor) > 0 && (n3 = n3.filter((e6) => e6 !== t2.anchor), n3.unshift(t2.anchor));
                    }
                    const l3 = (t2, i4, o4) => {
                      const r3 = t2.x2 - t2.x1, l4 = t2.y2 - t2.y1, h4 = e4.textBoxScale, u4 = w2 && "never" === x3 ? i4 : null;
                      let d3 = { box: [], offscreen: false };
                      const _3 = "never" !== f2 ? 2 * n3.length : n3.length;
                      for (let i5 = 0; i5 < _3; ++i5) {
                        const _4 = this.attemptAnchorPlacement(n3[i5 % n3.length], t2, r3, l4, h4, y3, b2, c2, s2, m2, i5 >= n3.length ? f2 : "never", e4, a2, o4, u4, F2);
                        if (_4 && (d3 = _4.placedGlyphBoxes, d3 && d3.box && d3.box.length)) {
                          v3 = true, S2 = _4.shift;
                          break;
                        }
                      }
                      return d3;
                    };
                    o3(() => l3(O2, u3.iconBox, t.WritingMode.horizontal), () => {
                      const i4 = u3.verticalTextBox;
                      return a2.allowVerticalPlacement && !(D2 && D2.box && D2.box.length) && e4.numVerticalGlyphVertices > 0 && i4 ? l3(i4, u3.verticalIconBox, t.WritingMode.vertical) : { box: null, offscreen: null };
                    }), D2 && (v3 = D2.box, C3 = D2.offscreen);
                    const h3 = i3(D2 && D2.box);
                    if (!v3 && this.prevPlacement) {
                      const t2 = this.prevPlacement.variableOffsets[e4.crossTileID];
                      t2 && (this.variableOffsets[e4.crossTileID] = t2, this.markUsedJustification(a2, t2.anchor, e4, h3));
                    }
                  } else {
                    const r3 = (t2, i4) => {
                      const o4 = this.collisionIndex.placeCollisionBox(t2, f2, c2, s2, m2.predicate, F2);
                      return o4 && o4.box && o4.box.length && (this.markUsedOrientation(a2, i4, e4), this.placedOrientations[e4.crossTileID] = i4), o4;
                    };
                    o3(() => r3(O2, t.WritingMode.horizontal), () => {
                      const i4 = u3.verticalTextBox;
                      return a2.allowVerticalPlacement && e4.numVerticalGlyphVertices > 0 && i4 ? r3(i4, t.WritingMode.vertical) : { box: null, offscreen: null };
                    }), i3(D2 && D2.box && D2.box.length);
                  }
                }
                if (P2 = D2, v3 = P2 && P2.box && P2.box.length > 0, C3 = P2 && P2.offscreen, e4.useRuntimeCollisionCircles) {
                  const i3 = a2.text.placedSymbolArray.get(e4.centerJustifiedTextSymbolIndex), c3 = t.evaluateSizeForFeature(a2.textSizeData, d2, i3), h3 = r2.get("text-padding");
                  M2 = this.collisionIndex.placeCollisionCircles(f2, i3, a2.lineVertexArray, a2.glyphOffsetArray, c3, s2, n2, l2, o2, b2, m2.predicate, e4.collisionCircleDiameter, h3, F2), M2.circles.length && M2.collisionDetected && !o2 && t.warnOnce("Collisions detected, but collision boxes are not shown"), v3 = g2 || M2.circles.length > 0 && !M2.collisionDetected, C3 = C3 && M2.offscreen;
                }
                if (u3.iconFeatureIndex && (k2 = u3.iconFeatureIndex), u3.iconBox) {
                  const t2 = (t3) => {
                    const e6 = w2 && S2 ? zt(t3, S2.x, S2.y, y3, b2, this.transform.angle) : t3;
                    return this.collisionIndex.placeCollisionBox(e6, x3, c2, s2, m2.predicate, F2);
                  };
                  z2 && z2.box && z2.box.length && u3.verticalIconBox ? (A2 = t2(u3.verticalIconBox), T3 = A2.box.length > 0) : (A2 = t2(u3.iconBox), T3 = A2.box.length > 0), C3 = C3 && A2.offscreen;
                }
                const U2 = _2 || 0 === e4.numHorizontalGlyphVertices && 0 === e4.numVerticalGlyphVertices, N2 = p2 || 0 === e4.numIconVertices;
                if (U2 || N2 ? N2 ? U2 || (T3 = T3 && v3) : v3 = T3 && v3 : T3 = v3 = T3 && v3, v3 && P2 && P2.box && this.collisionIndex.insertCollisionBox(P2.box, f2, r2.get("text-ignore-placement"), a2.bucketInstanceId, z2 && z2.box && R2 ? R2 : L2, m2.ID), T3 && A2 && this.collisionIndex.insertCollisionBox(A2.box, x3, r2.get("icon-ignore-placement"), a2.bucketInstanceId, k2, m2.ID), M2 && (v3 && this.collisionIndex.insertCollisionCircles(M2.circles, f2, r2.get("text-ignore-placement"), a2.bucketInstanceId, L2, m2.ID), o2)) {
                  const t2 = a2.bucketInstanceId;
                  let e6 = this.collisionCircleArrays[t2];
                  void 0 === e6 && (e6 = this.collisionCircleArrays[t2] = new It());
                  for (let t3 = 0; t3 < M2.circles.length; t3 += 4)
                    e6.circles.push(M2.circles[t3 + 0]), e6.circles.push(M2.circles[t3 + 1]), e6.circles.push(M2.circles[t3 + 2]), e6.circles.push(M2.collisionDetected ? 1 : 0);
                }
                if (0 === e4.crossTileID)
                  throw new Error("symbolInstance.crossTileID can't be 0");
                if (0 === a2.bucketInstanceId)
                  throw new Error("bucket.bucketInstanceId can't be 0");
                this.placements[e4.crossTileID] = new Et(v3 || E2, T3 || I2, C3 || a2.justReloaded), i2[e4.crossTileID] = true;
              };
              if (T2) {
                if (0 !== e3.symbolInstanceStart)
                  throw new Error("bucket.bucketInstanceId should be 0");
                const t2 = a2.getSortedSymbolIndexes(this.transform.angle);
                for (let e4 = t2.length - 1; e4 >= 0; --e4) {
                  const i3 = t2[e4];
                  C2(a2.symbolInstances.get(i3), a2.collisionArrays[i3]);
                }
              } else
                for (let t2 = e3.symbolInstanceStart; t2 < e3.symbolInstanceEnd; t2++)
                  C2(a2.symbolInstances.get(t2), a2.collisionArrays[t2]);
              if (o2 && a2.bucketInstanceId in this.collisionCircleArrays) {
                const e4 = this.collisionCircleArrays[a2.bucketInstanceId];
                t.invert(e4.invProjMatrix, s2), e4.viewportMatrix = this.collisionIndex.getViewportMatrix();
              }
              a2.justReloaded = false;
            }
            markUsedJustification(e3, i2, o2, a2) {
              let r2;
              r2 = a2 === t.WritingMode.vertical ? o2.verticalPlacedTextSymbolIndex : { left: o2.leftJustifiedTextSymbolIndex, center: o2.centerJustifiedTextSymbolIndex, right: o2.rightJustifiedTextSymbolIndex }[t.getAnchorJustification(i2)];
              const s2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex, o2.verticalPlacedTextSymbolIndex];
              for (const t2 of s2)
                t2 >= 0 && (e3.text.placedSymbolArray.get(t2).crossTileID = r2 >= 0 && t2 !== r2 ? 0 : o2.crossTileID);
            }
            markUsedOrientation(e3, i2, o2) {
              const a2 = i2 === t.WritingMode.horizontal || i2 === t.WritingMode.horizontalOnly ? i2 : 0, r2 = i2 === t.WritingMode.vertical ? i2 : 0, s2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex];
              for (const t2 of s2)
                e3.text.placedSymbolArray.get(t2).placedOrientation = a2;
              o2.verticalPlacedTextSymbolIndex && (e3.text.placedSymbolArray.get(o2.verticalPlacedTextSymbolIndex).placedOrientation = r2);
            }
            commit(t2) {
              this.commitTime = t2, this.zoomAtLastRecencyCheck = this.transform.zoom;
              const e3 = this.prevPlacement;
              let i2 = false;
              this.prevZoomAdjustment = e3 ? e3.zoomAdjustment(this.transform.zoom) : 0;
              const o2 = e3 ? e3.symbolFadeChange(t2) : 1, a2 = e3 ? e3.opacities : {}, r2 = e3 ? e3.variableOffsets : {}, s2 = e3 ? e3.placedOrientations : {};
              for (const t3 in this.placements) {
                const e4 = this.placements[t3], r3 = a2[t3];
                r3 ? (this.opacities[t3] = new Tt(r3, o2, e4.text, e4.icon), i2 = i2 || e4.text !== r3.text.placed || e4.icon !== r3.icon.placed) : (this.opacities[t3] = new Tt(null, o2, e4.text, e4.icon, e4.skipFade), i2 = i2 || e4.text || e4.icon);
              }
              for (const t3 in a2) {
                const e4 = a2[t3];
                if (!this.opacities[t3]) {
                  const a3 = new Tt(e4, o2, false, false);
                  a3.isHidden() || (this.opacities[t3] = a3, i2 = i2 || e4.text.placed || e4.icon.placed);
                }
              }
              for (const t3 in r2)
                this.variableOffsets[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.variableOffsets[t3] = r2[t3]);
              for (const t3 in s2)
                this.placedOrientations[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.placedOrientations[t3] = s2[t3]);
              if (e3 && void 0 === e3.lastPlacementChangeTime)
                throw new Error("Last placement time for previous placement is not defined");
              i2 ? this.lastPlacementChangeTime = t2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e3 ? e3.lastPlacementChangeTime : t2);
            }
            updateLayerOpacities(t2, e3) {
              const i2 = {};
              for (const o2 of e3) {
                const e4 = o2.getBucket(t2);
                e4 && o2.latestFeatureIndex && t2.id === e4.layerIds[0] && this.updateBucketOpacities(e4, i2, o2.collisionBoxArray);
              }
            }
            updateBucketOpacities(e3, i2, o2) {
              e3.hasTextData() && e3.text.opacityVertexArray.clear(), e3.hasIconData() && e3.icon.opacityVertexArray.clear(), e3.hasIconCollisionBoxData() && e3.iconCollisionBox.collisionVertexArray.clear(), e3.hasTextCollisionBoxData() && e3.textCollisionBox.collisionVertexArray.clear();
              const a2 = e3.layers[0].layout, r2 = new Tt(null, 0, false, false, true), s2 = a2.get("text-allow-overlap"), n2 = a2.get("icon-allow-overlap"), l2 = a2.get("text-variable-anchor"), c2 = "map" === a2.get("text-rotation-alignment"), h2 = "map" === a2.get("text-pitch-alignment"), u2 = "none" !== a2.get("icon-text-fit"), d2 = new Tt(null, 0, s2 && (n2 || !e3.hasIconData() || a2.get("icon-optional")), n2 && (s2 || !e3.hasTextData() || a2.get("text-optional")), true);
              !e3.collisionArrays && o2 && (e3.hasIconCollisionBoxData() || e3.hasTextCollisionBoxData()) && e3.deserializeCollisionBoxes(o2);
              const m2 = (t2, e4, i3) => {
                for (let o3 = 0; o3 < e4 / 4; o3++)
                  t2.opacityVertexArray.emplaceBack(i3);
              };
              for (let o3 = 0; o3 < e3.symbolInstances.length; o3++) {
                const a3 = e3.symbolInstances.get(o3), { numHorizontalGlyphVertices: s3, numVerticalGlyphVertices: n3, crossTileID: _2 } = a3;
                let p2 = this.opacities[_2];
                i2[_2] ? p2 = r2 : p2 || (p2 = d2, this.opacities[_2] = p2), i2[_2] = true;
                const f2 = a3.numIconVertices > 0, g2 = this.placedOrientations[a3.crossTileID], x3 = g2 === t.WritingMode.vertical, v2 = g2 === t.WritingMode.horizontal || g2 === t.WritingMode.horizontalOnly;
                if (s3 > 0 || n3 > 0) {
                  const t2 = Ut(p2.text);
                  m2(e3.text, s3, x3 ? Nt : t2), m2(e3.text, n3, v2 ? Nt : t2);
                  const i3 = p2.text.isHidden();
                  [a3.rightJustifiedTextSymbolIndex, a3.centerJustifiedTextSymbolIndex, a3.leftJustifiedTextSymbolIndex].forEach((t3) => {
                    t3 >= 0 && (e3.text.placedSymbolArray.get(t3).hidden = i3 || x3 ? 1 : 0);
                  }), a3.verticalPlacedTextSymbolIndex >= 0 && (e3.text.placedSymbolArray.get(a3.verticalPlacedTextSymbolIndex).hidden = i3 || v2 ? 1 : 0);
                  const o4 = this.variableOffsets[a3.crossTileID];
                  o4 && this.markUsedJustification(e3, o4.anchor, a3, g2);
                  const r3 = this.placedOrientations[a3.crossTileID];
                  r3 && (this.markUsedJustification(e3, "left", a3, r3), this.markUsedOrientation(e3, r3, a3));
                }
                if (f2) {
                  const t2 = Ut(p2.icon), i3 = !(u2 && a3.verticalPlacedIconSymbolIndex && x3);
                  a3.placedIconSymbolIndex >= 0 && (m2(e3.icon, a3.numIconVertices, i3 ? t2 : Nt), e3.icon.placedSymbolArray.get(a3.placedIconSymbolIndex).hidden = p2.icon.isHidden()), a3.verticalPlacedIconSymbolIndex >= 0 && (m2(e3.icon, a3.numVerticalIconVertices, i3 ? Nt : t2), e3.icon.placedSymbolArray.get(a3.verticalPlacedIconSymbolIndex).hidden = p2.icon.isHidden());
                }
                if (e3.hasIconCollisionBoxData() || e3.hasTextCollisionBoxData()) {
                  const i3 = e3.collisionArrays[o3];
                  if (i3) {
                    let o4 = new t.pointGeometry(0, 0);
                    if (i3.textBox || i3.verticalTextBox) {
                      let t2 = true;
                      if (l2) {
                        const e4 = this.variableOffsets[_2];
                        e4 ? (o4 = Dt(e4.anchor, e4.width, e4.height, e4.textOffset, e4.textBoxScale), c2 && o4._rotate(h2 ? this.transform.angle : -this.transform.angle)) : t2 = false;
                      }
                      i3.textBox && Mt(e3.textCollisionBox.collisionVertexArray, p2.text.placed, !t2 || x3, o4.x, o4.y), i3.verticalTextBox && Mt(e3.textCollisionBox.collisionVertexArray, p2.text.placed, !t2 || v2, o4.x, o4.y);
                    }
                    const a4 = Boolean(!v2 && i3.verticalIconBox);
                    i3.iconBox && Mt(e3.iconCollisionBox.collisionVertexArray, p2.icon.placed, a4, u2 ? o4.x : 0, u2 ? o4.y : 0), i3.verticalIconBox && Mt(e3.iconCollisionBox.collisionVertexArray, p2.icon.placed, !a4, u2 ? o4.x : 0, u2 ? o4.y : 0);
                  }
                }
              }
              if (e3.sortFeatures(this.transform.angle), this.retainedQueryData[e3.bucketInstanceId] && (this.retainedQueryData[e3.bucketInstanceId].featureSortOrder = e3.featureSortOrder), e3.hasTextData() && e3.text.opacityVertexBuffer && e3.text.opacityVertexBuffer.updateData(e3.text.opacityVertexArray), e3.hasIconData() && e3.icon.opacityVertexBuffer && e3.icon.opacityVertexBuffer.updateData(e3.icon.opacityVertexArray), e3.hasIconCollisionBoxData() && e3.iconCollisionBox.collisionVertexBuffer && e3.iconCollisionBox.collisionVertexBuffer.updateData(e3.iconCollisionBox.collisionVertexArray), e3.hasTextCollisionBoxData() && e3.textCollisionBox.collisionVertexBuffer && e3.textCollisionBox.collisionVertexBuffer.updateData(e3.textCollisionBox.collisionVertexArray), e3.text.opacityVertexArray.length !== e3.text.layoutVertexArray.length / 4)
                throw new Error(`bucket.text.opacityVertexArray.length (= ${e3.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e3.text.layoutVertexArray.length}) / 4`);
              if (e3.icon.opacityVertexArray.length !== e3.icon.layoutVertexArray.length / 4)
                throw new Error(`bucket.icon.opacityVertexArray.length (= ${e3.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e3.icon.layoutVertexArray.length}) / 4`);
              if (e3.bucketInstanceId in this.collisionCircleArrays) {
                const t2 = this.collisionCircleArrays[e3.bucketInstanceId];
                e3.placementInvProjMatrix = t2.invProjMatrix, e3.placementViewportMatrix = t2.viewportMatrix, e3.collisionCircleArray = t2.circles, delete this.collisionCircleArrays[e3.bucketInstanceId];
              }
            }
            symbolFadeChange(t2) {
              return 0 === this.fadeDuration ? 1 : (t2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(t2) {
              return Math.max(0, (this.transform.zoom - t2) / 1.5);
            }
            hasTransitions(t2) {
              return this.stale || t2 - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(t2, e3) {
              const i2 = this.zoomAtLastRecencyCheck === e3 ? 1 - this.zoomAdjustment(e3) : 1;
              return this.zoomAtLastRecencyCheck = e3, this.commitTime + this.fadeDuration * i2 > t2;
            }
            setStale() {
              this.stale = true;
            }
          }
          function Mt(t2, e3, i2, o2, a2) {
            t2.emplaceBack(e3 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0), t2.emplaceBack(e3 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0), t2.emplaceBack(e3 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0), t2.emplaceBack(e3 ? 1 : 0, i2 ? 1 : 0, o2 || 0, a2 || 0);
          }
          const At = Math.pow(2, 25), Lt = Math.pow(2, 24), Rt = Math.pow(2, 17), kt = Math.pow(2, 16), Bt = Math.pow(2, 9), Ft = Math.pow(2, 8), Ot = Math.pow(2, 1);
          function Ut(t2) {
            if (0 === t2.opacity && !t2.placed)
              return 0;
            if (1 === t2.opacity && t2.placed)
              return 4294967295;
            const e3 = t2.placed ? 1 : 0, i2 = Math.floor(127 * t2.opacity);
            return i2 * At + e3 * Lt + i2 * Rt + e3 * kt + i2 * Bt + e3 * Ft + i2 * Ot + e3;
          }
          const Nt = 0;
          class Gt {
            constructor(t2) {
              this._sortAcrossTiles = "viewport-y" !== t2.layout.get("symbol-z-order") && !t2.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
            }
            continuePlacement(t2, e3, i2, o2, a2) {
              const r2 = this._bucketParts;
              for (; this._currentTileIndex < t2.length; )
                if (e3.getBucketParts(r2, o2, t2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, a2())
                  return true;
              for (this._sortAcrossTiles && (this._sortAcrossTiles = false, r2.sort((t3, e4) => t3.sortKey - e4.sortKey)); this._currentPartIndex < r2.length; )
                if (e3.placeLayerBucketPart(r2[this._currentPartIndex], this._seenCrossTileIDs, i2), this._currentPartIndex++, a2())
                  return true;
              return false;
            }
          }
          class Zt {
            constructor(t2, e3, i2, o2, a2, r2, s2, n2) {
              this.placement = new Pt(t2, e3, r2, s2, n2), this._currentPlacementIndex = i2.length - 1, this._forceFullPlacement = o2, this._showCollisionBoxes = a2, this._done = false;
            }
            isDone() {
              return this._done;
            }
            continuePlacement(e3, i2, o2) {
              const a2 = t.exported.now(), r2 = () => {
                const e4 = t.exported.now() - a2;
                return !this._forceFullPlacement && e4 > 2;
              };
              for (; this._currentPlacementIndex >= 0; ) {
                const t2 = i2[e3[this._currentPlacementIndex]], a3 = this.placement.collisionIndex.transform.zoom;
                if ("symbol" === t2.type && (!t2.minzoom || t2.minzoom <= a3) && (!t2.maxzoom || t2.maxzoom > a3)) {
                  if (this._inProgressLayer || (this._inProgressLayer = new Gt(t2)), this._inProgressLayer.continuePlacement(o2[t2.source], this.placement, this._showCollisionBoxes, t2, r2))
                    return;
                  delete this._inProgressLayer;
                }
                this._currentPlacementIndex--;
              }
              this._done = true;
            }
            commit(t2) {
              return this.placement.commit(t2), this.placement;
            }
          }
          const Vt = 512 / t.EXTENT / 2;
          class qt {
            constructor(t2, e3, i2) {
              this.tileID = t2, this.indexedSymbolInstances = {}, this.bucketInstanceId = i2;
              for (let i3 = 0; i3 < e3.length; i3++) {
                const o2 = e3.get(i3), a2 = o2.key;
                this.indexedSymbolInstances[a2] || (this.indexedSymbolInstances[a2] = []), this.indexedSymbolInstances[a2].push({ crossTileID: o2.crossTileID, coord: this.getScaledCoordinates(o2, t2) });
              }
            }
            getScaledCoordinates(e3, i2) {
              const o2 = Vt / Math.pow(2, i2.canonical.z - this.tileID.canonical.z);
              return { x: Math.floor((i2.canonical.x * t.EXTENT + e3.anchorX) * o2), y: Math.floor((i2.canonical.y * t.EXTENT + e3.anchorY) * o2) };
            }
            findMatches(t2, e3, i2) {
              const o2 = this.tileID.canonical.z < e3.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e3.canonical.z);
              for (let a2 = 0; a2 < t2.length; a2++) {
                const r2 = t2.get(a2);
                if (r2.crossTileID)
                  continue;
                const s2 = this.indexedSymbolInstances[r2.key];
                if (!s2)
                  continue;
                const n2 = this.getScaledCoordinates(r2, e3);
                for (const t3 of s2)
                  if (Math.abs(t3.coord.x - n2.x) <= o2 && Math.abs(t3.coord.y - n2.y) <= o2 && !i2[t3.crossTileID]) {
                    i2[t3.crossTileID] = true, r2.crossTileID = t3.crossTileID;
                    break;
                  }
              }
            }
          }
          class jt {
            constructor() {
              this.maxCrossTileID = 0;
            }
            generate() {
              return ++this.maxCrossTileID;
            }
          }
          class $t {
            constructor() {
              this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }
            handleWrapJump(t2) {
              const e3 = Math.round((t2 - this.lng) / 360);
              if (0 !== e3)
                for (const t3 in this.indexes) {
                  const i2 = this.indexes[t3], o2 = {};
                  for (const t4 in i2) {
                    const a2 = i2[t4];
                    a2.tileID = a2.tileID.unwrapTo(a2.tileID.wrap + e3), o2[a2.tileID.key] = a2;
                  }
                  this.indexes[t3] = o2;
                }
              this.lng = t2;
            }
            addBucket(t2, e3, i2) {
              if (this.indexes[t2.overscaledZ] && this.indexes[t2.overscaledZ][t2.key]) {
                if (this.indexes[t2.overscaledZ][t2.key].bucketInstanceId === e3.bucketInstanceId)
                  return false;
                this.removeBucketCrossTileIDs(t2.overscaledZ, this.indexes[t2.overscaledZ][t2.key]);
              }
              for (let t3 = 0; t3 < e3.symbolInstances.length; t3++)
                e3.symbolInstances.get(t3).crossTileID = 0;
              this.usedCrossTileIDs[t2.overscaledZ] || (this.usedCrossTileIDs[t2.overscaledZ] = {});
              const o2 = this.usedCrossTileIDs[t2.overscaledZ];
              for (const i3 in this.indexes) {
                const a2 = this.indexes[i3];
                if (Number(i3) > t2.overscaledZ)
                  for (const i4 in a2) {
                    const r2 = a2[i4];
                    r2.tileID.isChildOf(t2) && r2.findMatches(e3.symbolInstances, t2, o2);
                  }
                else {
                  const r2 = a2[t2.scaledTo(Number(i3)).key];
                  r2 && r2.findMatches(e3.symbolInstances, t2, o2);
                }
              }
              for (let t3 = 0; t3 < e3.symbolInstances.length; t3++) {
                const a2 = e3.symbolInstances.get(t3);
                a2.crossTileID || (a2.crossTileID = i2.generate(), o2[a2.crossTileID] = true);
              }
              return void 0 === this.indexes[t2.overscaledZ] && (this.indexes[t2.overscaledZ] = {}), this.indexes[t2.overscaledZ][t2.key] = new qt(t2, e3.symbolInstances, e3.bucketInstanceId), true;
            }
            removeBucketCrossTileIDs(t2, e3) {
              for (const i2 in e3.indexedSymbolInstances)
                for (const o2 of e3.indexedSymbolInstances[i2])
                  delete this.usedCrossTileIDs[t2][o2.crossTileID];
            }
            removeStaleBuckets(t2) {
              let e3 = false;
              for (const i2 in this.indexes) {
                const o2 = this.indexes[i2];
                for (const a2 in o2)
                  t2[o2[a2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[a2]), delete o2[a2], e3 = true);
              }
              return e3;
            }
          }
          class Xt {
            constructor() {
              this.layerIndexes = {}, this.crossTileIDs = new jt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }
            addLayer(t2, e3, i2) {
              let o2 = this.layerIndexes[t2.id];
              void 0 === o2 && (o2 = this.layerIndexes[t2.id] = new $t());
              let a2 = false;
              const r2 = {};
              o2.handleWrapJump(i2);
              for (const i3 of e3) {
                const e4 = i3.getBucket(t2);
                e4 && t2.id === e4.layerIds[0] && (e4.bucketInstanceId || (e4.bucketInstanceId = ++this.maxBucketInstanceId), o2.addBucket(i3.tileID, e4, this.crossTileIDs) && (a2 = true), r2[e4.bucketInstanceId] = true);
              }
              return o2.removeStaleBuckets(r2) && (a2 = true), a2;
            }
            pruneUnusedLayers(t2) {
              const e3 = {};
              t2.forEach((t3) => {
                e3[t3] = true;
              });
              for (const t3 in this.layerIndexes)
                e3[t3] || delete this.layerIndexes[t3];
            }
          }
          var Wt = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]);
          class Ht extends t.Evented {
            constructor(t2) {
              super(), this.sourceCache = t2, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.renderHistory = [], this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, this.renderHistorySize = t2._cache.max, t2.usedForTerrain = true, t2.tileSize = this.tileSize * 2 ** this.deltaZoom;
            }
            destruct() {
              this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
              for (const t2 in this._tiles) {
                const e3 = this._tiles[t2];
                e3.textures.forEach((t3) => t3.destroy()), e3.textures = [];
              }
            }
            update(e3, i2) {
              this.sourceCache.update(e3, i2), this._renderableTilesKeys = [];
              for (const o2 of e3.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: i2 }))
                this._renderableTilesKeys.push(o2.key), this._tiles[o2.key] || (o2.posMatrix = new Float64Array(16), t.ortho(o2.posMatrix, 0, t.EXTENT, 0, t.EXTENT, 0, 1), this._tiles[o2.key] = new k(o2, this.tileSize));
            }
            removeOutdated(t2) {
              const e3 = {};
              this.renderHistory = this.renderHistory.filter((t3, e4) => this.renderHistory.indexOf(t3) === e4).slice(0, this.renderHistorySize);
              for (const t3 of this._renderableTilesKeys)
                e3[t3] = true;
              for (const t3 of this.renderHistory)
                e3[t3] = true;
              for (const i2 in this._tiles)
                e3[i2] || (this._tiles[i2].clearTextures(t2), delete this._tiles[i2]);
            }
            getRenderableTiles() {
              return this._renderableTilesKeys.map((t2) => this.getTileByID(t2));
            }
            getTileByID(t2) {
              return this._tiles[t2];
            }
            getTerrainCoords(e3) {
              const i2 = {};
              for (const o2 of this._renderableTilesKeys) {
                const a2 = this._tiles[o2].tileID;
                if (a2.canonical.equals(e3.canonical)) {
                  const a3 = e3.clone();
                  a3.posMatrix = new Float64Array(16), t.ortho(a3.posMatrix, 0, t.EXTENT, 0, t.EXTENT, 0, 1), i2[o2] = a3;
                } else if (a2.canonical.isChildOf(e3.canonical)) {
                  const r2 = e3.clone();
                  r2.posMatrix = new Float64Array(16);
                  const s2 = a2.canonical.z - e3.canonical.z, n2 = a2.canonical.x - (a2.canonical.x >> s2 << s2), l2 = a2.canonical.y - (a2.canonical.y >> s2 << s2), c2 = t.EXTENT >> s2;
                  t.ortho(r2.posMatrix, 0, c2, 0, c2, 0, 1), t.translate(r2.posMatrix, r2.posMatrix, [-n2 * c2, -l2 * c2, 0]), i2[o2] = r2;
                } else if (e3.canonical.isChildOf(a2.canonical)) {
                  const r2 = e3.clone();
                  r2.posMatrix = new Float64Array(16);
                  const s2 = e3.canonical.z - a2.canonical.z, n2 = e3.canonical.x - (e3.canonical.x >> s2 << s2), l2 = e3.canonical.y - (e3.canonical.y >> s2 << s2), c2 = t.EXTENT >> s2;
                  t.ortho(r2.posMatrix, 0, t.EXTENT, 0, t.EXTENT, 0, 1), t.translate(r2.posMatrix, r2.posMatrix, [n2 * c2, l2 * c2, 0]), t.scale(r2.posMatrix, r2.posMatrix, [1 / 2 ** s2, 1 / 2 ** s2, 0]), i2[o2] = r2;
                }
              }
              return i2;
            }
            getSourceTile(t2, e3) {
              const i2 = this.sourceCache._source;
              let o2 = t2.overscaledZ - this.deltaZoom;
              if (o2 > i2.maxzoom && (o2 = i2.maxzoom), o2 < i2.minzoom)
                return null;
              this._sourceTileCache[t2.key] || (this._sourceTileCache[t2.key] = t2.scaledTo(o2).key);
              let a2 = this.sourceCache.getTileByID(this._sourceTileCache[t2.key]);
              if ((!a2 || !a2.dem) && e3)
                for (; o2 >= i2.minzoom && (!a2 || !a2.dem); )
                  a2 = this.sourceCache.getTileByID(t2.scaledTo(o2--).key);
              return a2;
            }
            tilesAfterTime(t2 = Date.now()) {
              return Object.values(this._tiles).filter((e3) => e3.timeLoaded >= t2);
            }
          }
          class Kt {
            constructor(t2, e3, i2) {
              this.style = t2, this.sourceCache = new Ht(e3), this.options = i2, this.exaggeration = "number" == typeof i2.exaggeration ? i2.exaggeration : 1, this.elevationOffset = "number" == typeof i2.elevationOffset ? i2.elevationOffset : 450, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024, this.clearRerenderCache();
            }
            getDEMElevation(e3, i2, o2, a2 = t.EXTENT) {
              if (!(i2 >= 0 && i2 < a2 && o2 >= 0 && o2 < a2))
                return this.elevationOffset;
              let r2 = 0;
              const s2 = this.getTerrainData(e3);
              if (s2.tile && s2.tile.dem) {
                const e4 = t.transformMat4$1([], [i2 / a2 * t.EXTENT, o2 / a2 * t.EXTENT], s2.u_terrain_matrix), n2 = [e4[0] * s2.tile.dem.dim, e4[1] * s2.tile.dem.dim], l2 = [Math.floor(n2[0]), Math.floor(n2[1])], c2 = s2.tile.dem.get(l2[0], l2[1]), h2 = s2.tile.dem.get(l2[0], l2[1] + 1), u2 = s2.tile.dem.get(l2[0] + 1, l2[1]), d2 = s2.tile.dem.get(l2[0] + 1, l2[1] + 1);
                r2 = t.number(t.number(c2, h2, n2[0] - l2[0]), t.number(u2, d2, n2[0] - l2[0]), n2[1] - l2[1]);
              }
              return r2;
            }
            rememberForRerender(t2, e3) {
              for (const i2 in this.sourceCache._tiles) {
                const o2 = this.sourceCache._tiles[i2];
                (o2.tileID.equals(e3) || o2.tileID.isChildOf(e3)) && (t2 === this.sourceCache.sourceCache.id && (o2.timeLoaded = Date.now()), this._rerender[t2] = this._rerender[t2] || {}, this._rerender[t2][o2.tileID.key] = true);
              }
            }
            needsRerender(t2, e3) {
              return this._rerender[t2] && this._rerender[t2][e3.key];
            }
            clearRerenderCache() {
              this._rerender = {};
            }
            getElevation(e3, i2, o2, a2 = t.EXTENT) {
              return (this.getDEMElevation(e3, i2, o2, a2) + this.elevationOffset) * this.exaggeration;
            }
            getTerrainData(e3) {
              if (!this._emptyDemTexture) {
                const e4 = this.style.map.painter.context, i3 = new t.RGBAImage({ width: 1, height: 1 }, new Uint8Array(4));
                this._emptyDepthTexture = new l(e4, i3, e4.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new l(e4, new t.RGBAImage({ width: 1, height: 1 }), e4.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(e4.gl.NEAREST, e4.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t.identity([]);
              }
              const i2 = this.sourceCache.getSourceTile(e3, true);
              if (i2 && i2.dem && (!i2.demTexture || i2.needsTerrainPrepare)) {
                const t2 = this.style.map.painter.context;
                i2.demTexture = this.style.map.painter.getTileTexture(i2.dem.stride), i2.demTexture ? i2.demTexture.update(i2.dem.getPixels(), { premultiply: false }) : i2.demTexture = new l(t2, i2.dem.getPixels(), t2.gl.RGBA, { premultiply: false }), i2.demTexture.bind(t2.gl.NEAREST, t2.gl.CLAMP_TO_EDGE), i2.needsTerrainPrepare = false;
              }
              const o2 = i2 && i2 + i2.tileID.key + e3.key;
              if (o2 && !this._demMatrixCache[o2]) {
                const o3 = this.sourceCache.sourceCache._source.maxzoom;
                let a2 = e3.canonical.z - i2.tileID.canonical.z;
                e3.overscaledZ > e3.canonical.z && (e3.canonical.z >= o3 ? a2 = e3.canonical.z - o3 : t.warnOnce("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
                const r2 = e3.canonical.x - (e3.canonical.x >> a2 << a2), s2 = e3.canonical.y - (e3.canonical.y >> a2 << a2), n2 = t.fromScaling(new Float64Array(16), [1 / (t.EXTENT << a2), 1 / (t.EXTENT << a2), 0]);
                t.translate(n2, n2, [r2 * t.EXTENT, s2 * t.EXTENT, 0]), this._demMatrixCache[e3.key] = { matrix: n2, coord: e3 };
              }
              return { u_depth: 2, u_terrain: 3, u_terrain_dim: i2 && i2.dem && i2.dem.dim || 1, u_terrain_matrix: o2 ? this._demMatrixCache[e3.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i2 && i2.dem && i2.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_offset: this.elevationOffset, u_terrain_exaggeration: this.exaggeration, texture: (i2 && i2.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i2 };
            }
            getRTTFramebuffer() {
              const t2 = this.style.map.painter;
              if (!this._rttFramebuffer) {
                const e3 = this.sourceCache.tileSize * this.qualityFactor;
                this._rttFramebuffer = t2.context.createFramebuffer(e3, e3, true), this._rttFramebuffer.depthAttachment.set(t2.context.createRenderbuffer(t2.context.gl.DEPTH_COMPONENT16, e3, e3));
              }
              return this._rttFramebuffer;
            }
            getFramebuffer(t2) {
              const e3 = this.style.map.painter, i2 = e3.width / devicePixelRatio, o2 = e3.height / devicePixelRatio;
              return !this._fbo || this._fbo.width === i2 && this._fbo.height === o2 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new l(e3.context, { width: i2, height: o2, data: null }, e3.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(e3.context.gl.NEAREST, e3.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new l(e3.context, { width: i2, height: o2, data: null }, e3.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(e3.context.gl.NEAREST, e3.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = e3.context.createFramebuffer(i2, o2, true), this._fbo.depthAttachment.set(e3.context.createRenderbuffer(e3.context.gl.DEPTH_COMPONENT16, i2, o2))), this._fbo.colorAttachment.set("coords" === t2 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
            }
            getCoordsTexture() {
              const e3 = this.style.map.painter.context;
              if (this._coordsTexture)
                return this._coordsTexture;
              const i2 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
              for (let t2 = 0, e4 = 0; t2 < this._coordsTextureSize; t2++)
                for (let o3 = 0; o3 < this._coordsTextureSize; o3++, e4 += 4)
                  i2[e4 + 0] = 255 & o3, i2[e4 + 1] = 255 & t2, i2[e4 + 2] = o3 >> 8 << 4 | t2 >> 8, i2[e4 + 3] = 0;
              const o2 = new t.RGBAImage({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i2.buffer)), a2 = new l(e3, o2, e3.gl.RGBA, { premultiply: false });
              return a2.bind(e3.gl.NEAREST, e3.gl.CLAMP_TO_EDGE), this._coordsTexture = a2, a2;
            }
            pointCoordinate(e3) {
              const i2 = new Uint8Array(4), o2 = this.style.map.painter, a2 = o2.context, r2 = a2.gl;
              a2.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), r2.readPixels(e3.x, o2.height / devicePixelRatio - e3.y - 1, 1, 1, r2.RGBA, r2.UNSIGNED_BYTE, i2), a2.bindFramebuffer.set(null);
              const s2 = i2[0] + (i2[2] >> 4 << 8), n2 = i2[1] + ((15 & i2[2]) << 8), l2 = this.coordsIndex[255 - i2[3]], c2 = l2 && this.sourceCache.getTileByID(l2);
              if (!c2)
                return null;
              const h2 = this._coordsTextureSize, u2 = (1 << c2.tileID.canonical.z) * h2;
              return new t.MercatorCoordinate((c2.tileID.canonical.x * h2 + s2) / u2, (c2.tileID.canonical.y * h2 + n2) / u2, this.getElevation(c2.tileID, s2, n2, h2));
            }
            getTerrainMesh() {
              if (this._mesh)
                return this._mesh;
              const e3 = this.style.map.painter.context, i2 = new t.PosArray(), o2 = new t.TriangleIndexArray(), a2 = this.meshSize, r2 = t.EXTENT / a2, s2 = a2 * a2;
              for (let t2 = 0; t2 <= a2; t2++)
                for (let e4 = 0; e4 <= a2; e4++)
                  i2.emplaceBack(e4 * r2, t2 * r2);
              for (let t2 = 0; t2 < s2; t2 += a2 + 1)
                for (let e4 = 0; e4 < a2; e4++)
                  o2.emplaceBack(e4 + t2, a2 + e4 + t2 + 1, a2 + e4 + t2 + 2), o2.emplaceBack(e4 + t2, a2 + e4 + t2 + 2, e4 + t2 + 1);
              return this._mesh = { indexBuffer: e3.createIndexBuffer(o2), vertexBuffer: e3.createVertexBuffer(i2, Wt.members), segments: t.SegmentVector.simpleSegment(0, 0, i2.length, o2.length) }, this._mesh;
            }
            getMinMaxElevation(t2) {
              const e3 = this.getTerrainData(t2).tile, i2 = { minElevation: null, maxElevation: null };
              return e3 && e3.dem && (i2.minElevation = (e3.dem.min + this.elevationOffset) * this.exaggeration, i2.maxElevation = (e3.dem.max + this.elevationOffset) * this.exaggeration), i2;
            }
          }
          const Yt = (e3, i2) => t.emitValidationErrors(e3, i2 && i2.filter((t2) => "source.canvas" !== t2.identifier)), Jt = t.pick(W, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]), Qt = t.pick(W, ["setCenter", "setZoom", "setBearing", "setPitch"]), te = function() {
            const e3 = {}, i2 = t.spec.$version;
            for (const o2 in t.spec.$root) {
              const a2 = t.spec.$root[o2];
              if (a2.required) {
                let t2 = null;
                t2 = "version" === o2 ? i2 : "array" === a2.type ? [] : {}, null != t2 && (e3[o2] = t2);
              }
            }
            return e3;
          }();
          class ee extends t.Evented {
            constructor(e3, i2 = {}) {
              super(), this.map = e3, this.dispatcher = new v(j(), this), this.imageManager = new h(), this.imageManager.setEventedParent(this), this.glyphManager = new _(e3._requestManager, i2.localIdeographFontFamily), this.lineAtlas = new x2(256, 512), this.crossTileSymbolIndex = new Xt(), this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.ZoomHistory(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t.getReferrer());
              const o2 = this;
              this._rtlTextPluginCallback = ee.registerForPluginStateChange((e4) => {
                o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: e4.pluginStatus, pluginURL: e4.pluginURL }, (e6, i3) => {
                  if (t.triggerPluginCompletionEvent(e6), i3 && i3.every((t2) => t2))
                    for (const t2 in o2.sourceCaches)
                      o2.sourceCaches[t2].reload();
                });
              }), this.on("data", (t2) => {
                if ("source" !== t2.dataType || "metadata" !== t2.sourceDataType)
                  return;
                const e4 = this.sourceCaches[t2.sourceId];
                if (!e4)
                  return;
                const i3 = e4.getSource();
                if (i3 && i3.vectorLayerIds)
                  for (const t3 in this._layers) {
                    const e6 = this._layers[t3];
                    e6.source === i3.id && this._validateLayer(e6);
                  }
              });
            }
            loadURL(e3, i2 = {}) {
              this.fire(new t.Event("dataloading", { dataType: "style" }));
              const o2 = "boolean" != typeof i2.validate || i2.validate, a2 = this.map._requestManager.transformRequest(e3, t.ResourceType.Style);
              this._request = t.getJSON(a2, (e4, i3) => {
                this._request = null, e4 ? this.fire(new t.ErrorEvent(e4)) : i3 && this._load(i3, o2);
              });
            }
            loadJSON(e3, i2 = {}) {
              this.fire(new t.Event("dataloading", { dataType: "style" })), this._request = t.exported.frame(() => {
                this._request = null, this._load(e3, false !== i2.validate);
              });
            }
            loadEmpty() {
              this.fire(new t.Event("dataloading", { dataType: "style" })), this._load(te, false);
            }
            _load(e3, i2) {
              if (i2 && Yt(this, t.validateStyle(e3)))
                return;
              this._loaded = true, this.stylesheet = e3;
              for (const t2 in e3.sources)
                this.addSource(t2, e3.sources[t2], { validate: false });
              e3.sprite ? this._loadSprite(e3.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(e3.glyphs);
              const o2 = X(this.stylesheet.layers);
              this._order = o2.map((t2) => t2.id), this._layers = {}, this._serializedLayers = {};
              for (let e4 of o2)
                e4 = t.createStyleLayer(e4), e4.setEventedParent(this, { layer: { id: e4.id } }), this._layers[e4.id] = e4, this._serializedLayers[e4.id] = e4.serialize();
              this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new g(this.stylesheet.light), this.setTerrain(this.stylesheet.terrain), this.fire(new t.Event("data", { dataType: "style" })), this.fire(new t.Event("style.load"));
            }
            _loadSprite(e3) {
              this._spriteRequest = function(e4, i2, o2, a2) {
                let r2, s2, n2;
                const l2 = o2 > 1 ? "@2x" : "";
                let c2 = t.getJSON(i2.transformRequest(i2.normalizeSpriteURL(e4, l2, ".json"), t.ResourceType.SpriteJSON), (t2, e6) => {
                  c2 = null, n2 || (n2 = t2, r2 = e6, u2());
                }), h2 = t.getImage(i2.transformRequest(i2.normalizeSpriteURL(e4, l2, ".png"), t.ResourceType.SpriteImage), (t2, e6) => {
                  h2 = null, n2 || (n2 = t2, s2 = e6, u2());
                });
                function u2() {
                  if (n2)
                    a2(n2);
                  else if (r2 && s2) {
                    const e6 = t.exported.getImageData(s2), i3 = {};
                    for (const o3 in r2) {
                      const { width: a3, height: s3, x: n3, y: l3, sdf: c3, pixelRatio: h3, stretchX: u3, stretchY: d2, content: m2 } = r2[o3], _2 = new t.RGBAImage({ width: a3, height: s3 });
                      t.RGBAImage.copy(e6, _2, { x: n3, y: l3 }, { x: 0, y: 0 }, { width: a3, height: s3 }), i3[o3] = { data: _2, pixelRatio: h3, sdf: c3, stretchX: u3, stretchY: d2, content: m2 };
                    }
                    a2(null, i3);
                  }
                }
                return { cancel() {
                  c2 && (c2.cancel(), c2 = null), h2 && (h2.cancel(), h2 = null);
                } };
              }(e3, this.map._requestManager, this.map.getPixelRatio(), (e4, i2) => {
                if (this._spriteRequest = null, e4)
                  this.fire(new t.ErrorEvent(e4));
                else if (i2)
                  for (const t2 in i2)
                    this.imageManager.addImage(t2, i2[t2]);
                this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.Event("data", { dataType: "style" }));
              });
            }
            _validateLayer(e3) {
              const i2 = this.sourceCaches[e3.source];
              if (!i2)
                return;
              const o2 = e3.sourceLayer;
              if (!o2)
                return;
              const a2 = i2.getSource();
              ("geojson" === a2.type || a2.vectorLayerIds && -1 === a2.vectorLayerIds.indexOf(o2)) && this.fire(new t.ErrorEvent(new Error(`Source layer "${o2}" does not exist on source "${a2.id}" as specified by style layer "${e3.id}".`)));
            }
            loaded() {
              if (!this._loaded)
                return false;
              if (Object.keys(this._updatedSources).length)
                return false;
              for (const t2 in this.sourceCaches)
                if (!this.sourceCaches[t2].loaded())
                  return false;
              return !!this.imageManager.isLoaded();
            }
            _serializeLayers(t2) {
              const e3 = [];
              for (const i2 of t2) {
                const t3 = this._layers[i2];
                "custom" !== t3.type && e3.push(t3.serialize());
              }
              return e3;
            }
            hasTransitions() {
              if (this.light && this.light.hasTransition())
                return true;
              for (const t2 in this.sourceCaches)
                if (this.sourceCaches[t2].hasTransition())
                  return true;
              for (const t2 in this._layers)
                if (this._layers[t2].hasTransition())
                  return true;
              return false;
            }
            _checkLoaded() {
              if (!this._loaded)
                throw new Error("Style is not done loading.");
            }
            update(e3) {
              if (!this._loaded)
                return;
              const i2 = this._changed;
              if (this._changed) {
                const t2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
                (t2.length || i3.length) && this._updateWorkerLayers(t2, i3);
                for (const t3 in this._updatedSources) {
                  const e4 = this._updatedSources[t3];
                  if ("reload" === e4)
                    this._reloadSource(t3);
                  else {
                    if ("clear" !== e4)
                      throw new Error(`Invalid action ${e4}`);
                    this._clearSource(t3);
                  }
                }
                this._updateTilesForChangedImages();
                for (const t3 in this._updatedPaintProps)
                  this._layers[t3].updateTransitions(e3);
                this.light.updateTransitions(e3), this._resetUpdates();
              }
              const o2 = {};
              for (const t2 in this.sourceCaches) {
                const e4 = this.sourceCaches[t2];
                o2[t2] = e4.used, e4.used = false;
              }
              for (const t2 of this._order) {
                const i3 = this._layers[t2];
                i3.recalculate(e3, this._availableImages), !i3.isHidden(e3.zoom) && i3.source && (this.sourceCaches[i3.source].used = true);
              }
              for (const e4 in o2) {
                const i3 = this.sourceCaches[e4];
                o2[e4] !== i3.used && i3.fire(new t.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: e4 }));
              }
              this.light.recalculate(e3), this.z = e3.zoom, i2 && this.fire(new t.Event("data", { dataType: "style" }));
            }
            _updateTilesForChangedImages() {
              const t2 = Object.keys(this._changedImages);
              if (t2.length) {
                for (const e3 in this.sourceCaches)
                  this.sourceCaches[e3].reloadTilesForDependencies(["icons", "patterns"], t2);
                this._changedImages = {};
              }
            }
            _updateWorkerLayers(t2, e3) {
              this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(t2), removedIds: e3 });
            }
            _resetUpdates() {
              this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
            }
            setTerrain(e3) {
              if (this._checkLoaded(), this._terrainDataCallback && this.off("data", this._terrainDataCallback), this._terrainfreezeElevationCallback && this.map.off("freezeElevation", this._terrainfreezeElevationCallback), e3) {
                const t2 = this.sourceCaches[e3.source];
                if (!t2)
                  throw new Error(`cannot load terrain, because there exists no source with ID: ${e3.source}`);
                this.terrain = new Kt(this, t2, e3), this.map.transform.updateElevation(this.terrain), this._terrainfreezeElevationCallback = (t3) => {
                  t3.freeze ? this.map.transform.freezeElevation = true : (this.map.transform.freezeElevation = false, this.map.transform.recalculateZoom(this.terrain));
                }, this._terrainDataCallback = (t3) => {
                  t3.tile && (t3.sourceId === e3.source ? (this.map.transform.updateElevation(this.terrain), this.terrain.rememberForRerender(t3.sourceId, t3.tile.tileID)) : "geojson" === t3.source.type && this.terrain.rememberForRerender(t3.sourceId, t3.tile.tileID));
                }, this.on("data", this._terrainDataCallback), this.map.on("freezeElevation", this._terrainfreezeElevationCallback);
              } else
                this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.map.transform.updateElevation(this.terrain);
              this.map.fire(new t.Event("terrain", { terrain: e3 }));
            }
            setState(e3) {
              if (this._checkLoaded(), Yt(this, t.validateStyle(e3)))
                return false;
              (e3 = t.clone$1(e3)).layers = X(e3.layers);
              const i2 = function(t2, e4) {
                if (!t2)
                  return [{ command: W.setStyle, args: [e4] }];
                let i3 = [];
                try {
                  if (!a(t2.version, e4.version))
                    return [{ command: W.setStyle, args: [e4] }];
                  a(t2.center, e4.center) || i3.push({ command: W.setCenter, args: [e4.center] }), a(t2.zoom, e4.zoom) || i3.push({ command: W.setZoom, args: [e4.zoom] }), a(t2.bearing, e4.bearing) || i3.push({ command: W.setBearing, args: [e4.bearing] }), a(t2.pitch, e4.pitch) || i3.push({ command: W.setPitch, args: [e4.pitch] }), a(t2.sprite, e4.sprite) || i3.push({ command: W.setSprite, args: [e4.sprite] }), a(t2.glyphs, e4.glyphs) || i3.push({ command: W.setGlyphs, args: [e4.glyphs] }), a(t2.transition, e4.transition) || i3.push({ command: W.setTransition, args: [e4.transition] }), a(t2.light, e4.light) || i3.push({ command: W.setLight, args: [e4.light] });
                  const o3 = {}, r2 = [];
                  !function(t3, e6, i4, o4) {
                    let r3;
                    for (r3 in e6 = e6 || {}, t3 = t3 || {})
                      Object.prototype.hasOwnProperty.call(t3, r3) && (Object.prototype.hasOwnProperty.call(e6, r3) || K(r3, i4, o4));
                    for (r3 in e6)
                      Object.prototype.hasOwnProperty.call(e6, r3) && (Object.prototype.hasOwnProperty.call(t3, r3) ? a(t3[r3], e6[r3]) || ("geojson" === t3[r3].type && "geojson" === e6[r3].type && J(t3, e6, r3) ? i4.push({ command: W.setGeoJSONSourceData, args: [r3, e6[r3].data] }) : Y(r3, e6, i4, o4)) : H(r3, e6, i4));
                  }(t2.sources, e4.sources, r2, o3);
                  const s2 = [];
                  t2.layers && t2.layers.forEach((t3) => {
                    o3[t3.source] ? i3.push({ command: W.removeLayer, args: [t3.id] }) : s2.push(t3);
                  }), i3 = i3.concat(r2), function(t3, e6, i4) {
                    e6 = e6 || [];
                    const o4 = (t3 = t3 || []).map(tt), r3 = e6.map(tt), s3 = t3.reduce(et, {}), n2 = e6.reduce(et, {}), l2 = o4.slice(), c2 = /* @__PURE__ */ Object.create(null);
                    let h2, u2, d2, m2, _2, p2, f2;
                    for (h2 = 0, u2 = 0; h2 < o4.length; h2++)
                      d2 = o4[h2], Object.prototype.hasOwnProperty.call(n2, d2) ? u2++ : (i4.push({ command: W.removeLayer, args: [d2] }), l2.splice(l2.indexOf(d2, u2), 1));
                    for (h2 = 0, u2 = 0; h2 < r3.length; h2++)
                      d2 = r3[r3.length - 1 - h2], l2[l2.length - 1 - h2] !== d2 && (Object.prototype.hasOwnProperty.call(s3, d2) ? (i4.push({ command: W.removeLayer, args: [d2] }), l2.splice(l2.lastIndexOf(d2, l2.length - u2), 1)) : u2++, p2 = l2[l2.length - h2], i4.push({ command: W.addLayer, args: [n2[d2], p2] }), l2.splice(l2.length - h2, 0, d2), c2[d2] = true);
                    for (h2 = 0; h2 < r3.length; h2++)
                      if (d2 = r3[h2], m2 = s3[d2], _2 = n2[d2], !c2[d2] && !a(m2, _2))
                        if (a(m2.source, _2.source) && a(m2["source-layer"], _2["source-layer"]) && a(m2.type, _2.type)) {
                          for (f2 in Q(m2.layout, _2.layout, i4, d2, null, W.setLayoutProperty), Q(m2.paint, _2.paint, i4, d2, null, W.setPaintProperty), a(m2.filter, _2.filter) || i4.push({ command: W.setFilter, args: [d2, _2.filter] }), a(m2.minzoom, _2.minzoom) && a(m2.maxzoom, _2.maxzoom) || i4.push({ command: W.setLayerZoomRange, args: [d2, _2.minzoom, _2.maxzoom] }), m2)
                            Object.prototype.hasOwnProperty.call(m2, f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? Q(m2[f2], _2[f2], i4, d2, f2.slice(6), W.setPaintProperty) : a(m2[f2], _2[f2]) || i4.push({ command: W.setLayerProperty, args: [d2, f2, _2[f2]] }));
                          for (f2 in _2)
                            Object.prototype.hasOwnProperty.call(_2, f2) && !Object.prototype.hasOwnProperty.call(m2, f2) && "layout" !== f2 && "paint" !== f2 && "filter" !== f2 && "metadata" !== f2 && "minzoom" !== f2 && "maxzoom" !== f2 && (0 === f2.indexOf("paint.") ? Q(m2[f2], _2[f2], i4, d2, f2.slice(6), W.setPaintProperty) : a(m2[f2], _2[f2]) || i4.push({ command: W.setLayerProperty, args: [d2, f2, _2[f2]] }));
                        } else
                          i4.push({ command: W.removeLayer, args: [d2] }), p2 = l2[l2.lastIndexOf(d2) + 1], i4.push({ command: W.addLayer, args: [_2, p2] });
                  }(s2, e4.layers, i3);
                } catch (t3) {
                  console.warn("Unable to compute style diff:", t3), i3 = [{ command: W.setStyle, args: [e4] }];
                }
                return i3;
              }(this.serialize(), e3).filter((t2) => !(t2.command in Qt));
              if (0 === i2.length)
                return false;
              const o2 = i2.filter((t2) => !(t2.command in Jt));
              if (o2.length > 0)
                throw new Error(`Unimplemented: ${o2.map((t2) => t2.command).join(", ")}.`);
              return i2.forEach((t2) => {
                "setTransition" !== t2.command && this[t2.command].apply(this, t2.args);
              }), this.stylesheet = e3, true;
            }
            addImage(e3, i2) {
              if (this.getImage(e3))
                return this.fire(new t.ErrorEvent(new Error(`An image named "${e3}" already exists.`)));
              this.imageManager.addImage(e3, i2), this._afterImageUpdated(e3);
            }
            updateImage(t2, e3) {
              this.imageManager.updateImage(t2, e3);
            }
            getImage(t2) {
              return this.imageManager.getImage(t2);
            }
            removeImage(e3) {
              if (!this.getImage(e3))
                return this.fire(new t.ErrorEvent(new Error(`An image named "${e3}" does not exist.`)));
              this.imageManager.removeImage(e3), this._afterImageUpdated(e3);
            }
            _afterImageUpdated(e3) {
              this._availableImages = this.imageManager.listImages(), this._changedImages[e3] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.Event("data", { dataType: "style" }));
            }
            listImages() {
              return this._checkLoaded(), this.imageManager.listImages();
            }
            addSource(e3, i2, o2 = {}) {
              if (this._checkLoaded(), void 0 !== this.sourceCaches[e3])
                throw new Error(`Source "${e3}" already exists.`);
              if (!i2.type)
                throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
              if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(t.validateStyle.source, `sources.${e3}`, i2, null, o2))
                return;
              this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
              const a2 = this.sourceCaches[e3] = new O(e3, i2, this.dispatcher);
              a2.style = this, a2.setEventedParent(this, () => ({ isSourceLoaded: this.loaded(), source: a2.serialize(), sourceId: e3 })), a2.onAdd(this.map), this._changed = true;
            }
            removeSource(e3) {
              if (this._checkLoaded(), void 0 === this.sourceCaches[e3])
                throw new Error("There is no source with this ID");
              for (const i3 in this._layers)
                if (this._layers[i3].source === e3)
                  return this.fire(new t.ErrorEvent(new Error(`Source "${e3}" cannot be removed while layer "${i3}" is using it.`)));
              const i2 = this.sourceCaches[e3];
              delete this.sourceCaches[e3], delete this._updatedSources[e3], i2.fire(new t.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: e3 })), i2.setEventedParent(null), i2.onRemove(this.map), this._changed = true;
            }
            setGeoJSONSourceData(t2, e3) {
              if (this._checkLoaded(), void 0 === this.sourceCaches[t2])
                throw new Error(`There is no source with this ID=${t2}`);
              const i2 = this.sourceCaches[t2].getSource();
              if ("geojson" !== i2.type)
                throw new Error(`geojsonSource.type is ${i2.type}, which is !== 'geojson`);
              i2.setData(e3), this._changed = true;
            }
            getSource(t2) {
              return this.sourceCaches[t2] && this.sourceCaches[t2].getSource();
            }
            addLayer(e3, i2, o2 = {}) {
              this._checkLoaded();
              const a2 = e3.id;
              if (this.getLayer(a2))
                return void this.fire(new t.ErrorEvent(new Error(`Layer "${a2}" already exists on this map.`)));
              let r2;
              if ("custom" === e3.type) {
                if (Yt(this, t.validateCustomStyleLayer(e3)))
                  return;
                r2 = t.createStyleLayer(e3);
              } else {
                if ("object" == typeof e3.source && (this.addSource(a2, e3.source), e3 = t.clone$1(e3), e3 = t.extend(e3, { source: a2 })), this._validate(t.validateStyle.layer, `layers.${a2}`, e3, { arrayIndex: -1 }, o2))
                  return;
                r2 = t.createStyleLayer(e3), this._validateLayer(r2), r2.setEventedParent(this, { layer: { id: a2 } }), this._serializedLayers[r2.id] = r2.serialize();
              }
              const s2 = i2 ? this._order.indexOf(i2) : this._order.length;
              if (i2 && -1 === s2)
                this.fire(new t.ErrorEvent(new Error(`Cannot add layer "${a2}" before non-existing layer "${i2}".`)));
              else {
                if (this._order.splice(s2, 0, a2), this._layerOrderChanged = true, this._layers[a2] = r2, this._removedLayers[a2] && r2.source && "custom" !== r2.type) {
                  const t2 = this._removedLayers[a2];
                  delete this._removedLayers[a2], t2.type !== r2.type ? this._updatedSources[r2.source] = "clear" : (this._updatedSources[r2.source] = "reload", this.sourceCaches[r2.source].pause());
                }
                this._updateLayer(r2), r2.onAdd && r2.onAdd(this.map);
              }
            }
            moveLayer(e3, i2) {
              if (this._checkLoaded(), this._changed = true, !this._layers[e3])
                return void this.fire(new t.ErrorEvent(new Error(`The layer '${e3}' does not exist in the map's style and cannot be moved.`)));
              if (e3 === i2)
                return;
              const o2 = this._order.indexOf(e3);
              this._order.splice(o2, 1);
              const a2 = i2 ? this._order.indexOf(i2) : this._order.length;
              i2 && -1 === a2 ? this.fire(new t.ErrorEvent(new Error(`Cannot move layer "${e3}" before non-existing layer "${i2}".`))) : (this._order.splice(a2, 0, e3), this._layerOrderChanged = true);
            }
            removeLayer(e3) {
              this._checkLoaded();
              const i2 = this._layers[e3];
              if (!i2)
                return void this.fire(new t.ErrorEvent(new Error(`Cannot remove non-existing layer "${e3}".`)));
              i2.setEventedParent(null);
              const o2 = this._order.indexOf(e3);
              this._order.splice(o2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e3] = i2, delete this._layers[e3], delete this._serializedLayers[e3], delete this._updatedLayers[e3], delete this._updatedPaintProps[e3], i2.onRemove && i2.onRemove(this.map);
            }
            getLayer(t2) {
              return this._layers[t2];
            }
            hasLayer(t2) {
              return t2 in this._layers;
            }
            setLayerZoomRange(e3, i2, o2) {
              this._checkLoaded();
              const a2 = this.getLayer(e3);
              a2 ? a2.minzoom === i2 && a2.maxzoom === o2 || (null != i2 && (a2.minzoom = i2), null != o2 && (a2.maxzoom = o2), this._updateLayer(a2)) : this.fire(new t.ErrorEvent(new Error(`Cannot set the zoom range of non-existing layer "${e3}".`)));
            }
            setFilter(e3, i2, o2 = {}) {
              this._checkLoaded();
              const r2 = this.getLayer(e3);
              if (r2) {
                if (!a(r2.filter, i2))
                  return null == i2 ? (r2.filter = void 0, void this._updateLayer(r2)) : void (this._validate(t.validateStyle.filter, `layers.${r2.id}.filter`, i2, null, o2) || (r2.filter = t.clone$1(i2), this._updateLayer(r2)));
              } else
                this.fire(new t.ErrorEvent(new Error(`Cannot filter non-existing layer "${e3}".`)));
            }
            getFilter(e3) {
              return t.clone$1(this.getLayer(e3).filter);
            }
            setLayoutProperty(e3, i2, o2, r2 = {}) {
              this._checkLoaded();
              const s2 = this.getLayer(e3);
              s2 ? a(s2.getLayoutProperty(i2), o2) || (s2.setLayoutProperty(i2, o2, r2), this._updateLayer(s2)) : this.fire(new t.ErrorEvent(new Error(`Cannot style non-existing layer "${e3}".`)));
            }
            getLayoutProperty(e3, i2) {
              const o2 = this.getLayer(e3);
              if (o2)
                return o2.getLayoutProperty(i2);
              this.fire(new t.ErrorEvent(new Error(`Cannot get style of non-existing layer "${e3}".`)));
            }
            setPaintProperty(e3, i2, o2, r2 = {}) {
              this._checkLoaded();
              const s2 = this.getLayer(e3);
              s2 ? a(s2.getPaintProperty(i2), o2) || (s2.setPaintProperty(i2, o2, r2) && this._updateLayer(s2), this._changed = true, this._updatedPaintProps[e3] = true) : this.fire(new t.ErrorEvent(new Error(`Cannot style non-existing layer "${e3}".`)));
            }
            getPaintProperty(t2, e3) {
              return this.getLayer(t2).getPaintProperty(e3);
            }
            setFeatureState(e3, i2) {
              this._checkLoaded();
              const o2 = e3.source, a2 = e3.sourceLayer, r2 = this.sourceCaches[o2];
              if (void 0 === r2)
                return void this.fire(new t.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
              const s2 = r2.getSource().type;
              "geojson" === s2 && a2 ? this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== s2 || a2 ? (void 0 === e3.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), r2.setFeatureState(a2, e3.id, i2)) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
            removeFeatureState(e3, i2) {
              this._checkLoaded();
              const o2 = e3.source, a2 = this.sourceCaches[o2];
              if (void 0 === a2)
                return void this.fire(new t.ErrorEvent(new Error(`The source '${o2}' does not exist in the map's style.`)));
              const r2 = a2.getSource().type, s2 = "vector" === r2 ? e3.sourceLayer : void 0;
              "vector" !== r2 || s2 ? i2 && "string" != typeof e3.id && "number" != typeof e3.id ? this.fire(new t.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : a2.removeFeatureState(s2, e3.id, i2) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
            getFeatureState(e3) {
              this._checkLoaded();
              const i2 = e3.source, o2 = e3.sourceLayer, a2 = this.sourceCaches[i2];
              if (void 0 !== a2)
                return "vector" !== a2.getSource().type || o2 ? (void 0 === e3.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), a2.getFeatureState(o2, e3.id)) : void this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
              this.fire(new t.ErrorEvent(new Error(`The source '${i2}' does not exist in the map's style.`)));
            }
            getTransition() {
              return t.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
            }
            serialize() {
              return t.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: t.mapObject(this.sourceCaches, (t2) => t2.serialize()), layers: this._serializeLayers(this._order) }, (t2) => void 0 !== t2);
            }
            _updateLayer(t2) {
              this._updatedLayers[t2.id] = true, t2.source && !this._updatedSources[t2.source] && "raster" !== this.sourceCaches[t2.source].getSource().type && (this._updatedSources[t2.source] = "reload", this.sourceCaches[t2.source].pause()), this._changed = true;
            }
            _flattenAndSortRenderedFeatures(t2) {
              const e3 = (t3) => "fill-extrusion" === this._layers[t3].type, i2 = {}, o2 = [];
              for (let a3 = this._order.length - 1; a3 >= 0; a3--) {
                const r2 = this._order[a3];
                if (e3(r2)) {
                  i2[r2] = a3;
                  for (const e4 of t2) {
                    const t3 = e4[r2];
                    if (t3)
                      for (const e6 of t3)
                        o2.push(e6);
                  }
                }
              }
              o2.sort((t3, e4) => e4.intersectionZ - t3.intersectionZ);
              const a2 = [];
              for (let r2 = this._order.length - 1; r2 >= 0; r2--) {
                const s2 = this._order[r2];
                if (e3(s2))
                  for (let t3 = o2.length - 1; t3 >= 0; t3--) {
                    const e4 = o2[t3].feature;
                    if (i2[e4.layer.id] < r2)
                      break;
                    a2.push(e4), o2.pop();
                  }
                else
                  for (const e4 of t2) {
                    const t3 = e4[s2];
                    if (t3)
                      for (const e6 of t3)
                        a2.push(e6.feature);
                  }
              }
              return a2;
            }
            queryRenderedFeatures(e3, i2, o2) {
              i2 && i2.filter && this._validate(t.validateStyle.filter, "queryRenderedFeatures.filter", i2.filter, null, i2);
              const a2 = {};
              if (i2 && i2.layers) {
                if (!Array.isArray(i2.layers))
                  return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
                for (const e4 of i2.layers) {
                  const i3 = this._layers[e4];
                  if (!i3)
                    return this.fire(new t.ErrorEvent(new Error(`The layer '${e4}' does not exist in the map's style and cannot be queried for features.`))), [];
                  a2[i3.source] = true;
                }
              }
              const r2 = [];
              i2.availableImages = this._availableImages;
              for (const t2 in this.sourceCaches)
                i2.layers && !a2[t2] || r2.push(L(this.sourceCaches[t2], this._layers, this._serializedLayers, e3, i2, o2));
              return this.placement && r2.push(function(t2, e4, i3, o3, a3, r3, s2) {
                const n2 = {}, l2 = r3.queryRenderedSymbols(o3), c2 = [];
                for (const t3 of Object.keys(l2).map(Number))
                  c2.push(s2[t3]);
                c2.sort(R);
                for (const i4 of c2) {
                  const o4 = i4.featureIndex.lookupSymbolFeatures(l2[i4.bucketInstanceId], e4, i4.bucketIndex, i4.sourceLayerIndex, a3.filter, a3.layers, a3.availableImages, t2);
                  for (const t3 in o4) {
                    const e6 = n2[t3] = n2[t3] || [], a4 = o4[t3];
                    a4.sort((t4, e7) => {
                      const o5 = i4.featureSortOrder;
                      if (o5) {
                        const i5 = o5.indexOf(t4.featureIndex);
                        return o5.indexOf(e7.featureIndex) - i5;
                      }
                      return e7.featureIndex - t4.featureIndex;
                    });
                    for (const t4 of a4)
                      e6.push(t4);
                  }
                }
                for (const e6 in n2)
                  n2[e6].forEach((o4) => {
                    const a4 = o4.feature, r4 = i3[t2[e6].source].getFeatureState(a4.layer["source-layer"], a4.id);
                    a4.source = a4.layer.source, a4.layer["source-layer"] && (a4.sourceLayer = a4.layer["source-layer"]), a4.state = r4;
                  });
                return n2;
              }(this._layers, this._serializedLayers, this.sourceCaches, e3, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(r2);
            }
            querySourceFeatures(e3, i2) {
              i2 && i2.filter && this._validate(t.validateStyle.filter, "querySourceFeatures.filter", i2.filter, null, i2);
              const o2 = this.sourceCaches[e3];
              return o2 ? function(t2, e4) {
                const i3 = t2.getRenderableIds().map((e6) => t2.getTileByID(e6)), o3 = [], a2 = {};
                for (let t3 = 0; t3 < i3.length; t3++) {
                  const r2 = i3[t3], s2 = r2.tileID.canonical.key;
                  a2[s2] || (a2[s2] = true, r2.querySourceFeatures(o3, e4));
                }
                return o3;
              }(o2, i2) : [];
            }
            addSourceType(t2, e3, i2) {
              return ee.getSourceType(t2) ? i2(new Error(`A source type called "${t2}" already exists.`)) : (ee.setSourceType(t2, e3), e3.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t2, url: e3.workerSourceURL }, i2) : i2(null, null));
            }
            getLight() {
              return this.light.getLight();
            }
            setLight(e3, i2 = {}) {
              this._checkLoaded();
              const o2 = this.light.getLight();
              let r2 = false;
              for (const t2 in e3)
                if (!a(e3[t2], o2[t2])) {
                  r2 = true;
                  break;
                }
              if (!r2)
                return;
              const s2 = { now: t.exported.now(), transition: t.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
              this.light.setLight(e3, i2), this.light.updateTransitions(s2);
            }
            _validate(e3, i2, o2, a2, r2 = {}) {
              return (!r2 || false !== r2.validate) && Yt(this, e3.call(t.validateStyle, t.extend({ key: i2, style: this.serialize(), value: o2, styleSpec: t.spec }, a2)));
            }
            _remove() {
              this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t.evented.off("pluginStateChange", this._rtlTextPluginCallback);
              for (const t2 in this._layers)
                this._layers[t2].setEventedParent(null);
              for (const t2 in this.sourceCaches) {
                const e3 = this.sourceCaches[t2];
                e3.setEventedParent(null), e3.onRemove(this.map);
              }
              this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
            }
            _clearSource(t2) {
              this.sourceCaches[t2].clearTiles();
            }
            _reloadSource(t2) {
              this.sourceCaches[t2].resume(), this.sourceCaches[t2].reload();
            }
            _updateSources(t2) {
              for (const e3 in this.sourceCaches)
                this.sourceCaches[e3].update(t2, this.terrain);
            }
            _generateCollisionBoxes() {
              for (const t2 in this.sourceCaches)
                this._reloadSource(t2);
            }
            _updatePlacement(e3, i2, o2, a2, r2 = false) {
              let s2 = false, n2 = false;
              const l2 = {};
              for (const t2 of this._order) {
                const i3 = this._layers[t2];
                if ("symbol" !== i3.type)
                  continue;
                if (!l2[i3.source]) {
                  const t3 = this.sourceCaches[i3.source];
                  l2[i3.source] = t3.getRenderableIds(true).map((e4) => t3.getTileByID(e4)).sort((t4, e4) => e4.tileID.overscaledZ - t4.tileID.overscaledZ || (t4.tileID.isLessThan(e4.tileID) ? -1 : 1));
                }
                const o3 = this.crossTileSymbolIndex.addLayer(i3, l2[i3.source], e3.center.lng);
                s2 = s2 || o3;
              }
              if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((r2 = r2 || this._layerOrderChanged || 0 === o2) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.exported.now(), e3.zoom)) && (this.pauseablePlacement = new Zt(e3, this.terrain, this._order, r2, i2, o2, a2, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.exported.now()), n2 = true), s2 && this.pauseablePlacement.placement.setStale()), n2 || s2)
                for (const t2 of this._order) {
                  const e4 = this._layers[t2];
                  "symbol" === e4.type && this.placement.updateLayerOpacities(e4, l2[e4.source]);
                }
              return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.exported.now());
            }
            _releaseSymbolFadeTiles() {
              for (const t2 in this.sourceCaches)
                this.sourceCaches[t2].releaseSymbolFadeTiles();
            }
            getImages(t2, e3, i2) {
              this.imageManager.getImages(e3.icons, i2), this._updateTilesForChangedImages();
              const o2 = this.sourceCaches[e3.source];
              o2 && o2.setDependencies(e3.tileID.key, e3.type, e3.icons);
            }
            getGlyphs(t2, e3, i2) {
              this.glyphManager.getGlyphs(e3.stacks, i2);
            }
            getResource(e3, i2, o2) {
              return t.makeRequest(i2, o2);
            }
          }
          ee.getSourceType = function(t2) {
            return M[t2];
          }, ee.setSourceType = function(t2, e3) {
            M[t2] = e3;
          }, ee.registerForPluginStateChange = t.registerForPluginStateChange;
          var ie = "attribute vec2 a_pos;uniform mat4 u_matrix;varying vec2 v_texture_pos;varying float v_depth;void main() {v_texture_pos=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);v_depth=gl_Position.z/gl_Position.w;}";
          const oe = { prelude: ae("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_offset;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return (elevation+u_terrain_offset)*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}"), background: ae("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: ae("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: ae("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), clippingMask: ae("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: ae("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"), heatmapTexture: ae("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: ae("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: ae("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: ae("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: ae("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"), fillOutline: ae("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillOutlinePattern: ae("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillPattern: ae("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), fillExtrusion: ae("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat baseDelta=10.0;float ele=get_elevation(a_centroid);\n#else\nfloat baseDelta=0.0;float ele=0.0;\n#endif\nbase=max(0.0,ele+base-baseDelta);height=max(0.0,ele+height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), fillExtrusionPattern: ae("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat baseDelta=10.0;float ele=get_elevation(a_centroid);\n#else\nfloat baseDelta=0.0;float ele=0.0;\n#endif\nbase=max(0.0,ele+base-baseDelta);height=max(0.0,ele+height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), hillshadePrepare: ae("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: ae("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: ae("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), lineGradient: ae("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), linePattern: ae("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), lineSDF: ae("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), raster: ae("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: ae("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"), symbolSDF: ae("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: ae("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrain: ae("uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}", ie), terrainDepth: ae("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", ie), terrainCoords: ae("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", ie) };
          function ae(t2, e3) {
            const i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o2 = e3.match(/attribute ([\w]+) ([\w]+)/g), a2 = t2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), r2 = e3.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), s2 = r2 ? r2.concat(a2) : a2, n2 = {};
            return { fragmentSource: t2 = t2.replace(i2, (t3, e4, i3, o3, a3) => (n2[a3] = true, "define" === e4 ? `
#ifndef HAS_UNIFORM_u_${a3}
varying ${i3} ${o3} ${a3};
#else
uniform ${i3} ${o3} u_${a3};
#endif
` : `
#ifdef HAS_UNIFORM_u_${a3}
    ${i3} ${o3} ${a3} = u_${a3};
#endif
`)), vertexSource: e3 = e3.replace(i2, (t3, e4, i3, o3, a3) => {
              const r3 = "float" === o3 ? "vec2" : "vec4", s3 = a3.match(/color/) ? "color" : r3;
              return n2[a3] ? "define" === e4 ? `
#ifndef HAS_UNIFORM_u_${a3}
uniform lowp float u_${a3}_t;
attribute ${i3} ${r3} a_${a3};
varying ${i3} ${o3} ${a3};
#else
uniform ${i3} ${o3} u_${a3};
#endif
` : "vec4" === s3 ? `
#ifndef HAS_UNIFORM_u_${a3}
    ${a3} = a_${a3};
#else
    ${i3} ${o3} ${a3} = u_${a3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a3}
    ${a3} = unpack_mix_${s3}(a_${a3}, u_${a3}_t);
#else
    ${i3} ${o3} ${a3} = u_${a3};
#endif
` : "define" === e4 ? `
#ifndef HAS_UNIFORM_u_${a3}
uniform lowp float u_${a3}_t;
attribute ${i3} ${r3} a_${a3};
#else
uniform ${i3} ${o3} u_${a3};
#endif
` : "vec4" === s3 ? `
#ifndef HAS_UNIFORM_u_${a3}
    ${i3} ${o3} ${a3} = a_${a3};
#else
    ${i3} ${o3} ${a3} = u_${a3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a3}
    ${i3} ${o3} ${a3} = unpack_mix_${s3}(a_${a3}, u_${a3}_t);
#else
    ${i3} ${o3} ${a3} = u_${a3};
#endif
`;
            }), staticAttributes: o2, staticUniforms: s2 };
          }
          class re {
            constructor() {
              this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
            }
            bind(t2, e3, i2, o2, a2, r2, s2, n2, l2) {
              this.context = t2;
              let c2 = this.boundPaintVertexBuffers.length !== o2.length;
              for (let t3 = 0; !c2 && t3 < o2.length; t3++)
                this.boundPaintVertexBuffers[t3] !== o2[t3] && (c2 = true);
              t2.extVertexArrayObject && this.vao && this.boundProgram === e3 && this.boundLayoutVertexBuffer === i2 && !c2 && this.boundIndexBuffer === a2 && this.boundVertexOffset === r2 && this.boundDynamicVertexBuffer === s2 && this.boundDynamicVertexBuffer2 === n2 && this.boundDynamicVertexBuffer3 === l2 ? (t2.bindVertexArrayOES.set(this.vao), s2 && s2.bind(), a2 && a2.dynamicDraw && a2.bind(), n2 && n2.bind(), l2 && l2.bind()) : this.freshBind(e3, i2, o2, a2, r2, s2, n2, l2);
            }
            freshBind(t2, e3, i2, o2, a2, r2, s2, n2) {
              let l2;
              const c2 = t2.numAttributes, h2 = this.context, u2 = h2.gl;
              if (h2.extVertexArrayObject)
                this.vao && this.destroy(), this.vao = h2.extVertexArrayObject.createVertexArrayOES(), h2.bindVertexArrayOES.set(this.vao), l2 = 0, this.boundProgram = t2, this.boundLayoutVertexBuffer = e3, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = a2, this.boundDynamicVertexBuffer = r2, this.boundDynamicVertexBuffer2 = s2, this.boundDynamicVertexBuffer3 = n2;
              else {
                l2 = h2.currentNumAttributes || 0;
                for (let t3 = c2; t3 < l2; t3++)
                  u2.disableVertexAttribArray(t3);
              }
              e3.enableAttributes(u2, t2);
              for (const e4 of i2)
                e4.enableAttributes(u2, t2);
              r2 && r2.enableAttributes(u2, t2), s2 && s2.enableAttributes(u2, t2), n2 && n2.enableAttributes(u2, t2), e3.bind(), e3.setVertexAttribPointers(u2, t2, a2);
              for (const e4 of i2)
                e4.bind(), e4.setVertexAttribPointers(u2, t2, a2);
              r2 && (r2.bind(), r2.setVertexAttribPointers(u2, t2, a2)), o2 && o2.bind(), s2 && (s2.bind(), s2.setVertexAttribPointers(u2, t2, a2)), n2 && (n2.bind(), n2.setVertexAttribPointers(u2, t2, a2)), h2.currentNumAttributes = c2;
            }
            destroy() {
              this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
            }
          }
          function se(t2) {
            const e3 = [];
            for (let i2 = 0; i2 < t2.length; i2++) {
              if (null === t2[i2])
                continue;
              const o2 = t2[i2].split(" ");
              e3.push(o2.pop());
            }
            return e3;
          }
          class ne {
            constructor(e3, i2, o2, a2, r2, s2, n2) {
              const l2 = e3.gl;
              this.program = l2.createProgram();
              const c2 = se(o2.staticAttributes), h2 = a2 ? a2.getBinderAttributes() : [], u2 = c2.concat(h2), d2 = oe.prelude.staticUniforms ? se(oe.prelude.staticUniforms) : [], m2 = o2.staticUniforms ? se(o2.staticUniforms) : [], _2 = a2 ? a2.getBinderUniforms() : [], p2 = d2.concat(m2).concat(_2), f2 = [];
              for (const t2 of p2)
                f2.indexOf(t2) < 0 && f2.push(t2);
              const g2 = a2 ? a2.defines() : [];
              s2 && g2.push("#define OVERDRAW_INSPECTOR;"), n2 && g2.push("#define TERRAIN3D;");
              const x3 = g2.concat(oe.prelude.fragmentSource, o2.fragmentSource).join("\n"), v2 = g2.concat(oe.prelude.vertexSource, o2.vertexSource).join("\n"), y3 = l2.createShader(l2.FRAGMENT_SHADER);
              if (l2.isContextLost())
                return void (this.failedToCreate = true);
              l2.shaderSource(y3, x3), l2.compileShader(y3), l2.attachShader(this.program, y3);
              const b2 = l2.createShader(l2.VERTEX_SHADER);
              if (l2.isContextLost())
                return void (this.failedToCreate = true);
              l2.shaderSource(b2, v2), l2.compileShader(b2), l2.attachShader(this.program, b2), this.attributes = {};
              const w2 = {};
              this.numAttributes = u2.length;
              for (let t2 = 0; t2 < this.numAttributes; t2++)
                u2[t2] && (l2.bindAttribLocation(this.program, t2, u2[t2]), this.attributes[u2[t2]] = t2);
              l2.linkProgram(this.program), l2.deleteShader(b2), l2.deleteShader(y3);
              for (let t2 = 0; t2 < f2.length; t2++) {
                const e4 = f2[t2];
                if (e4 && !w2[e4]) {
                  const t3 = l2.getUniformLocation(this.program, e4);
                  t3 && (w2[e4] = t3);
                }
              }
              this.fixedUniforms = r2(e3, w2), this.terrainUniforms = ((e4, i3) => ({ u_depth: new t.Uniform1i(e4, i3.u_depth), u_terrain: new t.Uniform1i(e4, i3.u_terrain), u_terrain_dim: new t.Uniform1f(e4, i3.u_terrain_dim), u_terrain_matrix: new t.UniformMatrix4f(e4, i3.u_terrain_matrix), u_terrain_unpack: new t.Uniform4f(e4, i3.u_terrain_unpack), u_terrain_offset: new t.Uniform1f(e4, i3.u_terrain_offset), u_terrain_exaggeration: new t.Uniform1f(e4, i3.u_terrain_exaggeration) }))(e3, w2), this.binderUniforms = a2 ? a2.getUniforms(e3, w2) : [];
            }
            draw(t2, e3, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2, d2, m2, _2, p2, f2, g2) {
              const x3 = t2.gl;
              if (this.failedToCreate)
                return;
              if (t2.program.set(this.program), t2.setDepthMode(i2), t2.setStencilMode(o2), t2.setColorMode(a2), t2.setCullFace(r2), n2) {
                t2.activeTexture.set(x3.TEXTURE2), x3.bindTexture(x3.TEXTURE_2D, n2.depthTexture), t2.activeTexture.set(x3.TEXTURE3), x3.bindTexture(x3.TEXTURE_2D, n2.texture);
                for (const t3 in this.terrainUniforms)
                  this.terrainUniforms[t3].set(n2[t3]);
              }
              for (const t3 in this.fixedUniforms)
                this.fixedUniforms[t3].set(s2[t3]);
              _2 && _2.setUniforms(t2, this.binderUniforms, d2, { zoom: m2 });
              let v2 = 0;
              switch (e3) {
                case x3.LINES:
                  v2 = 2;
                  break;
                case x3.TRIANGLES:
                  v2 = 3;
                  break;
                case x3.LINE_STRIP:
                  v2 = 1;
              }
              for (const i3 of u2.get()) {
                const o3 = i3.vaos || (i3.vaos = {});
                (o3[l2] || (o3[l2] = new re())).bind(t2, this, c2, _2 ? _2.getPaintVertexBuffers() : [], h2, i3.vertexOffset, p2, f2, g2), x3.drawElements(e3, i3.primitiveLength * v2, x3.UNSIGNED_SHORT, i3.primitiveOffset * v2 * 2);
              }
            }
          }
          function le(t2, e3, i2) {
            const o2 = 1 / bt(i2, 1, e3.transform.tileZoom), a2 = Math.pow(2, i2.tileID.overscaledZ), r2 = i2.tileSize * Math.pow(2, e3.transform.tileZoom) / a2, s2 = r2 * (i2.tileID.canonical.x + i2.tileID.wrap * a2), n2 = r2 * i2.tileID.canonical.y;
            return { u_image: 0, u_texsize: i2.imageAtlasTexture.size, u_scale: [o2, t2.fromScale, t2.toScale], u_fade: t2.t, u_pixel_coord_upper: [s2 >> 16, n2 >> 16], u_pixel_coord_lower: [65535 & s2, 65535 & n2] };
          }
          const ce = (e3, i2, o2, a2) => {
            const r2 = i2.style.light, s2 = r2.properties.get("position"), n2 = [s2.x, s2.y, s2.z], l2 = t.create$1();
            "viewport" === r2.properties.get("anchor") && t.fromRotation(l2, -i2.transform.angle), t.transformMat3(n2, n2, l2);
            const c2 = r2.properties.get("color");
            return { u_matrix: e3, u_lightpos: n2, u_lightintensity: r2.properties.get("intensity"), u_lightcolor: [c2.r, c2.g, c2.b], u_vertical_gradient: +o2, u_opacity: a2 };
          }, he = (e3, i2, o2, a2, r2, s2, n2) => t.extend(ce(e3, i2, o2, a2), le(s2, i2, n2), { u_height_factor: -Math.pow(2, r2.overscaledZ) / n2.tileSize / 8 }), ue = (t2) => ({ u_matrix: t2 }), de = (e3, i2, o2, a2) => t.extend(ue(e3), le(o2, i2, a2)), me = (t2, e3) => ({ u_matrix: t2, u_world: e3 }), _e = (e3, i2, o2, a2, r2) => t.extend(de(e3, i2, o2, a2), { u_world: r2 }), pe = (t2, e3, i2, o2) => {
            const a2 = t2.transform;
            let r2, s2;
            if ("map" === o2.paint.get("circle-pitch-alignment")) {
              const t3 = bt(i2, 1, a2.zoom);
              r2 = true, s2 = [t3, t3];
            } else
              r2 = false, s2 = a2.pixelsToGLUnits;
            return { u_camera_to_center_distance: a2.cameraToCenterDistance, u_scale_with_map: +("map" === o2.paint.get("circle-pitch-scale")), u_matrix: t2.translatePosMatrix(e3.posMatrix, i2, o2.paint.get("circle-translate"), o2.paint.get("circle-translate-anchor")), u_pitch_with_map: +r2, u_device_pixel_ratio: t2.pixelRatio, u_extrude_scale: s2 };
          }, fe = (t2, e3, i2) => {
            const o2 = bt(i2, 1, e3.zoom), a2 = Math.pow(2, e3.zoom - i2.tileID.overscaledZ), r2 = i2.tileID.overscaleFactor();
            return { u_matrix: t2, u_camera_to_center_distance: e3.cameraToCenterDistance, u_pixels_to_tile_units: o2, u_extrude_scale: [e3.pixelsToGLUnits[0] / (o2 * a2), e3.pixelsToGLUnits[1] / (o2 * a2)], u_overscale_factor: r2 };
          }, ge = (t2, e3, i2 = 1) => ({ u_matrix: t2, u_color: e3, u_overlay: 0, u_overlay_scale: i2 }), xe = (t2) => ({ u_matrix: t2 }), ve = (t2, e3, i2, o2) => ({ u_matrix: t2, u_extrude_scale: bt(e3, 1, i2), u_intensity: o2 });
          function ye(e3, i2) {
            const o2 = Math.pow(2, i2.canonical.z), a2 = i2.canonical.y;
            return [new t.MercatorCoordinate(0, a2 / o2).toLngLat().lat, new t.MercatorCoordinate(0, (a2 + 1) / o2).toLngLat().lat];
          }
          const be = (t2, e3, i2, o2) => {
            const a2 = t2.transform;
            return { u_matrix: Ce(t2, e3, i2, o2), u_ratio: 1 / bt(e3, 1, a2.zoom), u_device_pixel_ratio: t2.pixelRatio, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]] };
          }, we = (e3, i2, o2, a2, r2) => t.extend(be(e3, i2, o2, r2), { u_image: 0, u_image_height: a2 }), Te = (t2, e3, i2, o2, a2) => {
            const r2 = t2.transform, s2 = Ie(e3, r2);
            return { u_matrix: Ce(t2, e3, i2, a2), u_texsize: e3.imageAtlasTexture.size, u_ratio: 1 / bt(e3, 1, r2.zoom), u_device_pixel_ratio: t2.pixelRatio, u_image: 0, u_scale: [s2, o2.fromScale, o2.toScale], u_fade: o2.t, u_units_to_pixels: [1 / r2.pixelsToGLUnits[0], 1 / r2.pixelsToGLUnits[1]] };
          }, Ee = (e3, i2, o2, a2, r2, s2) => {
            const n2 = e3.lineAtlas, l2 = Ie(i2, e3.transform), c2 = "round" === o2.layout.get("line-cap"), h2 = n2.getDash(a2.from, c2), u2 = n2.getDash(a2.to, c2), d2 = h2.width * r2.fromScale, m2 = u2.width * r2.toScale;
            return t.extend(be(e3, i2, o2, s2), { u_patternscale_a: [l2 / d2, -h2.height / 2], u_patternscale_b: [l2 / m2, -u2.height / 2], u_sdfgamma: n2.width / (256 * Math.min(d2, m2) * e3.pixelRatio) / 2, u_image: 0, u_tex_y_a: h2.y, u_tex_y_b: u2.y, u_mix: r2.t });
          };
          function Ie(t2, e3) {
            return 1 / bt(t2, 1, e3.tileZoom);
          }
          function Ce(t2, e3, i2, o2) {
            return t2.translatePosMatrix(o2 ? o2.posMatrix : e3.tileID.posMatrix, e3, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
          }
          const Se = (t2, e3, i2, o2, a2) => {
            return { u_matrix: t2, u_tl_parent: e3, u_scale_parent: i2, u_buffer_scale: 1, u_fade_t: o2.mix, u_opacity: o2.opacity * a2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: a2.paint.get("raster-brightness-min"), u_brightness_high: a2.paint.get("raster-brightness-max"), u_saturation_factor: (s2 = a2.paint.get("raster-saturation"), s2 > 0 ? 1 - 1 / (1.001 - s2) : -s2), u_contrast_factor: (r2 = a2.paint.get("raster-contrast"), r2 > 0 ? 1 / (1 - r2) : 1 + r2), u_spin_weights: De(a2.paint.get("raster-hue-rotate")) };
            var r2, s2;
          };
          function De(t2) {
            t2 *= Math.PI / 180;
            const e3 = Math.sin(t2), i2 = Math.cos(t2);
            return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * e3 - i2 + 1) / 3, (Math.sqrt(3) * e3 - i2 + 1) / 3];
          }
          const ze = (t2, e3, i2, o2, a2, r2, s2, n2, l2, c2) => {
            const h2 = a2.transform;
            return { u_is_size_zoom_constant: +("constant" === t2 || "source" === t2), u_is_size_feature_constant: +("constant" === t2 || "camera" === t2), u_size_t: e3 ? e3.uSizeT : 0, u_size: e3 ? e3.uSize : 0, u_camera_to_center_distance: h2.cameraToCenterDistance, u_pitch: h2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i2, u_aspect_ratio: h2.width / h2.height, u_fade_change: a2.options.fadeDuration ? a2.symbolFadeChange : 1, u_matrix: r2, u_label_plane_matrix: s2, u_coord_matrix: n2, u_is_text: +l2, u_pitch_with_map: +o2, u_texsize: c2, u_texture: 0 };
          }, Pe = (e3, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2) => {
            const d2 = r2.transform;
            return t.extend(ze(e3, i2, o2, a2, r2, s2, n2, l2, c2, h2), { u_gamma_scale: a2 ? Math.cos(d2._pitch) * d2.cameraToCenterDistance : 1, u_device_pixel_ratio: r2.pixelRatio, u_is_halo: +u2 });
          }, Me = (e3, i2, o2, a2, r2, s2, n2, l2, c2, h2) => t.extend(Pe(e3, i2, o2, a2, r2, s2, n2, l2, true, c2, true), { u_texsize_icon: h2, u_texture_icon: 1 }), Ae = (t2, e3, i2) => ({ u_matrix: t2, u_opacity: e3, u_color: i2 }), Le = (e3, i2, o2, a2, r2, s2) => t.extend(function(t2, e4, i3, o3) {
            const a3 = i3.imageManager.getPattern(t2.from.toString()), r3 = i3.imageManager.getPattern(t2.to.toString()), { width: s3, height: n2 } = i3.imageManager.getPixelSize(), l2 = Math.pow(2, o3.tileID.overscaledZ), c2 = o3.tileSize * Math.pow(2, i3.transform.tileZoom) / l2, h2 = c2 * (o3.tileID.canonical.x + o3.tileID.wrap * l2), u2 = c2 * o3.tileID.canonical.y;
            return { u_image: 0, u_pattern_tl_a: a3.tl, u_pattern_br_a: a3.br, u_pattern_tl_b: r3.tl, u_pattern_br_b: r3.br, u_texsize: [s3, n2], u_mix: e4.t, u_pattern_size_a: a3.displaySize, u_pattern_size_b: r3.displaySize, u_scale_a: e4.fromScale, u_scale_b: e4.toScale, u_tile_units_to_pixels: 1 / bt(o3, 1, i3.transform.tileZoom), u_pixel_coord_upper: [h2 >> 16, u2 >> 16], u_pixel_coord_lower: [65535 & h2, 65535 & u2] };
          }(a2, s2, o2, r2), { u_matrix: e3, u_opacity: i2 }), Re = { fillExtrusion: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_lightpos: new t.Uniform3f(e3, i2.u_lightpos), u_lightintensity: new t.Uniform1f(e3, i2.u_lightintensity), u_lightcolor: new t.Uniform3f(e3, i2.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e3, i2.u_vertical_gradient), u_opacity: new t.Uniform1f(e3, i2.u_opacity) }), fillExtrusionPattern: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_lightpos: new t.Uniform3f(e3, i2.u_lightpos), u_lightintensity: new t.Uniform1f(e3, i2.u_lightintensity), u_lightcolor: new t.Uniform3f(e3, i2.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e3, i2.u_vertical_gradient), u_height_factor: new t.Uniform1f(e3, i2.u_height_factor), u_image: new t.Uniform1i(e3, i2.u_image), u_texsize: new t.Uniform2f(e3, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e3, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e3, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e3, i2.u_scale), u_fade: new t.Uniform1f(e3, i2.u_fade), u_opacity: new t.Uniform1f(e3, i2.u_opacity) }), fill: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix) }), fillPattern: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_image: new t.Uniform1i(e3, i2.u_image), u_texsize: new t.Uniform2f(e3, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e3, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e3, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e3, i2.u_scale), u_fade: new t.Uniform1f(e3, i2.u_fade) }), fillOutline: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_world: new t.Uniform2f(e3, i2.u_world) }), fillOutlinePattern: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_world: new t.Uniform2f(e3, i2.u_world), u_image: new t.Uniform1i(e3, i2.u_image), u_texsize: new t.Uniform2f(e3, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e3, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e3, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e3, i2.u_scale), u_fade: new t.Uniform1f(e3, i2.u_fade) }), circle: (e3, i2) => ({ u_camera_to_center_distance: new t.Uniform1f(e3, i2.u_camera_to_center_distance), u_scale_with_map: new t.Uniform1i(e3, i2.u_scale_with_map), u_pitch_with_map: new t.Uniform1i(e3, i2.u_pitch_with_map), u_extrude_scale: new t.Uniform2f(e3, i2.u_extrude_scale), u_device_pixel_ratio: new t.Uniform1f(e3, i2.u_device_pixel_ratio), u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix) }), collisionBox: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_camera_to_center_distance: new t.Uniform1f(e3, i2.u_camera_to_center_distance), u_pixels_to_tile_units: new t.Uniform1f(e3, i2.u_pixels_to_tile_units), u_extrude_scale: new t.Uniform2f(e3, i2.u_extrude_scale), u_overscale_factor: new t.Uniform1f(e3, i2.u_overscale_factor) }), collisionCircle: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_inv_matrix: new t.UniformMatrix4f(e3, i2.u_inv_matrix), u_camera_to_center_distance: new t.Uniform1f(e3, i2.u_camera_to_center_distance), u_viewport_size: new t.Uniform2f(e3, i2.u_viewport_size) }), debug: (e3, i2) => ({ u_color: new t.UniformColor(e3, i2.u_color), u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_overlay: new t.Uniform1i(e3, i2.u_overlay), u_overlay_scale: new t.Uniform1f(e3, i2.u_overlay_scale) }), clippingMask: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix) }), heatmap: (e3, i2) => ({ u_extrude_scale: new t.Uniform1f(e3, i2.u_extrude_scale), u_intensity: new t.Uniform1f(e3, i2.u_intensity), u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix) }), heatmapTexture: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_world: new t.Uniform2f(e3, i2.u_world), u_image: new t.Uniform1i(e3, i2.u_image), u_color_ramp: new t.Uniform1i(e3, i2.u_color_ramp), u_opacity: new t.Uniform1f(e3, i2.u_opacity) }), hillshade: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_image: new t.Uniform1i(e3, i2.u_image), u_latrange: new t.Uniform2f(e3, i2.u_latrange), u_light: new t.Uniform2f(e3, i2.u_light), u_shadow: new t.UniformColor(e3, i2.u_shadow), u_highlight: new t.UniformColor(e3, i2.u_highlight), u_accent: new t.UniformColor(e3, i2.u_accent) }), hillshadePrepare: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_image: new t.Uniform1i(e3, i2.u_image), u_dimension: new t.Uniform2f(e3, i2.u_dimension), u_zoom: new t.Uniform1f(e3, i2.u_zoom), u_unpack: new t.Uniform4f(e3, i2.u_unpack) }), line: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_ratio: new t.Uniform1f(e3, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e3, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e3, i2.u_units_to_pixels) }), lineGradient: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_ratio: new t.Uniform1f(e3, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e3, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e3, i2.u_units_to_pixels), u_image: new t.Uniform1i(e3, i2.u_image), u_image_height: new t.Uniform1f(e3, i2.u_image_height) }), linePattern: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_texsize: new t.Uniform2f(e3, i2.u_texsize), u_ratio: new t.Uniform1f(e3, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e3, i2.u_device_pixel_ratio), u_image: new t.Uniform1i(e3, i2.u_image), u_units_to_pixels: new t.Uniform2f(e3, i2.u_units_to_pixels), u_scale: new t.Uniform3f(e3, i2.u_scale), u_fade: new t.Uniform1f(e3, i2.u_fade) }), lineSDF: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_ratio: new t.Uniform1f(e3, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e3, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e3, i2.u_units_to_pixels), u_patternscale_a: new t.Uniform2f(e3, i2.u_patternscale_a), u_patternscale_b: new t.Uniform2f(e3, i2.u_patternscale_b), u_sdfgamma: new t.Uniform1f(e3, i2.u_sdfgamma), u_image: new t.Uniform1i(e3, i2.u_image), u_tex_y_a: new t.Uniform1f(e3, i2.u_tex_y_a), u_tex_y_b: new t.Uniform1f(e3, i2.u_tex_y_b), u_mix: new t.Uniform1f(e3, i2.u_mix) }), raster: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_tl_parent: new t.Uniform2f(e3, i2.u_tl_parent), u_scale_parent: new t.Uniform1f(e3, i2.u_scale_parent), u_buffer_scale: new t.Uniform1f(e3, i2.u_buffer_scale), u_fade_t: new t.Uniform1f(e3, i2.u_fade_t), u_opacity: new t.Uniform1f(e3, i2.u_opacity), u_image0: new t.Uniform1i(e3, i2.u_image0), u_image1: new t.Uniform1i(e3, i2.u_image1), u_brightness_low: new t.Uniform1f(e3, i2.u_brightness_low), u_brightness_high: new t.Uniform1f(e3, i2.u_brightness_high), u_saturation_factor: new t.Uniform1f(e3, i2.u_saturation_factor), u_contrast_factor: new t.Uniform1f(e3, i2.u_contrast_factor), u_spin_weights: new t.Uniform3f(e3, i2.u_spin_weights) }), symbolIcon: (e3, i2) => ({ u_is_size_zoom_constant: new t.Uniform1i(e3, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e3, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e3, i2.u_size_t), u_size: new t.Uniform1f(e3, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e3, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e3, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e3, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e3, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e3, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e3, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e3, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e3, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e3, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e3, i2.u_texsize), u_texture: new t.Uniform1i(e3, i2.u_texture) }), symbolSDF: (e3, i2) => ({ u_is_size_zoom_constant: new t.Uniform1i(e3, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e3, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e3, i2.u_size_t), u_size: new t.Uniform1f(e3, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e3, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e3, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e3, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e3, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e3, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e3, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e3, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e3, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e3, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e3, i2.u_texsize), u_texture: new t.Uniform1i(e3, i2.u_texture), u_gamma_scale: new t.Uniform1f(e3, i2.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e3, i2.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e3, i2.u_is_halo) }), symbolTextAndIcon: (e3, i2) => ({ u_is_size_zoom_constant: new t.Uniform1i(e3, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e3, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e3, i2.u_size_t), u_size: new t.Uniform1f(e3, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e3, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e3, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e3, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e3, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e3, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e3, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e3, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e3, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e3, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e3, i2.u_texsize), u_texsize_icon: new t.Uniform2f(e3, i2.u_texsize_icon), u_texture: new t.Uniform1i(e3, i2.u_texture), u_texture_icon: new t.Uniform1i(e3, i2.u_texture_icon), u_gamma_scale: new t.Uniform1f(e3, i2.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e3, i2.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e3, i2.u_is_halo) }), background: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_opacity: new t.Uniform1f(e3, i2.u_opacity), u_color: new t.UniformColor(e3, i2.u_color) }), backgroundPattern: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_opacity: new t.Uniform1f(e3, i2.u_opacity), u_image: new t.Uniform1i(e3, i2.u_image), u_pattern_tl_a: new t.Uniform2f(e3, i2.u_pattern_tl_a), u_pattern_br_a: new t.Uniform2f(e3, i2.u_pattern_br_a), u_pattern_tl_b: new t.Uniform2f(e3, i2.u_pattern_tl_b), u_pattern_br_b: new t.Uniform2f(e3, i2.u_pattern_br_b), u_texsize: new t.Uniform2f(e3, i2.u_texsize), u_mix: new t.Uniform1f(e3, i2.u_mix), u_pattern_size_a: new t.Uniform2f(e3, i2.u_pattern_size_a), u_pattern_size_b: new t.Uniform2f(e3, i2.u_pattern_size_b), u_scale_a: new t.Uniform1f(e3, i2.u_scale_a), u_scale_b: new t.Uniform1f(e3, i2.u_scale_b), u_pixel_coord_upper: new t.Uniform2f(e3, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e3, i2.u_pixel_coord_lower), u_tile_units_to_pixels: new t.Uniform1f(e3, i2.u_tile_units_to_pixels) }), terrain: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_texture: new t.Uniform1i(e3, i2.u_texture) }), terrainDepth: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix) }), terrainCoords: (e3, i2) => ({ u_matrix: new t.UniformMatrix4f(e3, i2.u_matrix), u_texture: new t.Uniform1i(e3, i2.u_texture), u_terrain_coords_id: new t.Uniform1f(e3, i2.u_terrain_coords_id) }) };
          class ke {
            constructor(t2, e3, i2) {
              this.context = t2;
              const o2 = t2.gl;
              this.buffer = o2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), t2.bindElementBuffer.set(this.buffer), o2.bufferData(o2.ELEMENT_ARRAY_BUFFER, e3.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || delete e3.arrayBuffer;
            }
            bind() {
              this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(t2) {
              const e3 = this.context.gl;
              if (!this.dynamicDraw)
                throw new Error("Attempted to update data while not in dynamic mode.");
              this.context.unbindVAO(), this.bind(), e3.bufferSubData(e3.ELEMENT_ARRAY_BUFFER, 0, t2.arrayBuffer);
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          const Be = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
          class Fe {
            constructor(t2, e3, i2, o2) {
              this.length = e3.length, this.attributes = i2, this.itemSize = e3.bytesPerElement, this.dynamicDraw = o2, this.context = t2;
              const a2 = t2.gl;
              this.buffer = a2.createBuffer(), t2.bindVertexBuffer.set(this.buffer), a2.bufferData(a2.ARRAY_BUFFER, e3.arrayBuffer, this.dynamicDraw ? a2.DYNAMIC_DRAW : a2.STATIC_DRAW), this.dynamicDraw || delete e3.arrayBuffer;
            }
            bind() {
              this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(t2) {
              if (t2.length !== this.length)
                throw new Error(`Length of new data is ${t2.length}, which doesn't match current length of ${this.length}`);
              const e3 = this.context.gl;
              this.bind(), e3.bufferSubData(e3.ARRAY_BUFFER, 0, t2.arrayBuffer);
            }
            enableAttributes(t2, e3) {
              for (let i2 = 0; i2 < this.attributes.length; i2++) {
                const o2 = e3.attributes[this.attributes[i2].name];
                void 0 !== o2 && t2.enableVertexAttribArray(o2);
              }
            }
            setVertexAttribPointers(t2, e3, i2) {
              for (let o2 = 0; o2 < this.attributes.length; o2++) {
                const a2 = this.attributes[o2], r2 = e3.attributes[a2.name];
                void 0 !== r2 && t2.vertexAttribPointer(r2, a2.components, t2[Be[a2.type]], false, this.itemSize, a2.offset + this.itemSize * (i2 || 0));
              }
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          class Oe {
            constructor(t2) {
              this.gl = t2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
            }
            get() {
              return this.current;
            }
            set(t2) {
            }
            getDefault() {
              return this.default;
            }
            setDefault() {
              this.set(this.default);
            }
          }
          class Ue extends Oe {
            getDefault() {
              return t.Color.transparent;
            }
            set(t2) {
              const e3 = this.current;
              (t2.r !== e3.r || t2.g !== e3.g || t2.b !== e3.b || t2.a !== e3.a || this.dirty) && (this.gl.clearColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
            }
          }
          class Ne extends Oe {
            getDefault() {
              return 1;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.clearDepth(t2), this.current = t2, this.dirty = false);
            }
          }
          class Ge extends Oe {
            getDefault() {
              return 0;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.clearStencil(t2), this.current = t2, this.dirty = false);
            }
          }
          class Ze extends Oe {
            getDefault() {
              return [true, true, true, true];
            }
            set(t2) {
              const e3 = this.current;
              (t2[0] !== e3[0] || t2[1] !== e3[1] || t2[2] !== e3[2] || t2[3] !== e3[3] || this.dirty) && (this.gl.colorMask(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = false);
            }
          }
          class Ve extends Oe {
            getDefault() {
              return true;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.depthMask(t2), this.current = t2, this.dirty = false);
            }
          }
          class qe extends Oe {
            getDefault() {
              return 255;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.stencilMask(t2), this.current = t2, this.dirty = false);
            }
          }
          class je extends Oe {
            getDefault() {
              return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
            }
            set(t2) {
              const e3 = this.current;
              (t2.func !== e3.func || t2.ref !== e3.ref || t2.mask !== e3.mask || this.dirty) && (this.gl.stencilFunc(t2.func, t2.ref, t2.mask), this.current = t2, this.dirty = false);
            }
          }
          class $e extends Oe {
            getDefault() {
              const t2 = this.gl;
              return [t2.KEEP, t2.KEEP, t2.KEEP];
            }
            set(t2) {
              const e3 = this.current;
              (t2[0] !== e3[0] || t2[1] !== e3[1] || t2[2] !== e3[2] || this.dirty) && (this.gl.stencilOp(t2[0], t2[1], t2[2]), this.current = t2, this.dirty = false);
            }
          }
          class Xe extends Oe {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              t2 ? e3.enable(e3.STENCIL_TEST) : e3.disable(e3.STENCIL_TEST), this.current = t2, this.dirty = false;
            }
          }
          class We extends Oe {
            getDefault() {
              return [0, 1];
            }
            set(t2) {
              const e3 = this.current;
              (t2[0] !== e3[0] || t2[1] !== e3[1] || this.dirty) && (this.gl.depthRange(t2[0], t2[1]), this.current = t2, this.dirty = false);
            }
          }
          class He extends Oe {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              t2 ? e3.enable(e3.DEPTH_TEST) : e3.disable(e3.DEPTH_TEST), this.current = t2, this.dirty = false;
            }
          }
          class Ke extends Oe {
            getDefault() {
              return this.gl.LESS;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.depthFunc(t2), this.current = t2, this.dirty = false);
            }
          }
          class Ye extends Oe {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              t2 ? e3.enable(e3.BLEND) : e3.disable(e3.BLEND), this.current = t2, this.dirty = false;
            }
          }
          class Je extends Oe {
            getDefault() {
              const t2 = this.gl;
              return [t2.ONE, t2.ZERO];
            }
            set(t2) {
              const e3 = this.current;
              (t2[0] !== e3[0] || t2[1] !== e3[1] || this.dirty) && (this.gl.blendFunc(t2[0], t2[1]), this.current = t2, this.dirty = false);
            }
          }
          class Qe extends Oe {
            getDefault() {
              return t.Color.transparent;
            }
            set(t2) {
              const e3 = this.current;
              (t2.r !== e3.r || t2.g !== e3.g || t2.b !== e3.b || t2.a !== e3.a || this.dirty) && (this.gl.blendColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
            }
          }
          class ti extends Oe {
            getDefault() {
              return this.gl.FUNC_ADD;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.blendEquation(t2), this.current = t2, this.dirty = false);
            }
          }
          class ei extends Oe {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              t2 ? e3.enable(e3.CULL_FACE) : e3.disable(e3.CULL_FACE), this.current = t2, this.dirty = false;
            }
          }
          class ii extends Oe {
            getDefault() {
              return this.gl.BACK;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.cullFace(t2), this.current = t2, this.dirty = false);
            }
          }
          class oi extends Oe {
            getDefault() {
              return this.gl.CCW;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.frontFace(t2), this.current = t2, this.dirty = false);
            }
          }
          class ai extends Oe {
            getDefault() {
              return null;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.useProgram(t2), this.current = t2, this.dirty = false);
            }
          }
          class ri extends Oe {
            getDefault() {
              return this.gl.TEXTURE0;
            }
            set(t2) {
              (t2 !== this.current || this.dirty) && (this.gl.activeTexture(t2), this.current = t2, this.dirty = false);
            }
          }
          class si extends Oe {
            getDefault() {
              const t2 = this.gl;
              return [0, 0, t2.drawingBufferWidth, t2.drawingBufferHeight];
            }
            set(t2) {
              const e3 = this.current;
              (t2[0] !== e3[0] || t2[1] !== e3[1] || t2[2] !== e3[2] || t2[3] !== e3[3] || this.dirty) && (this.gl.viewport(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = false);
            }
          }
          class ni extends Oe {
            getDefault() {
              return null;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              e3.bindFramebuffer(e3.FRAMEBUFFER, t2), this.current = t2, this.dirty = false;
            }
          }
          class li extends Oe {
            getDefault() {
              return null;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              e3.bindRenderbuffer(e3.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
            }
          }
          class ci extends Oe {
            getDefault() {
              return null;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              e3.bindTexture(e3.TEXTURE_2D, t2), this.current = t2, this.dirty = false;
            }
          }
          class hi extends Oe {
            getDefault() {
              return null;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              e3.bindBuffer(e3.ARRAY_BUFFER, t2), this.current = t2, this.dirty = false;
            }
          }
          class ui extends Oe {
            getDefault() {
              return null;
            }
            set(t2) {
              const e3 = this.gl;
              e3.bindBuffer(e3.ELEMENT_ARRAY_BUFFER, t2), this.current = t2, this.dirty = false;
            }
          }
          class di extends Oe {
            constructor(t2) {
              super(t2), this.vao = t2.extVertexArrayObject;
            }
            getDefault() {
              return null;
            }
            set(t2) {
              this.vao && (t2 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t2), this.current = t2, this.dirty = false);
            }
          }
          class mi extends Oe {
            getDefault() {
              return 4;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              e3.pixelStorei(e3.UNPACK_ALIGNMENT, t2), this.current = t2, this.dirty = false;
            }
          }
          class _i extends Oe {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              e3.pixelStorei(e3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t2), this.current = t2, this.dirty = false;
            }
          }
          class pi2 extends Oe {
            getDefault() {
              return false;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              const e3 = this.gl;
              e3.pixelStorei(e3.UNPACK_FLIP_Y_WEBGL, t2), this.current = t2, this.dirty = false;
            }
          }
          class fi extends Oe {
            constructor(t2, e3) {
              super(t2), this.context = t2, this.parent = e3;
            }
            getDefault() {
              return null;
            }
          }
          class gi extends fi {
            setDirty() {
              this.dirty = true;
            }
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              this.context.bindFramebuffer.set(this.parent);
              const e3 = this.gl;
              e3.framebufferTexture2D(e3.FRAMEBUFFER, e3.COLOR_ATTACHMENT0, e3.TEXTURE_2D, t2, 0), this.current = t2, this.dirty = false;
            }
          }
          class xi extends fi {
            set(t2) {
              if (t2 === this.current && !this.dirty)
                return;
              this.context.bindFramebuffer.set(this.parent);
              const e3 = this.gl;
              e3.framebufferRenderbuffer(e3.FRAMEBUFFER, e3.DEPTH_ATTACHMENT, e3.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
            }
          }
          class vi {
            constructor(t2, e3, i2, o2) {
              this.context = t2, this.width = e3, this.height = i2;
              const a2 = t2.gl, r2 = this.framebuffer = a2.createFramebuffer();
              if (this.colorAttachment = new gi(t2, r2), o2 && (this.depthAttachment = new xi(t2, r2)), a2.checkFramebufferStatus(a2.FRAMEBUFFER) !== a2.FRAMEBUFFER_COMPLETE)
                throw new Error("Framebuffer is not complete");
            }
            destroy() {
              const t2 = this.context.gl, e3 = this.colorAttachment.get();
              if (e3 && t2.deleteTexture(e3), this.depthAttachment) {
                const e4 = this.depthAttachment.get();
                e4 && t2.deleteRenderbuffer(e4);
              }
              t2.deleteFramebuffer(this.framebuffer);
            }
          }
          class yi {
            constructor(t2, e3, i2) {
              this.blendFunction = t2, this.blendColor = e3, this.mask = i2;
            }
          }
          yi.Replace = [1, 0], yi.disabled = new yi(yi.Replace, t.Color.transparent, [false, false, false, false]), yi.unblended = new yi(yi.Replace, t.Color.transparent, [true, true, true, true]), yi.alphaBlended = new yi([1, 771], t.Color.transparent, [true, true, true, true]);
          class bi {
            constructor(t2) {
              this.gl = t2, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new Ue(this), this.clearDepth = new Ne(this), this.clearStencil = new Ge(this), this.colorMask = new Ze(this), this.depthMask = new Ve(this), this.stencilMask = new qe(this), this.stencilFunc = new je(this), this.stencilOp = new $e(this), this.stencilTest = new Xe(this), this.depthRange = new We(this), this.depthTest = new He(this), this.depthFunc = new Ke(this), this.blend = new Ye(this), this.blendFunc = new Je(this), this.blendColor = new Qe(this), this.blendEquation = new ti(this), this.cullFace = new ei(this), this.cullFaceSide = new ii(this), this.frontFace = new oi(this), this.program = new ai(this), this.activeTexture = new ri(this), this.viewport = new si(this), this.bindFramebuffer = new ni(this), this.bindRenderbuffer = new li(this), this.bindTexture = new ci(this), this.bindVertexBuffer = new hi(this), this.bindElementBuffer = new ui(this), this.bindVertexArrayOES = this.extVertexArrayObject && new di(this), this.pixelStoreUnpack = new mi(this), this.pixelStoreUnpackPremultiplyAlpha = new _i(this), this.pixelStoreUnpackFlipY = new pi2(this), this.extTextureFilterAnisotropic = t2.getExtension("EXT_texture_filter_anisotropic") || t2.getExtension("MOZ_EXT_texture_filter_anisotropic") || t2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = t2.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (t2.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = t2.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = t2.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = t2.getParameter(t2.MAX_TEXTURE_SIZE);
            }
            setDefault() {
              this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
              this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = true), this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
            }
            createIndexBuffer(t2, e3) {
              return new ke(this, t2, e3);
            }
            createVertexBuffer(t2, e3, i2) {
              return new Fe(this, t2, e3, i2);
            }
            createRenderbuffer(t2, e3, i2) {
              const o2 = this.gl, a2 = o2.createRenderbuffer();
              return this.bindRenderbuffer.set(a2), o2.renderbufferStorage(o2.RENDERBUFFER, t2, e3, i2), this.bindRenderbuffer.set(null), a2;
            }
            createFramebuffer(t2, e3, i2) {
              return new vi(this, t2, e3, i2);
            }
            clear({ color: t2, depth: e3 }) {
              const i2 = this.gl;
              let o2 = 0;
              t2 && (o2 |= i2.COLOR_BUFFER_BIT, this.clearColor.set(t2), this.colorMask.set([true, true, true, true])), void 0 !== e3 && (o2 |= i2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(e3), this.depthMask.set(true)), i2.clear(o2);
            }
            setCullFace(t2) {
              false === t2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t2.mode), this.frontFace.set(t2.frontFace));
            }
            setDepthMode(t2) {
              t2.func !== this.gl.ALWAYS || t2.mask ? (this.depthTest.set(true), this.depthFunc.set(t2.func), this.depthMask.set(t2.mask), this.depthRange.set(t2.range)) : this.depthTest.set(false);
            }
            setStencilMode(t2) {
              t2.test.func !== this.gl.ALWAYS || t2.mask ? (this.stencilTest.set(true), this.stencilMask.set(t2.mask), this.stencilOp.set([t2.fail, t2.depthFail, t2.pass]), this.stencilFunc.set({ func: t2.test.func, ref: t2.ref, mask: t2.test.mask })) : this.stencilTest.set(false);
            }
            setColorMode(t2) {
              a(t2.blendFunction, yi.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(t2.blendFunction), this.blendColor.set(t2.blendColor)), this.colorMask.set(t2.mask);
            }
            unbindVAO() {
              this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
            }
          }
          class wi {
            constructor(t2, e3, i2) {
              this.func = t2, this.mask = e3, this.range = i2;
            }
          }
          wi.ReadOnly = false, wi.ReadWrite = true, wi.disabled = new wi(519, wi.ReadOnly, [0, 1]);
          const Ti = 7680;
          class Ei {
            constructor(t2, e3, i2, o2, a2, r2) {
              this.test = t2, this.ref = e3, this.mask = i2, this.fail = o2, this.depthFail = a2, this.pass = r2;
            }
          }
          Ei.disabled = new Ei({ func: 519, mask: 0 }, 0, 0, Ti, Ti, Ti);
          class Ii {
            constructor(t2, e3, i2) {
              this.enable = t2, this.mode = e3, this.frontFace = i2;
            }
          }
          let Ci;
          function Si(e3, i2, o2, a2, r2, s2, n2) {
            const l2 = e3.context, c2 = l2.gl, h2 = e3.useProgram("collisionBox"), u2 = [];
            let d2 = 0, m2 = 0;
            for (let _3 = 0; _3 < a2.length; _3++) {
              const p3 = a2[_3], f3 = i2.getTile(p3), g3 = f3.getBucket(o2);
              if (!g3)
                continue;
              let x4 = p3.posMatrix;
              0 === r2[0] && 0 === r2[1] || (x4 = e3.translatePosMatrix(p3.posMatrix, f3, r2, s2));
              const v3 = n2 ? g3.textCollisionBox : g3.iconCollisionBox, y3 = g3.collisionCircleArray;
              if (y3.length > 0) {
                const i3 = t.create(), o3 = x4;
                t.mul(i3, g3.placementInvProjMatrix, e3.transform.glCoordMatrix), t.mul(i3, i3, g3.placementViewportMatrix), u2.push({ circleArray: y3, circleOffset: m2, transform: o3, invTransform: i3, coord: p3 }), d2 += y3.length / 4, m2 = d2;
              }
              v3 && h2.draw(l2, c2.LINES, wi.disabled, Ei.disabled, e3.colorModeForRenderPass(), Ii.disabled, fe(x4, e3.transform, f3), e3.style.terrain && e3.style.terrain.getTerrainData(p3), o2.id, v3.layoutVertexBuffer, v3.indexBuffer, v3.segments, null, e3.transform.zoom, null, null, v3.collisionVertexBuffer);
            }
            if (!n2 || !u2.length)
              return;
            const _2 = e3.useProgram("collisionCircle"), p2 = new t.CollisionCircleLayoutArray();
            p2.resize(4 * d2), p2._trim();
            let f2 = 0;
            for (const t2 of u2)
              for (let e4 = 0; e4 < t2.circleArray.length / 4; e4++) {
                const i3 = 4 * e4, o3 = t2.circleArray[i3 + 0], a3 = t2.circleArray[i3 + 1], r3 = t2.circleArray[i3 + 2], s3 = t2.circleArray[i3 + 3];
                p2.emplace(f2++, o3, a3, r3, s3, 0), p2.emplace(f2++, o3, a3, r3, s3, 1), p2.emplace(f2++, o3, a3, r3, s3, 2), p2.emplace(f2++, o3, a3, r3, s3, 3);
              }
            (!Ci || Ci.length < 2 * d2) && (Ci = function(e4) {
              const i3 = 2 * e4, o3 = new t.QuadTriangleArray();
              o3.resize(i3), o3._trim();
              for (let t2 = 0; t2 < i3; t2++) {
                const e6 = 6 * t2;
                o3.uint16[e6 + 0] = 4 * t2 + 0, o3.uint16[e6 + 1] = 4 * t2 + 1, o3.uint16[e6 + 2] = 4 * t2 + 2, o3.uint16[e6 + 3] = 4 * t2 + 2, o3.uint16[e6 + 4] = 4 * t2 + 3, o3.uint16[e6 + 5] = 4 * t2 + 0;
              }
              return o3;
            }(d2));
            const g2 = l2.createIndexBuffer(Ci, true), x3 = l2.createVertexBuffer(p2, t.collisionCircleLayout.members, true);
            for (const i3 of u2) {
              const a3 = { u_matrix: i3.transform, u_inv_matrix: i3.invTransform, u_camera_to_center_distance: (v2 = e3.transform).cameraToCenterDistance, u_viewport_size: [v2.width, v2.height] };
              _2.draw(l2, c2.TRIANGLES, wi.disabled, Ei.disabled, e3.colorModeForRenderPass(), Ii.disabled, a3, e3.style.terrain && e3.style.terrain.getTerrainData(i3.coord), o2.id, x3, g2, t.SegmentVector.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, e3.transform.zoom, null, null, null);
            }
            var v2;
            x3.destroy(), g2.destroy();
          }
          Ii.disabled = new Ii(false, 1029, 2305), Ii.backCCW = new Ii(true, 1029, 2305);
          const Di = t.identity(new Float32Array(16));
          function zi(e3, i2, o2, a2, r2, s2) {
            const { horizontalAlign: n2, verticalAlign: l2 } = t.getAnchorAlignment(e3), c2 = -(n2 - 0.5) * i2, h2 = -(l2 - 0.5) * o2, u2 = t.evaluateVariableOffset(e3, a2);
            return new t.pointGeometry((c2 / r2 + u2[0]) * s2, (h2 / r2 + u2[1]) * s2);
          }
          function Pi(e3, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2) {
            const d2 = e3.text.placedSymbolArray, m2 = e3.text.dynamicLayoutVertexArray, _2 = e3.icon.dynamicLayoutVertexArray, p2 = {};
            m2.clear();
            for (let _3 = 0; _3 < d2.length; _3++) {
              const f2 = d2.get(_3), g2 = e3.allowVerticalPlacement && !f2.placedOrientation, x3 = f2.hidden || !f2.crossTileID || g2 ? null : a2[f2.crossTileID];
              if (x3) {
                const a3 = new t.pointGeometry(f2.anchorX, f2.anchorY), d3 = nt(a3, o2 ? n2 : s2, u2), _4 = lt(r2.cameraToCenterDistance, d3.signedDistanceFromCamera);
                let g3 = t.evaluateSizeForFeature(e3.textSizeData, c2, f2) * _4 / t.ONE_EM;
                o2 && (g3 *= e3.tilePixelRatio / l2);
                const { width: v2, height: y3, anchor: b2, textOffset: w2, textBoxScale: T2 } = x3, E2 = zi(b2, v2, y3, w2, T2, g3), I2 = o2 ? nt(a3.add(E2), s2, u2).point : d3.point.add(i2 ? E2.rotate(-r2.angle) : E2), C2 = e3.allowVerticalPlacement && f2.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0;
                for (let e4 = 0; e4 < f2.numGlyphs; e4++)
                  t.addDynamicAttributes(m2, I2, C2);
                h2 && f2.associatedIconIndex >= 0 && (p2[f2.associatedIconIndex] = { shiftedAnchor: I2, angle: C2 });
              } else
                gt(f2.numGlyphs, m2);
            }
            if (h2) {
              _2.clear();
              const i3 = e3.icon.placedSymbolArray;
              for (let e4 = 0; e4 < i3.length; e4++) {
                const o3 = i3.get(e4);
                if (o3.hidden)
                  gt(o3.numGlyphs, _2);
                else {
                  const i4 = p2[e4];
                  if (i4)
                    for (let e6 = 0; e6 < o3.numGlyphs; e6++)
                      t.addDynamicAttributes(_2, i4.shiftedAnchor, i4.angle);
                  else
                    gt(o3.numGlyphs, _2);
                }
              }
              e3.icon.dynamicLayoutVertexBuffer.updateData(_2);
            }
            e3.text.dynamicLayoutVertexBuffer.updateData(m2);
          }
          function Mi(t2, e3, i2) {
            return i2.iconsInText && e3 ? "symbolTextAndIcon" : t2 ? "symbolSDF" : "symbolIcon";
          }
          function Ai(e3, i2, o2, a2, r2, s2, n2, l2, c2, h2, u2, d2) {
            const m2 = e3.context, _2 = m2.gl, p2 = e3.transform, f2 = "map" === l2, g2 = "map" === c2, x3 = "viewport" !== l2 && "point" !== o2.layout.get("symbol-placement"), v2 = f2 && !g2 && !x3, y3 = !o2.layout.get("symbol-sort-key").isConstant();
            let b2 = false;
            const w2 = e3.depthModeForSublayer(0, wi.ReadOnly), T2 = o2.layout.get("text-variable-anchor"), E2 = [];
            for (const l3 of a2) {
              const a3 = i2.getTile(l3), c3 = a3.getBucket(o2);
              if (!c3)
                continue;
              const u3 = r2 ? c3.text : c3.icon;
              if (!u3 || !u3.segments.get().length)
                continue;
              const d3 = u3.programConfigurations.get(o2.id), m3 = r2 || c3.sdfIcons, w3 = r2 ? c3.textSizeData : c3.iconSizeData, I2 = g2 || 0 !== p2.pitch, C2 = e3.useProgram(Mi(m3, r2, c3), d3), S2 = t.evaluateSizeForZoom(w3, p2.zoom), D2 = e3.style.terrain && e3.style.terrain.getTerrainData(l3);
              let z2, P2, M2, A2, L2 = [0, 0], R2 = null;
              if (r2) {
                if (P2 = a3.glyphAtlasTexture, M2 = _2.LINEAR, z2 = a3.glyphAtlasTexture.size, c3.iconsInText) {
                  L2 = a3.imageAtlasTexture.size, R2 = a3.imageAtlasTexture;
                  const t2 = "composite" === w3.kind || "camera" === w3.kind;
                  A2 = I2 || e3.options.rotating || e3.options.zooming || t2 ? _2.LINEAR : _2.NEAREST;
                }
              } else {
                const t2 = 1 !== o2.layout.get("icon-size").constantOr(0) || c3.iconsNeedLinear;
                P2 = a3.imageAtlasTexture, M2 = m3 || e3.options.rotating || e3.options.zooming || t2 || I2 ? _2.LINEAR : _2.NEAREST, z2 = a3.imageAtlasTexture.size;
              }
              const k2 = bt(a3, 1, e3.transform.zoom), B3 = rt(l3.posMatrix, g2, f2, e3.transform, k2), F2 = st(l3.posMatrix, g2, f2, e3.transform, k2), O2 = T2 && c3.hasTextData(), U2 = "none" !== o2.layout.get("icon-text-fit") && O2 && c3.hasIconData();
              if (x3) {
                const t2 = e3.style.terrain ? (t3, i4) => e3.style.terrain.getElevation(l3, t3, i4) : null, i3 = "map" === o2.layout.get("text-rotation-alignment");
                ht(c3, l3.posMatrix, e3, r2, B3, F2, g2, h2, i3, t2);
              }
              const N2 = e3.translatePosMatrix(l3.posMatrix, a3, s2, n2), G2 = x3 || r2 && T2 || U2 ? Di : B3, Z2 = e3.translatePosMatrix(F2, a3, s2, n2, true), V2 = m3 && 0 !== o2.paint.get(r2 ? "text-halo-width" : "icon-halo-width").constantOr(1);
              let q2;
              q2 = m3 ? c3.iconsInText ? Me(w3.kind, S2, v2, g2, e3, N2, G2, Z2, z2, L2) : Pe(w3.kind, S2, v2, g2, e3, N2, G2, Z2, r2, z2, true) : ze(w3.kind, S2, v2, g2, e3, N2, G2, Z2, r2, z2);
              const j2 = { program: C2, buffers: u3, uniformValues: q2, atlasTexture: P2, atlasTextureIcon: R2, atlasInterpolation: M2, atlasInterpolationIcon: A2, isSDF: m3, hasHalo: V2 };
              if (y3 && c3.canOverlap) {
                b2 = true;
                const e4 = u3.segments.get();
                for (const i3 of e4)
                  E2.push({ segments: new t.SegmentVector([i3]), sortKey: i3.sortKey, state: j2, terrainData: D2 });
              } else
                E2.push({ segments: u3.segments, sortKey: 0, state: j2, terrainData: D2 });
            }
            b2 && E2.sort((t2, e4) => t2.sortKey - e4.sortKey);
            for (const t2 of E2) {
              const i3 = t2.state;
              if (m2.activeTexture.set(_2.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, _2.CLAMP_TO_EDGE), i3.atlasTextureIcon && (m2.activeTexture.set(_2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, _2.CLAMP_TO_EDGE)), i3.isSDF) {
                const a3 = i3.uniformValues;
                i3.hasHalo && (a3.u_is_halo = 1, Li(i3.buffers, t2.segments, o2, e3, i3.program, w2, u2, d2, a3, t2.terrainData)), a3.u_is_halo = 0;
              }
              Li(i3.buffers, t2.segments, o2, e3, i3.program, w2, u2, d2, i3.uniformValues, t2.terrainData);
            }
          }
          function Li(t2, e3, i2, o2, a2, r2, s2, n2, l2, c2) {
            const h2 = o2.context;
            a2.draw(h2, h2.gl.TRIANGLES, r2, s2, n2, Ii.disabled, l2, c2, i2.id, t2.layoutVertexBuffer, t2.indexBuffer, e3, i2.paint, o2.transform.zoom, t2.programConfigurations.get(i2.id), t2.dynamicLayoutVertexBuffer, t2.opacityVertexBuffer);
          }
          function Ri(t2, e3, i2, o2, a2, r2, s2) {
            const n2 = t2.context.gl, l2 = i2.paint.get("fill-pattern"), c2 = l2 && l2.constantOr(1), h2 = i2.getCrossfadeParameters();
            let u2, d2, m2, _2, p2;
            s2 ? (d2 = c2 && !i2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", u2 = n2.LINES) : (d2 = c2 ? "fillPattern" : "fill", u2 = n2.TRIANGLES);
            for (const f2 of o2) {
              const o3 = e3.getTile(f2);
              if (c2 && !o3.patternsLoaded())
                continue;
              const g2 = o3.getBucket(i2);
              if (!g2)
                continue;
              const x3 = g2.programConfigurations.get(i2.id), v2 = t2.useProgram(d2, x3), y3 = t2.style.terrain && t2.style.terrain.getTerrainData(f2);
              c2 && (t2.context.activeTexture.set(n2.TEXTURE0), o3.imageAtlasTexture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE), x3.updatePaintBuffers(h2));
              const b2 = l2.constantOr(null);
              if (b2 && o3.imageAtlas) {
                const t3 = o3.imageAtlas, e4 = t3.patternPositions[b2.to.toString()], i3 = t3.patternPositions[b2.from.toString()];
                e4 && i3 && x3.setConstantPatternPositions(e4, i3);
              }
              const w2 = y3 ? f2 : null, T2 = t2.translatePosMatrix(w2 ? w2.posMatrix : f2.posMatrix, o3, i2.paint.get("fill-translate"), i2.paint.get("fill-translate-anchor"));
              if (s2) {
                _2 = g2.indexBuffer2, p2 = g2.segments2;
                const e4 = [n2.drawingBufferWidth, n2.drawingBufferHeight];
                m2 = "fillOutlinePattern" === d2 && c2 ? _e(T2, t2, h2, o3, e4) : me(T2, e4);
              } else
                _2 = g2.indexBuffer, p2 = g2.segments, m2 = c2 ? de(T2, t2, h2, o3) : ue(T2);
              v2.draw(t2.context, u2, a2, t2.stencilModeForClipping(f2), r2, Ii.disabled, m2, y3, i2.id, g2.layoutVertexBuffer, _2, p2, i2.paint, t2.transform.zoom, x3);
            }
          }
          function ki(t2, e3, i2, o2, a2, r2, s2) {
            const n2 = t2.context, l2 = n2.gl, c2 = i2.paint.get("fill-extrusion-pattern"), h2 = c2.constantOr(1), u2 = i2.getCrossfadeParameters(), d2 = i2.paint.get("fill-extrusion-opacity");
            for (const m2 of o2) {
              const o3 = e3.getTile(m2), _2 = o3.getBucket(i2);
              if (!_2)
                continue;
              const p2 = t2.style.terrain && t2.style.terrain.getTerrainData(m2), f2 = _2.programConfigurations.get(i2.id), g2 = t2.useProgram(h2 ? "fillExtrusionPattern" : "fillExtrusion", f2);
              h2 && (t2.context.activeTexture.set(l2.TEXTURE0), o3.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), f2.updatePaintBuffers(u2));
              const x3 = c2.constantOr(null);
              if (x3 && o3.imageAtlas) {
                const t3 = o3.imageAtlas, e4 = t3.patternPositions[x3.to.toString()], i3 = t3.patternPositions[x3.from.toString()];
                e4 && i3 && f2.setConstantPatternPositions(e4, i3);
              }
              const v2 = t2.translatePosMatrix(m2.posMatrix, o3, i2.paint.get("fill-extrusion-translate"), i2.paint.get("fill-extrusion-translate-anchor")), y3 = i2.paint.get("fill-extrusion-vertical-gradient"), b2 = h2 ? he(v2, t2, y3, d2, m2, u2, o3) : ce(v2, t2, y3, d2);
              g2.draw(n2, n2.gl.TRIANGLES, a2, r2, s2, Ii.backCCW, b2, p2, i2.id, _2.layoutVertexBuffer, _2.indexBuffer, _2.segments, i2.paint, t2.transform.zoom, f2, t2.style.terrain && _2.centroidVertexBuffer);
            }
          }
          function Bi(t2, e3, i2, o2, a2, r2, s2) {
            const n2 = t2.context, l2 = n2.gl, c2 = i2.fbo;
            if (!c2)
              return;
            const h2 = t2.useProgram("hillshade"), u2 = t2.style.terrain && t2.style.terrain.getTerrainData(e3);
            n2.activeTexture.set(l2.TEXTURE0), l2.bindTexture(l2.TEXTURE_2D, c2.colorAttachment.get()), h2.draw(n2, l2.TRIANGLES, a2, r2, s2, Ii.disabled, ((t3, e4, i3, o3) => {
              const a3 = i3.paint.get("hillshade-shadow-color"), r3 = i3.paint.get("hillshade-highlight-color"), s3 = i3.paint.get("hillshade-accent-color");
              let n3 = i3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
              "viewport" === i3.paint.get("hillshade-illumination-anchor") && (n3 -= t3.transform.angle);
              const l3 = !t3.options.moving;
              return { u_matrix: o3 ? o3.posMatrix : t3.transform.calculatePosMatrix(e4.tileID.toUnwrapped(), l3), u_image: 0, u_latrange: ye(0, e4.tileID), u_light: [i3.paint.get("hillshade-exaggeration"), n3], u_shadow: a3, u_highlight: r3, u_accent: s3 };
            })(t2, i2, o2, u2 ? e3 : null), u2, o2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
          }
          function Fi(e3, i2, o2, a2, r2, s2) {
            const n2 = e3.context, c2 = n2.gl, h2 = i2.dem;
            if (h2 && h2.data) {
              const u2 = h2.dim, d2 = h2.stride, m2 = h2.getPixels();
              if (n2.activeTexture.set(c2.TEXTURE1), n2.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || e3.getTileTexture(d2), i2.demTexture) {
                const t2 = i2.demTexture;
                t2.update(m2, { premultiply: false }), t2.bind(c2.NEAREST, c2.CLAMP_TO_EDGE);
              } else
                i2.demTexture = new l(n2, m2, c2.RGBA, { premultiply: false }), i2.demTexture.bind(c2.NEAREST, c2.CLAMP_TO_EDGE);
              n2.activeTexture.set(c2.TEXTURE0);
              let _2 = i2.fbo;
              if (!_2) {
                const t2 = new l(n2, { width: u2, height: u2, data: null }, c2.RGBA);
                t2.bind(c2.LINEAR, c2.CLAMP_TO_EDGE), _2 = i2.fbo = n2.createFramebuffer(u2, u2, true), _2.colorAttachment.set(t2.texture);
              }
              n2.bindFramebuffer.set(_2.framebuffer), n2.viewport.set([0, 0, u2, u2]), e3.useProgram("hillshadePrepare").draw(n2, c2.TRIANGLES, a2, r2, s2, Ii.disabled, ((e4, i3) => {
                const o3 = i3.stride, a3 = t.create();
                return t.ortho(a3, 0, t.EXTENT, -t.EXTENT, 0, 0, 1), t.translate(a3, a3, [0, -t.EXTENT, 0]), { u_matrix: a3, u_image: 1, u_dimension: [o3, o3], u_zoom: e4.overscaledZ, u_unpack: i3.getUnpackVector() };
              })(i2.tileID, h2), null, o2.id, e3.rasterBoundsBuffer, e3.quadTriangleIndexBuffer, e3.rasterBoundsSegments), i2.needsHillshadePrepare = false;
            }
          }
          function Oi(e3, i2, o2, a2, r2, s2) {
            const n2 = a2.paint.get("raster-fade-duration");
            if (!s2 && n2 > 0) {
              const a3 = t.exported.now(), s3 = (a3 - e3.timeAdded) / n2, l2 = i2 ? (a3 - i2.timeAdded) / n2 : -1, c2 = o2.getSource(), h2 = r2.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), u2 = !i2 || Math.abs(i2.tileID.overscaledZ - h2) > Math.abs(e3.tileID.overscaledZ - h2), d2 = u2 && e3.refreshedUponExpiration ? 1 : t.clamp(u2 ? s3 : 1 - l2, 0, 1);
              return e3.refreshedUponExpiration && s3 >= 1 && (e3.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - d2 } : { opacity: d2, mix: 0 };
            }
            return { opacity: 1, mix: 0 };
          }
          const Ui = new t.Color(1, 0, 0, 1), Ni = new t.Color(0, 1, 0, 1), Gi = new t.Color(0, 0, 1, 1), Zi = new t.Color(1, 0, 1, 1), Vi = new t.Color(0, 1, 1, 1);
          function qi(t2, e3, i2, o2) {
            $i(t2, 0, e3 + i2 / 2, t2.transform.width, i2, o2);
          }
          function ji(t2, e3, i2, o2) {
            $i(t2, e3 - i2 / 2, 0, i2, t2.transform.height, o2);
          }
          function $i(t2, e3, i2, o2, a2, r2) {
            const s2 = t2.context, n2 = s2.gl;
            n2.enable(n2.SCISSOR_TEST), n2.scissor(e3 * t2.pixelRatio, i2 * t2.pixelRatio, o2 * t2.pixelRatio, a2 * t2.pixelRatio), s2.clear({ color: r2 }), n2.disable(n2.SCISSOR_TEST);
          }
          function Xi(e3, i2, o2) {
            const a2 = e3.context, r2 = a2.gl, s2 = o2.posMatrix, n2 = e3.useProgram("debug"), l2 = wi.disabled, c2 = Ei.disabled, h2 = e3.colorModeForRenderPass(), u2 = "$debug", d2 = e3.style.terrain && e3.style.terrain.getTerrainData(o2);
            a2.activeTexture.set(r2.TEXTURE0), e3.emptyTexture.bind(r2.LINEAR, r2.CLAMP_TO_EDGE);
            const m2 = i2.getTileByID(o2.key).latestRawTileData, _2 = Math.floor((m2 && m2.byteLength || 0) / 1024), p2 = i2.getTile(o2).tileSize, f2 = 512 / Math.min(p2, 512) * (o2.overscaledZ / e3.transform.zoom) * 0.5;
            let g2 = o2.canonical.toString();
            o2.overscaledZ !== o2.canonical.z && (g2 += ` => ${o2.overscaledZ}`), function(t2, e4) {
              t2.initDebugOverlayCanvas();
              const i3 = t2.debugOverlayCanvas, o3 = t2.context.gl, a3 = t2.debugOverlayCanvas.getContext("2d");
              a3.clearRect(0, 0, i3.width, i3.height), a3.shadowColor = "white", a3.shadowBlur = 2, a3.lineWidth = 1.5, a3.strokeStyle = "white", a3.textBaseline = "top", a3.font = "bold 36px Open Sans, sans-serif", a3.fillText(e4, 5, 5), a3.strokeText(e4, 5, 5), t2.debugOverlayTexture.update(i3), t2.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
            }(e3, `${g2} ${_2}kB`), n2.draw(a2, r2.TRIANGLES, l2, c2, yi.alphaBlended, Ii.disabled, ge(s2, t.Color.transparent, f2), null, u2, e3.debugBuffer, e3.quadTriangleIndexBuffer, e3.debugSegments), n2.draw(a2, r2.LINE_STRIP, l2, c2, h2, Ii.disabled, ge(s2, t.Color.red), d2, u2, e3.debugBuffer, e3.tileBorderIndexBuffer, e3.debugSegments);
          }
          function Wi(t2, e3, i2) {
            const o2 = t2.context, a2 = o2.gl, r2 = t2.colorModeForRenderPass(), s2 = new wi(a2.LEQUAL, wi.ReadWrite, t2.depthRangeFor3D), n2 = t2.useProgram("terrain"), l2 = e3.getTerrainMesh(), c2 = e3.getTerrainData(i2.tileID);
            o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, t2.width, t2.height]), o2.activeTexture.set(a2.TEXTURE0), a2.bindTexture(a2.TEXTURE_2D, e3.getRTTFramebuffer().colorAttachment.get());
            const h2 = t2.transform.calculatePosMatrix(i2.tileID.toUnwrapped());
            n2.draw(o2, a2.TRIANGLES, s2, Ei.disabled, r2, Ii.backCCW, { u_matrix: h2, u_texture: 0 }, c2, "terrain", l2.vertexBuffer, l2.indexBuffer, l2.segments);
          }
          function Hi(t2, e3, i2, o2) {
            const a2 = t2.context, r2 = i2.tileSize * e3.qualityFactor;
            i2.textures[o2] || (i2.textures[o2] = t2.getTileTexture(r2) || new l(a2, { width: r2, height: r2, data: null }, a2.gl.RGBA), i2.textures[o2].bind(a2.gl.LINEAR, a2.gl.CLAMP_TO_EDGE), 0 === o2 && e3.sourceCache.renderHistory.unshift(i2.tileID.key));
            const s2 = e3.getRTTFramebuffer();
            s2.colorAttachment.set(i2.textures[o2].texture), a2.bindFramebuffer.set(s2.framebuffer), a2.viewport.set([0, 0, r2, r2]);
          }
          class Ki {
            constructor(t2) {
              this._coordsDescendingInv = {}, this._coordsDescendingInvStr = {}, this.painter = t2, this._renderToTexture = { background: true, fill: true, line: true, raster: true }, this._coordsDescendingInv = {}, this._coordsDescendingInvStr = {}, this._stacks = [], this._prevType = null, this._rerender = {}, this._renderableTiles = t2.style.terrain.sourceCache.getRenderableTiles(), this._init();
            }
            _init() {
              const t2 = this.painter.style, e3 = t2.terrain;
              for (const i2 in t2.sourceCaches) {
                this._coordsDescendingInv[i2] = {};
                const o2 = t2.sourceCaches[i2].getVisibleCoordinates();
                for (const t3 of o2) {
                  const o3 = e3.sourceCache.getTerrainCoords(t3);
                  for (const t4 in o3)
                    this._coordsDescendingInv[i2][t4] || (this._coordsDescendingInv[i2][t4] = []), this._coordsDescendingInv[i2][t4].push(o3[t4]);
                }
              }
              for (const e4 of t2._order) {
                const i2 = t2._layers[e4], o2 = i2.source;
                if (this._renderToTexture[i2.type] && !this._coordsDescendingInvStr[o2]) {
                  this._coordsDescendingInvStr[o2] = {};
                  for (const t3 in this._coordsDescendingInv[o2])
                    this._coordsDescendingInvStr[o2][t3] = this._coordsDescendingInv[o2][t3].map((t4) => t4.key).sort().join();
                }
              }
              return this._renderableTiles.forEach((t3) => {
                for (const i2 in this._coordsDescendingInvStr) {
                  const o2 = this._coordsDescendingInvStr[i2][t3.tileID.key];
                  o2 && o2 !== t3.textureCoords[i2] && t3.clearTextures(this.painter), e3.needsRerender(i2, t3.tileID) && t3.clearTextures(this.painter);
                }
                this._rerender[t3.tileID.key] = !t3.textures.length;
              }), e3.clearRerenderCache(), e3.sourceCache.removeOutdated(this.painter), this;
            }
            renderLayer(e3) {
              const i2 = e3.type, o2 = this.painter, a2 = o2.style._order, r2 = o2.currentLayer, s2 = r2 + 1 === a2.length;
              if (this._renderToTexture[i2] && (this._prevType && this._renderToTexture[this._prevType] || this._stacks.push([]), this._prevType = i2, this._stacks[this._stacks.length - 1].push(a2[r2]), !s2))
                return true;
              if (this._renderToTexture[this._prevType] || "hillshade" === i2 || this._renderToTexture[i2] && s2) {
                this._prevType = i2;
                const s3 = this._stacks.length - 1, n2 = this._stacks[s3] || [];
                for (const e4 of this._renderableTiles) {
                  if (Hi(o2, o2.style.terrain, e4, s3), this._rerender[e4.tileID.key]) {
                    o2.context.clear({ color: t.Color.transparent });
                    for (let t2 = 0; t2 < n2.length; t2++) {
                      const i3 = o2.style._layers[n2[t2]], a3 = i3.source ? this._coordsDescendingInv[i3.source][e4.tileID.key] : [e4.tileID];
                      o2._renderTileClippingMasks(i3, a3), o2.renderLayer(o2, o2.style.sourceCaches[i3.source], i3, a3), i3.source && (e4.textureCoords[i3.source] = this._coordsDescendingInvStr[i3.source][e4.tileID.key]);
                    }
                  }
                  Wi(o2, o2.style.terrain, e4);
                }
                if ("hillshade" === i2) {
                  this._stacks.push([a2[r2]]);
                  for (const i3 of this._renderableTiles) {
                    const a3 = this._coordsDescendingInv[e3.source][i3.tileID.key];
                    Hi(o2, o2.style.terrain, i3, this._stacks.length - 1), o2.context.clear({ color: t.Color.transparent }), o2._renderTileClippingMasks(e3, a3), o2.renderLayer(o2, o2.style.sourceCaches[e3.source], e3, a3), Wi(o2, o2.style.terrain, i3);
                  }
                  return true;
                }
                return this._renderToTexture[i2];
              }
              return false;
            }
          }
          const Yi = { symbol: function(e3, i2, o2, a2, r2) {
            if ("translucent" !== e3.renderPass)
              return;
            const s2 = Ei.disabled, n2 = e3.colorModeForRenderPass();
            o2.layout.get("text-variable-anchor") && function(e4, i3, o3, a3, r3, s3, n3) {
              const l2 = i3.transform, c2 = "map" === r3, h2 = "map" === s3;
              for (const r4 of e4) {
                const e6 = a3.getTile(r4), s4 = e6.getBucket(o3);
                if (!s4 || !s4.text || !s4.text.segments.get().length)
                  continue;
                const u2 = t.evaluateSizeForZoom(s4.textSizeData, l2.zoom), d2 = bt(e6, 1, i3.transform.zoom), m2 = rt(r4.posMatrix, h2, c2, i3.transform, d2), _2 = "none" !== o3.layout.get("icon-text-fit") && s4.hasIconData();
                if (u2) {
                  const t2 = Math.pow(2, l2.zoom - e6.tileID.overscaledZ);
                  Pi(s4, c2, h2, n3, l2, m2, r4.posMatrix, t2, u2, _2, i3.style.terrain ? (t3, e7) => i3.style.terrain.getElevation(r4, t3, e7) : null);
                }
              }
            }(a2, e3, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), r2), 0 !== o2.paint.get("icon-opacity").constantOr(1) && Ai(e3, i2, o2, a2, false, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), o2.layout.get("icon-rotation-alignment"), o2.layout.get("icon-pitch-alignment"), o2.layout.get("icon-keep-upright"), s2, n2), 0 !== o2.paint.get("text-opacity").constantOr(1) && Ai(e3, i2, o2, a2, true, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), o2.layout.get("text-keep-upright"), s2, n2), i2.map.showCollisionBoxes && (Si(e3, i2, o2, a2, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), Si(e3, i2, o2, a2, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
          }, circle: function(e3, i2, o2, a2) {
            if ("translucent" !== e3.renderPass)
              return;
            const r2 = o2.paint.get("circle-opacity"), s2 = o2.paint.get("circle-stroke-width"), n2 = o2.paint.get("circle-stroke-opacity"), l2 = !o2.layout.get("circle-sort-key").isConstant();
            if (0 === r2.constantOr(1) && (0 === s2.constantOr(1) || 0 === n2.constantOr(1)))
              return;
            const c2 = e3.context, h2 = c2.gl, u2 = e3.depthModeForSublayer(0, wi.ReadOnly), d2 = Ei.disabled, m2 = e3.colorModeForRenderPass(), _2 = [];
            for (let r3 = 0; r3 < a2.length; r3++) {
              const s3 = a2[r3], n3 = i2.getTile(s3), c3 = n3.getBucket(o2);
              if (!c3)
                continue;
              const h3 = c3.programConfigurations.get(o2.id), u3 = e3.useProgram("circle", h3), d3 = c3.layoutVertexBuffer, m3 = c3.indexBuffer, p2 = e3.style.terrain && e3.style.terrain.getTerrainData(s3), f2 = { programConfiguration: h3, program: u3, layoutVertexBuffer: d3, indexBuffer: m3, uniformValues: pe(e3, s3, n3, o2), terrainData: p2 };
              if (l2) {
                const e4 = c3.segments.get();
                for (const i3 of e4)
                  _2.push({ segments: new t.SegmentVector([i3]), sortKey: i3.sortKey, state: f2 });
              } else
                _2.push({ segments: c3.segments, sortKey: 0, state: f2 });
            }
            l2 && _2.sort((t2, e4) => t2.sortKey - e4.sortKey);
            for (const t2 of _2) {
              const { programConfiguration: i3, program: a3, layoutVertexBuffer: r3, indexBuffer: s3, uniformValues: n3, terrainData: l3 } = t2.state;
              a3.draw(c2, h2.TRIANGLES, u2, d2, m2, Ii.disabled, n3, l3, o2.id, r3, s3, t2.segments, o2.paint, e3.transform.zoom, i3);
            }
          }, heatmap: function(e3, i2, o2, a2) {
            if (0 !== o2.paint.get("heatmap-opacity"))
              if ("offscreen" === e3.renderPass) {
                const r2 = e3.context, s2 = r2.gl, n2 = Ei.disabled, l2 = new yi([s2.ONE, s2.ONE], t.Color.transparent, [true, true, true, true]);
                !function(t2, e4, i3) {
                  const o3 = t2.gl;
                  t2.activeTexture.set(o3.TEXTURE1), t2.viewport.set([0, 0, e4.width / 4, e4.height / 4]);
                  let a3 = i3.heatmapFbo;
                  if (a3)
                    o3.bindTexture(o3.TEXTURE_2D, a3.colorAttachment.get()), t2.bindFramebuffer.set(a3.framebuffer);
                  else {
                    const r3 = o3.createTexture();
                    o3.bindTexture(o3.TEXTURE_2D, r3), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_S, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_T, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MIN_FILTER, o3.LINEAR), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MAG_FILTER, o3.LINEAR), a3 = i3.heatmapFbo = t2.createFramebuffer(e4.width / 4, e4.height / 4, false), function(t3, e6, i4, o4) {
                      const a4 = t3.gl;
                      a4.texImage2D(a4.TEXTURE_2D, 0, a4.RGBA, e6.width / 4, e6.height / 4, 0, a4.RGBA, t3.extRenderToTextureHalfFloat ? t3.extTextureHalfFloat.HALF_FLOAT_OES : a4.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
                    }(t2, e4, r3, a3);
                  }
                }(r2, e3, o2), r2.clear({ color: t.Color.transparent });
                for (let t2 = 0; t2 < a2.length; t2++) {
                  const c2 = a2[t2];
                  if (i2.hasRenderableParent(c2))
                    continue;
                  const h2 = i2.getTile(c2), u2 = h2.getBucket(o2);
                  if (!u2)
                    continue;
                  const d2 = u2.programConfigurations.get(o2.id), m2 = e3.useProgram("heatmap", d2), { zoom: _2 } = e3.transform;
                  m2.draw(r2, s2.TRIANGLES, wi.disabled, n2, l2, Ii.disabled, ve(c2.posMatrix, h2, _2, o2.paint.get("heatmap-intensity")), null, o2.id, u2.layoutVertexBuffer, u2.indexBuffer, u2.segments, o2.paint, e3.transform.zoom, d2);
                }
                r2.viewport.set([0, 0, e3.width, e3.height]);
              } else
                "translucent" === e3.renderPass && (e3.context.setColorMode(e3.colorModeForRenderPass()), function(e4, i3) {
                  const o3 = e4.context, a3 = o3.gl, r2 = i3.heatmapFbo;
                  if (!r2)
                    return;
                  o3.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_2D, r2.colorAttachment.get()), o3.activeTexture.set(a3.TEXTURE1);
                  let s2 = i3.colorRampTexture;
                  s2 || (s2 = i3.colorRampTexture = new l(o3, i3.colorRamp, a3.RGBA)), s2.bind(a3.LINEAR, a3.CLAMP_TO_EDGE), e4.useProgram("heatmapTexture").draw(o3, a3.TRIANGLES, wi.disabled, Ei.disabled, e4.colorModeForRenderPass(), Ii.disabled, ((e6, i4, o4, a4) => {
                    const r3 = t.create();
                    t.ortho(r3, 0, e6.width, e6.height, 0, 0, 1);
                    const s3 = e6.context.gl;
                    return { u_matrix: r3, u_world: [s3.drawingBufferWidth, s3.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: i4.paint.get("heatmap-opacity") };
                  })(e4, i3), null, i3.id, e4.viewportBuffer, e4.quadTriangleIndexBuffer, e4.viewportSegments, i3.paint, e4.transform.zoom);
                }(e3, o2));
          }, line: function(e3, i2, o2, a2) {
            if ("translucent" !== e3.renderPass)
              return;
            const r2 = o2.paint.get("line-opacity"), s2 = o2.paint.get("line-width");
            if (0 === r2.constantOr(1) || 0 === s2.constantOr(1))
              return;
            const n2 = e3.depthModeForSublayer(0, wi.ReadOnly), c2 = e3.colorModeForRenderPass(), h2 = o2.paint.get("line-dasharray"), u2 = o2.paint.get("line-pattern"), d2 = u2.constantOr(1), m2 = o2.paint.get("line-gradient"), _2 = o2.getCrossfadeParameters(), p2 = d2 ? "linePattern" : h2 ? "lineSDF" : m2 ? "lineGradient" : "line", f2 = e3.context, g2 = f2.gl;
            let x3 = true;
            for (const r3 of a2) {
              const a3 = i2.getTile(r3);
              if (d2 && !a3.patternsLoaded())
                continue;
              const s3 = a3.getBucket(o2);
              if (!s3)
                continue;
              const v2 = s3.programConfigurations.get(o2.id), y3 = e3.context.program.get(), b2 = e3.useProgram(p2, v2), w2 = x3 || b2.program !== y3, T2 = e3.style.terrain && e3.style.terrain.getTerrainData(r3), E2 = u2.constantOr(null);
              if (E2 && a3.imageAtlas) {
                const t2 = a3.imageAtlas, e4 = t2.patternPositions[E2.to.toString()], i3 = t2.patternPositions[E2.from.toString()];
                e4 && i3 && v2.setConstantPatternPositions(e4, i3);
              }
              const I2 = T2 ? r3 : null, C2 = d2 ? Te(e3, a3, o2, _2, I2) : h2 ? Ee(e3, a3, o2, h2, _2, I2) : m2 ? we(e3, a3, o2, s3.lineClipsArray.length, I2) : be(e3, a3, o2, I2);
              if (d2)
                f2.activeTexture.set(g2.TEXTURE0), a3.imageAtlasTexture.bind(g2.LINEAR, g2.CLAMP_TO_EDGE), v2.updatePaintBuffers(_2);
              else if (h2 && (w2 || e3.lineAtlas.dirty))
                f2.activeTexture.set(g2.TEXTURE0), e3.lineAtlas.bind(f2);
              else if (m2) {
                const a4 = s3.gradients[o2.id];
                let n3 = a4.texture;
                if (o2.gradientVersion !== a4.version) {
                  let c3 = 256;
                  if (o2.stepInterpolant) {
                    const o3 = i2.getSource().maxzoom, a5 = r3.canonical.z === o3 ? Math.ceil(1 << e3.transform.maxZoom - r3.canonical.z) : 1;
                    c3 = t.clamp(t.nextPowerOfTwo(s3.maxLineLength / t.EXTENT * 1024 * a5), 256, f2.maxTextureSize);
                  }
                  a4.gradient = t.renderColorRamp({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: c3, image: a4.gradient || void 0, clips: s3.lineClipsArray }), a4.texture ? a4.texture.update(a4.gradient) : a4.texture = new l(f2, a4.gradient, g2.RGBA), a4.version = o2.gradientVersion, n3 = a4.texture;
                }
                f2.activeTexture.set(g2.TEXTURE0), n3.bind(o2.stepInterpolant ? g2.NEAREST : g2.LINEAR, g2.CLAMP_TO_EDGE);
              }
              b2.draw(f2, g2.TRIANGLES, n2, e3.stencilModeForClipping(r3), c2, Ii.disabled, C2, T2, o2.id, s3.layoutVertexBuffer, s3.indexBuffer, s3.segments, o2.paint, e3.transform.zoom, v2, s3.layoutVertexBuffer2), x3 = false;
            }
          }, fill: function(e3, i2, o2, a2) {
            const r2 = o2.paint.get("fill-color"), s2 = o2.paint.get("fill-opacity");
            if (0 === s2.constantOr(1))
              return;
            const n2 = e3.colorModeForRenderPass(), l2 = o2.paint.get("fill-pattern"), c2 = e3.opaquePassEnabledForLayer() && !l2.constantOr(1) && 1 === r2.constantOr(t.Color.transparent).a && 1 === s2.constantOr(0) ? "opaque" : "translucent";
            if (e3.renderPass === c2) {
              const t2 = e3.depthModeForSublayer(1, "opaque" === e3.renderPass ? wi.ReadWrite : wi.ReadOnly);
              Ri(e3, i2, o2, a2, t2, n2, false);
            }
            if ("translucent" === e3.renderPass && o2.paint.get("fill-antialias")) {
              const t2 = e3.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, wi.ReadOnly);
              Ri(e3, i2, o2, a2, t2, n2, true);
            }
          }, "fill-extrusion": function(t2, e3, i2, o2) {
            const a2 = i2.paint.get("fill-extrusion-opacity");
            if (0 !== a2 && "translucent" === t2.renderPass) {
              const r2 = new wi(t2.context.gl.LEQUAL, wi.ReadWrite, t2.depthRangeFor3D);
              if (1 !== a2 || i2.paint.get("fill-extrusion-pattern").constantOr(1))
                ki(t2, e3, i2, o2, r2, Ei.disabled, yi.disabled), ki(t2, e3, i2, o2, r2, t2.stencilModeFor3D(), t2.colorModeForRenderPass());
              else {
                const a3 = t2.colorModeForRenderPass();
                ki(t2, e3, i2, o2, r2, Ei.disabled, a3);
              }
            }
          }, hillshade: function(t2, e3, i2, o2) {
            if ("offscreen" !== t2.renderPass && "translucent" !== t2.renderPass)
              return;
            const a2 = t2.context, r2 = t2.depthModeForSublayer(0, wi.ReadOnly), s2 = t2.colorModeForRenderPass(), [n2, l2] = "translucent" === t2.renderPass ? t2.stencilConfigForOverlap(o2) : [{}, o2];
            for (const o3 of l2) {
              const a3 = e3.getTile(o3);
              void 0 !== a3.needsHillshadePrepare && a3.needsHillshadePrepare && "offscreen" === t2.renderPass ? Fi(t2, a3, i2, r2, Ei.disabled, s2) : "translucent" === t2.renderPass && Bi(t2, o3, a3, i2, r2, n2[o3.overscaledZ], s2);
            }
            a2.viewport.set([0, 0, t2.width, t2.height]);
          }, raster: function(t2, e3, i2, o2) {
            if ("translucent" !== t2.renderPass)
              return;
            if (0 === i2.paint.get("raster-opacity"))
              return;
            if (!o2.length)
              return;
            const a2 = t2.context, r2 = a2.gl, s2 = e3.getSource(), n2 = t2.useProgram("raster"), l2 = t2.colorModeForRenderPass(), [c2, h2] = s2 instanceof D ? [{}, o2] : t2.stencilConfigForOverlap(o2), u2 = h2[h2.length - 1].overscaledZ, d2 = !t2.options.moving;
            for (const o3 of h2) {
              const h3 = t2.depthModeForSublayer(o3.overscaledZ - u2, 1 === i2.paint.get("raster-opacity") ? wi.ReadWrite : wi.ReadOnly, r2.LESS), m2 = e3.getTile(o3);
              m2.registerFadeDuration(i2.paint.get("raster-fade-duration"));
              const _2 = e3.findLoadedParent(o3, 0), p2 = Oi(m2, _2, e3, i2, t2.transform, t2.style.terrain);
              let f2, g2;
              const x3 = "nearest" === i2.paint.get("raster-resampling") ? r2.NEAREST : r2.LINEAR;
              a2.activeTexture.set(r2.TEXTURE0), m2.texture.bind(x3, r2.CLAMP_TO_EDGE, r2.LINEAR_MIPMAP_NEAREST), a2.activeTexture.set(r2.TEXTURE1), _2 ? (_2.texture.bind(x3, r2.CLAMP_TO_EDGE, r2.LINEAR_MIPMAP_NEAREST), f2 = Math.pow(2, _2.tileID.overscaledZ - m2.tileID.overscaledZ), g2 = [m2.tileID.canonical.x * f2 % 1, m2.tileID.canonical.y * f2 % 1]) : m2.texture.bind(x3, r2.CLAMP_TO_EDGE, r2.LINEAR_MIPMAP_NEAREST);
              const v2 = t2.style.terrain && t2.style.terrain.getTerrainData(o3), y3 = v2 ? o3 : null, b2 = y3 ? y3.posMatrix : t2.transform.calculatePosMatrix(o3.toUnwrapped(), d2), w2 = Se(b2, g2 || [0, 0], f2 || 1, p2, i2);
              s2 instanceof D ? n2.draw(a2, r2.TRIANGLES, h3, Ei.disabled, l2, Ii.disabled, w2, v2, i2.id, s2.boundsBuffer, t2.quadTriangleIndexBuffer, s2.boundsSegments) : n2.draw(a2, r2.TRIANGLES, h3, c2[o3.overscaledZ], l2, Ii.disabled, w2, v2, i2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
            }
          }, background: function(t2, e3, i2, o2) {
            const a2 = i2.paint.get("background-color"), r2 = i2.paint.get("background-opacity");
            if (0 === r2)
              return;
            const s2 = t2.context, n2 = s2.gl, l2 = t2.transform, c2 = l2.tileSize, h2 = i2.paint.get("background-pattern");
            if (t2.isPatternMissing(h2))
              return;
            const u2 = !h2 && 1 === a2.a && 1 === r2 && t2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
            if (t2.renderPass !== u2)
              return;
            const d2 = Ei.disabled, m2 = t2.depthModeForSublayer(0, "opaque" === u2 ? wi.ReadWrite : wi.ReadOnly), _2 = t2.colorModeForRenderPass(), p2 = t2.useProgram(h2 ? "backgroundPattern" : "background"), f2 = o2 || l2.coveringTiles({ tileSize: c2, terrain: t2.style.terrain });
            h2 && (s2.activeTexture.set(n2.TEXTURE0), t2.imageManager.bind(t2.context));
            const g2 = i2.getCrossfadeParameters();
            for (const e4 of f2) {
              const l3 = o2 ? e4.posMatrix : t2.transform.calculatePosMatrix(e4.toUnwrapped()), u3 = h2 ? Le(l3, r2, t2, h2, { tileID: e4, tileSize: c2 }, g2) : Ae(l3, r2, a2), f3 = t2.style.terrain && t2.style.terrain.getTerrainData(e4);
              p2.draw(s2, n2.TRIANGLES, m2, d2, _2, Ii.disabled, u3, f3, i2.id, t2.tileExtentBuffer, t2.quadTriangleIndexBuffer, t2.tileExtentSegments);
            }
          }, debug: function(t2, e3, i2) {
            for (let o2 = 0; o2 < i2.length; o2++)
              Xi(t2, e3, i2[o2]);
          }, custom: function(t2, e3, i2) {
            const o2 = t2.context, a2 = i2.implementation;
            if ("offscreen" === t2.renderPass) {
              const e4 = a2.prerender;
              e4 && (t2.setCustomLayerDefaults(), o2.setColorMode(t2.colorModeForRenderPass()), e4.call(a2, o2.gl, t2.transform.customLayerMatrix()), o2.setDirty(), t2.setBaseState());
            } else if ("translucent" === t2.renderPass) {
              t2.setCustomLayerDefaults(), o2.setColorMode(t2.colorModeForRenderPass()), o2.setStencilMode(Ei.disabled);
              const e4 = "3d" === a2.renderingMode ? new wi(t2.context.gl.LEQUAL, wi.ReadWrite, t2.depthRangeFor3D) : t2.depthModeForSublayer(0, wi.ReadOnly);
              o2.setDepthMode(e4), a2.render(o2.gl, t2.transform.customLayerMatrix()), o2.setDirty(), t2.setBaseState(), o2.bindFramebuffer.set(null);
            }
          } };
          class Ji {
            constructor(e3, i2) {
              this.context = new bi(e3), this.transform = i2, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: t.create(), renderTime: 0 }, this.setup(), this.numSublayers = O.maxUnderzooming + O.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Xt(), this.gpuTimers = {};
            }
            resize(t2, e3, i2) {
              if (this.width = t2 * i2, this.height = e3 * i2, this.pixelRatio = i2, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
                for (const t3 of this.style._order)
                  this.style._layers[t3].resize();
            }
            setup() {
              const e3 = this.context, i2 = new t.PosArray();
              i2.emplaceBack(0, 0), i2.emplaceBack(t.EXTENT, 0), i2.emplaceBack(0, t.EXTENT), i2.emplaceBack(t.EXTENT, t.EXTENT), this.tileExtentBuffer = e3.createVertexBuffer(i2, Wt.members), this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
              const o2 = new t.PosArray();
              o2.emplaceBack(0, 0), o2.emplaceBack(t.EXTENT, 0), o2.emplaceBack(0, t.EXTENT), o2.emplaceBack(t.EXTENT, t.EXTENT), this.debugBuffer = e3.createVertexBuffer(o2, Wt.members), this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5);
              const a2 = new t.RasterBoundsArray();
              a2.emplaceBack(0, 0, 0, 0), a2.emplaceBack(t.EXTENT, 0, t.EXTENT, 0), a2.emplaceBack(0, t.EXTENT, 0, t.EXTENT), a2.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT), this.rasterBoundsBuffer = e3.createVertexBuffer(a2, S.members), this.rasterBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
              const r2 = new t.PosArray();
              r2.emplaceBack(0, 0), r2.emplaceBack(1, 0), r2.emplaceBack(0, 1), r2.emplaceBack(1, 1), this.viewportBuffer = e3.createVertexBuffer(r2, Wt.members), this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
              const s2 = new t.LineStripIndexArray();
              s2.emplaceBack(0), s2.emplaceBack(1), s2.emplaceBack(3), s2.emplaceBack(2), s2.emplaceBack(0), this.tileBorderIndexBuffer = e3.createIndexBuffer(s2);
              const n2 = new t.TriangleIndexArray();
              n2.emplaceBack(0, 1, 2), n2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e3.createIndexBuffer(n2), this.emptyTexture = new l(e3, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, e3.gl.RGBA);
              const c2 = this.context.gl;
              this.stencilClearMode = new Ei({ func: c2.ALWAYS, mask: 0 }, 0, 255, c2.ZERO, c2.ZERO, c2.ZERO);
            }
            clearStencil() {
              const e3 = this.context, i2 = e3.gl;
              this.nextStencilID = 1, this.currentStencilSource = void 0;
              const o2 = t.create();
              t.ortho(o2, 0, this.width, this.height, 0, 0, 1), t.scale(o2, o2, [i2.drawingBufferWidth, i2.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e3, i2.TRIANGLES, wi.disabled, this.stencilClearMode, yi.disabled, Ii.disabled, xe(o2), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            _renderTileClippingMasks(t2, e3) {
              if (this.currentStencilSource === t2.source || !t2.isTileClipped() || !e3 || !e3.length)
                return;
              this.currentStencilSource = t2.source;
              const i2 = this.context, o2 = i2.gl;
              this.nextStencilID + e3.length > 256 && this.clearStencil(), i2.setColorMode(yi.disabled), i2.setDepthMode(wi.disabled);
              const a2 = this.useProgram("clippingMask");
              this._tileClippingMaskIDs = {};
              for (const t3 of e3) {
                const e4 = this._tileClippingMaskIDs[t3.key] = this.nextStencilID++, r2 = this.style.terrain && this.style.terrain.getTerrainData(t3);
                a2.draw(i2, o2.TRIANGLES, wi.disabled, new Ei({ func: o2.ALWAYS, mask: 0 }, e4, 255, o2.KEEP, o2.KEEP, o2.REPLACE), yi.disabled, Ii.disabled, xe(t3.posMatrix), r2, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
              }
            }
            stencilModeFor3D() {
              this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
              const t2 = this.nextStencilID++, e3 = this.context.gl;
              return new Ei({ func: e3.NOTEQUAL, mask: 255 }, t2, 255, e3.KEEP, e3.KEEP, e3.REPLACE);
            }
            stencilModeForClipping(t2) {
              const e3 = this.context.gl;
              return new Ei({ func: e3.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t2.key], 0, e3.KEEP, e3.KEEP, e3.REPLACE);
            }
            stencilConfigForOverlap(t2) {
              const e3 = this.context.gl, i2 = t2.sort((t3, e4) => e4.overscaledZ - t3.overscaledZ), o2 = i2[i2.length - 1].overscaledZ, a2 = i2[0].overscaledZ - o2 + 1;
              if (a2 > 1) {
                this.currentStencilSource = void 0, this.nextStencilID + a2 > 256 && this.clearStencil();
                const t3 = {};
                for (let i3 = 0; i3 < a2; i3++)
                  t3[i3 + o2] = new Ei({ func: e3.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, e3.KEEP, e3.KEEP, e3.REPLACE);
                return this.nextStencilID += a2, [t3, i2];
              }
              return [{ [o2]: Ei.disabled }, i2];
            }
            colorModeForRenderPass() {
              const e3 = this.context.gl;
              if (this._showOverdrawInspector) {
                const i2 = 1 / 8;
                return new yi([e3.CONSTANT_COLOR, e3.ONE], new t.Color(i2, i2, i2, 0), [true, true, true, true]);
              }
              return "opaque" === this.renderPass ? yi.unblended : yi.alphaBlended;
            }
            depthModeForSublayer(t2, e3, i2) {
              if (!this.opaquePassEnabledForLayer())
                return wi.disabled;
              const o2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t2) * this.depthEpsilon;
              return new wi(i2 || this.context.gl.LEQUAL, e3, [o2, o2]);
            }
            opaquePassEnabledForLayer() {
              return this.currentLayer < this.opaquePassCutoff;
            }
            render(e3, i2) {
              this.style = e3, this.options = i2, this.lineAtlas = e3.lineAtlas, this.imageManager = e3.imageManager, this.glyphManager = e3.glyphManager, this.symbolFadeChange = e3.placement.symbolFadeChange(t.exported.now()), this.imageManager.beginFrame();
              const o2 = this.style._order, a2 = this.style.sourceCaches, r2 = this.style.terrain && new Ki(this);
              for (const t2 in a2) {
                const e4 = a2[t2];
                e4.used && e4.prepare(this.context);
              }
              const s2 = {}, n2 = {}, l2 = {};
              for (const t2 in a2) {
                const e4 = a2[t2];
                s2[t2] = e4.getVisibleCoordinates(), n2[t2] = s2[t2].slice().reverse(), l2[t2] = e4.getVisibleCoordinates(true).reverse();
              }
              this.opaquePassCutoff = 1 / 0;
              for (let t2 = 0; t2 < o2.length; t2++)
                if (this.style._layers[o2[t2]].is3D()) {
                  this.opaquePassCutoff = t2;
                  break;
                }
              if (r2) {
                this.opaquePassCutoff = 0;
                const e4 = this.style.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime);
                (this.terrainFacilitator.dirty || !t.equals(this.terrainFacilitator.matrix, this.transform.projMatrix) || e4.length) && (t.copy(this.terrainFacilitator.matrix, this.transform.projMatrix), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, function(e6, i3) {
                  const o3 = e6.context, a3 = o3.gl, r3 = yi.unblended, s3 = new wi(a3.LEQUAL, wi.ReadWrite, [0, 1]), n3 = i3.getTerrainMesh(), l3 = i3.sourceCache.getRenderableTiles(), c2 = e6.useProgram("terrainDepth");
                  o3.bindFramebuffer.set(i3.getFramebuffer("depth").framebuffer), o3.viewport.set([0, 0, e6.width / devicePixelRatio, e6.height / devicePixelRatio]), o3.clear({ color: t.Color.transparent, depth: 1 });
                  for (const t2 of l3) {
                    const l4 = i3.getTerrainData(t2.tileID), h2 = e6.transform.calculatePosMatrix(t2.tileID.toUnwrapped());
                    c2.draw(o3, a3.TRIANGLES, s3, Ei.disabled, r3, Ii.backCCW, { u_matrix: h2 }, l4, "terrain", n3.vertexBuffer, n3.indexBuffer, n3.segments);
                  }
                  o3.bindFramebuffer.set(null), o3.viewport.set([0, 0, e6.width, e6.height]);
                }(this, this.style.terrain), function(e6, i3) {
                  const o3 = e6.context, a3 = o3.gl, r3 = yi.unblended, s3 = new wi(a3.LEQUAL, wi.ReadWrite, [0, 1]), n3 = i3.getTerrainMesh(), l3 = i3.getCoordsTexture(), c2 = i3.sourceCache.getRenderableTiles(), h2 = e6.useProgram("terrainCoords");
                  o3.bindFramebuffer.set(i3.getFramebuffer("coords").framebuffer), o3.viewport.set([0, 0, e6.width / devicePixelRatio, e6.height / devicePixelRatio]), o3.clear({ color: t.Color.transparent, depth: 1 }), i3.coordsIndex = [];
                  for (const t2 of c2) {
                    const c3 = i3.getTerrainData(t2.tileID);
                    o3.activeTexture.set(a3.TEXTURE0), a3.bindTexture(a3.TEXTURE_2D, l3.texture);
                    const u2 = e6.transform.calculatePosMatrix(t2.tileID.toUnwrapped());
                    h2.draw(o3, a3.TRIANGLES, s3, Ei.disabled, r3, Ii.backCCW, { u_matrix: u2, u_terrain_coords_id: (255 - i3.coordsIndex.length) / 255, u_texture: 0 }, c3, "terrain", n3.vertexBuffer, n3.indexBuffer, n3.segments), i3.coordsIndex.push(t2.tileID.key);
                  }
                  o3.bindFramebuffer.set(null), o3.viewport.set([0, 0, e6.width, e6.height]);
                }(this, this.style.terrain));
              }
              this.renderPass = "offscreen";
              for (const t2 of o2) {
                const e4 = this.style._layers[t2];
                if (!e4.hasOffscreenPass() || e4.isHidden(this.transform.zoom))
                  continue;
                const i3 = n2[e4.source];
                ("custom" === e4.type || i3.length) && this.renderLayer(this, a2[e4.source], e4, i3);
              }
              if (this.context.bindFramebuffer.set(null), this.context.clear({ color: i2.showOverdrawInspector ? t.Color.black : t.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e3._order.length + 2) * this.numSublayers * this.depthEpsilon], !r2)
                for (this.renderPass = "opaque", this.currentLayer = o2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                  const t2 = this.style._layers[o2[this.currentLayer]], e4 = a2[t2.source], i3 = s2[t2.source];
                  this._renderTileClippingMasks(t2, i3), this.renderLayer(this, e4, t2, i3);
                }
              for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < o2.length; this.currentLayer++) {
                const t2 = this.style._layers[o2[this.currentLayer]], e4 = a2[t2.source];
                if (r2 && r2.renderLayer(t2))
                  continue;
                const i3 = ("symbol" === t2.type ? l2 : n2)[t2.source];
                this._renderTileClippingMasks(t2, s2[t2.source]), this.renderLayer(this, e4, t2, i3);
              }
              if (this.options.showTileBoundaries) {
                let t2, e4;
                Object.values(this.style._layers).forEach((i3) => {
                  i3.source && !i3.isHidden(this.transform.zoom) && (i3.source !== (e4 && e4.id) && (e4 = this.style.sourceCaches[i3.source]), (!t2 || t2.getSource().maxzoom < e4.getSource().maxzoom) && (t2 = e4));
                }), t2 && Yi.debug(this, t2, t2.getVisibleCoordinates());
              }
              this.options.showPadding && function(t2) {
                const e4 = t2.transform.padding;
                qi(t2, t2.transform.height - (e4.top || 0), 3, Ui), qi(t2, e4.bottom || 0, 3, Ni), ji(t2, e4.left || 0, 3, Gi), ji(t2, t2.transform.width - (e4.right || 0), 3, Zi);
                const i3 = t2.transform.centerPoint;
                !function(t3, e6, i4, o3) {
                  $i(t3, e6 - 1, i4 - 10, 2, 20, o3), $i(t3, e6 - 10, i4 - 1, 20, 2, o3);
                }(t2, i3.x, t2.transform.height - i3.y, Vi);
              }(this), this.context.setDefault();
            }
            renderLayer(t2, e3, i2, o2) {
              i2.isHidden(this.transform.zoom) || ("background" === i2.type || "custom" === i2.type || (o2 || []).length) && (this.id = i2.id, this.gpuTimingStart(i2), Yi[i2.type](t2, e3, i2, o2, this.style.placement.variableOffsets), this.gpuTimingEnd());
            }
            gpuTimingStart(t2) {
              if (!this.options.gpuTiming)
                return;
              const e3 = this.context.extTimerQuery;
              let i2 = this.gpuTimers[t2.id];
              i2 || (i2 = this.gpuTimers[t2.id] = { calls: 0, cpuTime: 0, query: e3.createQueryEXT() }), i2.calls++, e3.beginQueryEXT(e3.TIME_ELAPSED_EXT, i2.query);
            }
            gpuTimingEnd() {
              if (!this.options.gpuTiming)
                return;
              const t2 = this.context.extTimerQuery;
              t2.endQueryEXT(t2.TIME_ELAPSED_EXT);
            }
            collectGpuTimers() {
              const t2 = this.gpuTimers;
              return this.gpuTimers = {}, t2;
            }
            queryGpuTimers(t2) {
              const e3 = {};
              for (const i2 in t2) {
                const o2 = t2[i2], a2 = this.context.extTimerQuery, r2 = a2.getQueryObjectEXT(o2.query, a2.QUERY_RESULT_EXT) / 1e6;
                a2.deleteQueryEXT(o2.query), e3[i2] = r2;
              }
              return e3;
            }
            translatePosMatrix(e3, i2, o2, a2, r2) {
              if (!o2[0] && !o2[1])
                return e3;
              const s2 = r2 ? "map" === a2 ? this.transform.angle : 0 : "viewport" === a2 ? -this.transform.angle : 0;
              if (s2) {
                const t2 = Math.sin(s2), e4 = Math.cos(s2);
                o2 = [o2[0] * e4 - o2[1] * t2, o2[0] * t2 + o2[1] * e4];
              }
              const n2 = [r2 ? o2[0] : bt(i2, o2[0], this.transform.zoom), r2 ? o2[1] : bt(i2, o2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
              return t.translate(l2, e3, n2), l2;
            }
            saveTileTexture(t2) {
              const e3 = this._tileTextures[t2.size[0]];
              e3 ? e3.push(t2) : this._tileTextures[t2.size[0]] = [t2];
            }
            getTileTexture(t2) {
              const e3 = this._tileTextures[t2];
              return e3 && e3.length > 0 ? e3.pop() : null;
            }
            isPatternMissing(t2) {
              if (!t2)
                return false;
              if (!t2.from || !t2.to)
                return true;
              const e3 = this.imageManager.getPattern(t2.from.toString()), i2 = this.imageManager.getPattern(t2.to.toString());
              return !e3 || !i2;
            }
            useProgram(t2, e3) {
              this.cache = this.cache || {};
              const i2 = t2 + (e3 ? e3.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.terrain ? "/terrain" : "");
              return this.cache[i2] || (this.cache[i2] = new ne(this.context, t2, oe[t2], e3, Re[t2], this._showOverdrawInspector, this.style.terrain)), this.cache[i2];
            }
            setCustomLayerDefaults() {
              this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
              const t2 = this.context.gl;
              this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t2.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
              null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new l(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
            }
            destroy() {
              this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
            }
          }
          class Qi {
            constructor(t2, e3) {
              this.points = t2, this.planes = e3;
            }
            static fromInvProjectionMatrix(e3, i2, o2) {
              const a2 = Math.pow(2, o2), r2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((o3) => {
                const r3 = 1 / (o3 = t.transformMat4([], o3, e3))[3] / i2 * a2;
                return t.mul$1(o3, o3, [r3, r3, 1 / o3[3], r3]);
              }), s2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((e4) => {
                const i3 = t.sub([], r2[e4[0]], r2[e4[1]]), o3 = t.sub([], r2[e4[2]], r2[e4[1]]), a3 = t.normalize([], t.cross([], i3, o3)), s3 = -t.dot(a3, r2[e4[1]]);
                return a3.concat(s3);
              });
              return new Qi(r2, s2);
            }
          }
          class to {
            constructor(e3, i2) {
              this.min = e3, this.max = i2, this.center = t.scale$1([], t.add([], this.min, this.max), 0.5);
            }
            quadrant(e3) {
              const i2 = [e3 % 2 == 0, e3 < 2], o2 = t.clone$2(this.min), a2 = t.clone$2(this.max);
              for (let t2 = 0; t2 < i2.length; t2++)
                o2[t2] = i2[t2] ? this.min[t2] : this.center[t2], a2[t2] = i2[t2] ? this.center[t2] : this.max[t2];
              return a2[2] = this.max[2], new to(o2, a2);
            }
            distanceX(t2) {
              return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
            }
            distanceY(t2) {
              return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
            }
            intersects(e3) {
              const i2 = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
              let o2 = true;
              for (let a2 = 0; a2 < e3.planes.length; a2++) {
                const r2 = e3.planes[a2];
                let s2 = 0;
                for (let e4 = 0; e4 < i2.length; e4++)
                  t.dot$1(r2, i2[e4]) >= 0 && s2++;
                if (0 === s2)
                  return 0;
                s2 !== i2.length && (o2 = false);
              }
              if (o2)
                return 2;
              for (let t2 = 0; t2 < 3; t2++) {
                let i3 = Number.MAX_VALUE, o3 = -Number.MAX_VALUE;
                for (let a2 = 0; a2 < e3.points.length; a2++) {
                  const r2 = e3.points[a2][t2] - this.min[t2];
                  i3 = Math.min(i3, r2), o3 = Math.max(o3, r2);
                }
                if (o3 < 0 || i3 > this.max[t2] - this.min[t2])
                  return 0;
              }
              return 1;
            }
          }
          class eo {
            constructor(t2 = 0, e3 = 0, i2 = 0, o2 = 0) {
              if (isNaN(t2) || t2 < 0 || isNaN(e3) || e3 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0)
                throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
              this.top = t2, this.bottom = e3, this.left = i2, this.right = o2;
            }
            interpolate(e3, i2, o2) {
              return null != i2.top && null != e3.top && (this.top = t.number(e3.top, i2.top, o2)), null != i2.bottom && null != e3.bottom && (this.bottom = t.number(e3.bottom, i2.bottom, o2)), null != i2.left && null != e3.left && (this.left = t.number(e3.left, i2.left, o2)), null != i2.right && null != e3.right && (this.right = t.number(e3.right, i2.right, o2)), this;
            }
            getCenter(e3, i2) {
              const o2 = t.clamp((this.left + e3 - this.right) / 2, 0, e3), a2 = t.clamp((this.top + i2 - this.bottom) / 2, 0, i2);
              return new t.pointGeometry(o2, a2);
            }
            equals(t2) {
              return this.top === t2.top && this.bottom === t2.bottom && this.left === t2.left && this.right === t2.right;
            }
            clone() {
              return new eo(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
              return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
            }
          }
          class io {
            constructor(e3, i2, o2, a2, r2) {
              this.tileSize = 512, this.maxValidLatitude = 85.051129, this.freezeElevation = false, this._renderWorldCopies = void 0 === r2 || !!r2, this._minZoom = e3 || 0, this._maxZoom = i2 || 22, this._minPitch = null == o2 ? 0 : o2, this._maxPitch = null == a2 ? 60 : a2, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t.LngLat(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new eo(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
            }
            clone() {
              const t2 = new io(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
              return t2.tileSize = this.tileSize, t2.latRange = this.latRange, t2.width = this.width, t2.height = this.height, t2._center = this._center, t2._elevation = this._elevation, t2.zoom = this.zoom, t2.angle = this.angle, t2._fov = this._fov, t2._pitch = this._pitch, t2._unmodified = this._unmodified, t2._edgeInsets = this._edgeInsets.clone(), t2._calcMatrices(), t2;
            }
            get minZoom() {
              return this._minZoom;
            }
            set minZoom(t2) {
              this._minZoom !== t2 && (this._minZoom = t2, this.zoom = Math.max(this.zoom, t2));
            }
            get maxZoom() {
              return this._maxZoom;
            }
            set maxZoom(t2) {
              this._maxZoom !== t2 && (this._maxZoom = t2, this.zoom = Math.min(this.zoom, t2));
            }
            get minPitch() {
              return this._minPitch;
            }
            set minPitch(t2) {
              this._minPitch !== t2 && (this._minPitch = t2, this.pitch = Math.max(this.pitch, t2));
            }
            get maxPitch() {
              return this._maxPitch;
            }
            set maxPitch(t2) {
              this._maxPitch !== t2 && (this._maxPitch = t2, this.pitch = Math.min(this.pitch, t2));
            }
            get renderWorldCopies() {
              return this._renderWorldCopies;
            }
            set renderWorldCopies(t2) {
              void 0 === t2 ? t2 = true : null === t2 && (t2 = false), this._renderWorldCopies = t2;
            }
            get worldSize() {
              return this.tileSize * this.scale;
            }
            get centerOffset() {
              return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
              return new t.pointGeometry(this.width, this.height);
            }
            get bearing() {
              return -this.angle / Math.PI * 180;
            }
            set bearing(e3) {
              const i2 = -t.wrap(e3, -180, 180) * Math.PI / 180;
              var o2;
              this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = (o2 = new t.ARRAY_TYPE(4), t.ARRAY_TYPE != Float32Array && (o2[1] = 0, o2[2] = 0), o2[0] = 1, o2[3] = 1, o2), function(t2, e4, i3) {
                var o3 = e4[0], a2 = e4[1], r2 = e4[2], s2 = e4[3], n2 = Math.sin(i3), l2 = Math.cos(i3);
                t2[0] = o3 * l2 + r2 * n2, t2[1] = a2 * l2 + s2 * n2, t2[2] = o3 * -n2 + r2 * l2, t2[3] = a2 * -n2 + s2 * l2;
              }(this.rotationMatrix, this.rotationMatrix, this.angle));
            }
            get pitch() {
              return this._pitch / Math.PI * 180;
            }
            set pitch(e3) {
              const i2 = t.clamp(e3, this.minPitch, this.maxPitch) / 180 * Math.PI;
              this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
            }
            get fov() {
              return this._fov / Math.PI * 180;
            }
            set fov(t2) {
              t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = t2 / 180 * Math.PI, this._calcMatrices());
            }
            get zoom() {
              return this._zoom;
            }
            set zoom(t2) {
              const e3 = Math.min(Math.max(t2, this.minZoom), this.maxZoom);
              this._zoom !== e3 && (this._unmodified = false, this._zoom = e3, this.scale = this.zoomScale(e3), this.tileZoom = Math.floor(e3), this.zoomFraction = e3 - this.tileZoom, this._constrain(), this._calcMatrices());
            }
            get center() {
              return this._center;
            }
            set center(t2) {
              t2.lat === this._center.lat && t2.lng === this._center.lng || (this._unmodified = false, this._center = t2, this._constrain(), this._calcMatrices());
            }
            get elevation() {
              return this._elevation;
            }
            set elevation(t2) {
              t2 !== this._elevation && (this._elevation = t2, this._constrain(), this._calcMatrices());
            }
            get padding() {
              return this._edgeInsets.toJSON();
            }
            set padding(t2) {
              this._edgeInsets.equals(t2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t2, 1), this._calcMatrices());
            }
            get centerPoint() {
              return this._edgeInsets.getCenter(this.width, this.height);
            }
            isPaddingEqual(t2) {
              return this._edgeInsets.equals(t2);
            }
            interpolatePadding(t2, e3, i2) {
              this._unmodified = false, this._edgeInsets.interpolate(t2, e3, i2), this._constrain(), this._calcMatrices();
            }
            coveringZoomLevel(t2) {
              const e3 = (t2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t2.tileSize));
              return Math.max(0, e3);
            }
            getVisibleUnwrappedCoordinates(e3) {
              const i2 = [new t.UnwrappedTileID(0, e3)];
              if (this._renderWorldCopies) {
                const o2 = this.pointCoordinate(new t.pointGeometry(0, 0)), a2 = this.pointCoordinate(new t.pointGeometry(this.width, 0)), r2 = this.pointCoordinate(new t.pointGeometry(this.width, this.height)), s2 = this.pointCoordinate(new t.pointGeometry(0, this.height)), n2 = Math.floor(Math.min(o2.x, a2.x, r2.x, s2.x)), l2 = Math.floor(Math.max(o2.x, a2.x, r2.x, s2.x)), c2 = 1;
                for (let o3 = n2 - c2; o3 <= l2 + c2; o3++)
                  0 !== o3 && i2.push(new t.UnwrappedTileID(o3, e3));
              }
              return i2;
            }
            coveringTiles(e3) {
              var i2, o2;
              let a2 = this.coveringZoomLevel(e3);
              const r2 = a2;
              if (void 0 !== e3.minzoom && a2 < e3.minzoom)
                return [];
              void 0 !== e3.maxzoom && a2 > e3.maxzoom && (a2 = e3.maxzoom);
              const s2 = this.pointCoordinate(this.getCameraPoint()), n2 = t.MercatorCoordinate.fromLngLat(this.center), l2 = Math.pow(2, a2), c2 = [l2 * s2.x, l2 * s2.y, 0], h2 = [l2 * n2.x, l2 * n2.y, 0], u2 = Qi.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, a2);
              let d2 = e3.minzoom || 0;
              !e3.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (d2 = a2);
              const m2 = e3.terrain ? 2 / Math.min(this.tileSize, e3.tileSize) * this.tileSize : 3, _2 = (t2) => ({ aabb: new to([t2 * l2, 0, 0], [(t2 + 1) * l2, l2, 0]), zoom: 0, x: 0, y: 0, wrap: t2, fullyVisible: false }), p2 = [], f2 = [], g2 = a2, x3 = e3.reparseOverscaled ? r2 : a2;
              if (this._renderWorldCopies)
                for (let t2 = 1; t2 <= 3; t2++)
                  p2.push(_2(-t2)), p2.push(_2(t2));
              for (p2.push(_2(0)); p2.length > 0; ) {
                const a3 = p2.pop(), r3 = a3.x, s3 = a3.y;
                let n3 = a3.fullyVisible;
                if (!n3) {
                  const t2 = a3.aabb.intersects(u2);
                  if (0 === t2)
                    continue;
                  n3 = 2 === t2;
                }
                const l3 = e3.terrain ? c2 : h2, _3 = a3.aabb.distanceX(l3), v2 = a3.aabb.distanceY(l3), y3 = Math.max(Math.abs(_3), Math.abs(v2)), b2 = m2 + (1 << g2 - a3.zoom) - 2;
                if (a3.zoom === g2 || y3 > b2 && a3.zoom >= d2) {
                  const e4 = g2 - a3.zoom, i3 = c2[0] - 0.5 - (r3 << e4), o3 = c2[1] - 0.5 - (s3 << e4);
                  f2.push({ tileID: new t.OverscaledTileID(a3.zoom === g2 ? x3 : a3.zoom, a3.wrap, a3.zoom, r3, s3), distanceSq: t.sqrLen([h2[0] - 0.5 - r3, h2[1] - 0.5 - s3]), tileDistanceToCamera: Math.sqrt(i3 * i3 + o3 * o3) });
                } else
                  for (let l4 = 0; l4 < 4; l4++) {
                    const c3 = (r3 << 1) + l4 % 2, h3 = (s3 << 1) + (l4 >> 1), u3 = a3.zoom + 1;
                    let d3 = a3.aabb.quadrant(l4);
                    if (e3.terrain) {
                      const r4 = new t.OverscaledTileID(u3, a3.wrap, u3, c3, h3), s4 = e3.terrain.getMinMaxElevation(r4), n4 = null !== (i2 = s4.minElevation) && void 0 !== i2 ? i2 : this.elevation, l5 = null !== (o2 = s4.maxElevation) && void 0 !== o2 ? o2 : this.elevation;
                      d3 = new to([d3.min[0], d3.min[1], n4], [d3.max[0], d3.max[1], l5]);
                    }
                    p2.push({ aabb: d3, zoom: u3, x: c3, y: h3, wrap: a3.wrap, fullyVisible: n3 });
                  }
              }
              return f2.sort((t2, e4) => t2.distanceSq - e4.distanceSq).map((t2) => t2.tileID);
            }
            resize(t2, e3) {
              this.width = t2, this.height = e3, this.pixelsToGLUnits = [2 / t2, -2 / e3], this._constrain(), this._calcMatrices();
            }
            get unmodified() {
              return this._unmodified;
            }
            zoomScale(t2) {
              return Math.pow(2, t2);
            }
            scaleZoom(t2) {
              return Math.log(t2) / Math.LN2;
            }
            project(e3) {
              const i2 = t.clamp(e3.lat, -this.maxValidLatitude, this.maxValidLatitude);
              return new t.pointGeometry(t.mercatorXfromLng(e3.lng) * this.worldSize, t.mercatorYfromLat(i2) * this.worldSize);
            }
            unproject(e3) {
              return new t.MercatorCoordinate(e3.x / this.worldSize, e3.y / this.worldSize).toLngLat();
            }
            get point() {
              return this.project(this.center);
            }
            updateElevation(t2) {
              this.freezeElevation || (this.elevation = t2 ? this.getElevation(this._center, t2) : 0);
            }
            getElevation(e3, i2) {
              const o2 = t.MercatorCoordinate.fromLngLat(e3), a2 = (1 << this.tileZoom) * t.EXTENT, r2 = o2.x * a2, s2 = o2.y * a2, n2 = Math.floor(r2 / t.EXTENT), l2 = Math.floor(s2 / t.EXTENT), c2 = new t.OverscaledTileID(this.tileZoom, 0, this.tileZoom, n2, l2);
              return i2.getElevation(c2, r2 % t.EXTENT, s2 % t.EXTENT, t.EXTENT);
            }
            getCameraPosition() {
              return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
            }
            recalculateZoom(e3) {
              const i2 = this.pointLocation(this.centerPoint, e3), o2 = this.getElevation(i2, e3);
              if (!(this.elevation - o2))
                return;
              const a2 = this.getCameraPosition(), r2 = t.MercatorCoordinate.fromLngLat(a2.lngLat, a2.altitude), s2 = t.MercatorCoordinate.fromLngLat(i2, o2), n2 = r2.x - s2.x, l2 = r2.y - s2.y, c2 = r2.z - s2.z, h2 = Math.sqrt(n2 * n2 + l2 * l2 + c2 * c2), u2 = this.scaleZoom(this.cameraToCenterDistance / h2 / this.tileSize);
              this._elevation = o2, this._center = i2, this.zoom = u2;
            }
            setLocationAtPoint(e3, i2) {
              const o2 = this.pointCoordinate(i2), a2 = this.pointCoordinate(this.centerPoint), r2 = this.locationCoordinate(e3), s2 = new t.MercatorCoordinate(r2.x - (o2.x - a2.x), r2.y - (o2.y - a2.y));
              this.center = this.coordinateLocation(s2), this._renderWorldCopies && (this.center = this.center.wrap());
            }
            locationPoint(t2, e3) {
              return e3 ? this.coordinatePoint(this.locationCoordinate(t2), this.getElevation(t2, e3), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(t2));
            }
            pointLocation(t2, e3) {
              return this.coordinateLocation(this.pointCoordinate(t2, e3));
            }
            locationCoordinate(e3) {
              return t.MercatorCoordinate.fromLngLat(e3);
            }
            coordinateLocation(t2) {
              return t2 && t2.toLngLat();
            }
            pointCoordinate(e3, i2) {
              if (i2) {
                const t2 = i2.pointCoordinate(e3);
                if (null != t2)
                  return t2;
              }
              const o2 = [e3.x, e3.y, 0, 1], a2 = [e3.x, e3.y, 1, 1];
              t.transformMat4(o2, o2, this.pixelMatrixInverse), t.transformMat4(a2, a2, this.pixelMatrixInverse);
              const r2 = o2[3], s2 = a2[3], n2 = o2[1] / r2, l2 = a2[1] / s2, c2 = o2[2] / r2, h2 = a2[2] / s2, u2 = c2 === h2 ? 0 : (0 - c2) / (h2 - c2);
              return new t.MercatorCoordinate(t.number(o2[0] / r2, a2[0] / s2, u2) / this.worldSize, t.number(n2, l2, u2) / this.worldSize);
            }
            coordinatePoint(e3, i2 = 0, o2 = this.pixelMatrix) {
              const a2 = [e3.x * this.worldSize, e3.y * this.worldSize, i2, 1];
              return t.transformMat4(a2, a2, o2), new t.pointGeometry(a2[0] / a2[3], a2[1] / a2[3]);
            }
            getBounds() {
              const e3 = Math.max(0, this.height / 2 - this.getHorizon());
              return new t.LngLatBounds().extend(this.pointLocation(new t.pointGeometry(0, e3))).extend(this.pointLocation(new t.pointGeometry(this.width, e3))).extend(this.pointLocation(new t.pointGeometry(this.width, this.height))).extend(this.pointLocation(new t.pointGeometry(0, this.height)));
            }
            getMaxBounds() {
              return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new t.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
            }
            getHorizon() {
              return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
            }
            setMaxBounds(t2) {
              t2 ? (this.lngRange = [t2.getWest(), t2.getEast()], this.latRange = [t2.getSouth(), t2.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
            }
            calculatePosMatrix(e3, i2 = false) {
              const o2 = e3.key, a2 = i2 ? this._alignedPosMatrixCache : this._posMatrixCache;
              if (a2[o2])
                return a2[o2];
              const r2 = e3.canonical, s2 = this.worldSize / this.zoomScale(r2.z), n2 = r2.x + Math.pow(2, r2.z) * e3.wrap, l2 = t.identity(new Float64Array(16));
              return t.translate(l2, l2, [n2 * s2, r2.y * s2, 0]), t.scale(l2, l2, [s2 / t.EXTENT, s2 / t.EXTENT, 1]), t.multiply(l2, i2 ? this.alignedProjMatrix : this.projMatrix, l2), a2[o2] = new Float32Array(l2), a2[o2];
            }
            customLayerMatrix() {
              return this.mercatorMatrix.slice();
            }
            _constrain() {
              if (!this.center || !this.width || !this.height || this._constraining)
                return;
              this._constraining = true;
              let e3, i2, o2, a2, r2 = -90, s2 = 90, n2 = -180, l2 = 180;
              const c2 = this.size, h2 = this._unmodified;
              if (this.latRange) {
                const i3 = this.latRange;
                r2 = t.mercatorYfromLat(i3[1]) * this.worldSize, s2 = t.mercatorYfromLat(i3[0]) * this.worldSize, e3 = s2 - r2 < c2.y ? c2.y / (s2 - r2) : 0;
              }
              if (this.lngRange) {
                const e4 = this.lngRange;
                n2 = t.wrap(t.mercatorXfromLng(e4[0]) * this.worldSize, 0, this.worldSize), l2 = t.wrap(t.mercatorXfromLng(e4[1]) * this.worldSize, 0, this.worldSize), l2 < n2 && (l2 += this.worldSize), i2 = l2 - n2 < c2.x ? c2.x / (l2 - n2) : 0;
              }
              const u2 = this.point, d2 = Math.max(i2 || 0, e3 || 0);
              if (d2)
                return this.center = this.unproject(new t.pointGeometry(i2 ? (l2 + n2) / 2 : u2.x, e3 ? (s2 + r2) / 2 : u2.y)), this.zoom += this.scaleZoom(d2), this._unmodified = h2, void (this._constraining = false);
              if (this.latRange) {
                const t2 = u2.y, e4 = c2.y / 2;
                t2 - e4 < r2 && (a2 = r2 + e4), t2 + e4 > s2 && (a2 = s2 - e4);
              }
              if (this.lngRange) {
                const e4 = (n2 + l2) / 2, i3 = t.wrap(u2.x, e4 - this.worldSize / 2, e4 + this.worldSize / 2), a3 = c2.x / 2;
                i3 - a3 < n2 && (o2 = n2 + a3), i3 + a3 > l2 && (o2 = l2 - a3);
              }
              void 0 === o2 && void 0 === a2 || (this.center = this.unproject(new t.pointGeometry(void 0 !== o2 ? o2 : u2.x, void 0 !== a2 ? a2 : u2.y)).wrap()), this._unmodified = h2, this._constraining = false;
            }
            _calcMatrices() {
              if (!this.height)
                return;
              const e3 = this.centerOffset, i2 = this.point.x, o2 = this.point.y;
              this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = t.mercatorZfromAltitude(1, this.center.lat) * this.worldSize;
              let a2 = t.identity(new Float64Array(16));
              t.scale(a2, a2, [this.width / 2, -this.height / 2, 1]), t.translate(a2, a2, [1, -1, 0]), this.labelPlaneMatrix = a2, a2 = t.identity(new Float64Array(16)), t.scale(a2, a2, [1, -1, 1]), t.translate(a2, a2, [-1, -1, 0]), t.scale(a2, a2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a2, this.cameraToSeaLevelDistance = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch);
              const r2 = Math.PI / 2 + this._pitch, s2 = this._fov * (0.5 + e3.y / this.height), n2 = Math.sin(s2) * this.cameraToSeaLevelDistance / Math.sin(t.clamp(Math.PI - r2 - s2, 0.01, Math.PI - 0.01)), l2 = this.getHorizon(), c2 = 2 * Math.atan(l2 / this.cameraToCenterDistance) * (0.5 + e3.y / (2 * l2)), h2 = Math.sin(c2) * this.cameraToSeaLevelDistance / Math.sin(t.clamp(Math.PI - r2 - c2, 0.01, Math.PI - 0.01)), u2 = Math.cos(Math.PI / 2 - this._pitch) * n2 + this.cameraToSeaLevelDistance, d2 = Math.cos(Math.PI / 2 - this._pitch) * h2 + this.cameraToSeaLevelDistance, m2 = 1.01 * Math.min(u2, d2), _2 = this.height / 50;
              a2 = new Float64Array(16), t.perspective(a2, this._fov, this.width / this.height, _2, m2), a2[8] = 2 * -e3.x / this.width, a2[9] = 2 * e3.y / this.height, t.scale(a2, a2, [1, -1, 1]), t.translate(a2, a2, [0, 0, -this.cameraToCenterDistance]), t.rotateX(a2, a2, this._pitch), t.rotateZ(a2, a2, this.angle), t.translate(a2, a2, [-i2, -o2, 0]), this.mercatorMatrix = t.scale([], a2, [this.worldSize, this.worldSize, this.worldSize]), t.scale(a2, a2, [1, 1, this._pixelPerMeter]), this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, a2), t.translate(a2, a2, [0, 0, -this.elevation]), this.projMatrix = a2, this.invProjMatrix = t.invert([], a2), this.pixelMatrix3D = t.multiply(new Float64Array(16), this.labelPlaneMatrix, a2);
              const p2 = this.width % 2 / 2, f2 = this.height % 2 / 2, g2 = Math.cos(this.angle), x3 = Math.sin(this.angle), v2 = i2 - Math.round(i2) + g2 * p2 + x3 * f2, y3 = o2 - Math.round(o2) + g2 * f2 + x3 * p2, b2 = new Float64Array(a2);
              if (t.translate(b2, b2, [v2 > 0.5 ? v2 - 1 : v2, y3 > 0.5 ? y3 - 1 : y3, 0]), this.alignedProjMatrix = b2, a2 = t.invert(new Float64Array(16), this.pixelMatrix), !a2)
                throw new Error("failed to invert matrix");
              this.pixelMatrixInverse = a2, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
            }
            maxPitchScaleFactor() {
              if (!this.pixelMatrixInverse)
                return 1;
              const e3 = this.pointCoordinate(new t.pointGeometry(0, 0)), i2 = [e3.x * this.worldSize, e3.y * this.worldSize, 0, 1];
              return t.transformMat4(i2, i2, this.pixelMatrix)[3] / this.cameraToCenterDistance;
            }
            getCameraPoint() {
              const e3 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
              return this.centerPoint.add(new t.pointGeometry(0, e3));
            }
            getCameraQueryGeometry(e3) {
              const i2 = this.getCameraPoint();
              if (1 === e3.length)
                return [e3[0], i2];
              {
                let o2 = i2.x, a2 = i2.y, r2 = i2.x, s2 = i2.y;
                for (const t2 of e3)
                  o2 = Math.min(o2, t2.x), a2 = Math.min(a2, t2.y), r2 = Math.max(r2, t2.x), s2 = Math.max(s2, t2.y);
                return [new t.pointGeometry(o2, a2), new t.pointGeometry(r2, a2), new t.pointGeometry(r2, s2), new t.pointGeometry(o2, s2), new t.pointGeometry(o2, a2)];
              }
            }
          }
          class oo {
            constructor(e3) {
              this._hashName = e3 && encodeURIComponent(e3), t.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = function(t2, e4) {
                let i2 = false, o2 = null;
                const a2 = () => {
                  o2 = null, i2 && (t2(), o2 = setTimeout(a2, 300), i2 = false);
                };
                return () => (i2 = true, o2 || a2(), o2);
              }(this._updateHashUnthrottled.bind(this));
            }
            addTo(t2) {
              return this._map = t2, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
            }
            remove() {
              return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
            }
            getHashString(t2) {
              const e3 = this._map.getCenter(), i2 = Math.round(100 * this._map.getZoom()) / 100, o2 = Math.ceil((i2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a2 = Math.pow(10, o2), r2 = Math.round(e3.lng * a2) / a2, s2 = Math.round(e3.lat * a2) / a2, n2 = this._map.getBearing(), l2 = this._map.getPitch();
              let c2 = "";
              if (c2 += t2 ? `/${r2}/${s2}/${i2}` : `${i2}/${s2}/${r2}`, (n2 || l2) && (c2 += "/" + Math.round(10 * n2) / 10), l2 && (c2 += `/${Math.round(l2)}`), this._hashName) {
                const t3 = this._hashName;
                let e4 = false;
                const i3 = window.location.hash.slice(1).split("&").map((i4) => {
                  const o3 = i4.split("=")[0];
                  return o3 === t3 ? (e4 = true, `${o3}=${c2}`) : i4;
                }).filter((t4) => t4);
                return e4 || i3.push(`${t3}=${c2}`), `#${i3.join("&")}`;
              }
              return `#${c2}`;
            }
            _getCurrentHash() {
              const t2 = window.location.hash.replace("#", "");
              if (this._hashName) {
                let e3;
                return t2.split("&").map((t3) => t3.split("=")).forEach((t3) => {
                  t3[0] === this._hashName && (e3 = t3);
                }), (e3 && e3[1] || "").split("/");
              }
              return t2.split("/");
            }
            _onHashChange() {
              const t2 = this._getCurrentHash();
              if (t2.length >= 3 && !t2.some((t3) => isNaN(t3))) {
                const e3 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t2[3] || 0) : this._map.getBearing();
                return this._map.jumpTo({ center: [+t2[2], +t2[1]], zoom: +t2[0], bearing: e3, pitch: +(t2[4] || 0) }), true;
              }
              return false;
            }
            _updateHashUnthrottled() {
              const t2 = window.location.href.replace(/(#.+)?$/, this.getHashString());
              try {
                window.history.replaceState(window.history.state, null, t2);
              } catch (t3) {
              }
            }
          }
          const ao = { linearity: 0.3, easing: t.bezier(0, 0, 0.3, 1) }, ro = t.extend({ deceleration: 2500, maxSpeed: 1400 }, ao), so = t.extend({ deceleration: 20, maxSpeed: 1400 }, ao), no = t.extend({ deceleration: 1e3, maxSpeed: 360 }, ao), lo = t.extend({ deceleration: 1e3, maxSpeed: 90 }, ao);
          class co {
            constructor(t2) {
              this._map = t2, this.clear();
            }
            clear() {
              this._inertiaBuffer = [];
            }
            record(e3) {
              this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: t.exported.now(), settings: e3 });
            }
            _drainInertiaBuffer() {
              const e3 = this._inertiaBuffer, i2 = t.exported.now();
              for (; e3.length > 0 && i2 - e3[0].time > 160; )
                e3.shift();
            }
            _onMoveEnd(e3) {
              if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
                return;
              const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new t.pointGeometry(0, 0), pinchAround: void 0, around: void 0 };
              for (const { settings: t2 } of this._inertiaBuffer)
                i2.zoom += t2.zoomDelta || 0, i2.bearing += t2.bearingDelta || 0, i2.pitch += t2.pitchDelta || 0, t2.panDelta && i2.pan._add(t2.panDelta), t2.around && (i2.around = t2.around), t2.pinchAround && (i2.pinchAround = t2.pinchAround);
              const o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, a2 = {};
              if (i2.pan.mag()) {
                const r2 = uo(i2.pan.mag(), o2, t.extend({}, ro, e3 || {}));
                a2.offset = i2.pan.mult(r2.amount / i2.pan.mag()), a2.center = this._map.transform.center, ho(a2, r2);
              }
              if (i2.zoom) {
                const t2 = uo(i2.zoom, o2, so);
                a2.zoom = this._map.transform.zoom + t2.amount, ho(a2, t2);
              }
              if (i2.bearing) {
                const e4 = uo(i2.bearing, o2, no);
                a2.bearing = this._map.transform.bearing + t.clamp(e4.amount, -179, 179), ho(a2, e4);
              }
              if (i2.pitch) {
                const t2 = uo(i2.pitch, o2, lo);
                a2.pitch = this._map.transform.pitch + t2.amount, ho(a2, t2);
              }
              if (a2.zoom || a2.bearing) {
                const t2 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
                a2.around = t2 ? this._map.unproject(t2) : this._map.getCenter();
              }
              return this.clear(), t.extend(a2, { noMoveStart: true });
            }
          }
          function ho(t2, e3) {
            (!t2.duration || t2.duration < e3.duration) && (t2.duration = e3.duration, t2.easing = e3.easing);
          }
          function uo(e3, i2, o2) {
            const { maxSpeed: a2, linearity: r2, deceleration: s2 } = o2, n2 = t.clamp(e3 * r2 / (i2 / 1e3), -a2, a2), l2 = Math.abs(n2) / (s2 * r2);
            return { easing: o2.easing, duration: 1e3 * l2, amount: n2 * (l2 / 2) };
          }
          class mo extends t.Event {
            constructor(e3, i2, o2, a2 = {}) {
              const s2 = r.mousePos(i2.getCanvasContainer(), o2), n2 = i2.unproject(s2);
              super(e3, t.extend({ point: s2, lngLat: n2, originalEvent: o2 }, a2)), this._defaultPrevented = false, this.target = i2;
            }
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
          }
          class _o extends t.Event {
            constructor(e3, i2, o2) {
              const a2 = "touchend" === e3 ? o2.changedTouches : o2.touches, s2 = r.touchPos(i2.getCanvasContainer(), a2), n2 = s2.map((t2) => i2.unproject(t2)), l2 = s2.reduce((t2, e4, i3, o3) => t2.add(e4.div(o3.length)), new t.pointGeometry(0, 0));
              super(e3, { points: s2, point: l2, lngLats: n2, lngLat: i2.unproject(l2), originalEvent: o2 }), this._defaultPrevented = false;
            }
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
          }
          class po extends t.Event {
            constructor(t2, e3, i2) {
              super(t2, { originalEvent: i2 }), this._defaultPrevented = false;
            }
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
          }
          class fo {
            constructor(t2, e3) {
              this._map = t2, this._clickTolerance = e3.clickTolerance;
            }
            reset() {
              delete this._mousedownPos;
            }
            wheel(t2) {
              return this._firePreventable(new po(t2.type, this._map, t2));
            }
            mousedown(t2, e3) {
              return this._mousedownPos = e3, this._firePreventable(new mo(t2.type, this._map, t2));
            }
            mouseup(t2) {
              this._map.fire(new mo(t2.type, this._map, t2));
            }
            click(t2, e3) {
              this._mousedownPos && this._mousedownPos.dist(e3) >= this._clickTolerance || this._map.fire(new mo(t2.type, this._map, t2));
            }
            dblclick(t2) {
              return this._firePreventable(new mo(t2.type, this._map, t2));
            }
            mouseover(t2) {
              this._map.fire(new mo(t2.type, this._map, t2));
            }
            mouseout(t2) {
              this._map.fire(new mo(t2.type, this._map, t2));
            }
            touchstart(t2) {
              return this._firePreventable(new _o(t2.type, this._map, t2));
            }
            touchmove(t2) {
              this._map.fire(new _o(t2.type, this._map, t2));
            }
            touchend(t2) {
              this._map.fire(new _o(t2.type, this._map, t2));
            }
            touchcancel(t2) {
              this._map.fire(new _o(t2.type, this._map, t2));
            }
            _firePreventable(t2) {
              if (this._map.fire(t2), t2.defaultPrevented)
                return {};
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class go {
            constructor(t2) {
              this._map = t2;
            }
            reset() {
              this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
            }
            mousemove(t2) {
              this._map.fire(new mo(t2.type, this._map, t2));
            }
            mousedown() {
              this._delayContextMenu = true, this._ignoreContextMenu = false;
            }
            mouseup() {
              this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new mo("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(t2) {
              this._delayContextMenu ? this._contextMenuEvent = t2 : this._ignoreContextMenu || this._map.fire(new mo(t2.type, this._map, t2)), this._map.listens("contextmenu") && t2.preventDefault();
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class xo {
            constructor(t2, e3) {
              this._map = t2, this._el = t2.getCanvasContainer(), this._container = t2.getContainer(), this._clickTolerance = e3.clickTolerance || 1;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active;
            }
            enable() {
              this.isEnabled() || (this._enabled = true);
            }
            disable() {
              this.isEnabled() && (this._enabled = false);
            }
            mousedown(t2, e3) {
              this.isEnabled() && t2.shiftKey && 0 === t2.button && (r.disableDrag(), this._startPos = this._lastPos = e3, this._active = true);
            }
            mousemoveWindow(t2, e3) {
              if (!this._active)
                return;
              const i2 = e3;
              if (this._lastPos.equals(i2) || !this._box && i2.dist(this._startPos) < this._clickTolerance)
                return;
              const o2 = this._startPos;
              this._lastPos = i2, this._box || (this._box = r.create("div", "maplibregl-boxzoom mapboxgl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair", "mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t2));
              const a2 = Math.min(o2.x, i2.x), s2 = Math.max(o2.x, i2.x), n2 = Math.min(o2.y, i2.y), l2 = Math.max(o2.y, i2.y);
              r.setTransform(this._box, `translate(${a2}px,${n2}px)`), this._box.style.width = s2 - a2 + "px", this._box.style.height = l2 - n2 + "px";
            }
            mouseupWindow(e3, i2) {
              if (!this._active)
                return;
              if (0 !== e3.button)
                return;
              const o2 = this._startPos, a2 = i2;
              if (this.reset(), r.suppressClick(), o2.x !== a2.x || o2.y !== a2.y)
                return this._map.fire(new t.Event("boxzoomend", { originalEvent: e3 })), { cameraAnimation: (t2) => t2.fitScreenCoordinates(o2, a2, this._map.getBearing(), { linear: true }) };
              this._fireEvent("boxzoomcancel", e3);
            }
            keydown(t2) {
              this._active && 27 === t2.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t2));
            }
            reset() {
              this._active = false, this._container.classList.remove("maplibregl-crosshair", "mapboxgl-crosshair"), this._box && (r.remove(this._box), this._box = null), r.enableDrag(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(e3, i2) {
              return this._map.fire(new t.Event(e3, { originalEvent: i2 }));
            }
          }
          function vo(t2, e3) {
            if (t2.length !== e3.length)
              throw new Error(`The number of touches and points are not equal - touches ${t2.length}, points ${e3.length}`);
            const i2 = {};
            for (let o2 = 0; o2 < t2.length; o2++)
              i2[t2[o2].identifier] = e3[o2];
            return i2;
          }
          class yo {
            constructor(t2) {
              this.reset(), this.numTouches = t2.numTouches;
            }
            reset() {
              delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
            }
            touchstart(e3, i2, o2) {
              (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = e3.timeStamp), o2.length === this.numTouches && (this.centroid = function(e4) {
                const i3 = new t.pointGeometry(0, 0);
                for (const t2 of e4)
                  i3._add(t2);
                return i3.div(e4.length);
              }(i2), this.touches = vo(o2, i2)));
            }
            touchmove(t2, e3, i2) {
              if (this.aborted || !this.centroid)
                return;
              const o2 = vo(i2, e3);
              for (const t3 in this.touches) {
                const e4 = this.touches[t3], i3 = o2[t3];
                (!i3 || i3.dist(e4) > 30) && (this.aborted = true);
              }
            }
            touchend(t2, e3, i2) {
              if ((!this.centroid || t2.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
                const t3 = !this.aborted && this.centroid;
                if (this.reset(), t3)
                  return t3;
              }
            }
          }
          class bo {
            constructor(t2) {
              this.singleTap = new yo(t2), this.numTaps = t2.numTaps, this.reset();
            }
            reset() {
              this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
            }
            touchstart(t2, e3, i2) {
              this.singleTap.touchstart(t2, e3, i2);
            }
            touchmove(t2, e3, i2) {
              this.singleTap.touchmove(t2, e3, i2);
            }
            touchend(t2, e3, i2) {
              const o2 = this.singleTap.touchend(t2, e3, i2);
              if (o2) {
                const e4 = t2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(o2) < 30;
                if (e4 && i3 || this.reset(), this.count++, this.lastTime = t2.timeStamp, this.lastTap = o2, this.count === this.numTaps)
                  return this.reset(), o2;
              }
            }
          }
          class wo {
            constructor() {
              this._zoomIn = new bo({ numTouches: 1, numTaps: 2 }), this._zoomOut = new bo({ numTouches: 2, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(t2, e3, i2) {
              this._zoomIn.touchstart(t2, e3, i2), this._zoomOut.touchstart(t2, e3, i2);
            }
            touchmove(t2, e3, i2) {
              this._zoomIn.touchmove(t2, e3, i2), this._zoomOut.touchmove(t2, e3, i2);
            }
            touchend(t2, e3, i2) {
              const o2 = this._zoomIn.touchend(t2, e3, i2), a2 = this._zoomOut.touchend(t2, e3, i2);
              return o2 ? (this._active = true, t2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e4) => e4.easeTo({ duration: 300, zoom: e4.getZoom() + 1, around: e4.unproject(o2) }, { originalEvent: t2 }) }) : a2 ? (this._active = true, t2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e4) => e4.easeTo({ duration: 300, zoom: e4.getZoom() - 1, around: e4.unproject(a2) }, { originalEvent: t2 }) }) : void 0;
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          const To = { 0: 1, 2: 2 };
          class Eo {
            constructor(t2) {
              this.reset(), this._clickTolerance = t2.clickTolerance || 1;
            }
            reset() {
              this._active = false, this._moved = false, delete this._lastPoint, delete this._eventButton;
            }
            _correctButton(t2, e3) {
              return false;
            }
            _move(t2, e3) {
              return {};
            }
            mousedown(t2, e3) {
              if (this._lastPoint)
                return;
              const i2 = r.mouseButton(t2);
              this._correctButton(t2, i2) && (this._lastPoint = e3, this._eventButton = i2);
            }
            mousemoveWindow(t2, e3) {
              const i2 = this._lastPoint;
              if (i2) {
                if (t2.preventDefault(), function(t3, e4) {
                  const i3 = To[e4];
                  return void 0 === t3.buttons || (t3.buttons & i3) !== i3;
                }(t2, this._eventButton))
                  this.reset();
                else if (this._moved || !(e3.dist(i2) < this._clickTolerance))
                  return this._moved = true, this._lastPoint = e3, this._move(i2, e3);
              }
            }
            mouseupWindow(t2) {
              this._lastPoint && r.mouseButton(t2) === this._eventButton && (this._moved && r.suppressClick(), this.reset());
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Io extends Eo {
            mousedown(t2, e3) {
              super.mousedown(t2, e3), this._lastPoint && (this._active = true);
            }
            _correctButton(t2, e3) {
              return 0 === e3 && !t2.ctrlKey;
            }
            _move(t2, e3) {
              return { around: e3, panDelta: e3.sub(t2) };
            }
          }
          class Co extends Eo {
            _correctButton(t2, e3) {
              return 0 === e3 && t2.ctrlKey || 2 === e3;
            }
            _move(t2, e3) {
              const i2 = 0.8 * (e3.x - t2.x);
              if (i2)
                return this._active = true, { bearingDelta: i2 };
            }
            contextmenu(t2) {
              t2.preventDefault();
            }
          }
          class So extends Eo {
            _correctButton(t2, e3) {
              return 0 === e3 && t2.ctrlKey || 2 === e3;
            }
            _move(t2, e3) {
              const i2 = -0.5 * (e3.y - t2.y);
              if (i2)
                return this._active = true, { pitchDelta: i2 };
            }
            contextmenu(t2) {
              t2.preventDefault();
            }
          }
          class Do {
            constructor(t2, e3) {
              this._minTouches = t2.cooperativeGestures ? 2 : 1, this._clickTolerance = t2.clickTolerance || 1, this._map = e3, this.reset();
            }
            reset() {
              this._active = false, this._touches = {}, this._sum = new t.pointGeometry(0, 0), setTimeout(() => {
                this._cancelCooperativeMessage = false;
              }, 200);
            }
            touchstart(t2, e3, i2) {
              return this._calculateTransform(t2, e3, i2);
            }
            touchmove(t2, e3, i2) {
              if (this._map._cooperativeGestures && (2 === this._minTouches && i2.length < 2 && !this._cancelCooperativeMessage ? this._map._onCooperativeGesture(t2, false, i2.length) : this._cancelCooperativeMessage || (this._cancelCooperativeMessage = true)), this._active && !(i2.length < this._minTouches))
                return t2.preventDefault(), this._calculateTransform(t2, e3, i2);
            }
            touchend(t2, e3, i2) {
              this._calculateTransform(t2, e3, i2), this._active && i2.length < this._minTouches && this.reset();
            }
            touchcancel() {
              this.reset();
            }
            _calculateTransform(e3, i2, o2) {
              o2.length > 0 && (this._active = true);
              const a2 = vo(o2, i2), r2 = new t.pointGeometry(0, 0), s2 = new t.pointGeometry(0, 0);
              let n2 = 0;
              for (const t2 in a2) {
                const e4 = a2[t2], i3 = this._touches[t2];
                i3 && (r2._add(e4), s2._add(e4.sub(i3)), n2++, a2[t2] = e4);
              }
              if (this._touches = a2, n2 < this._minTouches || !s2.mag())
                return;
              const l2 = s2.div(n2);
              return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: r2.div(n2), panDelta: l2 };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class zo {
            constructor() {
              this.reset();
            }
            reset() {
              this._active = false, delete this._firstTwoTouches;
            }
            _start(t2) {
            }
            _move(t2, e3, i2) {
              return {};
            }
            touchstart(t2, e3, i2) {
              this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([e3[0], e3[1]]));
            }
            touchmove(t2, e3, i2) {
              if (!this._firstTwoTouches)
                return;
              t2.preventDefault();
              const [o2, a2] = this._firstTwoTouches, r2 = Po(i2, e3, o2), s2 = Po(i2, e3, a2);
              if (!r2 || !s2)
                return;
              const n2 = this._aroundCenter ? null : r2.add(s2).div(2);
              return this._move([r2, s2], n2, t2);
            }
            touchend(t2, e3, i2) {
              if (!this._firstTwoTouches)
                return;
              const [o2, a2] = this._firstTwoTouches, s2 = Po(i2, e3, o2), n2 = Po(i2, e3, a2);
              s2 && n2 || (this._active && r.suppressClick(), this.reset());
            }
            touchcancel() {
              this.reset();
            }
            enable(t2) {
              this._enabled = true, this._aroundCenter = !!t2 && "center" === t2.around;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          function Po(t2, e3, i2) {
            for (let o2 = 0; o2 < t2.length; o2++)
              if (t2[o2].identifier === i2)
                return e3[o2];
          }
          function Mo(t2, e3) {
            return Math.log(t2 / e3) / Math.LN2;
          }
          class Ao extends zo {
            reset() {
              super.reset(), delete this._distance, delete this._startDistance;
            }
            _start(t2) {
              this._startDistance = this._distance = t2[0].dist(t2[1]);
            }
            _move(t2, e3) {
              const i2 = this._distance;
              if (this._distance = t2[0].dist(t2[1]), this._active || !(Math.abs(Mo(this._distance, this._startDistance)) < 0.1))
                return this._active = true, { zoomDelta: Mo(this._distance, i2), pinchAround: e3 };
            }
          }
          function Lo(t2, e3) {
            return 180 * t2.angleWith(e3) / Math.PI;
          }
          class Ro extends zo {
            reset() {
              super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
            }
            _start(t2) {
              this._startVector = this._vector = t2[0].sub(t2[1]), this._minDiameter = t2[0].dist(t2[1]);
            }
            _move(t2, e3) {
              const i2 = this._vector;
              if (this._vector = t2[0].sub(t2[1]), this._active || !this._isBelowThreshold(this._vector))
                return this._active = true, { bearingDelta: Lo(this._vector, i2), pinchAround: e3 };
            }
            _isBelowThreshold(t2) {
              this._minDiameter = Math.min(this._minDiameter, t2.mag());
              const e3 = 25 / (Math.PI * this._minDiameter) * 360, i2 = Lo(t2, this._startVector);
              return Math.abs(i2) < e3;
            }
          }
          function ko(t2) {
            return Math.abs(t2.y) > Math.abs(t2.x);
          }
          class Bo extends zo {
            constructor(t2) {
              super(), this._map = t2;
            }
            reset() {
              super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
            }
            touchstart(t2, e3, i2) {
              super.touchstart(t2, e3, i2), this._currentTouchCount = i2.length;
            }
            _start(t2) {
              this._lastPoints = t2, ko(t2[0].sub(t2[1])) && (this._valid = false);
            }
            _move(t2, e3, i2) {
              if (this._map._cooperativeGestures && this._currentTouchCount < 3)
                return;
              const o2 = t2[0].sub(this._lastPoints[0]), a2 = t2[1].sub(this._lastPoints[1]);
              return this._valid = this.gestureBeginsVertically(o2, a2, i2.timeStamp), this._valid ? (this._lastPoints = t2, this._active = true, { pitchDelta: (o2.y + a2.y) / 2 * -0.5 }) : void 0;
            }
            gestureBeginsVertically(t2, e3, i2) {
              if (void 0 !== this._valid)
                return this._valid;
              const o2 = t2.mag() >= 2, a2 = e3.mag() >= 2;
              if (!o2 && !a2)
                return;
              if (!o2 || !a2)
                return void 0 === this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
              const r2 = t2.y > 0 == e3.y > 0;
              return ko(t2) && ko(e3) && r2;
            }
          }
          const Fo = { panStep: 100, bearingStep: 15, pitchStep: 10 };
          class Oo {
            constructor() {
              const t2 = Fo;
              this._panStep = t2.panStep, this._bearingStep = t2.bearingStep, this._pitchStep = t2.pitchStep, this._rotationDisabled = false;
            }
            reset() {
              this._active = false;
            }
            keydown(t2) {
              if (t2.altKey || t2.ctrlKey || t2.metaKey)
                return;
              let e3 = 0, i2 = 0, o2 = 0, a2 = 0, r2 = 0;
              switch (t2.keyCode) {
                case 61:
                case 107:
                case 171:
                case 187:
                  e3 = 1;
                  break;
                case 189:
                case 109:
                case 173:
                  e3 = -1;
                  break;
                case 37:
                  t2.shiftKey ? i2 = -1 : (t2.preventDefault(), a2 = -1);
                  break;
                case 39:
                  t2.shiftKey ? i2 = 1 : (t2.preventDefault(), a2 = 1);
                  break;
                case 38:
                  t2.shiftKey ? o2 = 1 : (t2.preventDefault(), r2 = -1);
                  break;
                case 40:
                  t2.shiftKey ? o2 = -1 : (t2.preventDefault(), r2 = 1);
                  break;
                default:
                  return;
              }
              return this._rotationDisabled && (i2 = 0, o2 = 0), { cameraAnimation: (s2) => {
                const n2 = s2.getZoom();
                s2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: Uo, zoom: e3 ? Math.round(n2) + e3 * (t2.shiftKey ? 2 : 1) : n2, bearing: s2.getBearing() + i2 * this._bearingStep, pitch: s2.getPitch() + o2 * this._pitchStep, offset: [-a2 * this._panStep, -r2 * this._panStep], center: s2.getCenter() }, { originalEvent: t2 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
            disableRotation() {
              this._rotationDisabled = true;
            }
            enableRotation() {
              this._rotationDisabled = false;
            }
          }
          function Uo(t2) {
            return t2 * (2 - t2);
          }
          const No = 4.000244140625;
          class Go {
            constructor(e3, i2) {
              this._map = e3, this._el = e3.getCanvasContainer(), this._handler = i2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222, t.bindAll(["_onTimeout"], this);
            }
            setZoomRate(t2) {
              this._defaultZoomRate = t2;
            }
            setWheelZoomRate(t2) {
              this._wheelZoomRate = t2;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active || void 0 !== this._finishTimeout;
            }
            isZooming() {
              return !!this._zooming;
            }
            enable(t2) {
              this.isEnabled() || (this._enabled = true, this._aroundCenter = t2 && "center" === t2.around);
            }
            disable() {
              this.isEnabled() && (this._enabled = false);
            }
            wheel(e3) {
              if (!this.isEnabled())
                return;
              if (this._map._cooperativeGestures) {
                if (!this._map._metaPress)
                  return;
                e3.preventDefault();
              }
              let i2 = e3.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e3.deltaY : e3.deltaY;
              const o2 = t.exported.now(), a2 = o2 - (this._lastWheelEventTime || 0);
              this._lastWheelEventTime = o2, 0 !== i2 && i2 % No == 0 ? this._type = "wheel" : 0 !== i2 && Math.abs(i2) < 4 ? this._type = "trackpad" : a2 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = setTimeout(this._onTimeout, 40, e3)) : this._type || (this._type = Math.abs(a2 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), e3.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = e3, this._delta -= i2, this._active || this._start(e3)), e3.preventDefault();
            }
            _onTimeout(t2) {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t2);
            }
            _start(e3) {
              if (!this._delta)
                return;
              this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
              const i2 = r.mousePos(this._el, e3);
              this._around = t.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(i2)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
            }
            renderFrame() {
              if (!this._frameId)
                return;
              if (this._frameId = null, !this.isActive())
                return;
              const e3 = this._map.transform;
              if (0 !== this._delta) {
                const t2 = "wheel" === this._type && Math.abs(this._delta) > No ? this._wheelZoomRate : this._defaultZoomRate;
                let i3 = 2 / (1 + Math.exp(-Math.abs(this._delta * t2)));
                this._delta < 0 && 0 !== i3 && (i3 = 1 / i3);
                const o3 = "number" == typeof this._targetZoom ? e3.zoomScale(this._targetZoom) : e3.scale;
                this._targetZoom = Math.min(e3.maxZoom, Math.max(e3.minZoom, e3.scaleZoom(o3 * i3))), "wheel" === this._type && (this._startZoom = e3.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
              }
              const i2 = "number" == typeof this._targetZoom ? this._targetZoom : e3.zoom, o2 = this._startZoom, a2 = this._easing;
              let r2, s2 = false;
              if ("wheel" === this._type && o2 && a2) {
                const e4 = Math.min((t.exported.now() - this._lastWheelEventTime) / 200, 1), n2 = a2(e4);
                r2 = t.number(o2, i2, n2), e4 < 1 ? this._frameId || (this._frameId = true) : s2 = true;
              } else
                r2 = i2, s2 = true;
              return this._active = true, s2 && (this._active = false, this._finishTimeout = setTimeout(() => {
                this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
              }, 200)), { noInertia: true, needsRenderFrame: !s2, zoomDelta: r2 - e3.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
            }
            _smoothOutEasing(e3) {
              let i2 = t.ease;
              if (this._prevEase) {
                const e4 = this._prevEase, o2 = (t.exported.now() - e4.start) / e4.duration, a2 = e4.easing(o2 + 0.01) - e4.easing(o2), r2 = 0.27 / Math.sqrt(a2 * a2 + 1e-4) * 0.01, s2 = Math.sqrt(0.0729 - r2 * r2);
                i2 = t.bezier(r2, s2, 0.25, 1);
              }
              return this._prevEase = { start: t.exported.now(), duration: e3, easing: i2 }, i2;
            }
            reset() {
              this._active = false;
            }
          }
          class Zo {
            constructor(t2, e3) {
              this._clickZoom = t2, this._tapZoom = e3;
            }
            enable() {
              this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
              this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
              return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
              return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
          }
          class Vo {
            constructor() {
              this.reset();
            }
            reset() {
              this._active = false;
            }
            dblclick(t2, e3) {
              return t2.preventDefault(), { cameraAnimation: (i2) => {
                i2.easeTo({ duration: 300, zoom: i2.getZoom() + (t2.shiftKey ? -1 : 1), around: i2.unproject(e3) }, { originalEvent: t2 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class qo {
            constructor() {
              this._tap = new bo({ numTouches: 1, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();
            }
            touchstart(t2, e3, i2) {
              this._swipePoint || (this._tapTime && t2.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = e3[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(t2, e3, i2));
            }
            touchmove(t2, e3, i2) {
              if (this._tapTime) {
                if (this._swipePoint) {
                  if (i2[0].identifier !== this._swipeTouch)
                    return;
                  const o2 = e3[0], a2 = o2.y - this._swipePoint.y;
                  return this._swipePoint = o2, t2.preventDefault(), this._active = true, { zoomDelta: a2 / 128 };
                }
              } else
                this._tap.touchmove(t2, e3, i2);
            }
            touchend(t2, e3, i2) {
              this._tapTime ? this._swipePoint && 0 === i2.length && this.reset() : this._tap.touchend(t2, e3, i2) && (this._tapTime = t2.timeStamp);
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class jo {
            constructor(t2, e3, i2) {
              this._el = t2, this._mousePan = e3, this._touchPan = i2;
            }
            enable(t2) {
              this._inertiaOptions = t2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan", "mapboxgl-touch-drag-pan");
            }
            disable() {
              this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan", "mapboxgl-touch-drag-pan");
            }
            isEnabled() {
              return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
              return this._mousePan.isActive() || this._touchPan.isActive();
            }
          }
          class $o {
            constructor(t2, e3, i2) {
              this._pitchWithRotate = t2.pitchWithRotate, this._mouseRotate = e3, this._mousePitch = i2;
            }
            enable() {
              this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
            }
            disable() {
              this._mouseRotate.disable(), this._mousePitch.disable();
            }
            isEnabled() {
              return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
            }
            isActive() {
              return this._mouseRotate.isActive() || this._mousePitch.isActive();
            }
          }
          class Xo {
            constructor(t2, e3, i2, o2) {
              this._el = t2, this._touchZoom = e3, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
            }
            enable(t2) {
              this._touchZoom.enable(t2), this._rotationDisabled || this._touchRotate.enable(t2), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate", "mapboxgl-touch-zoom-rotate");
            }
            disable() {
              this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate", "mapboxgl-touch-zoom-rotate");
            }
            isEnabled() {
              return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
              return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
              this._rotationDisabled = true, this._touchRotate.disable();
            }
            enableRotation() {
              this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
          }
          const Wo = (t2) => t2.zoom || t2.drag || t2.pitch || t2.rotate;
          class Ho extends t.Event {
          }
          function Ko(t2) {
            return t2.panDelta && t2.panDelta.mag() || t2.zoomDelta || t2.bearingDelta || t2.pitchDelta;
          }
          class Yo {
            constructor(e3, i2) {
              this._map = e3, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new co(e3), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(i2), t.bindAll(["handleEvent", "handleWindowEvent"], this);
              const o2 = this._el;
              this._listeners = [[o2, "touchstart", { passive: true }], [o2, "touchmove", { passive: false }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: false }], [o2, "keyup", void 0], [o2, "wheel", { passive: false }], [o2, "contextmenu", void 0], [window, "blur", void 0]];
              for (const [t2, e4, i3] of this._listeners)
                r.addEventListener(t2, e4, t2 === document ? this.handleWindowEvent : this.handleEvent, i3);
            }
            destroy() {
              for (const [t2, e3, i2] of this._listeners)
                r.removeEventListener(t2, e3, t2 === document ? this.handleWindowEvent : this.handleEvent, i2);
            }
            _addDefaultHandlers(t2) {
              const e3 = this._map, i2 = e3.getCanvasContainer();
              this._add("mapEvent", new fo(e3, t2));
              const o2 = e3.boxZoom = new xo(e3, t2);
              this._add("boxZoom", o2);
              const a2 = new wo(), r2 = new Vo();
              e3.doubleClickZoom = new Zo(r2, a2), this._add("tapZoom", a2), this._add("clickZoom", r2);
              const s2 = new qo();
              this._add("tapDragZoom", s2);
              const n2 = e3.touchPitch = new Bo(e3);
              this._add("touchPitch", n2);
              const l2 = new Co(t2), c2 = new So(t2);
              e3.dragRotate = new $o(t2, l2, c2), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
              const h2 = new Io(t2), u2 = new Do(t2, e3);
              e3.dragPan = new jo(i2, h2, u2), this._add("mousePan", h2), this._add("touchPan", u2, ["touchZoom", "touchRotate"]);
              const d2 = new Ro(), m2 = new Ao();
              e3.touchZoomRotate = new Xo(i2, m2, d2, s2), this._add("touchRotate", d2, ["touchPan", "touchZoom"]), this._add("touchZoom", m2, ["touchPan", "touchRotate"]);
              const _2 = e3.scrollZoom = new Go(e3, this);
              this._add("scrollZoom", _2, ["mousePan"]);
              const p2 = e3.keyboard = new Oo();
              this._add("keyboard", p2), this._add("blockableMapEvent", new go(e3));
              for (const i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"])
                t2.interactive && t2[i3] && e3[i3].enable(t2[i3]);
            }
            _add(t2, e3, i2) {
              this._handlers.push({ handlerName: t2, handler: e3, allowed: i2 }), this._handlersById[t2] = e3;
            }
            stop(t2) {
              if (!this._updatingCamera) {
                for (const { handler: t3 } of this._handlers)
                  t3.reset();
                this._inertia.clear(), this._fireEvents({}, {}, t2), this._changes = [];
              }
            }
            isActive() {
              for (const { handler: t2 } of this._handlers)
                if (t2.isActive())
                  return true;
              return false;
            }
            isZooming() {
              return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
              return !!this._eventsInProgress.rotate;
            }
            isMoving() {
              return Boolean(Wo(this._eventsInProgress)) || this.isZooming();
            }
            _blockedByActive(t2, e3, i2) {
              for (const o2 in t2)
                if (o2 !== i2 && (!e3 || e3.indexOf(o2) < 0))
                  return true;
              return false;
            }
            handleWindowEvent(t2) {
              this.handleEvent(t2, `${t2.type}Window`);
            }
            _getMapTouches(t2) {
              const e3 = [];
              for (const i2 of t2)
                this._el.contains(i2.target) && e3.push(i2);
              return e3;
            }
            handleEvent(t2, e3) {
              if ("blur" === t2.type)
                return void this.stop(true);
              this._updatingCamera = true;
              const i2 = "renderFrame" === t2.type ? void 0 : t2, o2 = { needsRenderFrame: false }, a2 = {}, s2 = {}, n2 = t2.touches, l2 = n2 ? this._getMapTouches(n2) : void 0, c2 = l2 ? r.touchPos(this._el, l2) : r.mousePos(this._el, t2);
              for (const { handlerName: r2, handler: n3, allowed: h3 } of this._handlers) {
                if (!n3.isEnabled())
                  continue;
                let u3;
                this._blockedByActive(s2, h3, r2) ? n3.reset() : n3[e3 || t2.type] && (u3 = n3[e3 || t2.type](t2, c2, l2), this.mergeHandlerResult(o2, a2, u3, r2, i2), u3 && u3.needsRenderFrame && this._triggerRenderFrame()), (u3 || n3.isActive()) && (s2[r2] = n3);
              }
              const h2 = {};
              for (const t3 in this._previousActiveHandlers)
                s2[t3] || (h2[t3] = i2);
              this._previousActiveHandlers = s2, (Object.keys(h2).length || Ko(o2)) && (this._changes.push([o2, a2, h2]), this._triggerRenderFrame()), (Object.keys(s2).length || Ko(o2)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: u2 } = o2;
              u2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], u2(this._map));
            }
            mergeHandlerResult(e3, i2, o2, a2, r2) {
              if (!o2)
                return;
              t.extend(e3, o2);
              const s2 = { handlerName: a2, originalEvent: o2.originalEvent || r2 };
              void 0 !== o2.zoomDelta && (i2.zoom = s2), void 0 !== o2.panDelta && (i2.drag = s2), void 0 !== o2.pitchDelta && (i2.pitch = s2), void 0 !== o2.bearingDelta && (i2.rotate = s2);
            }
            _applyChanges() {
              const e3 = {}, i2 = {}, o2 = {};
              for (const [a2, r2, s2] of this._changes)
                a2.panDelta && (e3.panDelta = (e3.panDelta || new t.pointGeometry(0, 0))._add(a2.panDelta)), a2.zoomDelta && (e3.zoomDelta = (e3.zoomDelta || 0) + a2.zoomDelta), a2.bearingDelta && (e3.bearingDelta = (e3.bearingDelta || 0) + a2.bearingDelta), a2.pitchDelta && (e3.pitchDelta = (e3.pitchDelta || 0) + a2.pitchDelta), void 0 !== a2.around && (e3.around = a2.around), void 0 !== a2.pinchAround && (e3.pinchAround = a2.pinchAround), a2.noInertia && (e3.noInertia = a2.noInertia), t.extend(i2, r2), t.extend(o2, s2);
              this._updateMapTransform(e3, i2, o2), this._changes = [];
            }
            _updateMapTransform(e3, i2, o2) {
              const a2 = this._map, r2 = a2.transform, s2 = a2.style && a2.style.terrain;
              if (!(Ko(e3) || s2 && this._drag))
                return this._fireEvents(i2, o2, true);
              let { panDelta: n2, zoomDelta: l2, bearingDelta: c2, pitchDelta: h2, around: u2, pinchAround: d2 } = e3;
              void 0 !== d2 && (u2 = d2), a2._stop(true), u2 = u2 || a2.transform.centerPoint;
              const m2 = r2.pointLocation(n2 ? u2.sub(n2) : u2);
              c2 && (r2.bearing += c2), h2 && (r2.pitch += h2), l2 && (r2.zoom += l2), s2 ? i2.drag && !this._drag ? (this._drag = { center: r2.centerPoint, lngLat: r2.pointLocation(u2), point: u2, handlerName: i2.drag.handlerName }, a2.fire(new t.Event("freezeElevation", { freeze: true }))) : this._drag && o2[this._drag.handlerName] ? (a2.fire(new t.Event("freezeElevation", { freeze: false })), this._drag = null) : i2.drag && this._drag && (r2.center = r2.pointLocation(r2.centerPoint.sub(n2))) : r2.setLocationAtPoint(m2, u2), this._map._update(), e3.noInertia || this._inertia.record(e3), this._fireEvents(i2, o2, true);
            }
            _fireEvents(e3, i2, o2) {
              const a2 = Wo(this._eventsInProgress), r2 = Wo(e3), s2 = {};
              for (const t2 in e3) {
                const { originalEvent: i3 } = e3[t2];
                this._eventsInProgress[t2] || (s2[`${t2}start`] = i3), this._eventsInProgress[t2] = e3[t2];
              }
              !a2 && r2 && this._fireEvent("movestart", r2.originalEvent);
              for (const t2 in s2)
                this._fireEvent(t2, s2[t2]);
              r2 && this._fireEvent("move", r2.originalEvent);
              for (const t2 in e3) {
                const { originalEvent: i3 } = e3[t2];
                this._fireEvent(t2, i3);
              }
              const n2 = {};
              let l2;
              for (const t2 in this._eventsInProgress) {
                const { handlerName: e4, originalEvent: o3 } = this._eventsInProgress[t2];
                this._handlersById[e4].isActive() || (delete this._eventsInProgress[t2], l2 = i2[e4] || o3, n2[`${t2}end`] = l2);
              }
              for (const t2 in n2)
                this._fireEvent(t2, n2[t2]);
              const c2 = Wo(this._eventsInProgress);
              if (o2 && (a2 || r2) && !c2) {
                this._updatingCamera = true;
                const e4 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (t2) => 0 !== t2 && -this._bearingSnap < t2 && t2 < this._bearingSnap;
                e4 ? (i3(e4.bearing || this._map.getBearing()) && (e4.bearing = 0), this._map.easeTo(e4, { originalEvent: l2 })) : (this._map.fire(new t.Event("moveend", { originalEvent: l2 })), i3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
              }
            }
            _fireEvent(e3, i2) {
              this._map.fire(new t.Event(e3, i2 ? { originalEvent: i2 } : {}));
            }
            _requestFrame() {
              return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t2) => {
                delete this._frameId, this.handleEvent(new Ho("renderFrame", { timeStamp: t2 })), this._applyChanges();
              });
            }
            _triggerRenderFrame() {
              void 0 === this._frameId && (this._frameId = this._requestFrame());
            }
          }
          const Jo = { extend: (e3, ...i2) => t.extend(e3, ...i2), run(t2) {
            t2();
          }, logToElement(t2, e3 = false, i2 = "log") {
            const o2 = window.document.getElementById(i2);
            o2 && (e3 && (o2.innerHTML = ""), o2.innerHTML += `<br>${t2}`);
          } };
          class Qo extends t.Evented {
            constructor(e3, i2) {
              super(), this._moving = false, this._zooming = false, this.transform = e3, this._bearingSnap = i2.bearingSnap, t.bindAll(["_renderFrameCallback"], this);
            }
            getCenter() {
              return new t.LngLat(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(t2, e3) {
              return this.jumpTo({ center: t2 }, e3);
            }
            panBy(e3, i2, o2) {
              return e3 = t.pointGeometry.convert(e3).mult(-1), this.panTo(this.transform.center, t.extend({ offset: e3 }, i2), o2);
            }
            panTo(e3, i2, o2) {
              return this.easeTo(t.extend({ center: e3 }, i2), o2);
            }
            getZoom() {
              return this.transform.zoom;
            }
            setZoom(t2, e3) {
              return this.jumpTo({ zoom: t2 }, e3), this;
            }
            zoomTo(e3, i2, o2) {
              return this.easeTo(t.extend({ zoom: e3 }, i2), o2);
            }
            zoomIn(t2, e3) {
              return this.zoomTo(this.getZoom() + 1, t2, e3), this;
            }
            zoomOut(t2, e3) {
              return this.zoomTo(this.getZoom() - 1, t2, e3), this;
            }
            getBearing() {
              return this.transform.bearing;
            }
            setBearing(t2, e3) {
              return this.jumpTo({ bearing: t2 }, e3), this;
            }
            getPadding() {
              return this.transform.padding;
            }
            setPadding(t2, e3) {
              return this.jumpTo({ padding: t2 }, e3), this;
            }
            rotateTo(e3, i2, o2) {
              return this.easeTo(t.extend({ bearing: e3 }, i2), o2);
            }
            resetNorth(e3, i2) {
              return this.rotateTo(0, t.extend({ duration: 1e3 }, e3), i2), this;
            }
            resetNorthPitch(e3, i2) {
              return this.easeTo(t.extend({ bearing: 0, pitch: 0, duration: 1e3 }, e3), i2), this;
            }
            snapToNorth(t2, e3) {
              return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t2, e3) : this;
            }
            getPitch() {
              return this.transform.pitch;
            }
            setPitch(t2, e3) {
              return this.jumpTo({ pitch: t2 }, e3), this;
            }
            cameraForBounds(e3, i2) {
              e3 = t.LngLatBounds.convert(e3);
              const o2 = i2 && i2.bearing || 0;
              return this._cameraForBoxAndBearing(e3.getNorthWest(), e3.getSouthEast(), o2, i2);
            }
            _cameraForBoxAndBearing(e3, i2, o2, a2) {
              const r2 = { top: 0, bottom: 0, right: 0, left: 0 };
              if ("number" == typeof (a2 = t.extend({ padding: r2, offset: [0, 0], maxZoom: this.transform.maxZoom }, a2)).padding) {
                const t2 = a2.padding;
                a2.padding = { top: t2, bottom: t2, right: t2, left: t2 };
              }
              a2.padding = t.extend(r2, a2.padding);
              const s2 = this.transform, n2 = s2.padding, l2 = s2.project(t.LngLat.convert(e3)), c2 = s2.project(t.LngLat.convert(i2)), h2 = l2.rotate(-o2 * Math.PI / 180), u2 = c2.rotate(-o2 * Math.PI / 180), d2 = new t.pointGeometry(Math.max(h2.x, u2.x), Math.max(h2.y, u2.y)), m2 = new t.pointGeometry(Math.min(h2.x, u2.x), Math.min(h2.y, u2.y)), _2 = d2.sub(m2), p2 = (s2.width - (n2.left + n2.right + a2.padding.left + a2.padding.right)) / _2.x, f2 = (s2.height - (n2.top + n2.bottom + a2.padding.top + a2.padding.bottom)) / _2.y;
              if (f2 < 0 || p2 < 0)
                return void t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
              const g2 = Math.min(s2.scaleZoom(s2.scale * Math.min(p2, f2)), a2.maxZoom), x3 = t.pointGeometry.convert(a2.offset), v2 = new t.pointGeometry((a2.padding.left - a2.padding.right) / 2, (a2.padding.top - a2.padding.bottom) / 2).rotate(o2 * Math.PI / 180), y3 = x3.add(v2).mult(s2.scale / s2.zoomScale(g2));
              return { center: s2.unproject(l2.add(c2).div(2).sub(y3)), zoom: g2, bearing: o2 };
            }
            fitBounds(t2, e3, i2) {
              return this._fitInternal(this.cameraForBounds(t2, e3), e3, i2);
            }
            fitScreenCoordinates(e3, i2, o2, a2, r2) {
              return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.pointGeometry.convert(e3)), this.transform.pointLocation(t.pointGeometry.convert(i2)), o2, a2), a2, r2);
            }
            _fitInternal(e3, i2, o2) {
              return e3 ? (delete (i2 = t.extend(e3, i2)).padding, i2.linear ? this.easeTo(i2, o2) : this.flyTo(i2, o2)) : this;
            }
            jumpTo(e3, i2) {
              this.stop();
              const o2 = this.transform;
              let a2 = false, r2 = false, s2 = false;
              return "zoom" in e3 && o2.zoom !== +e3.zoom && (a2 = true, o2.zoom = +e3.zoom), void 0 !== e3.center && (o2.center = t.LngLat.convert(e3.center)), "bearing" in e3 && o2.bearing !== +e3.bearing && (r2 = true, o2.bearing = +e3.bearing), "pitch" in e3 && o2.pitch !== +e3.pitch && (s2 = true, o2.pitch = +e3.pitch), null == e3.padding || o2.isPaddingEqual(e3.padding) || (o2.padding = e3.padding), this.fire(new t.Event("movestart", i2)).fire(new t.Event("move", i2)), a2 && this.fire(new t.Event("zoomstart", i2)).fire(new t.Event("zoom", i2)).fire(new t.Event("zoomend", i2)), r2 && this.fire(new t.Event("rotatestart", i2)).fire(new t.Event("rotate", i2)).fire(new t.Event("rotateend", i2)), s2 && this.fire(new t.Event("pitchstart", i2)).fire(new t.Event("pitch", i2)).fire(new t.Event("pitchend", i2)), this.fire(new t.Event("moveend", i2));
            }
            calculateCameraOptionsFromTo(e3, i2, o2, a2 = 0) {
              const r2 = t.MercatorCoordinate.fromLngLat(e3, i2), s2 = t.MercatorCoordinate.fromLngLat(o2, a2), n2 = s2.x - r2.x, l2 = s2.y - r2.y, c2 = s2.z - r2.z, h2 = Math.hypot(n2, l2, c2);
              if (0 === h2)
                throw new Error("Can't calculate camera options with same From and To");
              const u2 = Math.hypot(n2, l2), d2 = this.transform.scaleZoom(this.transform.cameraToCenterDistance / h2 / this.transform.tileSize), m2 = 180 * Math.atan2(n2, -l2) / Math.PI;
              let _2 = 180 * Math.acos(u2 / h2) / Math.PI;
              return _2 = c2 < 0 ? 90 - _2 : 90 + _2, { center: s2.toLngLat(), zoom: d2, pitch: _2, bearing: m2 };
            }
            easeTo(e3, i2) {
              this._stop(false, e3.easeId), (false === (e3 = t.extend({ offset: [0, 0], duration: 500, easing: t.ease }, e3)).animate || !e3.essential && t.exported.prefersReducedMotion) && (e3.duration = 0);
              const o2 = this.transform, a2 = this.getZoom(), r2 = this.getBearing(), s2 = this.getPitch(), n2 = this.getPadding(), l2 = "zoom" in e3 ? +e3.zoom : a2, c2 = "bearing" in e3 ? this._normalizeBearing(e3.bearing, r2) : r2, h2 = "pitch" in e3 ? +e3.pitch : s2, u2 = "padding" in e3 ? e3.padding : o2.padding, d2 = t.pointGeometry.convert(e3.offset);
              let m2 = o2.centerPoint.add(d2);
              const _2 = o2.pointLocation(m2), p2 = t.LngLat.convert(e3.center || _2);
              this._normalizeCenter(p2);
              const f2 = o2.project(_2), g2 = o2.project(p2).sub(f2), x3 = o2.zoomScale(l2 - a2);
              let v2, y3;
              e3.around && (v2 = t.LngLat.convert(e3.around), y3 = o2.locationPoint(v2));
              const b2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
              return this._zooming = this._zooming || l2 !== a2, this._rotating = this._rotating || r2 !== c2, this._pitching = this._pitching || h2 !== s2, this._padding = !o2.isPaddingEqual(u2), this._easeId = e3.easeId, this._prepareEase(i2, e3.noMoveStart, b2), this._ease((e4) => {
                if (this._zooming && (o2.zoom = t.number(a2, l2, e4)), this._rotating && (o2.bearing = t.number(r2, c2, e4)), this._pitching && (o2.pitch = t.number(s2, h2, e4)), this._padding && (o2.interpolatePadding(n2, u2, e4), m2 = o2.centerPoint.add(d2)), v2)
                  o2.setLocationAtPoint(v2, y3);
                else {
                  const t2 = o2.zoomScale(o2.zoom - a2), i3 = l2 > a2 ? Math.min(2, x3) : Math.max(0.5, x3), r3 = Math.pow(i3, 1 - e4), s3 = o2.unproject(f2.add(g2.mult(e4 * r3)).mult(t2));
                  o2.setLocationAtPoint(o2.renderWorldCopies ? s3.wrap() : s3, m2);
                }
                this._fireMoveEvents(i2);
              }, (t2) => {
                this._afterEase(i2, t2);
              }, e3), this;
            }
            _prepareEase(e3, i2, o2 = {}) {
              this._moving = true, this.fire(new t.Event("freezeElevation", { freeze: true })), i2 || o2.moving || this.fire(new t.Event("movestart", e3)), this._zooming && !o2.zooming && this.fire(new t.Event("zoomstart", e3)), this._rotating && !o2.rotating && this.fire(new t.Event("rotatestart", e3)), this._pitching && !o2.pitching && this.fire(new t.Event("pitchstart", e3));
            }
            _fireMoveEvents(e3) {
              this.fire(new t.Event("move", e3)), this._zooming && this.fire(new t.Event("zoom", e3)), this._rotating && this.fire(new t.Event("rotate", e3)), this._pitching && this.fire(new t.Event("pitch", e3));
            }
            _afterEase(e3, i2) {
              if (this._easeId && i2 && this._easeId === i2)
                return;
              delete this._easeId, this.fire(new t.Event("freezeElevation", { freeze: false }));
              const o2 = this._zooming, a2 = this._rotating, r2 = this._pitching;
              this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new t.Event("zoomend", e3)), a2 && this.fire(new t.Event("rotateend", e3)), r2 && this.fire(new t.Event("pitchend", e3)), this.fire(new t.Event("moveend", e3));
            }
            flyTo(e3, i2) {
              if (!e3.essential && t.exported.prefersReducedMotion) {
                const o3 = t.pick(e3, ["center", "zoom", "bearing", "pitch", "around"]);
                return this.jumpTo(o3, i2);
              }
              this.stop(), e3 = t.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.ease }, e3);
              const o2 = this.transform, a2 = this.getZoom(), r2 = this.getBearing(), s2 = this.getPitch(), n2 = this.getPadding(), l2 = "zoom" in e3 ? t.clamp(+e3.zoom, o2.minZoom, o2.maxZoom) : a2, c2 = "bearing" in e3 ? this._normalizeBearing(e3.bearing, r2) : r2, h2 = "pitch" in e3 ? +e3.pitch : s2, u2 = "padding" in e3 ? e3.padding : o2.padding, d2 = o2.zoomScale(l2 - a2), m2 = t.pointGeometry.convert(e3.offset);
              let _2 = o2.centerPoint.add(m2);
              const p2 = o2.pointLocation(_2), f2 = t.LngLat.convert(e3.center || p2);
              this._normalizeCenter(f2);
              const g2 = o2.project(p2), x3 = o2.project(f2).sub(g2);
              let v2 = e3.curve;
              const y3 = Math.max(o2.width, o2.height), b2 = y3 / d2, w2 = x3.mag();
              if ("minZoom" in e3) {
                const i3 = t.clamp(Math.min(e3.minZoom, a2, l2), o2.minZoom, o2.maxZoom), r3 = y3 / o2.zoomScale(i3 - a2);
                v2 = Math.sqrt(r3 / w2 * 2);
              }
              const T2 = v2 * v2;
              function E2(t2) {
                const e4 = (b2 * b2 - y3 * y3 + (t2 ? -1 : 1) * T2 * T2 * w2 * w2) / (2 * (t2 ? b2 : y3) * T2 * w2);
                return Math.log(Math.sqrt(e4 * e4 + 1) - e4);
              }
              function I2(t2) {
                return (Math.exp(t2) - Math.exp(-t2)) / 2;
              }
              function C2(t2) {
                return (Math.exp(t2) + Math.exp(-t2)) / 2;
              }
              const S2 = E2(0);
              let D2 = function(t2) {
                return C2(S2) / C2(S2 + v2 * t2);
              }, z2 = function(t2) {
                return y3 * ((C2(S2) * (I2(e4 = S2 + v2 * t2) / C2(e4)) - I2(S2)) / T2) / w2;
                var e4;
              }, P2 = (E2(1) - S2) / v2;
              if (Math.abs(w2) < 1e-6 || !isFinite(P2)) {
                if (Math.abs(y3 - b2) < 1e-6)
                  return this.easeTo(e3, i2);
                const t2 = b2 < y3 ? -1 : 1;
                P2 = Math.abs(Math.log(b2 / y3)) / v2, z2 = function() {
                  return 0;
                }, D2 = function(e4) {
                  return Math.exp(t2 * v2 * e4);
                };
              }
              return e3.duration = "duration" in e3 ? +e3.duration : 1e3 * P2 / ("screenSpeed" in e3 ? +e3.screenSpeed / v2 : +e3.speed), e3.maxDuration && e3.duration > e3.maxDuration && (e3.duration = 0), this._zooming = true, this._rotating = r2 !== c2, this._pitching = h2 !== s2, this._padding = !o2.isPaddingEqual(u2), this._prepareEase(i2, false), this._ease((e4) => {
                const d3 = e4 * P2, p3 = 1 / D2(d3);
                o2.zoom = 1 === e4 ? l2 : a2 + o2.scaleZoom(p3), this._rotating && (o2.bearing = t.number(r2, c2, e4)), this._pitching && (o2.pitch = t.number(s2, h2, e4)), this._padding && (o2.interpolatePadding(n2, u2, e4), _2 = o2.centerPoint.add(m2));
                const v3 = 1 === e4 ? f2 : o2.unproject(g2.add(x3.mult(z2(d3))).mult(p3));
                o2.setLocationAtPoint(o2.renderWorldCopies ? v3.wrap() : v3, _2), this._fireMoveEvents(i2);
              }, () => this._afterEase(i2), e3), this;
            }
            isEasing() {
              return !!this._easeFrameId;
            }
            stop() {
              return this._stop();
            }
            _stop(t2, e3) {
              if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
                const t3 = this._onEaseEnd;
                delete this._onEaseEnd, t3.call(this, e3);
              }
              if (!t2) {
                const t3 = this.handlers;
                t3 && t3.stop(false);
              }
              return this;
            }
            _ease(e3, i2, o2) {
              false === o2.animate || 0 === o2.duration ? (e3(1), i2()) : (this._easeStart = t.exported.now(), this._easeOptions = o2, this._onEaseFrame = e3, this._onEaseEnd = i2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _renderFrameCallback() {
              const e3 = Math.min((t.exported.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(e3)), e3 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }
            _normalizeBearing(e3, i2) {
              e3 = t.wrap(e3, -180, 180);
              const o2 = Math.abs(e3 - i2);
              return Math.abs(e3 - 360 - i2) < o2 && (e3 -= 360), Math.abs(e3 + 360 - i2) < o2 && (e3 += 360), e3;
            }
            _normalizeCenter(t2) {
              const e3 = this.transform;
              if (!e3.renderWorldCopies || e3.lngRange)
                return;
              const i2 = t2.lng - e3.center.lng;
              t2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
            }
          }
          class ta {
            constructor(e3 = {}) {
              this.options = e3, t.bindAll(["_toggleAttribution", "_updateData", "_updateCompact", "_updateCompactMinimize"], this);
            }
            getDefaultPosition() {
              return "bottom-right";
            }
            onAdd(t2) {
              return this._map = t2, this._compact = this.options && this.options.compact, this._container = r.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = r.create("summary", "maplibregl-ctrl-attrib-button mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = r.create("div", "maplibregl-ctrl-attrib-inner mapboxgl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
            }
            onRemove() {
              r.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
            }
            _setElementTitle(t2, e3) {
              const i2 = this._map._getUIString(`AttributionControl.${e3}`);
              t2.title = i2, t2.setAttribute("aria-label", i2);
            }
            _toggleAttribution() {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show", "mapboxgl-compact-show")) : (this._container.classList.add("maplibregl-compact-show", "mapboxgl-compact-show"), this._container.removeAttribute("open")));
            }
            _updateData(t2) {
              !t2 || "metadata" !== t2.sourceDataType && "visibility" !== t2.sourceDataType && "style" !== t2.dataType && "terrain" !== t2.type || this._updateAttributions();
            }
            _updateAttributions() {
              if (!this._map.style)
                return;
              let t2 = [];
              if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t2 = t2.concat(this.options.customAttribution.map((t3) => "string" != typeof t3 ? "" : t3)) : "string" == typeof this.options.customAttribution && t2.push(this.options.customAttribution)), this._map.style.stylesheet) {
                const t3 = this._map.style.stylesheet;
                this.styleOwner = t3.owner, this.styleId = t3.id;
              }
              const e3 = this._map.style.sourceCaches;
              for (const i3 in e3) {
                const o2 = e3[i3];
                if (o2.used || o2.usedForTerrain) {
                  const e4 = o2.getSource();
                  e4.attribution && t2.indexOf(e4.attribution) < 0 && t2.push(e4.attribution);
                }
              }
              t2 = t2.filter((t3) => String(t3).trim()), t2.sort((t3, e4) => t3.length - e4.length), t2 = t2.filter((e4, i3) => {
                for (let o2 = i3 + 1; o2 < t2.length; o2++)
                  if (t2[o2].indexOf(e4) >= 0)
                    return false;
                return true;
              });
              const i2 = t2.join(" | ");
              i2 !== this._attribHTML && (this._attribHTML = i2, t2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("maplibregl-attrib-empty", "mapboxgl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty", "mapboxgl-attrib-empty"), this._updateCompact(), this._editLink = null);
            }
            _updateCompact() {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "mapboxgl-compact", "maplibregl-compact-show", "mapboxgl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show", "mapboxgl-compact", "mapboxgl-compact-show"));
            }
            _updateCompactMinimize() {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show", "mapboxgl-compact-show");
            }
          }
          class ea {
            constructor(e3 = {}) {
              this.options = e3, t.bindAll(["_updateCompact"], this);
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            onAdd(t2) {
              this._map = t2, this._compact = this.options && this.options.compact, this._container = r.create("div", "maplibregl-ctrl mapboxgl-ctrl");
              const e3 = r.create("a", "maplibregl-ctrl-logo mapboxgl-ctrl-logo");
              return e3.target = "_blank", e3.rel = "noopener nofollow", e3.href = "https://maplibre.org/", e3.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e3.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e3), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
              r.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
            }
            _updateCompact() {
              const t2 = this._container.children;
              if (t2.length) {
                const e3 = t2[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false !== this._compact && e3.classList.add("maplibregl-compact", "mapboxgl-compact") : e3.classList.remove("maplibregl-compact", "mapboxgl-compact");
              }
            }
          }
          class ia {
            constructor() {
              this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
            }
            add(t2) {
              const e3 = ++this._id;
              return this._queue.push({ callback: t2, id: e3, cancelled: false }), e3;
            }
            remove(t2) {
              const e3 = this._currentlyRunning, i2 = e3 ? this._queue.concat(e3) : this._queue;
              for (const e4 of i2)
                if (e4.id === t2)
                  return void (e4.cancelled = true);
            }
            run(t2 = 0) {
              if (this._currentlyRunning)
                throw new Error("Attempting to run(), but is already running.");
              const e3 = this._currentlyRunning = this._queue;
              this._queue = [];
              for (const i2 of e3)
                if (!i2.cancelled && (i2.callback(t2), this._cleared))
                  break;
              this._cleared = false, this._currentlyRunning = false;
            }
            clear() {
              this._currentlyRunning && (this._cleared = true), this._queue = [];
            }
          }
          const oa = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.enableTerrain": "Enable terrain", "TerrainControl.disableTerrain": "Disable terrain" }, aa = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: void 0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, maplibreLogo: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", transformRequest: null, fadeDuration: 300, crossSourceCollisions: true }, ra = { showCompass: true, showZoom: true, visualizePitch: false };
          class sa {
            constructor(e3, i2, o2 = false) {
              this._clickTolerance = 10, this.element = i2, this.mouseRotate = new Co({ clickTolerance: e3.dragRotate._mouseRotate._clickTolerance }), this.map = e3, o2 && (this.mousePitch = new So({ clickTolerance: e3.dragRotate._mousePitch._clickTolerance })), t.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), r.addEventListener(i2, "mousedown", this.mousedown), r.addEventListener(i2, "touchstart", this.touchstart, { passive: false }), r.addEventListener(i2, "touchmove", this.touchmove), r.addEventListener(i2, "touchend", this.touchend), r.addEventListener(i2, "touchcancel", this.reset);
            }
            down(t2, e3) {
              this.mouseRotate.mousedown(t2, e3), this.mousePitch && this.mousePitch.mousedown(t2, e3), r.disableDrag();
            }
            move(t2, e3) {
              const i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(t2, e3);
              if (o2 && o2.bearingDelta && i2.setBearing(i2.getBearing() + o2.bearingDelta), this.mousePitch) {
                const o3 = this.mousePitch.mousemoveWindow(t2, e3);
                o3 && o3.pitchDelta && i2.setPitch(i2.getPitch() + o3.pitchDelta);
              }
            }
            off() {
              const t2 = this.element;
              r.removeEventListener(t2, "mousedown", this.mousedown), r.removeEventListener(t2, "touchstart", this.touchstart, { passive: false }), r.removeEventListener(t2, "touchmove", this.touchmove), r.removeEventListener(t2, "touchend", this.touchend), r.removeEventListener(t2, "touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
              r.enableDrag(), r.removeEventListener(window, "mousemove", this.mousemove), r.removeEventListener(window, "mouseup", this.mouseup);
            }
            mousedown(e3) {
              this.down(t.extend({}, e3, { ctrlKey: true, preventDefault: () => e3.preventDefault() }), r.mousePos(this.element, e3)), r.addEventListener(window, "mousemove", this.mousemove), r.addEventListener(window, "mouseup", this.mouseup);
            }
            mousemove(t2) {
              this.move(t2, r.mousePos(this.element, t2));
            }
            mouseup(t2) {
              this.mouseRotate.mouseupWindow(t2), this.mousePitch && this.mousePitch.mouseupWindow(t2), this.offTemp();
            }
            touchstart(t2) {
              1 !== t2.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = r.touchPos(this.element, t2.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => t2.preventDefault() }, this._startPos));
            }
            touchmove(t2) {
              1 !== t2.targetTouches.length ? this.reset() : (this._lastPos = r.touchPos(this.element, t2.targetTouches)[0], this.move({ preventDefault: () => t2.preventDefault() }, this._lastPos));
            }
            touchend(t2) {
              0 === t2.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
            }
            reset() {
              this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }
          }
          function na(e3, i2, o2) {
            if (e3 = new t.LngLat(e3.lng, e3.lat), i2) {
              const a2 = new t.LngLat(e3.lng - 360, e3.lat), r2 = new t.LngLat(e3.lng + 360, e3.lat), s2 = o2.locationPoint(e3).distSqr(i2);
              o2.locationPoint(a2).distSqr(i2) < s2 ? e3 = a2 : o2.locationPoint(r2).distSqr(i2) < s2 && (e3 = r2);
            }
            for (; Math.abs(e3.lng - o2.center.lng) > 180; ) {
              const t2 = o2.locationPoint(e3);
              if (t2.x >= 0 && t2.y >= 0 && t2.x <= o2.width && t2.y <= o2.height)
                break;
              e3.lng > o2.center.lng ? e3.lng -= 360 : e3.lng += 360;
            }
            return e3;
          }
          const la = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
          function ca(t2, e3, i2) {
            const o2 = t2.classList;
            for (const t3 in la)
              o2.remove(`maplibregl-${i2}-anchor-${t3}`, `mapboxgl-${i2}-anchor-${t3}`);
            o2.add(`maplibregl-${i2}-anchor-${e3}`, `mapboxgl-${i2}-anchor-${e3}`);
          }
          class ha extends t.Evented {
            constructor(e3, i2) {
              if (super(), (e3 instanceof HTMLElement || i2) && (e3 = t.extend({ element: e3 }, i2)), t.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = e3 && e3.anchor || "center", this._color = e3 && e3.color || "#3FB1CE", this._scale = e3 && e3.scale || 1, this._draggable = e3 && e3.draggable || false, this._clickTolerance = e3 && e3.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = e3 && e3.rotation || 0, this._rotationAlignment = e3 && e3.rotationAlignment || "auto", this._pitchAlignment = e3 && e3.pitchAlignment && "auto" !== e3.pitchAlignment ? e3.pitchAlignment : this._rotationAlignment, e3 && e3.element)
                this._element = e3.element, this._offset = t.pointGeometry.convert(e3 && e3.offset || [0, 0]);
              else {
                this._defaultMarker = true, this._element = r.create("div"), this._element.setAttribute("aria-label", "Map marker");
                const i3 = r.createNS("http://www.w3.org/2000/svg", "svg"), o2 = 41, a2 = 27;
                i3.setAttributeNS(null, "display", "block"), i3.setAttributeNS(null, "height", `${o2}px`), i3.setAttributeNS(null, "width", `${a2}px`), i3.setAttributeNS(null, "viewBox", `0 0 ${a2} ${o2}`);
                const s2 = r.createNS("http://www.w3.org/2000/svg", "g");
                s2.setAttributeNS(null, "stroke", "none"), s2.setAttributeNS(null, "stroke-width", "1"), s2.setAttributeNS(null, "fill", "none"), s2.setAttributeNS(null, "fill-rule", "evenodd");
                const n2 = r.createNS("http://www.w3.org/2000/svg", "g");
                n2.setAttributeNS(null, "fill-rule", "nonzero");
                const l2 = r.createNS("http://www.w3.org/2000/svg", "g");
                l2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l2.setAttributeNS(null, "fill", "#000000");
                const c2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
                for (const t2 of c2) {
                  const e4 = r.createNS("http://www.w3.org/2000/svg", "ellipse");
                  e4.setAttributeNS(null, "opacity", "0.04"), e4.setAttributeNS(null, "cx", "10.5"), e4.setAttributeNS(null, "cy", "5.80029008"), e4.setAttributeNS(null, "rx", t2.rx), e4.setAttributeNS(null, "ry", t2.ry), l2.appendChild(e4);
                }
                const h2 = r.createNS("http://www.w3.org/2000/svg", "g");
                h2.setAttributeNS(null, "fill", this._color);
                const u2 = r.createNS("http://www.w3.org/2000/svg", "path");
                u2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), h2.appendChild(u2);
                const d2 = r.createNS("http://www.w3.org/2000/svg", "g");
                d2.setAttributeNS(null, "opacity", "0.25"), d2.setAttributeNS(null, "fill", "#000000");
                const m2 = r.createNS("http://www.w3.org/2000/svg", "path");
                m2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d2.appendChild(m2);
                const _2 = r.createNS("http://www.w3.org/2000/svg", "g");
                _2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), _2.setAttributeNS(null, "fill", "#FFFFFF");
                const p2 = r.createNS("http://www.w3.org/2000/svg", "g");
                p2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
                const f2 = r.createNS("http://www.w3.org/2000/svg", "circle");
                f2.setAttributeNS(null, "fill", "#000000"), f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "cx", "5.5"), f2.setAttributeNS(null, "cy", "5.5"), f2.setAttributeNS(null, "r", "5.4999962");
                const g2 = r.createNS("http://www.w3.org/2000/svg", "circle");
                g2.setAttributeNS(null, "fill", "#FFFFFF"), g2.setAttributeNS(null, "cx", "5.5"), g2.setAttributeNS(null, "cy", "5.5"), g2.setAttributeNS(null, "r", "5.4999962"), p2.appendChild(f2), p2.appendChild(g2), n2.appendChild(l2), n2.appendChild(h2), n2.appendChild(d2), n2.appendChild(_2), n2.appendChild(p2), i3.appendChild(n2), i3.setAttributeNS(null, "height", o2 * this._scale + "px"), i3.setAttributeNS(null, "width", a2 * this._scale + "px"), this._element.appendChild(i3), this._offset = t.pointGeometry.convert(e3 && e3.offset || [0, -14]);
              }
              this._element.classList.add("maplibregl-marker", "mapboxgl-marker"), this._element.addEventListener("dragstart", (t2) => {
                t2.preventDefault();
              }), this._element.addEventListener("mousedown", (t2) => {
                t2.preventDefault();
              }), ca(this._element, this._anchor, "marker"), this._popup = null;
            }
            addTo(t2) {
              return this.remove(), this._map = t2, t2.getCanvasContainer().appendChild(this._element), t2.on("move", this._update), t2.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
            }
            remove() {
              return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), r.remove(this._element), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(e3) {
              return this._lngLat = t.LngLat.convert(e3), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
            }
            getElement() {
              return this._element;
            }
            setPopup(t2) {
              if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t2) {
                if (!("offset" in t2.options)) {
                  const e3 = 38.1, i2 = 13.5, o2 = Math.sqrt(Math.pow(i2, 2) / 2);
                  t2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -e3], "bottom-left": [o2, -1 * (e3 - i2 + o2)], "bottom-right": [-o2, -1 * (e3 - i2 + o2)], left: [i2, -1 * (e3 - i2)], right: [-i2, -1 * (e3 - i2)] } : this._offset;
                }
                this._popup = t2, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
              }
              return this;
            }
            _onKeyPress(t2) {
              const e3 = t2.code, i2 = t2.charCode || t2.keyCode;
              "Space" !== e3 && "Enter" !== e3 && 32 !== i2 && 13 !== i2 || this.togglePopup();
            }
            _onMapClick(t2) {
              const e3 = t2.originalEvent.target, i2 = this._element;
              this._popup && (e3 === i2 || i2.contains(e3)) && this.togglePopup();
            }
            getPopup() {
              return this._popup;
            }
            togglePopup() {
              const t2 = this._popup;
              return t2 ? (t2.isOpen() ? t2.remove() : t2.addTo(this._map), this) : this;
            }
            _update(t2) {
              if (!this._map)
                return;
              this._map.transform.renderWorldCopies && (this._lngLat = na(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
              let e3 = "";
              "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? e3 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (e3 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let i2 = "";
              "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? i2 = "rotateX(0deg)" : "map" === this._pitchAlignment && (i2 = `rotateX(${this._map.getPitch()}deg)`), t2 && "moveend" !== t2.type || (this._pos = this._pos.round()), r.setTransform(this._element, `${la[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${i2} ${e3}`), this._map.style && this._map.style.terrain && !this._opacityTimeout && (this._opacityTimeout = setTimeout(() => {
                const t3 = this._map.unproject(this._pos), e4 = 40075016686e-3 * Math.abs(Math.cos(this._lngLat.lat * Math.PI / 180)) / Math.pow(2, this._map.transform.tileZoom + 8);
                this._element.style.opacity = t3.distanceTo(this._lngLat) > 20 * e4 ? "0.2" : "1.0", this._opacityTimeout = null;
              }, 100));
            }
            getOffset() {
              return this._offset;
            }
            setOffset(e3) {
              return this._offset = t.pointGeometry.convert(e3), this._update(), this;
            }
            _onMove(e3) {
              if (!this._isDragging) {
                const t2 = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = e3.point.dist(this._pointerdownPos) >= t2;
              }
              this._isDragging && (this._pos = e3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.Event("dragstart"))), this.fire(new t.Event("drag")));
            }
            _onUp() {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.Event("dragend")), this._state = "inactive";
            }
            _addDragHandler(t2) {
              this._element.contains(t2.originalEvent.target) && (t2.preventDefault(), this._positionDelta = t2.point.sub(this._pos).add(this._offset), this._pointerdownPos = t2.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }
            setDraggable(t2) {
              return this._draggable = !!t2, this._map && (t2 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
              return this._draggable;
            }
            setRotation(t2) {
              return this._rotation = t2 || 0, this._update(), this;
            }
            getRotation() {
              return this._rotation;
            }
            setRotationAlignment(t2) {
              return this._rotationAlignment = t2 || "auto", this._update(), this;
            }
            getRotationAlignment() {
              return this._rotationAlignment;
            }
            setPitchAlignment(t2) {
              return this._pitchAlignment = t2 && "auto" !== t2 ? t2 : this._rotationAlignment, this._update(), this;
            }
            getPitchAlignment() {
              return this._pitchAlignment;
            }
          }
          const ua = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
          let da, ma = 0, _a = false;
          const pa = { maxWidth: 100, unit: "metric" };
          function fa(t2, e3, i2) {
            const o2 = i2 && i2.maxWidth || 100, a2 = t2._container.clientHeight / 2, r2 = t2.unproject([0, a2]), s2 = t2.unproject([o2, a2]), n2 = r2.distanceTo(s2);
            if (i2 && "imperial" === i2.unit) {
              const i3 = 3.2808 * n2;
              i3 > 5280 ? ga(e3, o2, i3 / 5280, t2._getUIString("ScaleControl.Miles")) : ga(e3, o2, i3, t2._getUIString("ScaleControl.Feet"));
            } else
              i2 && "nautical" === i2.unit ? ga(e3, o2, n2 / 1852, t2._getUIString("ScaleControl.NauticalMiles")) : n2 >= 1e3 ? ga(e3, o2, n2 / 1e3, t2._getUIString("ScaleControl.Kilometers")) : ga(e3, o2, n2, t2._getUIString("ScaleControl.Meters"));
          }
          function ga(t2, e3, i2, o2) {
            const a2 = function(t3) {
              const e4 = Math.pow(10, `${Math.floor(t3)}`.length - 1);
              let i3 = t3 / e4;
              return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(t4) {
                const e6 = Math.pow(10, Math.ceil(-Math.log(t4) / Math.LN10));
                return Math.round(t4 * e6) / e6;
              }(i3), e4 * i3;
            }(i2);
            t2.style.width = e3 * (a2 / i2) + "px", t2.innerHTML = `${a2}&nbsp;${o2}`;
          }
          const xa = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, va = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
          function ya(e3) {
            if (e3) {
              if ("number" == typeof e3) {
                const i2 = Math.round(Math.sqrt(0.5 * Math.pow(e3, 2)));
                return { center: new t.pointGeometry(0, 0), top: new t.pointGeometry(0, e3), "top-left": new t.pointGeometry(i2, i2), "top-right": new t.pointGeometry(-i2, i2), bottom: new t.pointGeometry(0, -e3), "bottom-left": new t.pointGeometry(i2, -i2), "bottom-right": new t.pointGeometry(-i2, -i2), left: new t.pointGeometry(e3, 0), right: new t.pointGeometry(-e3, 0) };
              }
              if (e3 instanceof t.pointGeometry || Array.isArray(e3)) {
                const i2 = t.pointGeometry.convert(e3);
                return { center: i2, top: i2, "top-left": i2, "top-right": i2, bottom: i2, "bottom-left": i2, "bottom-right": i2, left: i2, right: i2 };
              }
              return { center: t.pointGeometry.convert(e3.center || [0, 0]), top: t.pointGeometry.convert(e3.top || [0, 0]), "top-left": t.pointGeometry.convert(e3["top-left"] || [0, 0]), "top-right": t.pointGeometry.convert(e3["top-right"] || [0, 0]), bottom: t.pointGeometry.convert(e3.bottom || [0, 0]), "bottom-left": t.pointGeometry.convert(e3["bottom-left"] || [0, 0]), "bottom-right": t.pointGeometry.convert(e3["bottom-right"] || [0, 0]), left: t.pointGeometry.convert(e3.left || [0, 0]), right: t.pointGeometry.convert(e3.right || [0, 0]) };
            }
            return ya(new t.pointGeometry(0, 0));
          }
          const ba = { supported: e, setRTLTextPlugin: t.setRTLTextPlugin, getRTLTextPluginStatus: t.getRTLTextPluginStatus, Map: class extends Qo {
            constructor(e3) {
              var i2;
              if (t.PerformanceUtils.mark(t.PerformanceMarkers.create), null != (e3 = t.extend({}, aa, e3)).minZoom && null != e3.maxZoom && e3.minZoom > e3.maxZoom)
                throw new Error("maxZoom must be greater than or equal to minZoom");
              if (null != e3.minPitch && null != e3.maxPitch && e3.minPitch > e3.maxPitch)
                throw new Error("maxPitch must be greater than or equal to minPitch");
              if (null != e3.minPitch && e3.minPitch < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (null != e3.maxPitch && e3.maxPitch > 85)
                throw new Error("maxPitch must be less than or equal to 85");
              if (super(new io(e3.minZoom, e3.maxZoom, e3.minPitch, e3.maxPitch, e3.renderWorldCopies), { bearingSnap: e3.bearingSnap }), this._interactive = e3.interactive, this._cooperativeGestures = e3.cooperativeGestures, this._maxTileCacheSize = e3.maxTileCacheSize, this._failIfMajorPerformanceCaveat = e3.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e3.preserveDrawingBuffer, this._antialias = e3.antialias, this._trackResize = e3.trackResize, this._bearingSnap = e3.bearingSnap, this._refreshExpiredTiles = e3.refreshExpiredTiles, this._fadeDuration = e3.fadeDuration, this._crossSourceCollisions = e3.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e3.collectResourceTiming, this._renderTaskQueue = new ia(), this._controls = [], this._mapId = t.uniqueId(), this._locale = t.extend({}, oa, e3.locale), this._clickTolerance = e3.clickTolerance, this._pixelRatio = null !== (i2 = e3.pixelRatio) && void 0 !== i2 ? i2 : devicePixelRatio, this._requestManager = new s(e3.transformRequest), "string" == typeof e3.container) {
                if (this._container = document.getElementById(e3.container), !this._container)
                  throw new Error(`Container '${e3.container}' not found.`);
              } else {
                if (!(e3.container instanceof HTMLElement))
                  throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                this._container = e3.container;
              }
              if (e3.maxBounds && this.setMaxBounds(e3.maxBounds), t.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter)
                throw new Error("Failed to initialize WebGL.");
              this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
                this.painter.terrainFacilitator.dirty = true, this._update(true);
              }), "undefined" != typeof window && (addEventListener("online", this._onWindowOnline, false), addEventListener("resize", this._onWindowResize, false), addEventListener("orientationchange", this._onWindowResize, false)), this.handlers = new Yo(this, e3), this._cooperativeGestures && this._setupCooperativeGestures(), this._hash = e3.hash && new oo("string" == typeof e3.hash && e3.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e3.center, zoom: e3.zoom, bearing: e3.bearing, pitch: e3.pitch }), e3.bounds && (this.resize(), this.fitBounds(e3.bounds, t.extend({}, e3.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e3.localIdeographFontFamily, e3.style && this.setStyle(e3.style, { localIdeographFontFamily: e3.localIdeographFontFamily }), e3.attributionControl && this.addControl(new ta({ customAttribution: e3.customAttribution })), e3.maplibreLogo && this.addControl(new ea(), e3.logoPosition), this.on("style.load", () => {
                this.transform.unmodified && this.jumpTo(this.style.stylesheet);
              }), this.on("data", (e4) => {
                this._update("style" === e4.dataType), this.fire(new t.Event(`${e4.dataType}data`, e4));
              }), this.on("dataloading", (e4) => {
                this.fire(new t.Event(`${e4.dataType}dataloading`, e4));
              }), this.on("dataabort", (e4) => {
                this.fire(new t.Event("sourcedataabort", e4));
              });
            }
            _getMapId() {
              return this._mapId;
            }
            addControl(e3, i2) {
              if (void 0 === i2 && (i2 = e3.getDefaultPosition ? e3.getDefaultPosition() : "top-right"), !e3 || !e3.onAdd)
                return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
              const o2 = e3.onAdd(this);
              this._controls.push(e3);
              const a2 = this._controlPositions[i2];
              return -1 !== i2.indexOf("bottom") ? a2.insertBefore(o2, a2.firstChild) : a2.appendChild(o2), this;
            }
            removeControl(e3) {
              if (!e3 || !e3.onRemove)
                return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
              const i2 = this._controls.indexOf(e3);
              return i2 > -1 && this._controls.splice(i2, 1), e3.onRemove(this), this;
            }
            hasControl(t2) {
              return this._controls.indexOf(t2) > -1;
            }
            calculateCameraOptionsFromTo(t2, e3, i2, o2) {
              return null == o2 && this.style.terrain && (o2 = this.transform.getElevation(i2, this.style.terrain)), super.calculateCameraOptionsFromTo(t2, e3, i2, o2);
            }
            resize(e3) {
              const i2 = this._containerDimensions(), o2 = i2[0], a2 = i2[1];
              this._resizeCanvas(o2, a2, this.getPixelRatio()), this.transform.resize(o2, a2), this.painter.resize(o2, a2, this.getPixelRatio());
              const r2 = !this._moving;
              return r2 && (this.stop(), this.fire(new t.Event("movestart", e3)).fire(new t.Event("move", e3))), this.fire(new t.Event("resize", e3)), r2 && this.fire(new t.Event("moveend", e3)), this;
            }
            getPixelRatio() {
              return this._pixelRatio;
            }
            setPixelRatio(t2) {
              const [e3, i2] = this._containerDimensions();
              this._pixelRatio = t2, this._resizeCanvas(e3, i2, t2), this.painter.resize(e3, i2, t2);
            }
            getBounds() {
              return this.transform.getBounds();
            }
            getMaxBounds() {
              return this.transform.getMaxBounds();
            }
            setMaxBounds(e3) {
              return this.transform.setMaxBounds(t.LngLatBounds.convert(e3)), this._update();
            }
            setMinZoom(t2) {
              if ((t2 = null == t2 ? -2 : t2) >= -2 && t2 <= this.transform.maxZoom)
                return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 && this.setZoom(t2), this;
              throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
            }
            getMinZoom() {
              return this.transform.minZoom;
            }
            setMaxZoom(t2) {
              if ((t2 = null == t2 ? 22 : t2) >= this.transform.minZoom)
                return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 && this.setZoom(t2), this;
              throw new Error("maxZoom must be greater than the current minZoom");
            }
            getMaxZoom() {
              return this.transform.maxZoom;
            }
            setMinPitch(t2) {
              if ((t2 = null == t2 ? 0 : t2) < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (t2 >= 0 && t2 <= this.transform.maxPitch)
                return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 && this.setPitch(t2), this;
              throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
            }
            getMinPitch() {
              return this.transform.minPitch;
            }
            setMaxPitch(t2) {
              if ((t2 = null == t2 ? 60 : t2) > 85)
                throw new Error("maxPitch must be less than or equal to 85");
              if (t2 >= this.transform.minPitch)
                return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 && this.setPitch(t2), this;
              throw new Error("maxPitch must be greater than the current minPitch");
            }
            getMaxPitch() {
              return this.transform.maxPitch;
            }
            getRenderWorldCopies() {
              return this.transform.renderWorldCopies;
            }
            setRenderWorldCopies(t2) {
              return this.transform.renderWorldCopies = t2, this._update();
            }
            project(e3) {
              return this.transform.locationPoint(t.LngLat.convert(e3), this.style && this.style.terrain);
            }
            unproject(e3) {
              return this.transform.pointLocation(t.pointGeometry.convert(e3), this.style && this.style.terrain);
            }
            isMoving() {
              return this._moving || this.handlers.isMoving();
            }
            isZooming() {
              return this._zooming || this.handlers.isZooming();
            }
            isRotating() {
              return this._rotating || this.handlers.isRotating();
            }
            _createDelegatedListener(t2, e3, i2) {
              if ("mouseenter" === t2 || "mouseover" === t2) {
                let o2 = false;
                const a2 = (a3) => {
                  const r2 = this.getLayer(e3) ? this.queryRenderedFeatures(a3.point, { layers: [e3] }) : [];
                  r2.length ? o2 || (o2 = true, i2.call(this, new mo(t2, this, a3.originalEvent, { features: r2 }))) : o2 = false;
                };
                return { layer: e3, listener: i2, delegates: { mousemove: a2, mouseout: () => {
                  o2 = false;
                } } };
              }
              if ("mouseleave" === t2 || "mouseout" === t2) {
                let o2 = false;
                const a2 = (a3) => {
                  (this.getLayer(e3) ? this.queryRenderedFeatures(a3.point, { layers: [e3] }) : []).length ? o2 = true : o2 && (o2 = false, i2.call(this, new mo(t2, this, a3.originalEvent)));
                }, r2 = (e4) => {
                  o2 && (o2 = false, i2.call(this, new mo(t2, this, e4.originalEvent)));
                };
                return { layer: e3, listener: i2, delegates: { mousemove: a2, mouseout: r2 } };
              }
              {
                const o2 = (t3) => {
                  const o3 = this.getLayer(e3) ? this.queryRenderedFeatures(t3.point, { layers: [e3] }) : [];
                  o3.length && (t3.features = o3, i2.call(this, t3), delete t3.features);
                };
                return { layer: e3, listener: i2, delegates: { [t2]: o2 } };
              }
            }
            on(t2, e3, i2) {
              if (void 0 === i2)
                return super.on(t2, e3);
              const o2 = this._createDelegatedListener(t2, e3, i2);
              this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t2] = this._delegatedListeners[t2] || [], this._delegatedListeners[t2].push(o2);
              for (const t3 in o2.delegates)
                this.on(t3, o2.delegates[t3]);
              return this;
            }
            once(t2, e3, i2) {
              if (void 0 === i2)
                return super.once(t2, e3);
              const o2 = this._createDelegatedListener(t2, e3, i2);
              for (const t3 in o2.delegates)
                this.once(t3, o2.delegates[t3]);
              return this;
            }
            off(t2, e3, i2) {
              return void 0 === i2 ? super.off(t2, e3) : (this._delegatedListeners && this._delegatedListeners[t2] && ((o2) => {
                const a2 = this._delegatedListeners[t2];
                for (let t3 = 0; t3 < a2.length; t3++) {
                  const o3 = a2[t3];
                  if (o3.layer === e3 && o3.listener === i2) {
                    for (const t4 in o3.delegates)
                      this.off(t4, o3.delegates[t4]);
                    return a2.splice(t3, 1), this;
                  }
                }
              })(), this);
            }
            queryRenderedFeatures(e3, i2) {
              if (!this.style)
                return [];
              let o2;
              if (void 0 !== i2 || void 0 === e3 || e3 instanceof t.pointGeometry || Array.isArray(e3) || (i2 = e3, e3 = void 0), i2 = i2 || {}, (e3 = e3 || [[0, 0], [this.transform.width, this.transform.height]]) instanceof t.pointGeometry || "number" == typeof e3[0])
                o2 = [t.pointGeometry.convert(e3)];
              else {
                const i3 = t.pointGeometry.convert(e3[0]), a2 = t.pointGeometry.convert(e3[1]);
                o2 = [i3, new t.pointGeometry(a2.x, i3.y), a2, new t.pointGeometry(i3.x, a2.y), i3];
              }
              return this.style.queryRenderedFeatures(o2, i2, this.transform);
            }
            querySourceFeatures(t2, e3) {
              return this.style.querySourceFeatures(t2, e3);
            }
            setStyle(e3, i2) {
              return false !== (i2 = t.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily }, i2)).diff && i2.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e3 ? (this._diffStyle(e3, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._updateStyle(e3, i2));
            }
            setTransformRequest(t2) {
              return this._requestManager.setTransformRequest(t2), this;
            }
            _getUIString(t2) {
              const e3 = this._locale[t2];
              if (null == e3)
                throw new Error(`Missing UI string '${t2}'`);
              return e3;
            }
            _updateStyle(t2, e3) {
              return this.style && (this.style.setEventedParent(null), this.style._remove()), t2 ? (this.style = new ee(this, e3 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof t2 ? this.style.loadURL(t2) : this.style.loadJSON(t2), this) : (delete this.style, this);
            }
            _lazyInitEmptyStyle() {
              this.style || (this.style = new ee(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
            }
            _diffStyle(e3, i2) {
              if ("string" == typeof e3) {
                const o2 = this._requestManager.transformRequest(e3, t.ResourceType.Style);
                t.getJSON(o2, (e4, o3) => {
                  e4 ? this.fire(new t.ErrorEvent(e4)) : o3 && this._updateDiff(o3, i2);
                });
              } else
                "object" == typeof e3 && this._updateDiff(e3, i2);
            }
            _updateDiff(e3, i2) {
              try {
                this.style.setState(e3) && this._update(true);
              } catch (o2) {
                t.warnOnce(`Unable to perform style diff: ${o2.message || o2.error || o2}.  Rebuilding the style from scratch.`), this._updateStyle(e3, i2);
              }
            }
            getStyle() {
              if (this.style)
                return this.style.serialize();
            }
            isStyleLoaded() {
              return this.style ? this.style.loaded() : t.warnOnce("There is no style added to the map.");
            }
            addSource(t2, e3) {
              return this._lazyInitEmptyStyle(), this.style.addSource(t2, e3), this._update(true);
            }
            isSourceLoaded(e3) {
              const i2 = this.style && this.style.sourceCaches[e3];
              if (void 0 !== i2)
                return i2.loaded();
              this.fire(new t.ErrorEvent(new Error(`There is no source with ID '${e3}'`)));
            }
            setTerrain(t2) {
              return this.style.setTerrain(t2), this;
            }
            getTerrain() {
              return this.style.terrain && this.style.terrain.options;
            }
            areTilesLoaded() {
              const t2 = this.style && this.style.sourceCaches;
              for (const e3 in t2) {
                const i2 = t2[e3]._tiles;
                for (const t3 in i2) {
                  const e4 = i2[t3];
                  if ("loaded" !== e4.state && "errored" !== e4.state)
                    return false;
                }
              }
              return true;
            }
            addSourceType(t2, e3, i2) {
              return this._lazyInitEmptyStyle(), this.style.addSourceType(t2, e3, i2);
            }
            removeSource(t2) {
              return this.style.removeSource(t2), this._update(true);
            }
            getSource(t2) {
              return this.style.getSource(t2);
            }
            addImage(e3, i2, { pixelRatio: o2 = 1, sdf: a2 = false, stretchX: r2, stretchY: s2, content: n2 } = {}) {
              if (this._lazyInitEmptyStyle(), i2 instanceof HTMLImageElement || t.isImageBitmap(i2)) {
                const { width: l2, height: c2, data: h2 } = t.exported.getImageData(i2);
                this.style.addImage(e3, { data: new t.RGBAImage({ width: l2, height: c2 }, h2), pixelRatio: o2, stretchX: r2, stretchY: s2, content: n2, sdf: a2, version: 0 });
              } else {
                if (void 0 === i2.width || void 0 === i2.height)
                  return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                {
                  const { width: l2, height: c2, data: h2 } = i2, u2 = i2;
                  this.style.addImage(e3, { data: new t.RGBAImage({ width: l2, height: c2 }, new Uint8Array(h2)), pixelRatio: o2, stretchX: r2, stretchY: s2, content: n2, sdf: a2, version: 0, userImage: u2 }), u2.onAdd && u2.onAdd(this, e3);
                }
              }
            }
            updateImage(e3, i2) {
              const o2 = this.style.getImage(e3);
              if (!o2)
                return this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
              const a2 = i2 instanceof HTMLImageElement || t.isImageBitmap(i2) ? t.exported.getImageData(i2) : i2, { width: r2, height: s2, data: n2 } = a2;
              if (void 0 === r2 || void 0 === s2)
                return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              if (r2 !== o2.data.width || s2 !== o2.data.height)
                return this.fire(new t.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image")));
              const l2 = !(i2 instanceof HTMLImageElement || t.isImageBitmap(i2));
              o2.data.replace(n2, l2), this.style.updateImage(e3, o2);
            }
            hasImage(e3) {
              return e3 ? !!this.style.getImage(e3) : (this.fire(new t.ErrorEvent(new Error("Missing required image id"))), false);
            }
            removeImage(t2) {
              this.style.removeImage(t2);
            }
            loadImage(e3, i2) {
              t.getImage(this._requestManager.transformRequest(e3, t.ResourceType.Image), i2);
            }
            listImages() {
              return this.style.listImages();
            }
            addLayer(t2, e3) {
              return this._lazyInitEmptyStyle(), this.style.addLayer(t2, e3), this._update(true);
            }
            moveLayer(t2, e3) {
              return this.style.moveLayer(t2, e3), this._update(true);
            }
            removeLayer(t2) {
              return this.style.removeLayer(t2), this._update(true);
            }
            getLayer(t2) {
              return this.style.getLayer(t2);
            }
            setLayerZoomRange(t2, e3, i2) {
              return this.style.setLayerZoomRange(t2, e3, i2), this._update(true);
            }
            setFilter(t2, e3, i2 = {}) {
              return this.style.setFilter(t2, e3, i2), this._update(true);
            }
            getFilter(t2) {
              return this.style.getFilter(t2);
            }
            setPaintProperty(t2, e3, i2, o2 = {}) {
              return this.style.setPaintProperty(t2, e3, i2, o2), this._update(true);
            }
            getPaintProperty(t2, e3) {
              return this.style.getPaintProperty(t2, e3);
            }
            setLayoutProperty(t2, e3, i2, o2 = {}) {
              return this.style.setLayoutProperty(t2, e3, i2, o2), this._update(true);
            }
            getLayoutProperty(t2, e3) {
              return this.style.getLayoutProperty(t2, e3);
            }
            setLight(t2, e3 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setLight(t2, e3), this._update(true);
            }
            getLight() {
              return this.style.getLight();
            }
            setFeatureState(t2, e3) {
              return this.style.setFeatureState(t2, e3), this._update();
            }
            removeFeatureState(t2, e3) {
              return this.style.removeFeatureState(t2, e3), this._update();
            }
            getFeatureState(t2) {
              return this.style.getFeatureState(t2);
            }
            getContainer() {
              return this._container;
            }
            getCanvasContainer() {
              return this._canvasContainer;
            }
            getCanvas() {
              return this._canvas;
            }
            _containerDimensions() {
              let t2 = 0, e3 = 0;
              return this._container && (t2 = this._container.clientWidth || 400, e3 = this._container.clientHeight || 300), [t2, e3];
            }
            _setupContainer() {
              const t2 = this._container;
              t2.classList.add("maplibregl-map", "mapboxgl-map");
              const e3 = this._canvasContainer = r.create("div", "maplibregl-canvas-container mapboxgl-canvas-container", t2);
              this._interactive && e3.classList.add("maplibregl-interactive", "mapboxgl-interactive"), this._canvas = r.create("canvas", "maplibregl-canvas mapboxgl-canvas", e3), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
              const i2 = this._containerDimensions();
              this._resizeCanvas(i2[0], i2[1], this.getPixelRatio());
              const o2 = this._controlContainer = r.create("div", "maplibregl-control-container mapboxgl-control-container", t2), a2 = this._controlPositions = {};
              ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t3) => {
                a2[t3] = r.create("div", `maplibregl-ctrl-${t3} mapboxgl-ctrl-${t3}`, o2);
              }), this._container.addEventListener("scroll", this._onMapScroll, false);
            }
            _setupCooperativeGestures() {
              const t2 = this._container;
              this._metaPress = false, this._cooperativeGesturesScreen = r.create("div", "maplibregl-cooperative-gesture-screen", t2);
              let e3 = "Control", i2 = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.windowsHelpText ? this._cooperativeGestures.windowsHelpText : "Use Ctrl + scroll to zoom the map";
              0 === navigator.platform.indexOf("Mac") && (i2 = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.macHelpText ? this._cooperativeGestures.macHelpText : "Use \u2318 + scroll to zoom the map", e3 = "Meta"), this._cooperativeGesturesScreen.innerHTML = `
            <div class="maplibregl-desktop-message">${i2}</div>
            <div class="maplibregl-mobile-message">${"boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.mobileHelpText ? this._cooperativeGestures.mobileHelpText : "Use two fingers to move the map"}</div>
        `, document.addEventListener("keydown", (t3) => {
                t3.key === e3 && (this._metaPress = true);
              }), document.addEventListener("keyup", (t3) => {
                t3.key === e3 && (this._metaPress = false);
              }), this._canvasContainer.addEventListener("wheel", (t3) => {
                this._onCooperativeGesture(t3, this._metaPress, 1);
              }, false), this._canvasContainer.classList.remove("mapboxgl-touch-drag-pan", "maplibregl-touch-drag-pan");
            }
            _resizeCanvas(t2, e3, i2) {
              this._canvas.width = i2 * t2, this._canvas.height = i2 * e3, this._canvas.style.width = `${t2}px`, this._canvas.style.height = `${e3}px`;
            }
            _setupPainter() {
              const i2 = t.extend({}, e.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o2 = this._canvas.getContext("webgl", i2) || this._canvas.getContext("experimental-webgl", i2);
              o2 ? (this.painter = new Ji(o2, this.transform), t.exported$1.testSupport(o2)) : this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")));
            }
            _contextLost(e3) {
              e3.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t.Event("webglcontextlost", { originalEvent: e3 }));
            }
            _contextRestored(e3) {
              this._setupPainter(), this.resize(), this._update(), this.fire(new t.Event("webglcontextrestored", { originalEvent: e3 }));
            }
            _onMapScroll(t2) {
              if (t2.target === this._container)
                return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }
            _onCooperativeGesture(t2, e3, i2) {
              return !e3 && i2 < 2 && (this._cooperativeGesturesScreen.classList.add("maplibregl-show"), setTimeout(() => {
                this._cooperativeGesturesScreen.classList.remove("maplibregl-show");
              }, 100)), false;
            }
            loaded() {
              return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
            }
            _update(t2) {
              return this.style ? (this._styleDirty = this._styleDirty || t2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
            }
            _requestRenderFrame(t2) {
              return this._update(), this._renderTaskQueue.add(t2);
            }
            _cancelRenderFrame(t2) {
              this._renderTaskQueue.remove(t2);
            }
            _render(e3) {
              let i2, o2 = 0;
              const a2 = this.painter.context.extTimerQuery;
              if (this.listens("gpu-timing-frame") && (i2 = a2.createQueryEXT(), a2.beginQueryEXT(a2.TIME_ELAPSED_EXT, i2), o2 = t.exported.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e3), this._removed)
                return;
              let r2 = false;
              if (this.style && this._styleDirty) {
                this._styleDirty = false;
                const e4 = this.transform.zoom, i3 = t.exported.now();
                this.style.zoomHistory.update(e4, i3);
                const o3 = new t.EvaluationParameters(e4, { now: i3, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), a3 = o3.crossFadingFactor();
                1 === a3 && a3 === this._crossFadingFactor || (r2 = true, this._crossFadingFactor = a3), this.style.update(o3);
              }
              if (this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.style.terrain && this.style.terrain.sourceCache.update(this.transform, this.style.terrain), this.transform.updateElevation(this.style.terrain), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: this._fadeDuration, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer") }), this.fire(new t.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, t.PerformanceUtils.mark(t.PerformanceMarkers.load), this.fire(new t.Event("load"))), this.style && (this.style.hasTransitions() || r2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
                const e4 = t.exported.now() - o2;
                a2.endQueryEXT(a2.TIME_ELAPSED_EXT, i2), setTimeout(() => {
                  const o3 = a2.getQueryObjectEXT(i2, a2.QUERY_RESULT_EXT) / 1e6;
                  a2.deleteQueryEXT(i2), this.fire(new t.Event("gpu-timing-frame", { cpuTime: e4, gpuTime: o3 }));
                }, 50);
              }
              if (this.listens("gpu-timing-layer")) {
                const e4 = this.painter.collectGpuTimers();
                setTimeout(() => {
                  const i3 = this.painter.queryGpuTimers(e4);
                  this.fire(new t.Event("gpu-timing-layer", { layerTimes: i3 }));
                }, 50);
              }
              const s2 = this._sourcesDirty || this._styleDirty || this._placementDirty;
              return s2 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.Event("idle")), !this._loaded || this._fullyLoaded || s2 || (this._fullyLoaded = true, t.PerformanceUtils.mark(t.PerformanceMarkers.fullLoad)), this;
            }
            redraw() {
              return this.style && (this._frame && (this._frame.cancel(), this._frame = null), this._render(0)), this;
            }
            remove() {
              this._hash && this._hash.remove();
              for (const t2 of this._controls)
                t2.onRemove(this);
              this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && (removeEventListener("resize", this._onWindowResize, false), removeEventListener("orientationchange", this._onWindowResize, false), removeEventListener("online", this._onWindowOnline, false));
              const e3 = this.painter.context.gl.getExtension("WEBGL_lose_context");
              e3 && e3.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), r.remove(this._canvasContainer), r.remove(this._controlContainer), this._cooperativeGestures && r.remove(this._cooperativeGesturesScreen), this._container.classList.remove("maplibregl-map", "mapboxgl-map"), t.PerformanceUtils.clearMetrics(), this._removed = true, this.fire(new t.Event("remove"));
            }
            triggerRepaint() {
              this.style && !this._frame && (this._frame = t.exported.frame((e3) => {
                t.PerformanceUtils.frame(e3), this._frame = null, this._render(e3);
              }));
            }
            _onWindowOnline() {
              this._update();
            }
            _onWindowResize(t2) {
              this._trackResize && this.resize({ originalEvent: t2 })._update();
            }
            get showTileBoundaries() {
              return !!this._showTileBoundaries;
            }
            set showTileBoundaries(t2) {
              this._showTileBoundaries !== t2 && (this._showTileBoundaries = t2, this._update());
            }
            get showPadding() {
              return !!this._showPadding;
            }
            set showPadding(t2) {
              this._showPadding !== t2 && (this._showPadding = t2, this._update());
            }
            get showCollisionBoxes() {
              return !!this._showCollisionBoxes;
            }
            set showCollisionBoxes(t2) {
              this._showCollisionBoxes !== t2 && (this._showCollisionBoxes = t2, t2 ? this.style._generateCollisionBoxes() : this._update());
            }
            get showOverdrawInspector() {
              return !!this._showOverdrawInspector;
            }
            set showOverdrawInspector(t2) {
              this._showOverdrawInspector !== t2 && (this._showOverdrawInspector = t2, this._update());
            }
            get repaint() {
              return !!this._repaint;
            }
            set repaint(t2) {
              this._repaint !== t2 && (this._repaint = t2, this.triggerRepaint());
            }
            get vertices() {
              return !!this._vertices;
            }
            set vertices(t2) {
              this._vertices = t2, this._update();
            }
            _setCacheLimits(e3, i2) {
              t.setCacheLimits(e3, i2);
            }
            get version() {
              return "2.4.0";
            }
          }, NavigationControl: class {
            constructor(e3) {
              this.options = t.extend({}, ra, e3), this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (t2) => t2.preventDefault()), this.options.showZoom && (t.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in mapboxgl-ctrl-zoom-in", (t2) => this._map.zoomIn({}, { originalEvent: t2 })), r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out mapboxgl-ctrl-zoom-out", (t2) => this._map.zoomOut({}, { originalEvent: t2 })), r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (t.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("maplibregl-ctrl-compass mapboxgl-ctrl-compass", (t2) => {
                this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t2 }) : this._map.resetNorth({}, { originalEvent: t2 });
              }), this._compassIcon = r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
            }
            _updateZoomButtons() {
              const t2 = this._map.getZoom(), e3 = t2 === this._map.getMaxZoom(), i2 = t2 === this._map.getMinZoom();
              this._zoomInButton.disabled = e3, this._zoomOutButton.disabled = i2, this._zoomInButton.setAttribute("aria-disabled", e3.toString()), this._zoomOutButton.setAttribute("aria-disabled", i2.toString());
            }
            _rotateCompassArrow() {
              const t2 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
              this._compassIcon.style.transform = t2;
            }
            onAdd(t2) {
              return this._map = t2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new sa(this._map, this._compass, this.options.visualizePitch)), this._container;
            }
            onRemove() {
              r.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
            }
            _createButton(t2, e3) {
              const i2 = r.create("button", t2, this._container);
              return i2.type = "button", i2.addEventListener("click", e3), i2;
            }
            _setButtonTitle(t2, e3) {
              const i2 = this._map._getUIString(`NavigationControl.${e3}`);
              t2.title = i2, t2.setAttribute("aria-label", i2);
            }
          }, GeolocateControl: class extends t.Evented {
            constructor(e3) {
              super(), this.options = t.extend({}, ua, e3), t.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this);
            }
            onAdd(t2) {
              var e3;
              return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), e3 = this._setupUI, void 0 !== da ? e3(da) : void 0 !== window.navigator.permissions ? window.navigator.permissions.query({ name: "geolocation" }).then((t3) => {
                da = "denied" !== t3.state, e3(da);
              }) : (da = !!window.navigator.geolocation, e3(da)), this._container;
            }
            onRemove() {
              void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), r.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, ma = 0, _a = false;
            }
            _isOutOfMapMaxBounds(t2) {
              const e3 = this._map.getMaxBounds(), i2 = t2.coords;
              return e3 && (i2.longitude < e3.getWest() || i2.longitude > e3.getEast() || i2.latitude < e3.getSouth() || i2.latitude > e3.getNorth());
            }
            _setErrorState() {
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "ACTIVE_LOCK":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting");
                  break;
                case "BACKGROUND":
                  this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting");
                  break;
                case "ACTIVE_ERROR":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
            }
            _onSuccess(e3) {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e3))
                  return this._setErrorState(), this.fire(new t.Event("outofmaxbounds", e3)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation)
                  switch (this._lastKnownPosition = e3, this._watchState) {
                    case "WAITING_ACTIVE":
                    case "ACTIVE_LOCK":
                    case "ACTIVE_ERROR":
                      this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
                      break;
                    case "BACKGROUND":
                    case "BACKGROUND_ERROR":
                      this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background");
                      break;
                    default:
                      throw new Error(`Unexpected watchState ${this._watchState}`);
                  }
                this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e3), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e3), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale", "mapboxgl-user-location-dot-stale"), this.fire(new t.Event("geolocate", e3)), this._finish();
              }
            }
            _updateCamera(e3) {
              const i2 = new t.LngLat(e3.coords.longitude, e3.coords.latitude), o2 = e3.coords.accuracy, a2 = this._map.getBearing(), r2 = t.extend({ bearing: a2 }, this.options.fitBoundsOptions);
              this._map.fitBounds(i2.toBounds(o2), r2, { geolocateSource: true });
            }
            _updateMarker(e3) {
              if (e3) {
                const i2 = new t.LngLat(e3.coords.longitude, e3.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = e3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else
                this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }
            _updateCircleRadius() {
              const t2 = this._map._container.clientHeight / 2, e3 = this._map.unproject([0, t2]), i2 = this._map.unproject([1, t2]), o2 = e3.distanceTo(i2), a2 = Math.ceil(2 * this._accuracy / o2);
              this._circleElement.style.width = `${a2}px`, this._circleElement.style.height = `${a2}px`;
            }
            _onZoom() {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }
            _onError(e3) {
              if (this._map) {
                if (this.options.trackUserLocation)
                  if (1 === e3.code) {
                    this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                    const t2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                    this._geolocateButton.title = t2, this._geolocateButton.setAttribute("aria-label", t2), void 0 !== this._geolocationWatchID && this._clearWatch();
                  } else {
                    if (3 === e3.code && _a)
                      return;
                    this._setErrorState();
                  }
                "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale", "mapboxgl-user-location-dot-stale"), this.fire(new t.Event("error", e3)), this._finish();
              }
            }
            _finish() {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }
            _setupUI(e3) {
              if (this._container.addEventListener("contextmenu", (t2) => t2.preventDefault()), this._geolocateButton = r.create("button", "maplibregl-ctrl-geolocate mapboxgl-ctrl-geolocate", this._container), r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === e3) {
                t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                const e4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = true, this._geolocateButton.title = e4, this._geolocateButton.setAttribute("aria-label", e4);
              } else {
                const t2 = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.title = t2, this._geolocateButton.setAttribute("aria-label", t2);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = r.create("div", "maplibregl-user-location-dot mapboxgl-user-location-dot"), this._userLocationDotMarker = new ha(this._dotElement), this._circleElement = r.create("div", "maplibregl-user-location-accuracy-circle mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ha({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (e4) => {
                e4.geolocateSource || "ACTIVE_LOCK" !== this._watchState || e4.originalEvent && "resize" === e4.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this.fire(new t.Event("trackuserlocationend")));
              });
            }
            trigger() {
              if (!this._setup)
                return t.warnOnce("Geolocate control triggered before added to a map"), false;
              if (this.options.trackUserLocation) {
                switch (this._watchState) {
                  case "OFF":
                    this._watchState = "WAITING_ACTIVE", this.fire(new t.Event("trackuserlocationstart"));
                    break;
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                  case "BACKGROUND_ERROR":
                    ma--, _a = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error", "mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error", "mapboxgl-ctrl-geolocate-background-error"), this.fire(new t.Event("trackuserlocationend"));
                    break;
                  case "BACKGROUND":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background", "mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.Event("trackuserlocationstart"));
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                switch (this._watchState) {
                  case "WAITING_ACTIVE":
                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
                    break;
                  case "ACTIVE_LOCK":
                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active", "mapboxgl-ctrl-geolocate-active");
                    break;
                  case "OFF":
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                  this._clearWatch();
                else if (void 0 === this._geolocationWatchID) {
                  let t2;
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ma++, ma > 1 ? (t2 = { maximumAge: 6e5, timeout: 0 }, _a = true) : (t2 = this.options.positionOptions, _a = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t2);
                }
              } else
                window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
              return true;
            }
            _clearWatch() {
              window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting", "mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
            }
          }, AttributionControl: ta, LogoControl: ea, ScaleControl: class {
            constructor(e3) {
              this.options = t.extend({}, pa, e3), t.bindAll(["_onMove", "setUnit"], this);
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            _onMove() {
              fa(this._map, this._container, this.options);
            }
            onAdd(t2) {
              return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-scale mapboxgl-ctrl mapboxgl-ctrl-scale", t2.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
            }
            onRemove() {
              r.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
            }
            setUnit(t2) {
              this.options.unit = t2, fa(this._map, this._container, this.options);
            }
          }, FullscreenControl: class {
            constructor(e3) {
              this._fullscreen = false, e3 && e3.container && (e3.container instanceof HTMLElement ? this._container = e3.container : t.warnOnce("Full screen control 'container' must be a DOM element.")), t.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
            }
            onAdd(e3) {
              return this._map = e3, this._container || (this._container = this._map.getContainer()), this._controlContainer = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", t.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
            }
            onRemove() {
              r.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
            }
            _checkFullscreenSupport() {
              return !!(document.fullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled || document.webkitFullscreenEnabled);
            }
            _setupUI() {
              const t2 = this._fullscreenButton = r.create("button", "maplibregl-ctrl-fullscreen mapboxgl-ctrl-fullscreen", this._controlContainer);
              r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", t2).setAttribute("aria-hidden", "true"), t2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._changeIcon);
            }
            _updateTitle() {
              const t2 = this._getTitle();
              this._fullscreenButton.setAttribute("aria-label", t2), this._fullscreenButton.title = t2;
            }
            _getTitle() {
              return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
            }
            _isFullscreen() {
              return this._fullscreen;
            }
            _changeIcon() {
              (window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
            }
            _onClickFullscreen() {
              this._isFullscreen() ? window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen && window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
            }
          }, TerrainControl: class {
            constructor(e3) {
              this.options = e3, t.bindAll(["_toggleTerrain", "_updateTerrainIcon"], this);
            }
            onAdd(t2) {
              return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group mapboxgl-ctrl mapboxgl-ctrl-group"), this._terrainButton = r.create("button", "maplibregl-ctrl-terrain mapboxgl-ctrl-terrain", this._container), r.create("span", "maplibregl-ctrl-icon mapboxgl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
            }
            onRemove() {
              r.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
            }
            _toggleTerrain() {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }
            _updateTerrainIcon() {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain", "mapboxgl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled", "mapboxgl-ctrl-terrain-enabled"), this._map.style.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled", "mapboxgl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.disableTerrain")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain", "mapboxgl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.enableTerrain"));
            }
          }, Popup: class extends t.Evented {
            constructor(e3) {
              super(), this.options = t.extend(Object.create(xa), e3), t.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);
            }
            addTo(e3) {
              return this._map && this.remove(), this._map = e3, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer", "mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.Event("open")), this;
            }
            isOpen() {
              return !!this._map;
            }
            remove() {
              return this._content && r.remove(this._content), this._container && (r.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t.Event("close")), this;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(e3) {
              return this._lngLat = t.LngLat.convert(e3), this._pos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer", "mapboxgl-track-pointer")), this;
            }
            trackPointer() {
              return this._trackPointer = true, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer", "mapboxgl-track-pointer")), this;
            }
            getElement() {
              return this._container;
            }
            setText(t2) {
              return this.setDOMContent(document.createTextNode(t2));
            }
            setHTML(t2) {
              const e3 = document.createDocumentFragment(), i2 = document.createElement("body");
              let o2;
              for (i2.innerHTML = t2; o2 = i2.firstChild, o2; )
                e3.appendChild(o2);
              return this.setDOMContent(e3);
            }
            getMaxWidth() {
              return this._container && this._container.style.maxWidth;
            }
            setMaxWidth(t2) {
              return this.options.maxWidth = t2, this._update(), this;
            }
            setDOMContent(t2) {
              if (this._content)
                for (; this._content.hasChildNodes(); )
                  this._content.firstChild && this._content.removeChild(this._content.firstChild);
              else
                this._content = r.create("div", "maplibregl-popup-content mapboxgl-popup-content", this._container);
              return this._content.appendChild(t2), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
            }
            addClassName(t2) {
              this._container && this._container.classList.add(t2);
            }
            removeClassName(t2) {
              this._container && this._container.classList.remove(t2);
            }
            setOffset(t2) {
              return this.options.offset = t2, this._update(), this;
            }
            toggleClassName(t2) {
              if (this._container)
                return this._container.classList.toggle(t2);
            }
            _createCloseButton() {
              this.options.closeButton && (this._closeButton = r.create("button", "maplibregl-popup-close-button mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
            }
            _onMouseUp(t2) {
              this._update(t2.point);
            }
            _onMouseMove(t2) {
              this._update(t2.point);
            }
            _onDrag(t2) {
              this._update(t2.point);
            }
            _update(t2) {
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content)
                return;
              if (this._container || (this._container = r.create("div", "maplibregl-popup mapboxgl-popup", this._map.getContainer()), this._tip = r.create("div", "maplibregl-popup-tip mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach((t3) => this._container.classList.add(t3)), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer", "mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = na(this._lngLat, this._pos, this._map.transform)), this._trackPointer && !t2)
                return;
              const e3 = this._pos = this._trackPointer && t2 ? t2 : this._map.project(this._lngLat);
              let i2 = this.options.anchor;
              const o2 = ya(this.options.offset);
              if (!i2) {
                const t3 = this._container.offsetWidth, a3 = this._container.offsetHeight;
                let r2;
                r2 = e3.y + o2.bottom.y < a3 ? ["top"] : e3.y > this._map.transform.height - a3 ? ["bottom"] : [], e3.x < t3 / 2 ? r2.push("left") : e3.x > this._map.transform.width - t3 / 2 && r2.push("right"), i2 = 0 === r2.length ? "bottom" : r2.join("-");
              }
              const a2 = e3.add(o2[i2]).round();
              r.setTransform(this._container, `${la[i2]} translate(${a2.x}px,${a2.y}px)`), ca(this._container, i2, "popup");
            }
            _focusFirstElement() {
              if (!this.options.focusAfterOpen || !this._container)
                return;
              const t2 = this._container.querySelector(va);
              t2 && t2.focus();
            }
            _onClose() {
              this.remove();
            }
          }, Marker: ha, Style: ee, LngLat: t.LngLat, LngLatBounds: t.LngLatBounds, Point: t.pointGeometry, MercatorCoordinate: t.MercatorCoordinate, Evented: t.Evented, AJAXError: t.AJAXError, config: t.config, CanvasSource: P, GeoJSONSource: C, ImageSource: D, RasterDEMTileSource: I, RasterTileSource: T, VectorTileSource: w, VideoSource: z, prewarm: function() {
            j().acquire(G);
          }, clearPrewarmedResources: function() {
            const t2 = q;
            t2 && (t2.isPreloaded() && 1 === t2.numActive() ? (t2.release(G), q = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
          }, get version() {
            return "2.4.0";
          }, get workerCount() {
            return Z.workerCount;
          }, set workerCount(t2) {
            Z.workerCount = t2;
          }, get maxParallelImageRequests() {
            return t.config.MAX_PARALLEL_IMAGE_REQUESTS;
          }, set maxParallelImageRequests(e3) {
            t.config.MAX_PARALLEL_IMAGE_REQUESTS = e3;
          }, clearStorage(e3) {
            t.clearTileCache(e3);
          }, workerUrl: "", addProtocol(e3, i2) {
            t.config.REGISTERED_PROTOCOLS[e3] = i2;
          }, removeProtocol(e3) {
            delete t.config.REGISTERED_PROTOCOLS[e3];
          } };
          return Jo.extend(ba, { isSafari: t.isSafari, getPerformanceMetrics: t.PerformanceUtils.getPerformanceMetrics }), ba;
        });
        var maplibregl$1 = maplibregl;
        return maplibregl$1;
      });
    }
  });

  // node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "node_modules/object-assign/index.js"(exports, module) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty2 = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = shouldUseNative() ? Object.assign : function(target, source) {
        var from;
        var to = toObject(target);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from = Object(arguments[s]);
          for (var key in from) {
            if (hasOwnProperty2.call(from, key)) {
              to[key] = from[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from, symbols[i])) {
                to[symbols[i]] = from[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }
  });

  // node_modules/concaveman/node_modules/rbush/rbush.min.js
  var require_rbush_min = __commonJS({
    "node_modules/concaveman/node_modules/rbush/rbush.min.js"(exports, module) {
      !function(t, i) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = t || self).RBush = i();
      }(exports, function() {
        "use strict";
        function t(t2, r2, e3, a2, h2) {
          !function t3(n2, r3, e4, a3, h3) {
            for (; a3 > e4; ) {
              if (a3 - e4 > 600) {
                var o2 = a3 - e4 + 1, s2 = r3 - e4 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u2 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m2 = Math.max(e4, Math.floor(r3 - s2 * f2 / o2 + u2)), c2 = Math.min(a3, Math.floor(r3 + (o2 - s2) * f2 / o2 + u2));
                t3(n2, r3, m2, c2, h3);
              }
              var p2 = n2[r3], d2 = e4, x2 = a3;
              for (i(n2, e4, r3), h3(n2[a3], p2) > 0 && i(n2, e4, a3); d2 < x2; ) {
                for (i(n2, d2, x2), d2++, x2--; h3(n2[d2], p2) < 0; )
                  d2++;
                for (; h3(n2[x2], p2) > 0; )
                  x2--;
              }
              0 === h3(n2[e4], p2) ? i(n2, e4, x2) : i(n2, ++x2, a3), x2 <= r3 && (e4 = x2 + 1), r3 <= x2 && (a3 = x2 - 1);
            }
          }(t2, r2, e3 || 0, a2 || t2.length - 1, h2 || n);
        }
        function i(t2, i2, n2) {
          var r2 = t2[i2];
          t2[i2] = t2[n2], t2[n2] = r2;
        }
        function n(t2, i2) {
          return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
        }
        var r = function(t2) {
          void 0 === t2 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
        };
        function e(t2, i2, n2) {
          if (!n2)
            return i2.indexOf(t2);
          for (var r2 = 0; r2 < i2.length; r2++)
            if (n2(t2, i2[r2]))
              return r2;
          return -1;
        }
        function a(t2, i2) {
          h(t2, 0, t2.children.length, i2, t2);
        }
        function h(t2, i2, n2, r2, e3) {
          e3 || (e3 = p(null)), e3.minX = 1 / 0, e3.minY = 1 / 0, e3.maxX = -1 / 0, e3.maxY = -1 / 0;
          for (var a2 = i2; a2 < n2; a2++) {
            var h2 = t2.children[a2];
            o(e3, t2.leaf ? r2(h2) : h2);
          }
          return e3;
        }
        function o(t2, i2) {
          return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
        }
        function s(t2, i2) {
          return t2.minX - i2.minX;
        }
        function l(t2, i2) {
          return t2.minY - i2.minY;
        }
        function f(t2) {
          return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
        }
        function u(t2) {
          return t2.maxX - t2.minX + (t2.maxY - t2.minY);
        }
        function m(t2, i2) {
          return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
        }
        function c(t2, i2) {
          return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
        }
        function p(t2) {
          return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        }
        function d(i2, n2, r2, e3, a2) {
          for (var h2 = [n2, r2]; h2.length; )
            if (!((r2 = h2.pop()) - (n2 = h2.pop()) <= e3)) {
              var o2 = n2 + Math.ceil((r2 - n2) / e3 / 2) * e3;
              t(i2, o2, n2, r2, a2), h2.push(n2, o2, o2, r2);
            }
        }
        return r.prototype.all = function() {
          return this._all(this.data, []);
        }, r.prototype.search = function(t2) {
          var i2 = this.data, n2 = [];
          if (!c(t2, i2))
            return n2;
          for (var r2 = this.toBBox, e3 = []; i2; ) {
            for (var a2 = 0; a2 < i2.children.length; a2++) {
              var h2 = i2.children[a2], o2 = i2.leaf ? r2(h2) : h2;
              c(t2, o2) && (i2.leaf ? n2.push(h2) : m(t2, o2) ? this._all(h2, n2) : e3.push(h2));
            }
            i2 = e3.pop();
          }
          return n2;
        }, r.prototype.collides = function(t2) {
          var i2 = this.data;
          if (!c(t2, i2))
            return false;
          for (var n2 = []; i2; ) {
            for (var r2 = 0; r2 < i2.children.length; r2++) {
              var e3 = i2.children[r2], a2 = i2.leaf ? this.toBBox(e3) : e3;
              if (c(t2, a2)) {
                if (i2.leaf || m(t2, a2))
                  return true;
                n2.push(e3);
              }
            }
            i2 = n2.pop();
          }
          return false;
        }, r.prototype.load = function(t2) {
          if (!t2 || !t2.length)
            return this;
          if (t2.length < this._minEntries) {
            for (var i2 = 0; i2 < t2.length; i2++)
              this.insert(t2[i2]);
            return this;
          }
          var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
          if (this.data.children.length)
            if (this.data.height === n2.height)
              this._splitRoot(this.data, n2);
            else {
              if (this.data.height < n2.height) {
                var r2 = this.data;
                this.data = n2, n2 = r2;
              }
              this._insert(n2, this.data.height - n2.height - 1, true);
            }
          else
            this.data = n2;
          return this;
        }, r.prototype.insert = function(t2) {
          return t2 && this._insert(t2, this.data.height - 1), this;
        }, r.prototype.clear = function() {
          return this.data = p([]), this;
        }, r.prototype.remove = function(t2, i2) {
          if (!t2)
            return this;
          for (var n2, r2, a2, h2 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h2 || s2.length; ) {
            if (h2 || (h2 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a2 = true), h2.leaf) {
              var f2 = e(t2, h2.children, i2);
              if (-1 !== f2)
                return h2.children.splice(f2, 1), s2.push(h2), this._condense(s2), this;
            }
            a2 || h2.leaf || !m(h2, o2) ? r2 ? (n2++, h2 = r2.children[n2], a2 = false) : h2 = null : (s2.push(h2), l2.push(n2), n2 = 0, r2 = h2, h2 = h2.children[0]);
          }
          return this;
        }, r.prototype.toBBox = function(t2) {
          return t2;
        }, r.prototype.compareMinX = function(t2, i2) {
          return t2.minX - i2.minX;
        }, r.prototype.compareMinY = function(t2, i2) {
          return t2.minY - i2.minY;
        }, r.prototype.toJSON = function() {
          return this.data;
        }, r.prototype.fromJSON = function(t2) {
          return this.data = t2, this;
        }, r.prototype._all = function(t2, i2) {
          for (var n2 = []; t2; )
            t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
          return i2;
        }, r.prototype._build = function(t2, i2, n2, r2) {
          var e3, h2 = n2 - i2 + 1, o2 = this._maxEntries;
          if (h2 <= o2)
            return a(e3 = p(t2.slice(i2, n2 + 1)), this.toBBox), e3;
          r2 || (r2 = Math.ceil(Math.log(h2) / Math.log(o2)), o2 = Math.ceil(h2 / Math.pow(o2, r2 - 1))), (e3 = p([])).leaf = false, e3.height = r2;
          var s2 = Math.ceil(h2 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
          d(t2, i2, n2, l2, this.compareMinX);
          for (var f2 = i2; f2 <= n2; f2 += l2) {
            var u2 = Math.min(f2 + l2 - 1, n2);
            d(t2, f2, u2, s2, this.compareMinY);
            for (var m2 = f2; m2 <= u2; m2 += s2) {
              var c2 = Math.min(m2 + s2 - 1, u2);
              e3.children.push(this._build(t2, m2, c2, r2 - 1));
            }
          }
          return a(e3, this.toBBox), e3;
        }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
          for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
            for (var e3 = 1 / 0, a2 = 1 / 0, h2 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
              var s2 = i2.children[o2], l2 = f(s2), u2 = (m2 = t2, c2 = s2, (Math.max(c2.maxX, m2.maxX) - Math.min(c2.minX, m2.minX)) * (Math.max(c2.maxY, m2.maxY) - Math.min(c2.minY, m2.minY)) - l2);
              u2 < a2 ? (a2 = u2, e3 = l2 < e3 ? l2 : e3, h2 = s2) : u2 === a2 && l2 < e3 && (e3 = l2, h2 = s2);
            }
            i2 = h2 || i2.children[0];
          }
          var m2, c2;
          return i2;
        }, r.prototype._insert = function(t2, i2, n2) {
          var r2 = n2 ? t2 : this.toBBox(t2), e3 = [], a2 = this._chooseSubtree(r2, this.data, i2, e3);
          for (a2.children.push(t2), o(a2, r2); i2 >= 0 && e3[i2].children.length > this._maxEntries; )
            this._split(e3, i2), i2--;
          this._adjustParentBBoxes(r2, e3, i2);
        }, r.prototype._split = function(t2, i2) {
          var n2 = t2[i2], r2 = n2.children.length, e3 = this._minEntries;
          this._chooseSplitAxis(n2, e3, r2);
          var h2 = this._chooseSplitIndex(n2, e3, r2), o2 = p(n2.children.splice(h2, n2.children.length - h2));
          o2.height = n2.height, o2.leaf = n2.leaf, a(n2, this.toBBox), a(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
        }, r.prototype._splitRoot = function(t2, i2) {
          this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a(this.data, this.toBBox);
        }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
          for (var r2, e3, a2, o2, s2, l2, u2, m2 = 1 / 0, c2 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
            var d2 = h(t2, 0, p2, this.toBBox), x2 = h(t2, p2, n2, this.toBBox), v = (e3 = d2, a2 = x2, o2 = void 0, s2 = void 0, l2 = void 0, u2 = void 0, o2 = Math.max(e3.minX, a2.minX), s2 = Math.max(e3.minY, a2.minY), l2 = Math.min(e3.maxX, a2.maxX), u2 = Math.min(e3.maxY, a2.maxY), Math.max(0, l2 - o2) * Math.max(0, u2 - s2)), M = f(d2) + f(x2);
            v < m2 ? (m2 = v, r2 = p2, c2 = M < c2 ? M : c2) : v === m2 && M < c2 && (c2 = M, r2 = p2);
          }
          return r2 || n2 - i2;
        }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
          var r2 = t2.leaf ? this.compareMinX : s, e3 = t2.leaf ? this.compareMinY : l;
          this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e3) && t2.children.sort(r2);
        }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
          t2.children.sort(r2);
          for (var e3 = this.toBBox, a2 = h(t2, 0, i2, e3), s2 = h(t2, n2 - i2, n2, e3), l2 = u(a2) + u(s2), f2 = i2; f2 < n2 - i2; f2++) {
            var m2 = t2.children[f2];
            o(a2, t2.leaf ? e3(m2) : m2), l2 += u(a2);
          }
          for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
            var p2 = t2.children[c2];
            o(s2, t2.leaf ? e3(p2) : p2), l2 += u(s2);
          }
          return l2;
        }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
          for (var r2 = n2; r2 >= 0; r2--)
            o(i2[r2], t2);
        }, r.prototype._condense = function(t2) {
          for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--)
            0 === t2[i2].children.length ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a(t2[i2], this.toBBox);
        }, r;
      });
    }
  });

  // node_modules/tinyqueue/tinyqueue.js
  var require_tinyqueue = __commonJS({
    "node_modules/tinyqueue/tinyqueue.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = global || self, global.TinyQueue = factory());
      })(exports, function() {
        "use strict";
        var TinyQueue = function TinyQueue2(data, compare) {
          if (data === void 0)
            data = [];
          if (compare === void 0)
            compare = defaultCompare;
          this.data = data;
          this.length = this.data.length;
          this.compare = compare;
          if (this.length > 0) {
            for (var i = (this.length >> 1) - 1; i >= 0; i--) {
              this._down(i);
            }
          }
        };
        TinyQueue.prototype.push = function push(item) {
          this.data.push(item);
          this.length++;
          this._up(this.length - 1);
        };
        TinyQueue.prototype.pop = function pop() {
          if (this.length === 0) {
            return void 0;
          }
          var top = this.data[0];
          var bottom = this.data.pop();
          this.length--;
          if (this.length > 0) {
            this.data[0] = bottom;
            this._down(0);
          }
          return top;
        };
        TinyQueue.prototype.peek = function peek() {
          return this.data[0];
        };
        TinyQueue.prototype._up = function _up(pos) {
          var ref = this;
          var data = ref.data;
          var compare = ref.compare;
          var item = data[pos];
          while (pos > 0) {
            var parent = pos - 1 >> 1;
            var current = data[parent];
            if (compare(item, current) >= 0) {
              break;
            }
            data[pos] = current;
            pos = parent;
          }
          data[pos] = item;
        };
        TinyQueue.prototype._down = function _down(pos) {
          var ref = this;
          var data = ref.data;
          var compare = ref.compare;
          var halfLength = this.length >> 1;
          var item = data[pos];
          while (pos < halfLength) {
            var left = (pos << 1) + 1;
            var best = data[left];
            var right = left + 1;
            if (right < this.length && compare(data[right], best) < 0) {
              left = right;
              best = data[right];
            }
            if (compare(best, item) >= 0) {
              break;
            }
            data[pos] = best;
            pos = left;
          }
          data[pos] = item;
        };
        function defaultCompare(a, b) {
          return a < b ? -1 : a > b ? 1 : 0;
        }
        return TinyQueue;
      });
    }
  });

  // node_modules/point-in-polygon/flat.js
  var require_flat = __commonJS({
    "node_modules/point-in-polygon/flat.js"(exports, module) {
      module.exports = function pointInPolygonFlat(point2, vs, start, end) {
        var x2 = point2[0], y2 = point2[1];
        var inside = false;
        if (start === void 0)
          start = 0;
        if (end === void 0)
          end = vs.length;
        var len = (end - start) / 2;
        for (var i = 0, j = len - 1; i < len; j = i++) {
          var xi = vs[start + i * 2 + 0], yi = vs[start + i * 2 + 1];
          var xj = vs[start + j * 2 + 0], yj = vs[start + j * 2 + 1];
          var intersect2 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
          if (intersect2)
            inside = !inside;
        }
        return inside;
      };
    }
  });

  // node_modules/point-in-polygon/nested.js
  var require_nested = __commonJS({
    "node_modules/point-in-polygon/nested.js"(exports, module) {
      module.exports = function pointInPolygonNested(point2, vs, start, end) {
        var x2 = point2[0], y2 = point2[1];
        var inside = false;
        if (start === void 0)
          start = 0;
        if (end === void 0)
          end = vs.length;
        var len = end - start;
        for (var i = 0, j = len - 1; i < len; j = i++) {
          var xi = vs[i + start][0], yi = vs[i + start][1];
          var xj = vs[j + start][0], yj = vs[j + start][1];
          var intersect2 = yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi;
          if (intersect2)
            inside = !inside;
        }
        return inside;
      };
    }
  });

  // node_modules/point-in-polygon/index.js
  var require_point_in_polygon = __commonJS({
    "node_modules/point-in-polygon/index.js"(exports, module) {
      var pointInPolygonFlat = require_flat();
      var pointInPolygonNested = require_nested();
      module.exports = function pointInPolygon(point2, vs, start, end) {
        if (vs.length > 0 && Array.isArray(vs[0])) {
          return pointInPolygonNested(point2, vs, start, end);
        } else {
          return pointInPolygonFlat(point2, vs, start, end);
        }
      };
      module.exports.nested = pointInPolygonNested;
      module.exports.flat = pointInPolygonFlat;
    }
  });

  // node_modules/robust-predicates/umd/orient2d.min.js
  var require_orient2d_min = __commonJS({
    "node_modules/robust-predicates/umd/orient2d.min.js"(exports, module) {
      !function(t, e) {
        "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = t || self).predicates = {});
      }(exports, function(t) {
        "use strict";
        const e = 134217729, n = 33306690738754706e-32;
        function r(t2, e3, n2, r2, o2) {
          let f2, i2, u2, c2, s2 = e3[0], a2 = r2[0], d2 = 0, l2 = 0;
          a2 > s2 == a2 > -s2 ? (f2 = s2, s2 = e3[++d2]) : (f2 = a2, a2 = r2[++l2]);
          let p = 0;
          if (d2 < t2 && l2 < n2)
            for (a2 > s2 == a2 > -s2 ? (u2 = f2 - ((i2 = s2 + f2) - s2), s2 = e3[++d2]) : (u2 = f2 - ((i2 = a2 + f2) - a2), a2 = r2[++l2]), f2 = i2, 0 !== u2 && (o2[p++] = u2); d2 < t2 && l2 < n2; )
              a2 > s2 == a2 > -s2 ? (u2 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e3[++d2]) : (u2 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2]), f2 = i2, 0 !== u2 && (o2[p++] = u2);
          for (; d2 < t2; )
            u2 = f2 - ((i2 = f2 + s2) - (c2 = i2 - f2)) + (s2 - c2), s2 = e3[++d2], f2 = i2, 0 !== u2 && (o2[p++] = u2);
          for (; l2 < n2; )
            u2 = f2 - ((i2 = f2 + a2) - (c2 = i2 - f2)) + (a2 - c2), a2 = r2[++l2], f2 = i2, 0 !== u2 && (o2[p++] = u2);
          return 0 === f2 && 0 !== p || (o2[p++] = f2), p;
        }
        function o(t2) {
          return new Float64Array(t2);
        }
        const f = 33306690738754716e-32, i = 22204460492503146e-32, u = 11093356479670487e-47, c = o(4), s = o(8), a = o(12), d = o(16), l = o(4);
        t.orient2d = function(t2, o2, p, b, y2, h) {
          const M = (o2 - h) * (p - y2), x2 = (t2 - y2) * (b - h), j = M - x2;
          if (0 === M || 0 === x2 || M > 0 != x2 > 0)
            return j;
          const m = Math.abs(M + x2);
          return Math.abs(j) >= f * m ? j : -function(t3, o3, f2, p2, b2, y3, h2) {
            let M2, x3, j2, m2, _, v, w, A, F, O, P, g, k, q, z, B2, C, D;
            const E = t3 - b2, G = f2 - b2, H = o3 - y3, I = p2 - y3;
            _ = (z = (A = E - (w = (v = e * E) - (v - E))) * (O = I - (F = (v = e * I) - (v - I))) - ((q = E * I) - w * F - A * F - w * O)) - (P = z - (C = (A = H - (w = (v = e * H) - (v - H))) * (O = G - (F = (v = e * G) - (v - G))) - ((B2 = H * G) - w * F - A * F - w * O))), c[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), c[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, c[2] = g - (D - _) + (P - _), c[3] = D;
            let J = function(t4, e3) {
              let n2 = e3[0];
              for (let r2 = 1; r2 < t4; r2++)
                n2 += e3[r2];
              return n2;
            }(4, c), K = i * h2;
            if (J >= K || -J >= K)
              return J;
            if (M2 = t3 - (E + (_ = t3 - E)) + (_ - b2), j2 = f2 - (G + (_ = f2 - G)) + (_ - b2), x3 = o3 - (H + (_ = o3 - H)) + (_ - y3), m2 = p2 - (I + (_ = p2 - I)) + (_ - y3), 0 === M2 && 0 === x3 && 0 === j2 && 0 === m2)
              return J;
            if (K = u * h2 + n * Math.abs(J), (J += E * m2 + I * M2 - (H * j2 + G * x3)) >= K || -J >= K)
              return J;
            _ = (z = (A = M2 - (w = (v = e * M2) - (v - M2))) * (O = I - (F = (v = e * I) - (v - I))) - ((q = M2 * I) - w * F - A * F - w * O)) - (P = z - (C = (A = x3 - (w = (v = e * x3) - (v - x3))) * (O = G - (F = (v = e * G) - (v - G))) - ((B2 = x3 * G) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
            const L = r(4, c, 4, l, s);
            _ = (z = (A = E - (w = (v = e * E) - (v - E))) * (O = m2 - (F = (v = e * m2) - (v - m2))) - ((q = E * m2) - w * F - A * F - w * O)) - (P = z - (C = (A = H - (w = (v = e * H) - (v - H))) * (O = j2 - (F = (v = e * j2) - (v - j2))) - ((B2 = H * j2) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
            const N = r(L, s, 4, l, a);
            _ = (z = (A = M2 - (w = (v = e * M2) - (v - M2))) * (O = m2 - (F = (v = e * m2) - (v - m2))) - ((q = M2 * m2) - w * F - A * F - w * O)) - (P = z - (C = (A = x3 - (w = (v = e * x3) - (v - x3))) * (O = j2 - (F = (v = e * j2) - (v - j2))) - ((B2 = x3 * j2) - w * F - A * F - w * O))), l[0] = z - (P + _) + (_ - C), _ = (k = q - ((g = q + P) - (_ = g - q)) + (P - _)) - (P = k - B2), l[1] = k - (P + _) + (_ - B2), _ = (D = g + P) - g, l[2] = g - (D - _) + (P - _), l[3] = D;
            const Q = r(N, a, 4, l, d);
            return d[Q - 1];
          }(t2, o2, p, b, y2, h, m);
        }, t.orient2dfast = function(t2, e3, n2, r2, o2, f2) {
          return (e3 - f2) * (n2 - o2) - (t2 - o2) * (r2 - f2);
        }, Object.defineProperty(t, "__esModule", { value: true });
      });
    }
  });

  // node_modules/concaveman/index.js
  var require_concaveman = __commonJS({
    "node_modules/concaveman/index.js"(exports, module) {
      "use strict";
      var RBush = require_rbush_min();
      var Queue = require_tinyqueue();
      var pointInPolygon = require_point_in_polygon();
      var orient = require_orient2d_min().orient2d;
      if (Queue.default) {
        Queue = Queue.default;
      }
      module.exports = concaveman2;
      module.exports.default = concaveman2;
      function concaveman2(points, concavity, lengthThreshold) {
        concavity = Math.max(0, concavity === void 0 ? 2 : concavity);
        lengthThreshold = lengthThreshold || 0;
        var hull = fastConvexHull(points);
        var tree = new RBush(16);
        tree.toBBox = function(a2) {
          return {
            minX: a2[0],
            minY: a2[1],
            maxX: a2[0],
            maxY: a2[1]
          };
        };
        tree.compareMinX = function(a2, b2) {
          return a2[0] - b2[0];
        };
        tree.compareMinY = function(a2, b2) {
          return a2[1] - b2[1];
        };
        tree.load(points);
        var queue = [];
        for (var i = 0, last; i < hull.length; i++) {
          var p = hull[i];
          tree.remove(p);
          last = insertNode(p, last);
          queue.push(last);
        }
        var segTree = new RBush(16);
        for (i = 0; i < queue.length; i++)
          segTree.insert(updateBBox(queue[i]));
        var sqConcavity = concavity * concavity;
        var sqLenThreshold = lengthThreshold * lengthThreshold;
        while (queue.length) {
          var node = queue.shift();
          var a = node.p;
          var b = node.next.p;
          var sqLen = getSqDist(a, b);
          if (sqLen < sqLenThreshold)
            continue;
          var maxSqLen = sqLen / sqConcavity;
          p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);
          if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {
            queue.push(node);
            queue.push(insertNode(p, node));
            tree.remove(p);
            segTree.remove(node);
            segTree.insert(updateBBox(node));
            segTree.insert(updateBBox(node.next));
          }
        }
        node = last;
        var concave = [];
        do {
          concave.push(node.p);
          node = node.next;
        } while (node !== last);
        concave.push(node.p);
        return concave;
      }
      function findCandidate(tree, a, b, c, d, maxDist, segTree) {
        var queue = new Queue([], compareDist);
        var node = tree.data;
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);
            if (dist > maxDist)
              continue;
            queue.push({
              node: child,
              dist
            });
          }
          while (queue.length && !queue.peek().node.children) {
            var item = queue.pop();
            var p = item.node;
            var d0 = sqSegDist(p, a, b);
            var d1 = sqSegDist(p, c, d);
            if (item.dist < d0 && item.dist < d1 && noIntersections(b, p, segTree) && noIntersections(c, p, segTree))
              return p;
          }
          node = queue.pop();
          if (node)
            node = node.node;
        }
        return null;
      }
      function compareDist(a, b) {
        return a.dist - b.dist;
      }
      function sqSegBoxDist(a, b, bbox3) {
        if (inside(a, bbox3) || inside(b, bbox3))
          return 0;
        var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.minX, bbox3.minY, bbox3.maxX, bbox3.minY);
        if (d1 === 0)
          return 0;
        var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.minX, bbox3.minY, bbox3.minX, bbox3.maxY);
        if (d2 === 0)
          return 0;
        var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.maxX, bbox3.minY, bbox3.maxX, bbox3.maxY);
        if (d3 === 0)
          return 0;
        var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox3.minX, bbox3.maxY, bbox3.maxX, bbox3.maxY);
        if (d4 === 0)
          return 0;
        return Math.min(d1, d2, d3, d4);
      }
      function inside(a, bbox3) {
        return a[0] >= bbox3.minX && a[0] <= bbox3.maxX && a[1] >= bbox3.minY && a[1] <= bbox3.maxY;
      }
      function noIntersections(a, b, segTree) {
        var minX = Math.min(a[0], b[0]);
        var minY = Math.min(a[1], b[1]);
        var maxX = Math.max(a[0], b[0]);
        var maxY = Math.max(a[1], b[1]);
        var edges2 = segTree.search({ minX, minY, maxX, maxY });
        for (var i = 0; i < edges2.length; i++) {
          if (intersects2(edges2[i].p, edges2[i].next.p, a, b))
            return false;
        }
        return true;
      }
      function cross(p1, p2, p3) {
        return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
      }
      function intersects2(p1, q1, p2, q2) {
        return p1 !== q2 && q1 !== p2 && cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 && cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;
      }
      function updateBBox(node) {
        var p1 = node.p;
        var p2 = node.next.p;
        node.minX = Math.min(p1[0], p2[0]);
        node.minY = Math.min(p1[1], p2[1]);
        node.maxX = Math.max(p1[0], p2[0]);
        node.maxY = Math.max(p1[1], p2[1]);
        return node;
      }
      function fastConvexHull(points) {
        var left = points[0];
        var top = points[0];
        var right = points[0];
        var bottom = points[0];
        for (var i = 0; i < points.length; i++) {
          var p = points[i];
          if (p[0] < left[0])
            left = p;
          if (p[0] > right[0])
            right = p;
          if (p[1] < top[1])
            top = p;
          if (p[1] > bottom[1])
            bottom = p;
        }
        var cull = [left, top, right, bottom];
        var filtered = cull.slice();
        for (i = 0; i < points.length; i++) {
          if (!pointInPolygon(points[i], cull))
            filtered.push(points[i]);
        }
        return convexHull(filtered);
      }
      function insertNode(p, prev) {
        var node = {
          p,
          prev: null,
          next: null,
          minX: 0,
          minY: 0,
          maxX: 0,
          maxY: 0
        };
        if (!prev) {
          node.prev = node;
          node.next = node;
        } else {
          node.next = prev.next;
          node.prev = prev;
          prev.next.prev = node;
          prev.next = node;
        }
        return node;
      }
      function getSqDist(p1, p2) {
        var dx = p1[0] - p2[0], dy = p1[1] - p2[1];
        return dx * dx + dy * dy;
      }
      function sqSegDist(p, p1, p2) {
        var x2 = p1[0], y2 = p1[1], dx = p2[0] - x2, dy = p2[1] - y2;
        if (dx !== 0 || dy !== 0) {
          var t = ((p[0] - x2) * dx + (p[1] - y2) * dy) / (dx * dx + dy * dy);
          if (t > 1) {
            x2 = p2[0];
            y2 = p2[1];
          } else if (t > 0) {
            x2 += dx * t;
            y2 += dy * t;
          }
        }
        dx = p[0] - x2;
        dy = p[1] - y2;
        return dx * dx + dy * dy;
      }
      function sqSegSegDist(x02, y0, x12, y1, x2, y2, x3, y3) {
        var ux = x12 - x02;
        var uy = y1 - y0;
        var vx = x3 - x2;
        var vy = y3 - y2;
        var wx = x02 - x2;
        var wy = y0 - y2;
        var a = ux * ux + uy * uy;
        var b = ux * vx + uy * vy;
        var c = vx * vx + vy * vy;
        var d = ux * wx + uy * wy;
        var e = vx * wx + vy * wy;
        var D = a * c - b * b;
        var sc, sN, tc, tN;
        var sD = D;
        var tD = D;
        if (D === 0) {
          sN = 0;
          sD = 1;
          tN = e;
          tD = c;
        } else {
          sN = b * e - c * d;
          tN = a * e - b * d;
          if (sN < 0) {
            sN = 0;
            tN = e;
            tD = c;
          } else if (sN > sD) {
            sN = sD;
            tN = e + b;
            tD = c;
          }
        }
        if (tN < 0) {
          tN = 0;
          if (-d < 0)
            sN = 0;
          else if (-d > a)
            sN = sD;
          else {
            sN = -d;
            sD = a;
          }
        } else if (tN > tD) {
          tN = tD;
          if (-d + b < 0)
            sN = 0;
          else if (-d + b > a)
            sN = sD;
          else {
            sN = -d + b;
            sD = a;
          }
        }
        sc = sN === 0 ? 0 : sN / sD;
        tc = tN === 0 ? 0 : tN / tD;
        var cx = (1 - sc) * x02 + sc * x12;
        var cy = (1 - sc) * y0 + sc * y1;
        var cx2 = (1 - tc) * x2 + tc * x3;
        var cy2 = (1 - tc) * y2 + tc * y3;
        var dx = cx2 - cx;
        var dy = cy2 - cy;
        return dx * dx + dy * dy;
      }
      function compareByX(a, b) {
        return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];
      }
      function convexHull(points) {
        points.sort(compareByX);
        var lower = [];
        for (var i = 0; i < points.length; i++) {
          while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
            lower.pop();
          }
          lower.push(points[i]);
        }
        var upper = [];
        for (var ii = points.length - 1; ii >= 0; ii--) {
          while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0) {
            upper.pop();
          }
          upper.push(points[ii]);
        }
        upper.pop();
        lower.pop();
        return lower.concat(upper);
      }
    }
  });

  // node_modules/rbush/node_modules/quickselect/quickselect.js
  var require_quickselect = __commonJS({
    "node_modules/rbush/node_modules/quickselect/quickselect.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.quickselect = factory();
      })(exports, function() {
        "use strict";
        function quickselect(arr, k, left, right, compare) {
          quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
        }
        function quickselectStep(arr, k, left, right, compare) {
          while (right > left) {
            if (right - left > 600) {
              var n = right - left + 1;
              var m = k - left + 1;
              var z = Math.log(n);
              var s = 0.5 * Math.exp(2 * z / 3);
              var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
              quickselectStep(arr, k, newLeft, newRight, compare);
            }
            var t = arr[k];
            var i = left;
            var j = right;
            swap(arr, left, k);
            if (compare(arr[right], t) > 0)
              swap(arr, left, right);
            while (i < j) {
              swap(arr, i, j);
              i++;
              j--;
              while (compare(arr[i], t) < 0)
                i++;
              while (compare(arr[j], t) > 0)
                j--;
            }
            if (compare(arr[left], t) === 0)
              swap(arr, left, j);
            else {
              j++;
              swap(arr, j, right);
            }
            if (j <= k)
              left = j + 1;
            if (k <= j)
              right = j - 1;
          }
        }
        function swap(arr, i, j) {
          var tmp = arr[i];
          arr[i] = arr[j];
          arr[j] = tmp;
        }
        function defaultCompare(a, b) {
          return a < b ? -1 : a > b ? 1 : 0;
        }
        return quickselect;
      });
    }
  });

  // node_modules/rbush/index.js
  var require_rbush = __commonJS({
    "node_modules/rbush/index.js"(exports, module) {
      "use strict";
      module.exports = rbush6;
      module.exports.default = rbush6;
      var quickselect = require_quickselect();
      function rbush6(maxEntries, format) {
        if (!(this instanceof rbush6))
          return new rbush6(maxEntries, format);
        this._maxEntries = Math.max(4, maxEntries || 9);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        if (format) {
          this._initFormat(format);
        }
        this.clear();
      }
      rbush6.prototype = {
        all: function() {
          return this._all(this.data, []);
        },
        search: function(bbox3) {
          var node = this.data, result = [], toBBox = this.toBBox;
          if (!intersects2(bbox3, node))
            return result;
          var nodesToSearch = [], i, len, child, childBBox;
          while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              childBBox = node.leaf ? toBBox(child) : child;
              if (intersects2(bbox3, childBBox)) {
                if (node.leaf)
                  result.push(child);
                else if (contains(bbox3, childBBox))
                  this._all(child, result);
                else
                  nodesToSearch.push(child);
              }
            }
            node = nodesToSearch.pop();
          }
          return result;
        },
        collides: function(bbox3) {
          var node = this.data, toBBox = this.toBBox;
          if (!intersects2(bbox3, node))
            return false;
          var nodesToSearch = [], i, len, child, childBBox;
          while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              childBBox = node.leaf ? toBBox(child) : child;
              if (intersects2(bbox3, childBBox)) {
                if (node.leaf || contains(bbox3, childBBox))
                  return true;
                nodesToSearch.push(child);
              }
            }
            node = nodesToSearch.pop();
          }
          return false;
        },
        load: function(data) {
          if (!(data && data.length))
            return this;
          if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
              this.insert(data[i]);
            }
            return this;
          }
          var node = this._build(data.slice(), 0, data.length - 1, 0);
          if (!this.data.children.length) {
            this.data = node;
          } else if (this.data.height === node.height) {
            this._splitRoot(this.data, node);
          } else {
            if (this.data.height < node.height) {
              var tmpNode = this.data;
              this.data = node;
              node = tmpNode;
            }
            this._insert(node, this.data.height - node.height - 1, true);
          }
          return this;
        },
        insert: function(item) {
          if (item)
            this._insert(item, this.data.height - 1);
          return this;
        },
        clear: function() {
          this.data = createNode([]);
          return this;
        },
        remove: function(item, equalsFn) {
          if (!item)
            return this;
          var node = this.data, bbox3 = this.toBBox(item), path = [], indexes = [], i, parent, index, goingUp;
          while (node || path.length) {
            if (!node) {
              node = path.pop();
              parent = path[path.length - 1];
              i = indexes.pop();
              goingUp = true;
            }
            if (node.leaf) {
              index = findItem(item, node.children, equalsFn);
              if (index !== -1) {
                node.children.splice(index, 1);
                path.push(node);
                this._condense(path);
                return this;
              }
            }
            if (!goingUp && !node.leaf && contains(node, bbox3)) {
              path.push(node);
              indexes.push(i);
              i = 0;
              parent = node;
              node = node.children[0];
            } else if (parent) {
              i++;
              node = parent.children[i];
              goingUp = false;
            } else
              node = null;
          }
          return this;
        },
        toBBox: function(item) {
          return item;
        },
        compareMinX: compareNodeMinX,
        compareMinY: compareNodeMinY,
        toJSON: function() {
          return this.data;
        },
        fromJSON: function(data) {
          this.data = data;
          return this;
        },
        _all: function(node, result) {
          var nodesToSearch = [];
          while (node) {
            if (node.leaf)
              result.push.apply(result, node.children);
            else
              nodesToSearch.push.apply(nodesToSearch, node.children);
            node = nodesToSearch.pop();
          }
          return result;
        },
        _build: function(items, left, right, height) {
          var N = right - left + 1, M = this._maxEntries, node;
          if (N <= M) {
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
          }
          if (!height) {
            height = Math.ceil(Math.log(N) / Math.log(M));
            M = Math.ceil(N / Math.pow(M, height - 1));
          }
          node = createNode([]);
          node.leaf = false;
          node.height = height;
          var N2 = Math.ceil(N / M), N1 = N2 * Math.ceil(Math.sqrt(M)), i, j, right2, right3;
          multiSelect(items, left, right, N1, this.compareMinX);
          for (i = left; i <= right; i += N1) {
            right2 = Math.min(i + N1 - 1, right);
            multiSelect(items, i, right2, N2, this.compareMinY);
            for (j = i; j <= right2; j += N2) {
              right3 = Math.min(j + N2 - 1, right2);
              node.children.push(this._build(items, j, right3, height - 1));
            }
          }
          calcBBox(node, this.toBBox);
          return node;
        },
        _chooseSubtree: function(bbox3, node, level, path) {
          var i, len, child, targetNode, area2, enlargement, minArea, minEnlargement;
          while (true) {
            path.push(node);
            if (node.leaf || path.length - 1 === level)
              break;
            minArea = minEnlargement = Infinity;
            for (i = 0, len = node.children.length; i < len; i++) {
              child = node.children[i];
              area2 = bboxArea(child);
              enlargement = enlargedArea(bbox3, child) - area2;
              if (enlargement < minEnlargement) {
                minEnlargement = enlargement;
                minArea = area2 < minArea ? area2 : minArea;
                targetNode = child;
              } else if (enlargement === minEnlargement) {
                if (area2 < minArea) {
                  minArea = area2;
                  targetNode = child;
                }
              }
            }
            node = targetNode || node.children[0];
          }
          return node;
        },
        _insert: function(item, level, isNode) {
          var toBBox = this.toBBox, bbox3 = isNode ? item : toBBox(item), insertPath = [];
          var node = this._chooseSubtree(bbox3, this.data, level, insertPath);
          node.children.push(item);
          extend(node, bbox3);
          while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
              this._split(insertPath, level);
              level--;
            } else
              break;
          }
          this._adjustParentBBoxes(bbox3, insertPath, level);
        },
        // split overflowed node into two
        _split: function(insertPath, level) {
          var node = insertPath[level], M = node.children.length, m = this._minEntries;
          this._chooseSplitAxis(node, m, M);
          var splitIndex = this._chooseSplitIndex(node, m, M);
          var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
          newNode.height = node.height;
          newNode.leaf = node.leaf;
          calcBBox(node, this.toBBox);
          calcBBox(newNode, this.toBBox);
          if (level)
            insertPath[level - 1].children.push(newNode);
          else
            this._splitRoot(node, newNode);
        },
        _splitRoot: function(node, newNode) {
          this.data = createNode([node, newNode]);
          this.data.height = node.height + 1;
          this.data.leaf = false;
          calcBBox(this.data, this.toBBox);
        },
        _chooseSplitIndex: function(node, m, M) {
          var i, bbox1, bbox22, overlap, area2, minOverlap, minArea, index;
          minOverlap = minArea = Infinity;
          for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox22 = distBBox(node, i, M, this.toBBox);
            overlap = intersectionArea(bbox1, bbox22);
            area2 = bboxArea(bbox1) + bboxArea(bbox22);
            if (overlap < minOverlap) {
              minOverlap = overlap;
              index = i;
              minArea = area2 < minArea ? area2 : minArea;
            } else if (overlap === minOverlap) {
              if (area2 < minArea) {
                minArea = area2;
                index = i;
              }
            }
          }
          return index;
        },
        // sorts node children by the best axis for split
        _chooseSplitAxis: function(node, m, M) {
          var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX, compareMinY = node.leaf ? this.compareMinY : compareNodeMinY, xMargin = this._allDistMargin(node, m, M, compareMinX), yMargin = this._allDistMargin(node, m, M, compareMinY);
          if (xMargin < yMargin)
            node.children.sort(compareMinX);
        },
        // total margin of all possible split distributions where each node is at least m full
        _allDistMargin: function(node, m, M, compare) {
          node.children.sort(compare);
          var toBBox = this.toBBox, leftBBox = distBBox(node, 0, m, toBBox), rightBBox = distBBox(node, M - m, M, toBBox), margin = bboxMargin(leftBBox) + bboxMargin(rightBBox), i, child;
          for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
          }
          for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
          }
          return margin;
        },
        _adjustParentBBoxes: function(bbox3, path, level) {
          for (var i = level; i >= 0; i--) {
            extend(path[i], bbox3);
          }
        },
        _condense: function(path) {
          for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
              if (i > 0) {
                siblings = path[i - 1].children;
                siblings.splice(siblings.indexOf(path[i]), 1);
              } else
                this.clear();
            } else
              calcBBox(path[i], this.toBBox);
          }
        },
        _initFormat: function(format) {
          var compareArr = ["return a", " - b", ";"];
          this.compareMinX = new Function("a", "b", compareArr.join(format[0]));
          this.compareMinY = new Function("a", "b", compareArr.join(format[1]));
          this.toBBox = new Function(
            "a",
            "return {minX: a" + format[0] + ", minY: a" + format[1] + ", maxX: a" + format[2] + ", maxY: a" + format[3] + "};"
          );
        }
      };
      function findItem(item, items, equalsFn) {
        if (!equalsFn)
          return items.indexOf(item);
        for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i]))
            return i;
        }
        return -1;
      }
      function calcBBox(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
      }
      function distBBox(node, k, p, toBBox, destNode) {
        if (!destNode)
          destNode = createNode(null);
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;
        for (var i = k, child; i < p; i++) {
          child = node.children[i];
          extend(destNode, node.leaf ? toBBox(child) : child);
        }
        return destNode;
      }
      function extend(a, b) {
        a.minX = Math.min(a.minX, b.minX);
        a.minY = Math.min(a.minY, b.minY);
        a.maxX = Math.max(a.maxX, b.maxX);
        a.maxY = Math.max(a.maxY, b.maxY);
        return a;
      }
      function compareNodeMinX(a, b) {
        return a.minX - b.minX;
      }
      function compareNodeMinY(a, b) {
        return a.minY - b.minY;
      }
      function bboxArea(a) {
        return (a.maxX - a.minX) * (a.maxY - a.minY);
      }
      function bboxMargin(a) {
        return a.maxX - a.minX + (a.maxY - a.minY);
      }
      function enlargedArea(a, b) {
        return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
      }
      function intersectionArea(a, b) {
        var minX = Math.max(a.minX, b.minX), minY = Math.max(a.minY, b.minY), maxX = Math.min(a.maxX, b.maxX), maxY = Math.min(a.maxY, b.maxY);
        return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
      }
      function contains(a, b) {
        return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
      }
      function intersects2(a, b) {
        return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
      }
      function createNode(children) {
        return {
          children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
        };
      }
      function multiSelect(arr, left, right, n, compare) {
        var stack = [left, right], mid;
        while (stack.length) {
          right = stack.pop();
          left = stack.pop();
          if (right - left <= n)
            continue;
          mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr, mid, left, right, compare);
          stack.push(left, mid, mid, right);
        }
      }
    }
  });

  // node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "node_modules/earcut/src/earcut.js"(exports, module) {
      "use strict";
      module.exports = earcut2;
      module.exports.default = earcut2;
      function earcut2(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x2, y2, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i = dim; i < outerLen; i += dim) {
            x2 = data[i];
            y2 = data[i + 1];
            if (x2 < minX)
              minX = x2;
            if (y2 < minY)
              minY = y2;
            if (x2 > maxX)
              maxX = x2;
            if (y2 > maxY)
              maxY = y2;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
      }
      function linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === signedArea(data, start, end, dim) > 0) {
          for (i = start; i < end; i += dim)
            last = insertNode(i, data[i], data[i + 1], last);
        } else {
          for (i = end - dim; i >= start; i -= dim)
            last = insertNode(i, data[i], data[i + 1], last);
        }
        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        var p = start, again;
        do {
          again = false;
          if (!p.steiner && (equals(p, p.next) || area2(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next)
              break;
            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area2(a, b, c) >= 0)
          return false;
        var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
        var x02 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x12 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var p = c.next;
        while (p !== a) {
          if (p.x >= x02 && p.x <= x12 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
            return false;
          p = p.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area2(a, b, c) >= 0)
          return false;
        var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
        var x02 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x12 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var minZ = zOrder(x02, y0, minX, minY, invSize), maxZ = zOrder(x12, y1, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ;
        while (p && p.z >= minZ && n && n.z <= maxZ) {
          if (p.x >= x02 && p.x <= x12 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
          if (n.x >= x02 && n.x <= x12 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        while (p && p.z >= minZ) {
          if (p.x >= x02 && p.x <= x12 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
        }
        while (n && n.z <= maxZ) {
          if (n.x >= x02 && n.x <= x12 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
          var a = p.prev, b = p.next.next;
          if (!equals(a, b) && intersects2(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);
            removeNode(p);
            removeNode(p.next);
            p = start = b;
          }
          p = p.next;
        } while (p !== start);
        return filterPoints(p);
      }
      function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        var a = start;
        do {
          var b = a.next.next;
          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
              var c = splitPolygon(a, b);
              a = filterPoints(a, a.next);
              c = filterPoints(c, c.next);
              earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
              earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
              return;
            }
            b = b.next;
          }
          a = a.next;
        } while (a !== start);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
          start = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i = 0; i < queue.length; i++) {
          outerNode = eliminateHole(queue[i], outerNode);
        }
        return outerNode;
      }
      function compareX(a, b) {
        return a.x - b.x;
      }
      function eliminateHole(hole, outerNode) {
        var bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon(bridge, hole);
        filterPoints(bridgeReverse, bridgeReverse.next);
        return filterPoints(bridge, bridge.next);
      }
      function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        do {
          if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x2 = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x2 <= hx && x2 > qx) {
              qx = x2;
              m = p.x < p.next.x ? p : p.next;
              if (x2 === hx)
                return m;
            }
          }
          p = p.next;
        } while (p !== outerNode);
        if (!m)
          return null;
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan2;
        p = m;
        do {
          if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan2 = Math.abs(hy - p.y) / (hx - p.x);
            if (locallyInside(p, hole) && (tan2 < tanMin || tan2 === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
              m = p;
              tanMin = tan2;
            }
          }
          p = p.next;
        } while (p !== stop);
        return m;
      }
      function sectorContainsSector(m, p) {
        return area2(m.prev, m, p.prev) < 0 && area2(p.next, m, m.next) < 0;
      }
      function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
          if (p.z === 0)
            p.z = zOrder(p.x, p.y, minX, minY, invSize);
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }
      function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e;
              else
                list = e;
              e.prevZ = tail;
              tail = e;
            }
            p = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x2, y2, minX, minY, invSize) {
        x2 = (x2 - minX) * invSize | 0;
        y2 = (y2 - minY) * invSize | 0;
        x2 = (x2 | x2 << 8) & 16711935;
        x2 = (x2 | x2 << 4) & 252645135;
        x2 = (x2 | x2 << 2) & 858993459;
        x2 = (x2 | x2 << 1) & 1431655765;
        y2 = (y2 | y2 << 8) & 16711935;
        y2 = (y2 | y2 << 4) & 252645135;
        y2 = (y2 | y2 << 2) & 858993459;
        y2 = (y2 | y2 << 1) & 1431655765;
        return x2 | y2 << 1;
      }
      function getLeftmost(start) {
        var p = start, leftmost = start;
        do {
          if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
            leftmost = p;
          p = p.next;
        } while (p !== start);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
      }
      function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
        (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
        (area2(a.prev, a, b.prev) || area2(a, b.prev, b)) || // does not create opposite-facing sectors
        equals(a, b) && area2(a.prev, a, a.next) > 0 && area2(b.prev, b, b.next) > 0);
      }
      function area2(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects2(p1, q1, p2, q2) {
        var o1 = sign2(area2(p1, q1, p2));
        var o2 = sign2(area2(p1, q1, q2));
        var o3 = sign2(area2(p2, q2, p1));
        var o4 = sign2(area2(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
      }
      function sign2(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a, b) {
        var p = a;
        do {
          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects2(p, p.next, a, b))
            return true;
          p = p.next;
        } while (p !== a);
        return false;
      }
      function locallyInside(a, b) {
        return area2(a.prev, a, a.next) < 0 ? area2(a, b, a.next) >= 0 && area2(a, a.prev, b) >= 0 : area2(a, b, a.prev) < 0 || area2(a, a.next, b) < 0;
      }
      function middleInside(a, b) {
        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
          if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
            inside = !inside;
          p = p.next;
        } while (p !== a);
        return inside;
      }
      function splitPolygon(a, b) {
        var a2 = new Node2(a.i, a.x, a.y), b2 = new Node2(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode(i, x2, y2, last) {
        var p = new Node2(i, x2, y2);
        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }
        return p;
      }
      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ)
          p.prevZ.nextZ = p.nextZ;
        if (p.nextZ)
          p.nextZ.prevZ = p.prevZ;
      }
      function Node2(i, x2, y2) {
        this.i = i;
        this.x = x2;
        this.y = y2;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut2.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
          var a = triangles[i] * dim;
          var b = triangles[i + 1] * dim;
          var c = triangles[i + 2] * dim;
          trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
          );
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };
      function signedArea(data, start, end, dim) {
        var sum2 = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
          sum2 += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
          j = i;
        }
        return sum2;
      }
      earcut2.flatten = function(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i = 0; i < data.length; i++) {
          for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++)
              result.vertices.push(data[i][j][d]);
          }
          if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // node_modules/geojson-rbush/node_modules/rbush/rbush.min.js
  var require_rbush_min2 = __commonJS({
    "node_modules/geojson-rbush/node_modules/rbush/rbush.min.js"(exports, module) {
      !function(t, i) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = i() : "function" == typeof define && define.amd ? define(i) : (t = t || self).RBush = i();
      }(exports, function() {
        "use strict";
        function t(t2, r2, e3, a2, h2) {
          !function t3(n2, r3, e4, a3, h3) {
            for (; a3 > e4; ) {
              if (a3 - e4 > 600) {
                var o2 = a3 - e4 + 1, s2 = r3 - e4 + 1, l2 = Math.log(o2), f2 = 0.5 * Math.exp(2 * l2 / 3), u2 = 0.5 * Math.sqrt(l2 * f2 * (o2 - f2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1), m2 = Math.max(e4, Math.floor(r3 - s2 * f2 / o2 + u2)), c2 = Math.min(a3, Math.floor(r3 + (o2 - s2) * f2 / o2 + u2));
                t3(n2, r3, m2, c2, h3);
              }
              var p2 = n2[r3], d2 = e4, x2 = a3;
              for (i(n2, e4, r3), h3(n2[a3], p2) > 0 && i(n2, e4, a3); d2 < x2; ) {
                for (i(n2, d2, x2), d2++, x2--; h3(n2[d2], p2) < 0; )
                  d2++;
                for (; h3(n2[x2], p2) > 0; )
                  x2--;
              }
              0 === h3(n2[e4], p2) ? i(n2, e4, x2) : i(n2, ++x2, a3), x2 <= r3 && (e4 = x2 + 1), r3 <= x2 && (a3 = x2 - 1);
            }
          }(t2, r2, e3 || 0, a2 || t2.length - 1, h2 || n);
        }
        function i(t2, i2, n2) {
          var r2 = t2[i2];
          t2[i2] = t2[n2], t2[n2] = r2;
        }
        function n(t2, i2) {
          return t2 < i2 ? -1 : t2 > i2 ? 1 : 0;
        }
        var r = function(t2) {
          void 0 === t2 && (t2 = 9), this._maxEntries = Math.max(4, t2), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
        };
        function e(t2, i2, n2) {
          if (!n2)
            return i2.indexOf(t2);
          for (var r2 = 0; r2 < i2.length; r2++)
            if (n2(t2, i2[r2]))
              return r2;
          return -1;
        }
        function a(t2, i2) {
          h(t2, 0, t2.children.length, i2, t2);
        }
        function h(t2, i2, n2, r2, e3) {
          e3 || (e3 = p(null)), e3.minX = 1 / 0, e3.minY = 1 / 0, e3.maxX = -1 / 0, e3.maxY = -1 / 0;
          for (var a2 = i2; a2 < n2; a2++) {
            var h2 = t2.children[a2];
            o(e3, t2.leaf ? r2(h2) : h2);
          }
          return e3;
        }
        function o(t2, i2) {
          return t2.minX = Math.min(t2.minX, i2.minX), t2.minY = Math.min(t2.minY, i2.minY), t2.maxX = Math.max(t2.maxX, i2.maxX), t2.maxY = Math.max(t2.maxY, i2.maxY), t2;
        }
        function s(t2, i2) {
          return t2.minX - i2.minX;
        }
        function l(t2, i2) {
          return t2.minY - i2.minY;
        }
        function f(t2) {
          return (t2.maxX - t2.minX) * (t2.maxY - t2.minY);
        }
        function u(t2) {
          return t2.maxX - t2.minX + (t2.maxY - t2.minY);
        }
        function m(t2, i2) {
          return t2.minX <= i2.minX && t2.minY <= i2.minY && i2.maxX <= t2.maxX && i2.maxY <= t2.maxY;
        }
        function c(t2, i2) {
          return i2.minX <= t2.maxX && i2.minY <= t2.maxY && i2.maxX >= t2.minX && i2.maxY >= t2.minY;
        }
        function p(t2) {
          return { children: t2, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        }
        function d(i2, n2, r2, e3, a2) {
          for (var h2 = [n2, r2]; h2.length; )
            if (!((r2 = h2.pop()) - (n2 = h2.pop()) <= e3)) {
              var o2 = n2 + Math.ceil((r2 - n2) / e3 / 2) * e3;
              t(i2, o2, n2, r2, a2), h2.push(n2, o2, o2, r2);
            }
        }
        return r.prototype.all = function() {
          return this._all(this.data, []);
        }, r.prototype.search = function(t2) {
          var i2 = this.data, n2 = [];
          if (!c(t2, i2))
            return n2;
          for (var r2 = this.toBBox, e3 = []; i2; ) {
            for (var a2 = 0; a2 < i2.children.length; a2++) {
              var h2 = i2.children[a2], o2 = i2.leaf ? r2(h2) : h2;
              c(t2, o2) && (i2.leaf ? n2.push(h2) : m(t2, o2) ? this._all(h2, n2) : e3.push(h2));
            }
            i2 = e3.pop();
          }
          return n2;
        }, r.prototype.collides = function(t2) {
          var i2 = this.data;
          if (!c(t2, i2))
            return false;
          for (var n2 = []; i2; ) {
            for (var r2 = 0; r2 < i2.children.length; r2++) {
              var e3 = i2.children[r2], a2 = i2.leaf ? this.toBBox(e3) : e3;
              if (c(t2, a2)) {
                if (i2.leaf || m(t2, a2))
                  return true;
                n2.push(e3);
              }
            }
            i2 = n2.pop();
          }
          return false;
        }, r.prototype.load = function(t2) {
          if (!t2 || !t2.length)
            return this;
          if (t2.length < this._minEntries) {
            for (var i2 = 0; i2 < t2.length; i2++)
              this.insert(t2[i2]);
            return this;
          }
          var n2 = this._build(t2.slice(), 0, t2.length - 1, 0);
          if (this.data.children.length)
            if (this.data.height === n2.height)
              this._splitRoot(this.data, n2);
            else {
              if (this.data.height < n2.height) {
                var r2 = this.data;
                this.data = n2, n2 = r2;
              }
              this._insert(n2, this.data.height - n2.height - 1, true);
            }
          else
            this.data = n2;
          return this;
        }, r.prototype.insert = function(t2) {
          return t2 && this._insert(t2, this.data.height - 1), this;
        }, r.prototype.clear = function() {
          return this.data = p([]), this;
        }, r.prototype.remove = function(t2, i2) {
          if (!t2)
            return this;
          for (var n2, r2, a2, h2 = this.data, o2 = this.toBBox(t2), s2 = [], l2 = []; h2 || s2.length; ) {
            if (h2 || (h2 = s2.pop(), r2 = s2[s2.length - 1], n2 = l2.pop(), a2 = true), h2.leaf) {
              var f2 = e(t2, h2.children, i2);
              if (-1 !== f2)
                return h2.children.splice(f2, 1), s2.push(h2), this._condense(s2), this;
            }
            a2 || h2.leaf || !m(h2, o2) ? r2 ? (n2++, h2 = r2.children[n2], a2 = false) : h2 = null : (s2.push(h2), l2.push(n2), n2 = 0, r2 = h2, h2 = h2.children[0]);
          }
          return this;
        }, r.prototype.toBBox = function(t2) {
          return t2;
        }, r.prototype.compareMinX = function(t2, i2) {
          return t2.minX - i2.minX;
        }, r.prototype.compareMinY = function(t2, i2) {
          return t2.minY - i2.minY;
        }, r.prototype.toJSON = function() {
          return this.data;
        }, r.prototype.fromJSON = function(t2) {
          return this.data = t2, this;
        }, r.prototype._all = function(t2, i2) {
          for (var n2 = []; t2; )
            t2.leaf ? i2.push.apply(i2, t2.children) : n2.push.apply(n2, t2.children), t2 = n2.pop();
          return i2;
        }, r.prototype._build = function(t2, i2, n2, r2) {
          var e3, h2 = n2 - i2 + 1, o2 = this._maxEntries;
          if (h2 <= o2)
            return a(e3 = p(t2.slice(i2, n2 + 1)), this.toBBox), e3;
          r2 || (r2 = Math.ceil(Math.log(h2) / Math.log(o2)), o2 = Math.ceil(h2 / Math.pow(o2, r2 - 1))), (e3 = p([])).leaf = false, e3.height = r2;
          var s2 = Math.ceil(h2 / o2), l2 = s2 * Math.ceil(Math.sqrt(o2));
          d(t2, i2, n2, l2, this.compareMinX);
          for (var f2 = i2; f2 <= n2; f2 += l2) {
            var u2 = Math.min(f2 + l2 - 1, n2);
            d(t2, f2, u2, s2, this.compareMinY);
            for (var m2 = f2; m2 <= u2; m2 += s2) {
              var c2 = Math.min(m2 + s2 - 1, u2);
              e3.children.push(this._build(t2, m2, c2, r2 - 1));
            }
          }
          return a(e3, this.toBBox), e3;
        }, r.prototype._chooseSubtree = function(t2, i2, n2, r2) {
          for (; r2.push(i2), !i2.leaf && r2.length - 1 !== n2; ) {
            for (var e3 = 1 / 0, a2 = 1 / 0, h2 = void 0, o2 = 0; o2 < i2.children.length; o2++) {
              var s2 = i2.children[o2], l2 = f(s2), u2 = (m2 = t2, c2 = s2, (Math.max(c2.maxX, m2.maxX) - Math.min(c2.minX, m2.minX)) * (Math.max(c2.maxY, m2.maxY) - Math.min(c2.minY, m2.minY)) - l2);
              u2 < a2 ? (a2 = u2, e3 = l2 < e3 ? l2 : e3, h2 = s2) : u2 === a2 && l2 < e3 && (e3 = l2, h2 = s2);
            }
            i2 = h2 || i2.children[0];
          }
          var m2, c2;
          return i2;
        }, r.prototype._insert = function(t2, i2, n2) {
          var r2 = n2 ? t2 : this.toBBox(t2), e3 = [], a2 = this._chooseSubtree(r2, this.data, i2, e3);
          for (a2.children.push(t2), o(a2, r2); i2 >= 0 && e3[i2].children.length > this._maxEntries; )
            this._split(e3, i2), i2--;
          this._adjustParentBBoxes(r2, e3, i2);
        }, r.prototype._split = function(t2, i2) {
          var n2 = t2[i2], r2 = n2.children.length, e3 = this._minEntries;
          this._chooseSplitAxis(n2, e3, r2);
          var h2 = this._chooseSplitIndex(n2, e3, r2), o2 = p(n2.children.splice(h2, n2.children.length - h2));
          o2.height = n2.height, o2.leaf = n2.leaf, a(n2, this.toBBox), a(o2, this.toBBox), i2 ? t2[i2 - 1].children.push(o2) : this._splitRoot(n2, o2);
        }, r.prototype._splitRoot = function(t2, i2) {
          this.data = p([t2, i2]), this.data.height = t2.height + 1, this.data.leaf = false, a(this.data, this.toBBox);
        }, r.prototype._chooseSplitIndex = function(t2, i2, n2) {
          for (var r2, e3, a2, o2, s2, l2, u2, m2 = 1 / 0, c2 = 1 / 0, p2 = i2; p2 <= n2 - i2; p2++) {
            var d2 = h(t2, 0, p2, this.toBBox), x2 = h(t2, p2, n2, this.toBBox), v = (e3 = d2, a2 = x2, o2 = void 0, s2 = void 0, l2 = void 0, u2 = void 0, o2 = Math.max(e3.minX, a2.minX), s2 = Math.max(e3.minY, a2.minY), l2 = Math.min(e3.maxX, a2.maxX), u2 = Math.min(e3.maxY, a2.maxY), Math.max(0, l2 - o2) * Math.max(0, u2 - s2)), M = f(d2) + f(x2);
            v < m2 ? (m2 = v, r2 = p2, c2 = M < c2 ? M : c2) : v === m2 && M < c2 && (c2 = M, r2 = p2);
          }
          return r2 || n2 - i2;
        }, r.prototype._chooseSplitAxis = function(t2, i2, n2) {
          var r2 = t2.leaf ? this.compareMinX : s, e3 = t2.leaf ? this.compareMinY : l;
          this._allDistMargin(t2, i2, n2, r2) < this._allDistMargin(t2, i2, n2, e3) && t2.children.sort(r2);
        }, r.prototype._allDistMargin = function(t2, i2, n2, r2) {
          t2.children.sort(r2);
          for (var e3 = this.toBBox, a2 = h(t2, 0, i2, e3), s2 = h(t2, n2 - i2, n2, e3), l2 = u(a2) + u(s2), f2 = i2; f2 < n2 - i2; f2++) {
            var m2 = t2.children[f2];
            o(a2, t2.leaf ? e3(m2) : m2), l2 += u(a2);
          }
          for (var c2 = n2 - i2 - 1; c2 >= i2; c2--) {
            var p2 = t2.children[c2];
            o(s2, t2.leaf ? e3(p2) : p2), l2 += u(s2);
          }
          return l2;
        }, r.prototype._adjustParentBBoxes = function(t2, i2, n2) {
          for (var r2 = n2; r2 >= 0; r2--)
            o(i2[r2], t2);
        }, r.prototype._condense = function(t2) {
          for (var i2 = t2.length - 1, n2 = void 0; i2 >= 0; i2--)
            0 === t2[i2].children.length ? i2 > 0 ? (n2 = t2[i2 - 1].children).splice(n2.indexOf(t2[i2]), 1) : this.clear() : a(t2[i2], this.toBBox);
        }, r;
      });
    }
  });

  // node_modules/@turf/helpers/dist/js/index.js
  var require_js = __commonJS({
    "node_modules/@turf/helpers/dist/js/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.earthRadius = 63710088e-1;
      exports.factors = {
        centimeters: exports.earthRadius * 100,
        centimetres: exports.earthRadius * 100,
        degrees: exports.earthRadius / 111325,
        feet: exports.earthRadius * 3.28084,
        inches: exports.earthRadius * 39.37,
        kilometers: exports.earthRadius / 1e3,
        kilometres: exports.earthRadius / 1e3,
        meters: exports.earthRadius,
        metres: exports.earthRadius,
        miles: exports.earthRadius / 1609.344,
        millimeters: exports.earthRadius * 1e3,
        millimetres: exports.earthRadius * 1e3,
        nauticalmiles: exports.earthRadius / 1852,
        radians: 1,
        yards: exports.earthRadius * 1.0936
      };
      exports.unitsFactors = {
        centimeters: 100,
        centimetres: 100,
        degrees: 1 / 111325,
        feet: 3.28084,
        inches: 39.37,
        kilometers: 1 / 1e3,
        kilometres: 1 / 1e3,
        meters: 1,
        metres: 1,
        miles: 1 / 1609.344,
        millimeters: 1e3,
        millimetres: 1e3,
        nauticalmiles: 1 / 1852,
        radians: 1 / exports.earthRadius,
        yards: 1.0936133
      };
      exports.areaFactors = {
        acres: 247105e-9,
        centimeters: 1e4,
        centimetres: 1e4,
        feet: 10.763910417,
        hectares: 1e-4,
        inches: 1550.003100006,
        kilometers: 1e-6,
        kilometres: 1e-6,
        meters: 1,
        metres: 1,
        miles: 386e-9,
        millimeters: 1e6,
        millimetres: 1e6,
        yards: 1.195990046
      };
      function feature2(geom, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var feat = { type: "Feature" };
        if (options.id === 0 || options.id) {
          feat.id = options.id;
        }
        if (options.bbox) {
          feat.bbox = options.bbox;
        }
        feat.properties = properties || {};
        feat.geometry = geom;
        return feat;
      }
      exports.feature = feature2;
      function geometry(type, coordinates, _options) {
        if (_options === void 0) {
          _options = {};
        }
        switch (type) {
          case "Point":
            return point2(coordinates).geometry;
          case "LineString":
            return lineString2(coordinates).geometry;
          case "Polygon":
            return polygon2(coordinates).geometry;
          case "MultiPoint":
            return multiPoint2(coordinates).geometry;
          case "MultiLineString":
            return multiLineString2(coordinates).geometry;
          case "MultiPolygon":
            return multiPolygon2(coordinates).geometry;
          default:
            throw new Error(type + " is invalid");
        }
      }
      exports.geometry = geometry;
      function point2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        if (!coordinates) {
          throw new Error("coordinates is required");
        }
        if (!Array.isArray(coordinates)) {
          throw new Error("coordinates must be an Array");
        }
        if (coordinates.length < 2) {
          throw new Error("coordinates must be at least 2 numbers long");
        }
        if (!isNumber2(coordinates[0]) || !isNumber2(coordinates[1])) {
          throw new Error("coordinates must contain numbers");
        }
        var geom = {
          type: "Point",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.point = point2;
      function points(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        return featureCollection2(coordinates.map(function(coords) {
          return point2(coords, properties);
        }), options);
      }
      exports.points = points;
      function polygon2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
          var ring = coordinates_1[_i];
          if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
          }
          for (var j = 0; j < ring[ring.length - 1].length; j++) {
            if (ring[ring.length - 1][j] !== ring[0][j]) {
              throw new Error("First and last Position are not equivalent.");
            }
          }
        }
        var geom = {
          type: "Polygon",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.polygon = polygon2;
      function polygons(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        return featureCollection2(coordinates.map(function(coords) {
          return polygon2(coords, properties);
        }), options);
      }
      exports.polygons = polygons;
      function lineString2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        if (coordinates.length < 2) {
          throw new Error("coordinates must be an array of two or more positions");
        }
        var geom = {
          type: "LineString",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.lineString = lineString2;
      function lineStrings(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        return featureCollection2(coordinates.map(function(coords) {
          return lineString2(coords, properties);
        }), options);
      }
      exports.lineStrings = lineStrings;
      function featureCollection2(features2, options) {
        if (options === void 0) {
          options = {};
        }
        var fc = { type: "FeatureCollection" };
        if (options.id) {
          fc.id = options.id;
        }
        if (options.bbox) {
          fc.bbox = options.bbox;
        }
        fc.features = features2;
        return fc;
      }
      exports.featureCollection = featureCollection2;
      function multiLineString2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "MultiLineString",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.multiLineString = multiLineString2;
      function multiPoint2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "MultiPoint",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.multiPoint = multiPoint2;
      function multiPolygon2(coordinates, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "MultiPolygon",
          coordinates
        };
        return feature2(geom, properties, options);
      }
      exports.multiPolygon = multiPolygon2;
      function geometryCollection2(geometries, properties, options) {
        if (options === void 0) {
          options = {};
        }
        var geom = {
          type: "GeometryCollection",
          geometries
        };
        return feature2(geom, properties, options);
      }
      exports.geometryCollection = geometryCollection2;
      function round(num, precision) {
        if (precision === void 0) {
          precision = 0;
        }
        if (precision && !(precision >= 0)) {
          throw new Error("precision must be a positive number");
        }
        var multiplier = Math.pow(10, precision || 0);
        return Math.round(num * multiplier) / multiplier;
      }
      exports.round = round;
      function radiansToLength2(radians2, units) {
        if (units === void 0) {
          units = "kilometers";
        }
        var factor = exports.factors[units];
        if (!factor) {
          throw new Error(units + " units is invalid");
        }
        return radians2 * factor;
      }
      exports.radiansToLength = radiansToLength2;
      function lengthToRadians2(distance2, units) {
        if (units === void 0) {
          units = "kilometers";
        }
        var factor = exports.factors[units];
        if (!factor) {
          throw new Error(units + " units is invalid");
        }
        return distance2 / factor;
      }
      exports.lengthToRadians = lengthToRadians2;
      function lengthToDegrees2(distance2, units) {
        return radiansToDegrees2(lengthToRadians2(distance2, units));
      }
      exports.lengthToDegrees = lengthToDegrees2;
      function bearingToAzimuth2(bearing2) {
        var angle = bearing2 % 360;
        if (angle < 0) {
          angle += 360;
        }
        return angle;
      }
      exports.bearingToAzimuth = bearingToAzimuth2;
      function radiansToDegrees2(radians2) {
        var degrees2 = radians2 % (2 * Math.PI);
        return degrees2 * 180 / Math.PI;
      }
      exports.radiansToDegrees = radiansToDegrees2;
      function degreesToRadians2(degrees2) {
        var radians2 = degrees2 % 360;
        return radians2 * Math.PI / 180;
      }
      exports.degreesToRadians = degreesToRadians2;
      function convertLength2(length2, originalUnit, finalUnit) {
        if (originalUnit === void 0) {
          originalUnit = "kilometers";
        }
        if (finalUnit === void 0) {
          finalUnit = "kilometers";
        }
        if (!(length2 >= 0)) {
          throw new Error("length must be a positive number");
        }
        return radiansToLength2(lengthToRadians2(length2, originalUnit), finalUnit);
      }
      exports.convertLength = convertLength2;
      function convertArea(area2, originalUnit, finalUnit) {
        if (originalUnit === void 0) {
          originalUnit = "meters";
        }
        if (finalUnit === void 0) {
          finalUnit = "kilometers";
        }
        if (!(area2 >= 0)) {
          throw new Error("area must be a positive number");
        }
        var startFactor = exports.areaFactors[originalUnit];
        if (!startFactor) {
          throw new Error("invalid original units");
        }
        var finalFactor = exports.areaFactors[finalUnit];
        if (!finalFactor) {
          throw new Error("invalid final units");
        }
        return area2 / startFactor * finalFactor;
      }
      exports.convertArea = convertArea;
      function isNumber2(num) {
        return !isNaN(num) && num !== null && !Array.isArray(num);
      }
      exports.isNumber = isNumber2;
      function isObject2(input) {
        return !!input && input.constructor === Object;
      }
      exports.isObject = isObject2;
      function validateBBox(bbox3) {
        if (!bbox3) {
          throw new Error("bbox is required");
        }
        if (!Array.isArray(bbox3)) {
          throw new Error("bbox must be an Array");
        }
        if (bbox3.length !== 4 && bbox3.length !== 6) {
          throw new Error("bbox must be an Array of 4 or 6 numbers");
        }
        bbox3.forEach(function(num) {
          if (!isNumber2(num)) {
            throw new Error("bbox must only contain numbers");
          }
        });
      }
      exports.validateBBox = validateBBox;
      function validateId(id) {
        if (!id) {
          throw new Error("id is required");
        }
        if (["string", "number"].indexOf(typeof id) === -1) {
          throw new Error("id must be a number or a string");
        }
      }
      exports.validateId = validateId;
    }
  });

  // node_modules/@turf/meta/dist/js/index.js
  var require_js2 = __commonJS({
    "node_modules/@turf/meta/dist/js/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var helpers = require_js();
      function coordEach2(geojson, callback, excludeWrapCoord) {
        if (geojson === null)
          return;
        var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
        for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
          geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
          for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
            var multiFeatureIndex = 0;
            var geometryIndex = 0;
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
            if (geometry === null)
              continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;
            wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
            switch (geomType) {
              case null:
                break;
              case "Point":
                if (callback(
                  coords,
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
                multiFeatureIndex++;
                break;
              case "LineString":
              case "MultiPoint":
                for (j = 0; j < coords.length; j++) {
                  if (callback(
                    coords[j],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false)
                    return false;
                  coordIndex++;
                  if (geomType === "MultiPoint")
                    multiFeatureIndex++;
                }
                if (geomType === "LineString")
                  multiFeatureIndex++;
                break;
              case "Polygon":
              case "MultiLineString":
                for (j = 0; j < coords.length; j++) {
                  for (k = 0; k < coords[j].length - wrapShrink; k++) {
                    if (callback(
                      coords[j][k],
                      coordIndex,
                      featureIndex,
                      multiFeatureIndex,
                      geometryIndex
                    ) === false)
                      return false;
                    coordIndex++;
                  }
                  if (geomType === "MultiLineString")
                    multiFeatureIndex++;
                  if (geomType === "Polygon")
                    geometryIndex++;
                }
                if (geomType === "Polygon")
                  multiFeatureIndex++;
                break;
              case "MultiPolygon":
                for (j = 0; j < coords.length; j++) {
                  geometryIndex = 0;
                  for (k = 0; k < coords[j].length; k++) {
                    for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                      if (callback(
                        coords[j][k][l],
                        coordIndex,
                        featureIndex,
                        multiFeatureIndex,
                        geometryIndex
                      ) === false)
                        return false;
                      coordIndex++;
                    }
                    geometryIndex++;
                  }
                  multiFeatureIndex++;
                }
                break;
              case "GeometryCollection":
                for (j = 0; j < geometry.geometries.length; j++)
                  if (coordEach2(geometry.geometries[j], callback, excludeWrapCoord) === false)
                    return false;
                break;
              default:
                throw new Error("Unknown Geometry Type");
            }
          }
        }
      }
      function coordReduce2(geojson, callback, initialValue, excludeWrapCoord) {
        var previousValue = initialValue;
        coordEach2(
          geojson,
          function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
            if (coordIndex === 0 && initialValue === void 0)
              previousValue = currentCoord;
            else
              previousValue = callback(
                previousValue,
                currentCoord,
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              );
          },
          excludeWrapCoord
        );
        return previousValue;
      }
      function propEach(geojson, callback) {
        var i;
        switch (geojson.type) {
          case "FeatureCollection":
            for (i = 0; i < geojson.features.length; i++) {
              if (callback(geojson.features[i].properties, i) === false)
                break;
            }
            break;
          case "Feature":
            callback(geojson.properties, 0);
            break;
        }
      }
      function propReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        propEach(geojson, function(currentProperties, featureIndex) {
          if (featureIndex === 0 && initialValue === void 0)
            previousValue = currentProperties;
          else
            previousValue = callback(previousValue, currentProperties, featureIndex);
        });
        return previousValue;
      }
      function featureEach2(geojson, callback) {
        if (geojson.type === "Feature") {
          callback(geojson, 0);
        } else if (geojson.type === "FeatureCollection") {
          for (var i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i], i) === false)
              break;
          }
        }
      }
      function featureReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        featureEach2(geojson, function(currentFeature2, featureIndex) {
          if (featureIndex === 0 && initialValue === void 0)
            previousValue = currentFeature2;
          else
            previousValue = callback(previousValue, currentFeature2, featureIndex);
        });
        return previousValue;
      }
      function coordAll2(geojson) {
        var coords = [];
        coordEach2(geojson, function(coord) {
          coords.push(coord);
        });
        return coords;
      }
      function geomEach2(geojson, callback) {
        var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
        for (i = 0; i < stop; i++) {
          geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
          featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
          featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
          featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
          isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
          for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
            if (geometry === null) {
              if (callback(
                null,
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              ) === false)
                return false;
              continue;
            }
            switch (geometry.type) {
              case "Point":
              case "LineString":
              case "MultiPoint":
              case "Polygon":
              case "MultiLineString":
              case "MultiPolygon": {
                if (callback(
                  geometry,
                  featureIndex,
                  featureProperties,
                  featureBBox,
                  featureId
                ) === false)
                  return false;
                break;
              }
              case "GeometryCollection": {
                for (j = 0; j < geometry.geometries.length; j++) {
                  if (callback(
                    geometry.geometries[j],
                    featureIndex,
                    featureProperties,
                    featureBBox,
                    featureId
                  ) === false)
                    return false;
                }
                break;
              }
              default:
                throw new Error("Unknown Geometry Type");
            }
          }
          featureIndex++;
        }
      }
      function geomReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        geomEach2(
          geojson,
          function(currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
            if (featureIndex === 0 && initialValue === void 0)
              previousValue = currentGeometry;
            else
              previousValue = callback(
                previousValue,
                currentGeometry,
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              );
          }
        );
        return previousValue;
      }
      function flattenEach2(geojson, callback) {
        geomEach2(geojson, function(geometry, featureIndex, properties, bbox3, id) {
          var type = geometry === null ? null : geometry.type;
          switch (type) {
            case null:
            case "Point":
            case "LineString":
            case "Polygon":
              if (callback(
                helpers.feature(geometry, properties, { bbox: bbox3, id }),
                featureIndex,
                0
              ) === false)
                return false;
              return;
          }
          var geomType;
          switch (type) {
            case "MultiPoint":
              geomType = "Point";
              break;
            case "MultiLineString":
              geomType = "LineString";
              break;
            case "MultiPolygon":
              geomType = "Polygon";
              break;
          }
          for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
            var coordinate = geometry.coordinates[multiFeatureIndex];
            var geom = {
              type: geomType,
              coordinates: coordinate
            };
            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false)
              return false;
          }
        });
      }
      function flattenReduce(geojson, callback, initialValue) {
        var previousValue = initialValue;
        flattenEach2(
          geojson,
          function(currentFeature2, featureIndex, multiFeatureIndex) {
            if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === void 0)
              previousValue = currentFeature2;
            else
              previousValue = callback(
                previousValue,
                currentFeature2,
                featureIndex,
                multiFeatureIndex
              );
          }
        );
        return previousValue;
      }
      function segmentEach2(geojson, callback) {
        flattenEach2(geojson, function(feature2, featureIndex, multiFeatureIndex) {
          var segmentIndex = 0;
          if (!feature2.geometry)
            return;
          var type = feature2.geometry.type;
          if (type === "Point" || type === "MultiPoint")
            return;
          var previousCoords;
          var previousFeatureIndex = 0;
          var previousMultiIndex = 0;
          var prevGeomIndex = 0;
          if (coordEach2(
            feature2,
            function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
              if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
                previousCoords = currentCoord;
                previousFeatureIndex = featureIndex;
                previousMultiIndex = multiPartIndexCoord;
                prevGeomIndex = geometryIndex;
                segmentIndex = 0;
                return;
              }
              var currentSegment = helpers.lineString(
                [previousCoords, currentCoord],
                feature2.properties
              );
              if (callback(
                currentSegment,
                featureIndex,
                multiFeatureIndex,
                geometryIndex,
                segmentIndex
              ) === false)
                return false;
              segmentIndex++;
              previousCoords = currentCoord;
            }
          ) === false)
            return false;
        });
      }
      function segmentReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        var started = false;
        segmentEach2(
          geojson,
          function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
            if (started === false && initialValue === void 0)
              previousValue = currentSegment;
            else
              previousValue = callback(
                previousValue,
                currentSegment,
                featureIndex,
                multiFeatureIndex,
                geometryIndex,
                segmentIndex
              );
            started = true;
          }
        );
        return previousValue;
      }
      function lineEach(geojson, callback) {
        if (!geojson)
          throw new Error("geojson is required");
        flattenEach2(geojson, function(feature2, featureIndex, multiFeatureIndex) {
          if (feature2.geometry === null)
            return;
          var type = feature2.geometry.type;
          var coords = feature2.geometry.coordinates;
          switch (type) {
            case "LineString":
              if (callback(feature2, featureIndex, multiFeatureIndex, 0, 0) === false)
                return false;
              break;
            case "Polygon":
              for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
                if (callback(
                  helpers.lineString(coords[geometryIndex], feature2.properties),
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
              }
              break;
          }
        });
      }
      function lineReduce2(geojson, callback, initialValue) {
        var previousValue = initialValue;
        lineEach(
          geojson,
          function(currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
            if (featureIndex === 0 && initialValue === void 0)
              previousValue = currentLine;
            else
              previousValue = callback(
                previousValue,
                currentLine,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              );
          }
        );
        return previousValue;
      }
      function findSegment(geojson, options) {
        options = options || {};
        if (!helpers.isObject(options))
          throw new Error("options is invalid");
        var featureIndex = options.featureIndex || 0;
        var multiFeatureIndex = options.multiFeatureIndex || 0;
        var geometryIndex = options.geometryIndex || 0;
        var segmentIndex = options.segmentIndex || 0;
        var properties = options.properties;
        var geometry;
        switch (geojson.type) {
          case "FeatureCollection":
            if (featureIndex < 0)
              featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
          case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            geometry = geojson;
            break;
          default:
            throw new Error("geojson is invalid");
        }
        if (geometry === null)
          return null;
        var coords = geometry.coordinates;
        switch (geometry.type) {
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
            if (segmentIndex < 0)
              segmentIndex = coords.length + segmentIndex - 1;
            return helpers.lineString(
              [coords[segmentIndex], coords[segmentIndex + 1]],
              properties,
              options
            );
          case "Polygon":
            if (geometryIndex < 0)
              geometryIndex = coords.length + geometryIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
            return helpers.lineString(
              [
                coords[geometryIndex][segmentIndex],
                coords[geometryIndex][segmentIndex + 1]
              ],
              properties,
              options
            );
          case "MultiLineString":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
            return helpers.lineString(
              [
                coords[multiFeatureIndex][segmentIndex],
                coords[multiFeatureIndex][segmentIndex + 1]
              ],
              properties,
              options
            );
          case "MultiPolygon":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0)
              geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (segmentIndex < 0)
              segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
            return helpers.lineString(
              [
                coords[multiFeatureIndex][geometryIndex][segmentIndex],
                coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]
              ],
              properties,
              options
            );
        }
        throw new Error("geojson is invalid");
      }
      function findPoint(geojson, options) {
        options = options || {};
        if (!helpers.isObject(options))
          throw new Error("options is invalid");
        var featureIndex = options.featureIndex || 0;
        var multiFeatureIndex = options.multiFeatureIndex || 0;
        var geometryIndex = options.geometryIndex || 0;
        var coordIndex = options.coordIndex || 0;
        var properties = options.properties;
        var geometry;
        switch (geojson.type) {
          case "FeatureCollection":
            if (featureIndex < 0)
              featureIndex = geojson.features.length + featureIndex;
            properties = properties || geojson.features[featureIndex].properties;
            geometry = geojson.features[featureIndex].geometry;
            break;
          case "Feature":
            properties = properties || geojson.properties;
            geometry = geojson.geometry;
            break;
          case "Point":
          case "MultiPoint":
            return null;
          case "LineString":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            geometry = geojson;
            break;
          default:
            throw new Error("geojson is invalid");
        }
        if (geometry === null)
          return null;
        var coords = geometry.coordinates;
        switch (geometry.type) {
          case "Point":
            return helpers.point(coords, properties, options);
          case "MultiPoint":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            return helpers.point(coords[multiFeatureIndex], properties, options);
          case "LineString":
            if (coordIndex < 0)
              coordIndex = coords.length + coordIndex;
            return helpers.point(coords[coordIndex], properties, options);
          case "Polygon":
            if (geometryIndex < 0)
              geometryIndex = coords.length + geometryIndex;
            if (coordIndex < 0)
              coordIndex = coords[geometryIndex].length + coordIndex;
            return helpers.point(coords[geometryIndex][coordIndex], properties, options);
          case "MultiLineString":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (coordIndex < 0)
              coordIndex = coords[multiFeatureIndex].length + coordIndex;
            return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);
          case "MultiPolygon":
            if (multiFeatureIndex < 0)
              multiFeatureIndex = coords.length + multiFeatureIndex;
            if (geometryIndex < 0)
              geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
            if (coordIndex < 0)
              coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
            return helpers.point(
              coords[multiFeatureIndex][geometryIndex][coordIndex],
              properties,
              options
            );
        }
        throw new Error("geojson is invalid");
      }
      exports.coordAll = coordAll2;
      exports.coordEach = coordEach2;
      exports.coordReduce = coordReduce2;
      exports.featureEach = featureEach2;
      exports.featureReduce = featureReduce2;
      exports.findPoint = findPoint;
      exports.findSegment = findSegment;
      exports.flattenEach = flattenEach2;
      exports.flattenReduce = flattenReduce;
      exports.geomEach = geomEach2;
      exports.geomReduce = geomReduce2;
      exports.lineEach = lineEach;
      exports.lineReduce = lineReduce2;
      exports.propEach = propEach;
      exports.propReduce = propReduce;
      exports.segmentEach = segmentEach2;
      exports.segmentReduce = segmentReduce2;
    }
  });

  // node_modules/@turf/bbox/dist/js/index.js
  var require_js3 = __commonJS({
    "node_modules/@turf/bbox/dist/js/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var meta_1 = require_js2();
      function bbox3(geojson) {
        var result = [Infinity, Infinity, -Infinity, -Infinity];
        meta_1.coordEach(geojson, function(coord) {
          if (result[0] > coord[0]) {
            result[0] = coord[0];
          }
          if (result[1] > coord[1]) {
            result[1] = coord[1];
          }
          if (result[2] < coord[0]) {
            result[2] = coord[0];
          }
          if (result[3] < coord[1]) {
            result[3] = coord[1];
          }
        });
        return result;
      }
      bbox3["default"] = bbox3;
      exports.default = bbox3;
    }
  });

  // node_modules/geojson-rbush/index.js
  var require_geojson_rbush = __commonJS({
    "node_modules/geojson-rbush/index.js"(exports, module) {
      var rbush6 = require_rbush_min2();
      var helpers = require_js();
      var meta = require_js2();
      var turfBBox = require_js3().default;
      var featureEach2 = meta.featureEach;
      var coordEach2 = meta.coordEach;
      var polygon2 = helpers.polygon;
      var featureCollection2 = helpers.featureCollection;
      function geojsonRbush(maxEntries) {
        var tree = new rbush6(maxEntries);
        tree.insert = function(feature2) {
          if (feature2.type !== "Feature")
            throw new Error("invalid feature");
          feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
          return rbush6.prototype.insert.call(this, feature2);
        };
        tree.load = function(features2) {
          var load = [];
          if (Array.isArray(features2)) {
            features2.forEach(function(feature2) {
              if (feature2.type !== "Feature")
                throw new Error("invalid features");
              feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
              load.push(feature2);
            });
          } else {
            featureEach2(features2, function(feature2) {
              if (feature2.type !== "Feature")
                throw new Error("invalid features");
              feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
              load.push(feature2);
            });
          }
          return rbush6.prototype.load.call(this, load);
        };
        tree.remove = function(feature2, equals) {
          if (feature2.type !== "Feature")
            throw new Error("invalid feature");
          feature2.bbox = feature2.bbox ? feature2.bbox : turfBBox(feature2);
          return rbush6.prototype.remove.call(this, feature2, equals);
        };
        tree.clear = function() {
          return rbush6.prototype.clear.call(this);
        };
        tree.search = function(geojson) {
          var features2 = rbush6.prototype.search.call(this, this.toBBox(geojson));
          return featureCollection2(features2);
        };
        tree.collides = function(geojson) {
          return rbush6.prototype.collides.call(this, this.toBBox(geojson));
        };
        tree.all = function() {
          var features2 = rbush6.prototype.all.call(this);
          return featureCollection2(features2);
        };
        tree.toJSON = function() {
          return rbush6.prototype.toJSON.call(this);
        };
        tree.fromJSON = function(json) {
          return rbush6.prototype.fromJSON.call(this, json);
        };
        tree.toBBox = function(geojson) {
          var bbox3;
          if (geojson.bbox)
            bbox3 = geojson.bbox;
          else if (Array.isArray(geojson) && geojson.length === 4)
            bbox3 = geojson;
          else if (Array.isArray(geojson) && geojson.length === 6)
            bbox3 = [geojson[0], geojson[1], geojson[3], geojson[4]];
          else if (geojson.type === "Feature")
            bbox3 = turfBBox(geojson);
          else if (geojson.type === "FeatureCollection")
            bbox3 = turfBBox(geojson);
          else
            throw new Error("invalid geojson");
          return {
            minX: bbox3[0],
            minY: bbox3[1],
            maxX: bbox3[2],
            maxY: bbox3[3]
          };
        };
        return tree;
      }
      module.exports = geojsonRbush;
      module.exports.default = geojsonRbush;
    }
  });

  // node_modules/object-keys/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/object-keys/isArguments.js"(exports, module) {
      "use strict";
      var toStr = Object.prototype.toString;
      module.exports = function isArguments(value) {
        var str = toStr.call(value);
        var isArgs = str === "[object Arguments]";
        if (!isArgs) {
          isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
        }
        return isArgs;
      };
    }
  });

  // node_modules/object-keys/implementation.js
  var require_implementation = __commonJS({
    "node_modules/object-keys/implementation.js"(exports, module) {
      "use strict";
      var keysShim;
      if (!Object.keys) {
        has = Object.prototype.hasOwnProperty;
        toStr = Object.prototype.toString;
        isArgs = require_isArguments();
        isEnumerable = Object.prototype.propertyIsEnumerable;
        hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
        hasProtoEnumBug = isEnumerable.call(function() {
        }, "prototype");
        dontEnums = [
          "toString",
          "toLocaleString",
          "valueOf",
          "hasOwnProperty",
          "isPrototypeOf",
          "propertyIsEnumerable",
          "constructor"
        ];
        equalsConstructorPrototype = function(o) {
          var ctor = o.constructor;
          return ctor && ctor.prototype === o;
        };
        excludedKeys = {
          $applicationCache: true,
          $console: true,
          $external: true,
          $frame: true,
          $frameElement: true,
          $frames: true,
          $innerHeight: true,
          $innerWidth: true,
          $onmozfullscreenchange: true,
          $onmozfullscreenerror: true,
          $outerHeight: true,
          $outerWidth: true,
          $pageXOffset: true,
          $pageYOffset: true,
          $parent: true,
          $scrollLeft: true,
          $scrollTop: true,
          $scrollX: true,
          $scrollY: true,
          $self: true,
          $webkitIndexedDB: true,
          $webkitStorageInfo: true,
          $window: true
        };
        hasAutomationEqualityBug = function() {
          if (typeof window === "undefined") {
            return false;
          }
          for (var k in window) {
            try {
              if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
                try {
                  equalsConstructorPrototype(window[k]);
                } catch (e) {
                  return true;
                }
              }
            } catch (e) {
              return true;
            }
          }
          return false;
        }();
        equalsConstructorPrototypeIfNotBuggy = function(o) {
          if (typeof window === "undefined" || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(o);
          }
          try {
            return equalsConstructorPrototype(o);
          } catch (e) {
            return false;
          }
        };
        keysShim = function keys(object2) {
          var isObject2 = object2 !== null && typeof object2 === "object";
          var isFunction = toStr.call(object2) === "[object Function]";
          var isArguments = isArgs(object2);
          var isString = isObject2 && toStr.call(object2) === "[object String]";
          var theKeys = [];
          if (!isObject2 && !isFunction && !isArguments) {
            throw new TypeError("Object.keys called on a non-object");
          }
          var skipProto = hasProtoEnumBug && isFunction;
          if (isString && object2.length > 0 && !has.call(object2, 0)) {
            for (var i = 0; i < object2.length; ++i) {
              theKeys.push(String(i));
            }
          }
          if (isArguments && object2.length > 0) {
            for (var j = 0; j < object2.length; ++j) {
              theKeys.push(String(j));
            }
          } else {
            for (var name in object2) {
              if (!(skipProto && name === "prototype") && has.call(object2, name)) {
                theKeys.push(String(name));
              }
            }
          }
          if (hasDontEnumBug) {
            var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object2);
            for (var k = 0; k < dontEnums.length; ++k) {
              if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object2, dontEnums[k])) {
                theKeys.push(dontEnums[k]);
              }
            }
          }
          return theKeys;
        };
      }
      var has;
      var toStr;
      var isArgs;
      var isEnumerable;
      var hasDontEnumBug;
      var hasProtoEnumBug;
      var dontEnums;
      var equalsConstructorPrototype;
      var excludedKeys;
      var hasAutomationEqualityBug;
      var equalsConstructorPrototypeIfNotBuggy;
      module.exports = keysShim;
    }
  });

  // node_modules/object-keys/index.js
  var require_object_keys = __commonJS({
    "node_modules/object-keys/index.js"(exports, module) {
      "use strict";
      var slice2 = Array.prototype.slice;
      var isArgs = require_isArguments();
      var origKeys = Object.keys;
      var keysShim = origKeys ? function keys(o) {
        return origKeys(o);
      } : require_implementation();
      var originalKeys = Object.keys;
      keysShim.shim = function shimObjectKeys() {
        if (Object.keys) {
          var keysWorksWithArguments = function() {
            var args = Object.keys(arguments);
            return args && args.length === arguments.length;
          }(1, 2);
          if (!keysWorksWithArguments) {
            Object.keys = function keys(object2) {
              if (isArgs(object2)) {
                return originalKeys(slice2.call(object2));
              }
              return originalKeys(object2);
            };
          }
        } else {
          Object.keys = keysShim;
        }
        return Object.keys || keysShim;
      };
      module.exports = keysShim;
    }
  });

  // node_modules/has-symbols/shams.js
  var require_shams = __commonJS({
    "node_modules/has-symbols/shams.js"(exports, module) {
      "use strict";
      module.exports = function hasSymbols() {
        if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
          return false;
        }
        if (typeof Symbol.iterator === "symbol") {
          return true;
        }
        var obj = {};
        var sym = Symbol("test");
        var symObj = Object(sym);
        if (typeof sym === "string") {
          return false;
        }
        if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
          return false;
        }
        if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
          return false;
        }
        var symVal = 42;
        obj[sym] = symVal;
        for (sym in obj) {
          return false;
        }
        if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
          return false;
        }
        if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
          return false;
        }
        var syms = Object.getOwnPropertySymbols(obj);
        if (syms.length !== 1 || syms[0] !== sym) {
          return false;
        }
        if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
          return false;
        }
        if (typeof Object.getOwnPropertyDescriptor === "function") {
          var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
          if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/has-tostringtag/shams.js
  var require_shams2 = __commonJS({
    "node_modules/has-tostringtag/shams.js"(exports, module) {
      "use strict";
      var hasSymbols = require_shams();
      module.exports = function hasToStringTagShams() {
        return hasSymbols() && !!Symbol.toStringTag;
      };
    }
  });

  // node_modules/has-symbols/index.js
  var require_has_symbols = __commonJS({
    "node_modules/has-symbols/index.js"(exports, module) {
      "use strict";
      var origSymbol = typeof Symbol !== "undefined" && Symbol;
      var hasSymbolSham = require_shams();
      module.exports = function hasNativeSymbols() {
        if (typeof origSymbol !== "function") {
          return false;
        }
        if (typeof Symbol !== "function") {
          return false;
        }
        if (typeof origSymbol("foo") !== "symbol") {
          return false;
        }
        if (typeof Symbol("bar") !== "symbol") {
          return false;
        }
        return hasSymbolSham();
      };
    }
  });

  // node_modules/function-bind/implementation.js
  var require_implementation2 = __commonJS({
    "node_modules/function-bind/implementation.js"(exports, module) {
      "use strict";
      var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
      var slice2 = Array.prototype.slice;
      var toStr = Object.prototype.toString;
      var funcType = "[object Function]";
      module.exports = function bind(that) {
        var target = this;
        if (typeof target !== "function" || toStr.call(target) !== funcType) {
          throw new TypeError(ERROR_MESSAGE + target);
        }
        var args = slice2.call(arguments, 1);
        var bound;
        var binder = function() {
          if (this instanceof bound) {
            var result = target.apply(
              this,
              args.concat(slice2.call(arguments))
            );
            if (Object(result) === result) {
              return result;
            }
            return this;
          } else {
            return target.apply(
              that,
              args.concat(slice2.call(arguments))
            );
          }
        };
        var boundLength = Math.max(0, target.length - args.length);
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
          boundArgs.push("$" + i);
        }
        bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
        if (target.prototype) {
          var Empty = function Empty2() {
          };
          Empty.prototype = target.prototype;
          bound.prototype = new Empty();
          Empty.prototype = null;
        }
        return bound;
      };
    }
  });

  // node_modules/function-bind/index.js
  var require_function_bind = __commonJS({
    "node_modules/function-bind/index.js"(exports, module) {
      "use strict";
      var implementation = require_implementation2();
      module.exports = Function.prototype.bind || implementation;
    }
  });

  // node_modules/has/src/index.js
  var require_src = __commonJS({
    "node_modules/has/src/index.js"(exports, module) {
      "use strict";
      var bind = require_function_bind();
      module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/get-intrinsic/index.js
  var require_get_intrinsic = __commonJS({
    "node_modules/get-intrinsic/index.js"(exports, module) {
      "use strict";
      var undefined2;
      var $SyntaxError = SyntaxError;
      var $Function = Function;
      var $TypeError = TypeError;
      var getEvalledConstructor = function(expressionSyntax) {
        try {
          return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
        } catch (e) {
        }
      };
      var $gOPD = Object.getOwnPropertyDescriptor;
      if ($gOPD) {
        try {
          $gOPD({}, "");
        } catch (e) {
          $gOPD = null;
        }
      }
      var throwTypeError = function() {
        throw new $TypeError();
      };
      var ThrowTypeError = $gOPD ? function() {
        try {
          arguments.callee;
          return throwTypeError;
        } catch (calleeThrows) {
          try {
            return $gOPD(arguments, "callee").get;
          } catch (gOPDthrows) {
            return throwTypeError;
          }
        }
      }() : throwTypeError;
      var hasSymbols = require_has_symbols()();
      var getProto = Object.getPrototypeOf || function(x2) {
        return x2.__proto__;
      };
      var needsEval = {};
      var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
      var INTRINSICS = {
        "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
        "%Array%": Array,
        "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
        "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
        "%AsyncFromSyncIteratorPrototype%": undefined2,
        "%AsyncFunction%": needsEval,
        "%AsyncGenerator%": needsEval,
        "%AsyncGeneratorFunction%": needsEval,
        "%AsyncIteratorPrototype%": needsEval,
        "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
        "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
        "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
        "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
        "%Boolean%": Boolean,
        "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
        "%Date%": Date,
        "%decodeURI%": decodeURI,
        "%decodeURIComponent%": decodeURIComponent,
        "%encodeURI%": encodeURI,
        "%encodeURIComponent%": encodeURIComponent,
        "%Error%": Error,
        "%eval%": eval,
        // eslint-disable-line no-eval
        "%EvalError%": EvalError,
        "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
        "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
        "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
        "%Function%": $Function,
        "%GeneratorFunction%": needsEval,
        "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
        "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
        "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
        "%isFinite%": isFinite,
        "%isNaN%": isNaN,
        "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
        "%JSON%": typeof JSON === "object" ? JSON : undefined2,
        "%Map%": typeof Map === "undefined" ? undefined2 : Map,
        "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
        "%Math%": Math,
        "%Number%": Number,
        "%Object%": Object,
        "%parseFloat%": parseFloat,
        "%parseInt%": parseInt,
        "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
        "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
        "%RangeError%": RangeError,
        "%ReferenceError%": ReferenceError,
        "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
        "%RegExp%": RegExp,
        "%Set%": typeof Set === "undefined" ? undefined2 : Set,
        "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
        "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
        "%String%": String,
        "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
        "%Symbol%": hasSymbols ? Symbol : undefined2,
        "%SyntaxError%": $SyntaxError,
        "%ThrowTypeError%": ThrowTypeError,
        "%TypedArray%": TypedArray,
        "%TypeError%": $TypeError,
        "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
        "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
        "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
        "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
        "%URIError%": URIError,
        "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
        "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
        "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
      };
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
      var errorProto;
      var doEval = function doEval2(name) {
        var value;
        if (name === "%AsyncFunction%") {
          value = getEvalledConstructor("async function () {}");
        } else if (name === "%GeneratorFunction%") {
          value = getEvalledConstructor("function* () {}");
        } else if (name === "%AsyncGeneratorFunction%") {
          value = getEvalledConstructor("async function* () {}");
        } else if (name === "%AsyncGenerator%") {
          var fn = doEval2("%AsyncGeneratorFunction%");
          if (fn) {
            value = fn.prototype;
          }
        } else if (name === "%AsyncIteratorPrototype%") {
          var gen = doEval2("%AsyncGenerator%");
          if (gen) {
            value = getProto(gen.prototype);
          }
        }
        INTRINSICS[name] = value;
        return value;
      };
      var LEGACY_ALIASES = {
        "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
        "%ArrayPrototype%": ["Array", "prototype"],
        "%ArrayProto_entries%": ["Array", "prototype", "entries"],
        "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
        "%ArrayProto_keys%": ["Array", "prototype", "keys"],
        "%ArrayProto_values%": ["Array", "prototype", "values"],
        "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
        "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
        "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
        "%BooleanPrototype%": ["Boolean", "prototype"],
        "%DataViewPrototype%": ["DataView", "prototype"],
        "%DatePrototype%": ["Date", "prototype"],
        "%ErrorPrototype%": ["Error", "prototype"],
        "%EvalErrorPrototype%": ["EvalError", "prototype"],
        "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
        "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
        "%FunctionPrototype%": ["Function", "prototype"],
        "%Generator%": ["GeneratorFunction", "prototype"],
        "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
        "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
        "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
        "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
        "%JSONParse%": ["JSON", "parse"],
        "%JSONStringify%": ["JSON", "stringify"],
        "%MapPrototype%": ["Map", "prototype"],
        "%NumberPrototype%": ["Number", "prototype"],
        "%ObjectPrototype%": ["Object", "prototype"],
        "%ObjProto_toString%": ["Object", "prototype", "toString"],
        "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
        "%PromisePrototype%": ["Promise", "prototype"],
        "%PromiseProto_then%": ["Promise", "prototype", "then"],
        "%Promise_all%": ["Promise", "all"],
        "%Promise_reject%": ["Promise", "reject"],
        "%Promise_resolve%": ["Promise", "resolve"],
        "%RangeErrorPrototype%": ["RangeError", "prototype"],
        "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
        "%RegExpPrototype%": ["RegExp", "prototype"],
        "%SetPrototype%": ["Set", "prototype"],
        "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
        "%StringPrototype%": ["String", "prototype"],
        "%SymbolPrototype%": ["Symbol", "prototype"],
        "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
        "%TypedArrayPrototype%": ["TypedArray", "prototype"],
        "%TypeErrorPrototype%": ["TypeError", "prototype"],
        "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
        "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
        "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
        "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
        "%URIErrorPrototype%": ["URIError", "prototype"],
        "%WeakMapPrototype%": ["WeakMap", "prototype"],
        "%WeakSetPrototype%": ["WeakSet", "prototype"]
      };
      var bind = require_function_bind();
      var hasOwn = require_src();
      var $concat = bind.call(Function.call, Array.prototype.concat);
      var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
      var $replace = bind.call(Function.call, String.prototype.replace);
      var $strSlice = bind.call(Function.call, String.prototype.slice);
      var $exec = bind.call(Function.call, RegExp.prototype.exec);
      var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = function stringToPath2(string) {
        var first = $strSlice(string, 0, 1);
        var last = $strSlice(string, -1);
        if (first === "%" && last !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
        } else if (last === "%" && first !== "%") {
          throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
        }
        var result = [];
        $replace(string, rePropName, function(match, number, quote, subString) {
          result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
        });
        return result;
      };
      var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
        var intrinsicName = name;
        var alias;
        if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
          alias = LEGACY_ALIASES[intrinsicName];
          intrinsicName = "%" + alias[0] + "%";
        }
        if (hasOwn(INTRINSICS, intrinsicName)) {
          var value = INTRINSICS[intrinsicName];
          if (value === needsEval) {
            value = doEval(intrinsicName);
          }
          if (typeof value === "undefined" && !allowMissing) {
            throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
          }
          return {
            alias,
            name: intrinsicName,
            value
          };
        }
        throw new $SyntaxError("intrinsic " + name + " does not exist!");
      };
      module.exports = function GetIntrinsic(name, allowMissing) {
        if (typeof name !== "string" || name.length === 0) {
          throw new $TypeError("intrinsic name must be a non-empty string");
        }
        if (arguments.length > 1 && typeof allowMissing !== "boolean") {
          throw new $TypeError('"allowMissing" argument must be a boolean');
        }
        if ($exec(/^%?[^%]*%?$/, name) === null) {
          throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
        }
        var parts = stringToPath(name);
        var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
        var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
        var intrinsicRealName = intrinsic.name;
        var value = intrinsic.value;
        var skipFurtherCaching = false;
        var alias = intrinsic.alias;
        if (alias) {
          intrinsicBaseName = alias[0];
          $spliceApply(parts, $concat([0, 1], alias));
        }
        for (var i = 1, isOwn = true; i < parts.length; i += 1) {
          var part = parts[i];
          var first = $strSlice(part, 0, 1);
          var last = $strSlice(part, -1);
          if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
            throw new $SyntaxError("property names with quotes must have matching quotes");
          }
          if (part === "constructor" || !isOwn) {
            skipFurtherCaching = true;
          }
          intrinsicBaseName += "." + part;
          intrinsicRealName = "%" + intrinsicBaseName + "%";
          if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
          } else if (value != null) {
            if (!(part in value)) {
              if (!allowMissing) {
                throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
              }
              return void 0;
            }
            if ($gOPD && i + 1 >= parts.length) {
              var desc = $gOPD(value, part);
              isOwn = !!desc;
              if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
                value = desc.get;
              } else {
                value = value[part];
              }
            } else {
              isOwn = hasOwn(value, part);
              value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
              INTRINSICS[intrinsicRealName] = value;
            }
          }
        }
        return value;
      };
    }
  });

  // node_modules/call-bind/index.js
  var require_call_bind = __commonJS({
    "node_modules/call-bind/index.js"(exports, module) {
      "use strict";
      var bind = require_function_bind();
      var GetIntrinsic = require_get_intrinsic();
      var $apply = GetIntrinsic("%Function.prototype.apply%");
      var $call = GetIntrinsic("%Function.prototype.call%");
      var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
      var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var $max = GetIntrinsic("%Math.max%");
      if ($defineProperty) {
        try {
          $defineProperty({}, "a", { value: 1 });
        } catch (e) {
          $defineProperty = null;
        }
      }
      module.exports = function callBind(originalFunction) {
        var func = $reflectApply(bind, $call, arguments);
        if ($gOPD && $defineProperty) {
          var desc = $gOPD(func, "length");
          if (desc.configurable) {
            $defineProperty(
              func,
              "length",
              { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }
            );
          }
        }
        return func;
      };
      var applyBind = function applyBind2() {
        return $reflectApply(bind, $apply, arguments);
      };
      if ($defineProperty) {
        $defineProperty(module.exports, "apply", { value: applyBind });
      } else {
        module.exports.apply = applyBind;
      }
    }
  });

  // node_modules/call-bind/callBound.js
  var require_callBound = __commonJS({
    "node_modules/call-bind/callBound.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var callBind = require_call_bind();
      var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
      module.exports = function callBoundIntrinsic(name, allowMissing) {
        var intrinsic = GetIntrinsic(name, !!allowMissing);
        if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
          return callBind(intrinsic);
        }
        return intrinsic;
      };
    }
  });

  // node_modules/is-arguments/index.js
  var require_is_arguments = __commonJS({
    "node_modules/is-arguments/index.js"(exports, module) {
      "use strict";
      var hasToStringTag = require_shams2()();
      var callBound = require_callBound();
      var $toString = callBound("Object.prototype.toString");
      var isStandardArguments = function isArguments(value) {
        if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
          return false;
        }
        return $toString(value) === "[object Arguments]";
      };
      var isLegacyArguments = function isArguments(value) {
        if (isStandardArguments(value)) {
          return true;
        }
        return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
      };
      var supportsStandardArguments = function() {
        return isStandardArguments(arguments);
      }();
      isStandardArguments.isLegacyArguments = isLegacyArguments;
      module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
    }
  });

  // node_modules/has-property-descriptors/index.js
  var require_has_property_descriptors = __commonJS({
    "node_modules/has-property-descriptors/index.js"(exports, module) {
      "use strict";
      var GetIntrinsic = require_get_intrinsic();
      var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
      var hasPropertyDescriptors = function hasPropertyDescriptors2() {
        if ($defineProperty) {
          try {
            $defineProperty({}, "a", { value: 1 });
            return true;
          } catch (e) {
            return false;
          }
        }
        return false;
      };
      hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
        if (!hasPropertyDescriptors()) {
          return null;
        }
        try {
          return $defineProperty([], "length", { value: 1 }).length !== 1;
        } catch (e) {
          return true;
        }
      };
      module.exports = hasPropertyDescriptors;
    }
  });

  // node_modules/define-properties/index.js
  var require_define_properties = __commonJS({
    "node_modules/define-properties/index.js"(exports, module) {
      "use strict";
      var keys = require_object_keys();
      var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
      var toStr = Object.prototype.toString;
      var concat = Array.prototype.concat;
      var origDefineProperty = Object.defineProperty;
      var isFunction = function(fn) {
        return typeof fn === "function" && toStr.call(fn) === "[object Function]";
      };
      var hasPropertyDescriptors = require_has_property_descriptors()();
      var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;
      var defineProperty = function(object2, name, value, predicate) {
        if (name in object2) {
          if (predicate === true) {
            if (object2[name] === value) {
              return;
            }
          } else if (!isFunction(predicate) || !predicate()) {
            return;
          }
        }
        if (supportsDescriptors) {
          origDefineProperty(object2, name, {
            configurable: true,
            enumerable: false,
            value,
            writable: true
          });
        } else {
          object2[name] = value;
        }
      };
      var defineProperties = function(object2, map3) {
        var predicates = arguments.length > 2 ? arguments[2] : {};
        var props = keys(map3);
        if (hasSymbols) {
          props = concat.call(props, Object.getOwnPropertySymbols(map3));
        }
        for (var i = 0; i < props.length; i += 1) {
          defineProperty(object2, props[i], map3[props[i]], predicates[props[i]]);
        }
      };
      defineProperties.supportsDescriptors = !!supportsDescriptors;
      module.exports = defineProperties;
    }
  });

  // node_modules/object-is/implementation.js
  var require_implementation3 = __commonJS({
    "node_modules/object-is/implementation.js"(exports, module) {
      "use strict";
      var numberIsNaN = function(value) {
        return value !== value;
      };
      module.exports = function is(a, b) {
        if (a === 0 && b === 0) {
          return 1 / a === 1 / b;
        }
        if (a === b) {
          return true;
        }
        if (numberIsNaN(a) && numberIsNaN(b)) {
          return true;
        }
        return false;
      };
    }
  });

  // node_modules/object-is/polyfill.js
  var require_polyfill = __commonJS({
    "node_modules/object-is/polyfill.js"(exports, module) {
      "use strict";
      var implementation = require_implementation3();
      module.exports = function getPolyfill() {
        return typeof Object.is === "function" ? Object.is : implementation;
      };
    }
  });

  // node_modules/object-is/shim.js
  var require_shim = __commonJS({
    "node_modules/object-is/shim.js"(exports, module) {
      "use strict";
      var getPolyfill = require_polyfill();
      var define2 = require_define_properties();
      module.exports = function shimObjectIs() {
        var polyfill = getPolyfill();
        define2(Object, { is: polyfill }, {
          is: function testObjectIs() {
            return Object.is !== polyfill;
          }
        });
        return polyfill;
      };
    }
  });

  // node_modules/object-is/index.js
  var require_object_is = __commonJS({
    "node_modules/object-is/index.js"(exports, module) {
      "use strict";
      var define2 = require_define_properties();
      var callBind = require_call_bind();
      var implementation = require_implementation3();
      var getPolyfill = require_polyfill();
      var shim = require_shim();
      var polyfill = callBind(getPolyfill(), Object);
      define2(polyfill, {
        getPolyfill,
        implementation,
        shim
      });
      module.exports = polyfill;
    }
  });

  // node_modules/is-regex/index.js
  var require_is_regex = __commonJS({
    "node_modules/is-regex/index.js"(exports, module) {
      "use strict";
      var callBound = require_callBound();
      var hasToStringTag = require_shams2()();
      var has;
      var $exec;
      var isRegexMarker;
      var badStringifier;
      if (hasToStringTag) {
        has = callBound("Object.prototype.hasOwnProperty");
        $exec = callBound("RegExp.prototype.exec");
        isRegexMarker = {};
        throwRegexMarker = function() {
          throw isRegexMarker;
        };
        badStringifier = {
          toString: throwRegexMarker,
          valueOf: throwRegexMarker
        };
        if (typeof Symbol.toPrimitive === "symbol") {
          badStringifier[Symbol.toPrimitive] = throwRegexMarker;
        }
      }
      var throwRegexMarker;
      var $toString = callBound("Object.prototype.toString");
      var gOPD = Object.getOwnPropertyDescriptor;
      var regexClass = "[object RegExp]";
      module.exports = hasToStringTag ? function isRegex(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        var descriptor = gOPD(value, "lastIndex");
        var hasLastIndexDataProperty = descriptor && has(descriptor, "value");
        if (!hasLastIndexDataProperty) {
          return false;
        }
        try {
          $exec(value, badStringifier);
        } catch (e) {
          return e === isRegexMarker;
        }
      } : function isRegex(value) {
        if (!value || typeof value !== "object" && typeof value !== "function") {
          return false;
        }
        return $toString(value) === regexClass;
      };
    }
  });

  // node_modules/functions-have-names/index.js
  var require_functions_have_names = __commonJS({
    "node_modules/functions-have-names/index.js"(exports, module) {
      "use strict";
      var functionsHaveNames = function functionsHaveNames2() {
        return typeof function f() {
        }.name === "string";
      };
      var gOPD = Object.getOwnPropertyDescriptor;
      if (gOPD) {
        try {
          gOPD([], "length");
        } catch (e) {
          gOPD = null;
        }
      }
      functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
        if (!functionsHaveNames() || !gOPD) {
          return false;
        }
        var desc = gOPD(function() {
        }, "name");
        return !!desc && !!desc.configurable;
      };
      var $bind = Function.prototype.bind;
      functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
        return functionsHaveNames() && typeof $bind === "function" && function f() {
        }.bind().name !== "";
      };
      module.exports = functionsHaveNames;
    }
  });

  // node_modules/regexp.prototype.flags/implementation.js
  var require_implementation4 = __commonJS({
    "node_modules/regexp.prototype.flags/implementation.js"(exports, module) {
      "use strict";
      var functionsHaveConfigurableNames = require_functions_have_names().functionsHaveConfigurableNames();
      var $Object = Object;
      var $TypeError = TypeError;
      module.exports = function flags() {
        if (this != null && this !== $Object(this)) {
          throw new $TypeError("RegExp.prototype.flags getter called on non-object");
        }
        var result = "";
        if (this.hasIndices) {
          result += "d";
        }
        if (this.global) {
          result += "g";
        }
        if (this.ignoreCase) {
          result += "i";
        }
        if (this.multiline) {
          result += "m";
        }
        if (this.dotAll) {
          result += "s";
        }
        if (this.unicode) {
          result += "u";
        }
        if (this.sticky) {
          result += "y";
        }
        return result;
      };
      if (functionsHaveConfigurableNames && Object.defineProperty) {
        Object.defineProperty(module.exports, "name", { value: "get flags" });
      }
    }
  });

  // node_modules/regexp.prototype.flags/polyfill.js
  var require_polyfill2 = __commonJS({
    "node_modules/regexp.prototype.flags/polyfill.js"(exports, module) {
      "use strict";
      var implementation = require_implementation4();
      var supportsDescriptors = require_define_properties().supportsDescriptors;
      var $gOPD = Object.getOwnPropertyDescriptor;
      module.exports = function getPolyfill() {
        if (supportsDescriptors && /a/mig.flags === "gim") {
          var descriptor = $gOPD(RegExp.prototype, "flags");
          if (descriptor && typeof descriptor.get === "function" && typeof RegExp.prototype.dotAll === "boolean" && typeof RegExp.prototype.hasIndices === "boolean") {
            var calls = "";
            var o = {};
            Object.defineProperty(o, "hasIndices", {
              get: function() {
                calls += "d";
              }
            });
            Object.defineProperty(o, "sticky", {
              get: function() {
                calls += "y";
              }
            });
            if (calls === "dy") {
              return descriptor.get;
            }
          }
        }
        return implementation;
      };
    }
  });

  // node_modules/regexp.prototype.flags/shim.js
  var require_shim2 = __commonJS({
    "node_modules/regexp.prototype.flags/shim.js"(exports, module) {
      "use strict";
      var supportsDescriptors = require_define_properties().supportsDescriptors;
      var getPolyfill = require_polyfill2();
      var gOPD = Object.getOwnPropertyDescriptor;
      var defineProperty = Object.defineProperty;
      var TypeErr = TypeError;
      var getProto = Object.getPrototypeOf;
      var regex = /a/;
      module.exports = function shimFlags() {
        if (!supportsDescriptors || !getProto) {
          throw new TypeErr("RegExp.prototype.flags requires a true ES5 environment that supports property descriptors");
        }
        var polyfill = getPolyfill();
        var proto = getProto(regex);
        var descriptor = gOPD(proto, "flags");
        if (!descriptor || descriptor.get !== polyfill) {
          defineProperty(proto, "flags", {
            configurable: true,
            enumerable: false,
            get: polyfill
          });
        }
        return polyfill;
      };
    }
  });

  // node_modules/regexp.prototype.flags/index.js
  var require_regexp_prototype = __commonJS({
    "node_modules/regexp.prototype.flags/index.js"(exports, module) {
      "use strict";
      var define2 = require_define_properties();
      var callBind = require_call_bind();
      var implementation = require_implementation4();
      var getPolyfill = require_polyfill2();
      var shim = require_shim2();
      var flagsBound = callBind(getPolyfill());
      define2(flagsBound, {
        getPolyfill,
        implementation,
        shim
      });
      module.exports = flagsBound;
    }
  });

  // node_modules/is-date-object/index.js
  var require_is_date_object = __commonJS({
    "node_modules/is-date-object/index.js"(exports, module) {
      "use strict";
      var getDay = Date.prototype.getDay;
      var tryDateObject = function tryDateGetDayCall(value) {
        try {
          getDay.call(value);
          return true;
        } catch (e) {
          return false;
        }
      };
      var toStr = Object.prototype.toString;
      var dateClass = "[object Date]";
      var hasToStringTag = require_shams2()();
      module.exports = function isDateObject(value) {
        if (typeof value !== "object" || value === null) {
          return false;
        }
        return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
      };
    }
  });

  // node_modules/deep-equal/index.js
  var require_deep_equal = __commonJS({
    "node_modules/deep-equal/index.js"(exports, module) {
      var objectKeys = require_object_keys();
      var isArguments = require_is_arguments();
      var is = require_object_is();
      var isRegex = require_is_regex();
      var flags = require_regexp_prototype();
      var isDate = require_is_date_object();
      var getTime = Date.prototype.getTime;
      function deepEqual(actual, expected, options) {
        var opts = options || {};
        if (opts.strict ? is(actual, expected) : actual === expected) {
          return true;
        }
        if (!actual || !expected || typeof actual !== "object" && typeof expected !== "object") {
          return opts.strict ? is(actual, expected) : actual == expected;
        }
        return objEquiv(actual, expected, opts);
      }
      function isUndefinedOrNull(value) {
        return value === null || value === void 0;
      }
      function isBuffer(x2) {
        if (!x2 || typeof x2 !== "object" || typeof x2.length !== "number") {
          return false;
        }
        if (typeof x2.copy !== "function" || typeof x2.slice !== "function") {
          return false;
        }
        if (x2.length > 0 && typeof x2[0] !== "number") {
          return false;
        }
        return true;
      }
      function objEquiv(a, b, opts) {
        var i, key;
        if (typeof a !== typeof b) {
          return false;
        }
        if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) {
          return false;
        }
        if (a.prototype !== b.prototype) {
          return false;
        }
        if (isArguments(a) !== isArguments(b)) {
          return false;
        }
        var aIsRegex = isRegex(a);
        var bIsRegex = isRegex(b);
        if (aIsRegex !== bIsRegex) {
          return false;
        }
        if (aIsRegex || bIsRegex) {
          return a.source === b.source && flags(a) === flags(b);
        }
        if (isDate(a) && isDate(b)) {
          return getTime.call(a) === getTime.call(b);
        }
        var aIsBuffer = isBuffer(a);
        var bIsBuffer = isBuffer(b);
        if (aIsBuffer !== bIsBuffer) {
          return false;
        }
        if (aIsBuffer || bIsBuffer) {
          if (a.length !== b.length) {
            return false;
          }
          for (i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) {
              return false;
            }
          }
          return true;
        }
        if (typeof a !== typeof b) {
          return false;
        }
        try {
          var ka = objectKeys(a);
          var kb = objectKeys(b);
        } catch (e) {
          return false;
        }
        if (ka.length !== kb.length) {
          return false;
        }
        ka.sort();
        kb.sort();
        for (i = ka.length - 1; i >= 0; i--) {
          if (ka[i] != kb[i]) {
            return false;
          }
        }
        for (i = ka.length - 1; i >= 0; i--) {
          key = ka[i];
          if (!deepEqual(a[key], b[key], opts)) {
            return false;
          }
        }
        return true;
      }
      module.exports = deepEqual;
    }
  });

  // node_modules/geojson-equality/index.js
  var require_geojson_equality = __commonJS({
    "node_modules/geojson-equality/index.js"(exports, module) {
      var deepEqual = require_deep_equal();
      var Equality = function(opt) {
        this.precision = opt && opt.precision ? opt.precision : 17;
        this.direction = opt && opt.direction ? opt.direction : false;
        this.pseudoNode = opt && opt.pseudoNode ? opt.pseudoNode : false;
        this.objectComparator = opt && opt.objectComparator ? opt.objectComparator : objectComparator;
      };
      Equality.prototype.compare = function(g1, g2) {
        if (g1.type !== g2.type || !sameLength(g1, g2))
          return false;
        switch (g1.type) {
          case "Point":
            return this.compareCoord(g1.coordinates, g2.coordinates);
            break;
          case "LineString":
            return this.compareLine(g1.coordinates, g2.coordinates, 0, false);
            break;
          case "Polygon":
            return this.comparePolygon(g1, g2);
            break;
          case "Feature":
            return this.compareFeature(g1, g2);
          default:
            if (g1.type.indexOf("Multi") === 0) {
              var context = this;
              var g1s = explode(g1);
              var g2s = explode(g2);
              return g1s.every(function(g1part) {
                return this.some(function(g2part) {
                  return context.compare(g1part, g2part);
                });
              }, g2s);
            }
        }
        return false;
      };
      function explode(g) {
        return g.coordinates.map(function(part) {
          return {
            type: g.type.replace("Multi", ""),
            coordinates: part
          };
        });
      }
      function sameLength(g1, g2) {
        return g1.hasOwnProperty("coordinates") ? g1.coordinates.length === g2.coordinates.length : g1.length === g2.length;
      }
      Equality.prototype.compareCoord = function(c1, c2) {
        if (c1.length !== c2.length) {
          return false;
        }
        for (var i = 0; i < c1.length; i++) {
          if (c1[i].toFixed(this.precision) !== c2[i].toFixed(this.precision)) {
            return false;
          }
        }
        return true;
      };
      Equality.prototype.compareLine = function(path1, path2, ind, isPoly) {
        if (!sameLength(path1, path2))
          return false;
        var p1 = this.pseudoNode ? path1 : this.removePseudo(path1);
        var p2 = this.pseudoNode ? path2 : this.removePseudo(path2);
        if (isPoly && !this.compareCoord(p1[0], p2[0])) {
          p2 = this.fixStartIndex(p2, p1);
          if (!p2)
            return;
        }
        var sameDirection = this.compareCoord(p1[ind], p2[ind]);
        if (this.direction || sameDirection) {
          return this.comparePath(p1, p2);
        } else {
          if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {
            return this.comparePath(p1.slice().reverse(), p2);
          }
          return false;
        }
      };
      Equality.prototype.fixStartIndex = function(sourcePath, targetPath) {
        var correctPath, ind = -1;
        for (var i = 0; i < sourcePath.length; i++) {
          if (this.compareCoord(sourcePath[i], targetPath[0])) {
            ind = i;
            break;
          }
        }
        if (ind >= 0) {
          correctPath = [].concat(
            sourcePath.slice(ind, sourcePath.length),
            sourcePath.slice(1, ind + 1)
          );
        }
        return correctPath;
      };
      Equality.prototype.comparePath = function(p1, p2) {
        var cont = this;
        return p1.every(function(c, i) {
          return cont.compareCoord(c, this[i]);
        }, p2);
      };
      Equality.prototype.comparePolygon = function(g1, g2) {
        if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {
          var holes1 = g1.coordinates.slice(1, g1.coordinates.length);
          var holes2 = g2.coordinates.slice(1, g2.coordinates.length);
          var cont = this;
          return holes1.every(function(h1) {
            return this.some(function(h2) {
              return cont.compareLine(h1, h2, 1, true);
            });
          }, holes2);
        } else {
          return false;
        }
      };
      Equality.prototype.compareFeature = function(g1, g2) {
        if (g1.id !== g2.id || !this.objectComparator(g1.properties, g2.properties) || !this.compareBBox(g1, g2)) {
          return false;
        }
        return this.compare(g1.geometry, g2.geometry);
      };
      Equality.prototype.compareBBox = function(g1, g2) {
        if (!g1.bbox && !g2.bbox || g1.bbox && g2.bbox && this.compareCoord(g1.bbox, g2.bbox)) {
          return true;
        }
        return false;
      };
      Equality.prototype.removePseudo = function(path) {
        return path;
      };
      function objectComparator(obj1, obj2) {
        return deepEqual(obj1, obj2, { strict: true });
      }
      module.exports = Equality;
    }
  });

  // node_modules/density-clustering/lib/DBSCAN.js
  var require_DBSCAN = __commonJS({
    "node_modules/density-clustering/lib/DBSCAN.js"(exports, module) {
      function DBSCAN(dataset, epsilon4, minPts, distanceFunction) {
        this.dataset = [];
        this.epsilon = 1;
        this.minPts = 2;
        this.distance = this._euclideanDistance;
        this.clusters = [];
        this.noise = [];
        this._visited = [];
        this._assigned = [];
        this._datasetLength = 0;
        this._init(dataset, epsilon4, minPts, distanceFunction);
      }
      DBSCAN.prototype.run = function(dataset, epsilon4, minPts, distanceFunction) {
        this._init(dataset, epsilon4, minPts, distanceFunction);
        for (var pointId = 0; pointId < this._datasetLength; pointId++) {
          if (this._visited[pointId] !== 1) {
            this._visited[pointId] = 1;
            var neighbors = this._regionQuery(pointId);
            if (neighbors.length < this.minPts) {
              this.noise.push(pointId);
            } else {
              var clusterId = this.clusters.length;
              this.clusters.push([]);
              this._addToCluster(pointId, clusterId);
              this._expandCluster(clusterId, neighbors);
            }
          }
        }
        return this.clusters;
      };
      DBSCAN.prototype._init = function(dataset, epsilon4, minPts, distance2) {
        if (dataset) {
          if (!(dataset instanceof Array)) {
            throw Error("Dataset must be of type array, " + typeof dataset + " given");
          }
          this.dataset = dataset;
          this.clusters = [];
          this.noise = [];
          this._datasetLength = dataset.length;
          this._visited = new Array(this._datasetLength);
          this._assigned = new Array(this._datasetLength);
        }
        if (epsilon4) {
          this.epsilon = epsilon4;
        }
        if (minPts) {
          this.minPts = minPts;
        }
        if (distance2) {
          this.distance = distance2;
        }
      };
      DBSCAN.prototype._expandCluster = function(clusterId, neighbors) {
        for (var i = 0; i < neighbors.length; i++) {
          var pointId2 = neighbors[i];
          if (this._visited[pointId2] !== 1) {
            this._visited[pointId2] = 1;
            var neighbors2 = this._regionQuery(pointId2);
            if (neighbors2.length >= this.minPts) {
              neighbors = this._mergeArrays(neighbors, neighbors2);
            }
          }
          if (this._assigned[pointId2] !== 1) {
            this._addToCluster(pointId2, clusterId);
          }
        }
      };
      DBSCAN.prototype._addToCluster = function(pointId, clusterId) {
        this.clusters[clusterId].push(pointId);
        this._assigned[pointId] = 1;
      };
      DBSCAN.prototype._regionQuery = function(pointId) {
        var neighbors = [];
        for (var id = 0; id < this._datasetLength; id++) {
          var dist = this.distance(this.dataset[pointId], this.dataset[id]);
          if (dist < this.epsilon) {
            neighbors.push(id);
          }
        }
        return neighbors;
      };
      DBSCAN.prototype._mergeArrays = function(a, b) {
        var len = b.length;
        for (var i = 0; i < len; i++) {
          var P = b[i];
          if (a.indexOf(P) < 0) {
            a.push(P);
          }
        }
        return a;
      };
      DBSCAN.prototype._euclideanDistance = function(p, q) {
        var sum2 = 0;
        var i = Math.min(p.length, q.length);
        while (i--) {
          sum2 += (p[i] - q[i]) * (p[i] - q[i]);
        }
        return Math.sqrt(sum2);
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = DBSCAN;
      }
    }
  });

  // node_modules/density-clustering/lib/KMEANS.js
  var require_KMEANS = __commonJS({
    "node_modules/density-clustering/lib/KMEANS.js"(exports, module) {
      function KMEANS(dataset, k, distance2) {
        this.k = 3;
        this.dataset = [];
        this.assignments = [];
        this.centroids = [];
        this.init(dataset, k, distance2);
      }
      KMEANS.prototype.init = function(dataset, k, distance2) {
        this.assignments = [];
        this.centroids = [];
        if (typeof dataset !== "undefined") {
          this.dataset = dataset;
        }
        if (typeof k !== "undefined") {
          this.k = k;
        }
        if (typeof distance2 !== "undefined") {
          this.distance = distance2;
        }
      };
      KMEANS.prototype.run = function(dataset, k) {
        this.init(dataset, k);
        var len = this.dataset.length;
        for (var i = 0; i < this.k; i++) {
          this.centroids[i] = this.randomCentroid();
        }
        var change = true;
        while (change) {
          change = this.assign();
          for (var centroidId = 0; centroidId < this.k; centroidId++) {
            var mean = new Array(maxDim);
            var count = 0;
            for (var dim = 0; dim < maxDim; dim++) {
              mean[dim] = 0;
            }
            for (var j = 0; j < len; j++) {
              var maxDim = this.dataset[j].length;
              if (centroidId === this.assignments[j]) {
                for (var dim = 0; dim < maxDim; dim++) {
                  mean[dim] += this.dataset[j][dim];
                }
                count++;
              }
            }
            if (count > 0) {
              for (var dim = 0; dim < maxDim; dim++) {
                mean[dim] /= count;
              }
              this.centroids[centroidId] = mean;
            } else {
              this.centroids[centroidId] = this.randomCentroid();
              change = true;
            }
          }
        }
        return this.getClusters();
      };
      KMEANS.prototype.randomCentroid = function() {
        var maxId = this.dataset.length - 1;
        var centroid;
        var id;
        do {
          id = Math.round(Math.random() * maxId);
          centroid = this.dataset[id];
        } while (this.centroids.indexOf(centroid) >= 0);
        return centroid;
      };
      KMEANS.prototype.assign = function() {
        var change = false;
        var len = this.dataset.length;
        var closestCentroid;
        for (var i = 0; i < len; i++) {
          closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);
          if (closestCentroid != this.assignments[i]) {
            this.assignments[i] = closestCentroid;
            change = true;
          }
        }
        return change;
      };
      KMEANS.prototype.getClusters = function() {
        var clusters = new Array(this.k);
        var centroidId;
        for (var pointId = 0; pointId < this.assignments.length; pointId++) {
          centroidId = this.assignments[pointId];
          if (typeof clusters[centroidId] === "undefined") {
            clusters[centroidId] = [];
          }
          clusters[centroidId].push(pointId);
        }
        return clusters;
      };
      KMEANS.prototype.argmin = function(point2, set, f) {
        var min = Number.MAX_VALUE;
        var arg = 0;
        var len = set.length;
        var d;
        for (var i = 0; i < len; i++) {
          d = f(point2, set[i]);
          if (d < min) {
            min = d;
            arg = i;
          }
        }
        return arg;
      };
      KMEANS.prototype.distance = function(p, q) {
        var sum2 = 0;
        var i = Math.min(p.length, q.length);
        while (i--) {
          var diff = p[i] - q[i];
          sum2 += diff * diff;
        }
        return Math.sqrt(sum2);
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = KMEANS;
      }
    }
  });

  // node_modules/density-clustering/lib/PriorityQueue.js
  var require_PriorityQueue = __commonJS({
    "node_modules/density-clustering/lib/PriorityQueue.js"(exports, module) {
      function PriorityQueue(elements, priorities, sorting) {
        this._queue = [];
        this._priorities = [];
        this._sorting = "desc";
        this._init(elements, priorities, sorting);
      }
      PriorityQueue.prototype.insert = function(ele, priority) {
        var indexToInsert = this._queue.length;
        var index = indexToInsert;
        while (index--) {
          var priority2 = this._priorities[index];
          if (this._sorting === "desc") {
            if (priority > priority2) {
              indexToInsert = index;
            }
          } else {
            if (priority < priority2) {
              indexToInsert = index;
            }
          }
        }
        this._insertAt(ele, priority, indexToInsert);
      };
      PriorityQueue.prototype.remove = function(ele) {
        var index = this._queue.length;
        while (index--) {
          var ele2 = this._queue[index];
          if (ele === ele2) {
            this._queue.splice(index, 1);
            this._priorities.splice(index, 1);
            break;
          }
        }
      };
      PriorityQueue.prototype.forEach = function(func) {
        this._queue.forEach(func);
      };
      PriorityQueue.prototype.getElements = function() {
        return this._queue;
      };
      PriorityQueue.prototype.getElementPriority = function(index) {
        return this._priorities[index];
      };
      PriorityQueue.prototype.getPriorities = function() {
        return this._priorities;
      };
      PriorityQueue.prototype.getElementsWithPriorities = function() {
        var result = [];
        for (var i = 0, l = this._queue.length; i < l; i++) {
          result.push([this._queue[i], this._priorities[i]]);
        }
        return result;
      };
      PriorityQueue.prototype._init = function(elements, priorities, sorting) {
        if (elements && priorities) {
          this._queue = [];
          this._priorities = [];
          if (elements.length !== priorities.length) {
            throw new Error("Arrays must have the same length");
          }
          for (var i = 0; i < elements.length; i++) {
            this.insert(elements[i], priorities[i]);
          }
        }
        if (sorting) {
          this._sorting = sorting;
        }
      };
      PriorityQueue.prototype._insertAt = function(ele, priority, index) {
        if (this._queue.length === index) {
          this._queue.push(ele);
          this._priorities.push(priority);
        } else {
          this._queue.splice(index, 0, ele);
          this._priorities.splice(index, 0, priority);
        }
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = PriorityQueue;
      }
    }
  });

  // node_modules/density-clustering/lib/OPTICS.js
  var require_OPTICS = __commonJS({
    "node_modules/density-clustering/lib/OPTICS.js"(exports, module) {
      if (typeof module !== "undefined" && module.exports) {
        PriorityQueue = require_PriorityQueue();
      }
      var PriorityQueue;
      function OPTICS(dataset, epsilon4, minPts, distanceFunction) {
        this.epsilon = 1;
        this.minPts = 1;
        this.distance = this._euclideanDistance;
        this._reachability = [];
        this._processed = [];
        this._coreDistance = 0;
        this._orderedList = [];
        this._init(dataset, epsilon4, minPts, distanceFunction);
      }
      OPTICS.prototype.run = function(dataset, epsilon4, minPts, distanceFunction) {
        this._init(dataset, epsilon4, minPts, distanceFunction);
        for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {
          if (this._processed[pointId] !== 1) {
            this._processed[pointId] = 1;
            this.clusters.push([pointId]);
            var clusterId = this.clusters.length - 1;
            this._orderedList.push(pointId);
            var priorityQueue = new PriorityQueue(null, null, "asc");
            var neighbors = this._regionQuery(pointId);
            if (this._distanceToCore(pointId) !== void 0) {
              this._updateQueue(pointId, neighbors, priorityQueue);
              this._expandCluster(clusterId, priorityQueue);
            }
          }
        }
        return this.clusters;
      };
      OPTICS.prototype.getReachabilityPlot = function() {
        var reachabilityPlot = [];
        for (var i = 0, l = this._orderedList.length; i < l; i++) {
          var pointId = this._orderedList[i];
          var distance2 = this._reachability[pointId];
          reachabilityPlot.push([pointId, distance2]);
        }
        return reachabilityPlot;
      };
      OPTICS.prototype._init = function(dataset, epsilon4, minPts, distance2) {
        if (dataset) {
          if (!(dataset instanceof Array)) {
            throw Error("Dataset must be of type array, " + typeof dataset + " given");
          }
          this.dataset = dataset;
          this.clusters = [];
          this._reachability = new Array(this.dataset.length);
          this._processed = new Array(this.dataset.length);
          this._coreDistance = 0;
          this._orderedList = [];
        }
        if (epsilon4) {
          this.epsilon = epsilon4;
        }
        if (minPts) {
          this.minPts = minPts;
        }
        if (distance2) {
          this.distance = distance2;
        }
      };
      OPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {
        var self2 = this;
        this._coreDistance = this._distanceToCore(pointId);
        neighbors.forEach(function(pointId2) {
          if (self2._processed[pointId2] === void 0) {
            var dist = self2.distance(self2.dataset[pointId], self2.dataset[pointId2]);
            var newReachableDistance = Math.max(self2._coreDistance, dist);
            if (self2._reachability[pointId2] === void 0) {
              self2._reachability[pointId2] = newReachableDistance;
              queue.insert(pointId2, newReachableDistance);
            } else {
              if (newReachableDistance < self2._reachability[pointId2]) {
                self2._reachability[pointId2] = newReachableDistance;
                queue.remove(pointId2);
                queue.insert(pointId2, newReachableDistance);
              }
            }
          }
        });
      };
      OPTICS.prototype._expandCluster = function(clusterId, queue) {
        var queueElements = queue.getElements();
        for (var p = 0, l = queueElements.length; p < l; p++) {
          var pointId = queueElements[p];
          if (this._processed[pointId] === void 0) {
            var neighbors = this._regionQuery(pointId);
            this._processed[pointId] = 1;
            this.clusters[clusterId].push(pointId);
            this._orderedList.push(pointId);
            if (this._distanceToCore(pointId) !== void 0) {
              this._updateQueue(pointId, neighbors, queue);
              this._expandCluster(clusterId, queue);
            }
          }
        }
      };
      OPTICS.prototype._distanceToCore = function(pointId) {
        var l = this.epsilon;
        for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {
          var neighbors = this._regionQuery(pointId, coreDistCand);
          if (neighbors.length >= this.minPts) {
            return coreDistCand;
          }
        }
        return;
      };
      OPTICS.prototype._regionQuery = function(pointId, epsilon4) {
        epsilon4 = epsilon4 || this.epsilon;
        var neighbors = [];
        for (var id = 0, l = this.dataset.length; id < l; id++) {
          if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon4) {
            neighbors.push(id);
          }
        }
        return neighbors;
      };
      OPTICS.prototype._euclideanDistance = function(p, q) {
        var sum2 = 0;
        var i = Math.min(p.length, q.length);
        while (i--) {
          sum2 += (p[i] - q[i]) * (p[i] - q[i]);
        }
        return Math.sqrt(sum2);
      };
      if (typeof module !== "undefined" && module.exports) {
        module.exports = OPTICS;
      }
    }
  });

  // node_modules/density-clustering/lib/index.js
  var require_lib = __commonJS({
    "node_modules/density-clustering/lib/index.js"(exports, module) {
      if (typeof module !== "undefined" && module.exports) {
        module.exports = {
          DBSCAN: require_DBSCAN(),
          KMEANS: require_KMEANS(),
          OPTICS: require_OPTICS(),
          PriorityQueue: require_PriorityQueue()
        };
      }
    }
  });

  // node_modules/skmeans/dist/node/distance.js
  var require_distance = __commonJS({
    "node_modules/skmeans/dist/node/distance.js"(exports, module) {
      "use strict";
      module.exports = {
        /**
         * Euclidean distance
         */
        eudist: function eudist(v1, v2, sqrt2) {
          var len = v1.length;
          var sum2 = 0;
          for (var i = 0; i < len; i++) {
            var d = (v1[i] || 0) - (v2[i] || 0);
            sum2 += d * d;
          }
          return sqrt2 ? Math.sqrt(sum2) : sum2;
        },
        mandist: function mandist(v1, v2, sqrt2) {
          var len = v1.length;
          var sum2 = 0;
          for (var i = 0; i < len; i++) {
            sum2 += Math.abs((v1[i] || 0) - (v2[i] || 0));
          }
          return sqrt2 ? Math.sqrt(sum2) : sum2;
        },
        /**
         * Unidimensional distance
         */
        dist: function dist(v1, v2, sqrt2) {
          var d = Math.abs(v1 - v2);
          return sqrt2 ? d : d * d;
        }
      };
    }
  });

  // node_modules/skmeans/dist/node/kinit.js
  var require_kinit = __commonJS({
    "node_modules/skmeans/dist/node/kinit.js"(exports, module) {
      "use strict";
      var Distance = require_distance();
      var eudist = Distance.eudist;
      var dist = Distance.dist;
      module.exports = {
        kmrand: function kmrand(data, k) {
          var map3 = {}, ks = [], t = k << 2;
          var len = data.length;
          var multi = data[0].length > 0;
          while (ks.length < k && t-- > 0) {
            var d = data[Math.floor(Math.random() * len)];
            var key = multi ? d.join("_") : "" + d;
            if (!map3[key]) {
              map3[key] = true;
              ks.push(d);
            }
          }
          if (ks.length < k)
            throw new Error("Error initializating clusters");
          else
            return ks;
        },
        /**
         * K-means++ initial centroid selection
         */
        kmpp: function kmpp(data, k) {
          var distance2 = data[0].length ? eudist : dist;
          var ks = [], len = data.length;
          var multi = data[0].length > 0;
          var map3 = {};
          var c = data[Math.floor(Math.random() * len)];
          var key = multi ? c.join("_") : "" + c;
          ks.push(c);
          map3[key] = true;
          while (ks.length < k) {
            var dists = [], lk = ks.length;
            var dsum = 0, prs = [];
            for (var i = 0; i < len; i++) {
              var min = Infinity;
              for (var j = 0; j < lk; j++) {
                var _dist = distance2(data[i], ks[j]);
                if (_dist <= min)
                  min = _dist;
              }
              dists[i] = min;
            }
            for (var _i = 0; _i < len; _i++) {
              dsum += dists[_i];
            }
            for (var _i2 = 0; _i2 < len; _i2++) {
              prs[_i2] = { i: _i2, v: data[_i2], pr: dists[_i2] / dsum, cs: 0 };
            }
            prs.sort(function(a, b) {
              return a.pr - b.pr;
            });
            prs[0].cs = prs[0].pr;
            for (var _i3 = 1; _i3 < len; _i3++) {
              prs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;
            }
            var rnd = Math.random();
            var idx = 0;
            while (idx < len - 1 && prs[idx++].cs < rnd) {
            }
            ks.push(prs[idx - 1].v);
          }
          return ks;
        }
      };
    }
  });

  // node_modules/skmeans/dist/node/main.js
  var require_main = __commonJS({
    "node_modules/skmeans/dist/node/main.js"(exports, module) {
      "use strict";
      var Distance = require_distance();
      var ClusterInit = require_kinit();
      var eudist = Distance.eudist;
      var mandist = Distance.mandist;
      var dist = Distance.dist;
      var kmrand = ClusterInit.kmrand;
      var kmpp = ClusterInit.kmpp;
      var MAX = 1e4;
      function init(len, val, v) {
        v = v || [];
        for (var i = 0; i < len; i++) {
          v[i] = val;
        }
        return v;
      }
      function skmeans2(data, k, initial, maxit) {
        var ks = [], old = [], idxs = [], dist2 = [];
        var conv = false, it = maxit || MAX;
        var len = data.length, vlen = data[0].length, multi = vlen > 0;
        var count = [];
        if (!initial) {
          var _idxs = {};
          while (ks.length < k) {
            var idx = Math.floor(Math.random() * len);
            if (!_idxs[idx]) {
              _idxs[idx] = true;
              ks.push(data[idx]);
            }
          }
        } else if (initial == "kmrand") {
          ks = kmrand(data, k);
        } else if (initial == "kmpp") {
          ks = kmpp(data, k);
        } else {
          ks = initial;
        }
        do {
          init(k, 0, count);
          for (var i = 0; i < len; i++) {
            var min = Infinity, _idx = 0;
            for (var j = 0; j < k; j++) {
              var dist2 = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);
              if (dist2 <= min) {
                min = dist2;
                _idx = j;
              }
            }
            idxs[i] = _idx;
            count[_idx]++;
          }
          var sum2 = [], old = [], dif = 0;
          for (var _j = 0; _j < k; _j++) {
            sum2[_j] = multi ? init(vlen, 0, sum2[_j]) : 0;
            old[_j] = ks[_j];
          }
          if (multi) {
            for (var _j2 = 0; _j2 < k; _j2++) {
              ks[_j2] = [];
            }
            for (var _i = 0; _i < len; _i++) {
              var _idx2 = idxs[_i], vsum = sum2[_idx2], vect = data[_i];
              for (var h = 0; h < vlen; h++) {
                vsum[h] += vect[h];
              }
            }
            conv = true;
            for (var _j3 = 0; _j3 < k; _j3++) {
              var ksj = ks[_j3], sumj = sum2[_j3], oldj = old[_j3], cj = count[_j3];
              for (var _h = 0; _h < vlen; _h++) {
                ksj[_h] = sumj[_h] / cj || 0;
              }
              if (conv) {
                for (var _h2 = 0; _h2 < vlen; _h2++) {
                  if (oldj[_h2] != ksj[_h2]) {
                    conv = false;
                    break;
                  }
                }
              }
            }
          } else {
            for (var _i2 = 0; _i2 < len; _i2++) {
              var _idx3 = idxs[_i2];
              sum2[_idx3] += data[_i2];
            }
            for (var _j4 = 0; _j4 < k; _j4++) {
              ks[_j4] = sum2[_j4] / count[_j4] || 0;
            }
            conv = true;
            for (var _j5 = 0; _j5 < k; _j5++) {
              if (old[_j5] != ks[_j5]) {
                conv = false;
                break;
              }
            }
          }
          conv = conv || --it <= 0;
        } while (!conv);
        return {
          it: MAX - it,
          k,
          idxs,
          centroids: ks
        };
      }
      module.exports = skmeans2;
    }
  });

  // node_modules/polygon-clipping/dist/polygon-clipping.umd.js
  var require_polygon_clipping_umd = __commonJS({
    "node_modules/polygon-clipping/dist/polygon-clipping.umd.js"(exports, module) {
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.polygonClipping = factory());
      })(exports, function() {
        "use strict";
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties(Constructor, staticProps);
          return Constructor;
        }
        var Node2 = (
          /** @class */
          function() {
            function Node3(key, data) {
              this.next = null;
              this.key = key;
              this.data = data;
              this.left = null;
              this.right = null;
            }
            return Node3;
          }()
        );
        function DEFAULT_COMPARE(a, b) {
          return a > b ? 1 : a < b ? -1 : 0;
        }
        function splay(i, t, comparator) {
          var N = new Node2(null, null);
          var l = N;
          var r = N;
          while (true) {
            var cmp2 = comparator(i, t.key);
            if (cmp2 < 0) {
              if (t.left === null)
                break;
              if (comparator(i, t.left.key) < 0) {
                var y2 = t.left;
                t.left = y2.right;
                y2.right = t;
                t = y2;
                if (t.left === null)
                  break;
              }
              r.left = t;
              r = t;
              t = t.left;
            } else if (cmp2 > 0) {
              if (t.right === null)
                break;
              if (comparator(i, t.right.key) > 0) {
                var y2 = t.right;
                t.right = y2.left;
                y2.left = t;
                t = y2;
                if (t.right === null)
                  break;
              }
              l.right = t;
              l = t;
              t = t.right;
            } else
              break;
          }
          l.right = t.left;
          r.left = t.right;
          t.left = N.right;
          t.right = N.left;
          return t;
        }
        function insert(i, data, t, comparator) {
          var node = new Node2(i, data);
          if (t === null) {
            node.left = node.right = null;
            return node;
          }
          t = splay(i, t, comparator);
          var cmp2 = comparator(i, t.key);
          if (cmp2 < 0) {
            node.left = t.left;
            node.right = t;
            t.left = null;
          } else if (cmp2 >= 0) {
            node.right = t.right;
            node.left = t;
            t.right = null;
          }
          return node;
        }
        function split(key, v, comparator) {
          var left = null;
          var right = null;
          if (v) {
            v = splay(key, v, comparator);
            var cmp2 = comparator(v.key, key);
            if (cmp2 === 0) {
              left = v.left;
              right = v.right;
            } else if (cmp2 < 0) {
              right = v.right;
              v.right = null;
              left = v;
            } else {
              left = v.left;
              v.left = null;
              right = v;
            }
          }
          return {
            left,
            right
          };
        }
        function merge(left, right, comparator) {
          if (right === null)
            return left;
          if (left === null)
            return right;
          right = splay(left.key, right, comparator);
          right.left = left;
          return right;
        }
        function printRow(root, prefix, isTail, out, printNode) {
          if (root) {
            out("" + prefix + (isTail ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ") + printNode(root) + "\n");
            var indent = prefix + (isTail ? "    " : "\u2502   ");
            if (root.left)
              printRow(root.left, indent, false, out, printNode);
            if (root.right)
              printRow(root.right, indent, true, out, printNode);
          }
        }
        var Tree = (
          /** @class */
          function() {
            function Tree2(comparator) {
              if (comparator === void 0) {
                comparator = DEFAULT_COMPARE;
              }
              this._root = null;
              this._size = 0;
              this._comparator = comparator;
            }
            Tree2.prototype.insert = function(key, data) {
              this._size++;
              return this._root = insert(key, data, this._root, this._comparator);
            };
            Tree2.prototype.add = function(key, data) {
              var node = new Node2(key, data);
              if (this._root === null) {
                node.left = node.right = null;
                this._size++;
                this._root = node;
              }
              var comparator = this._comparator;
              var t = splay(key, this._root, comparator);
              var cmp2 = comparator(key, t.key);
              if (cmp2 === 0)
                this._root = t;
              else {
                if (cmp2 < 0) {
                  node.left = t.left;
                  node.right = t;
                  t.left = null;
                } else if (cmp2 > 0) {
                  node.right = t.right;
                  node.left = t;
                  t.right = null;
                }
                this._size++;
                this._root = node;
              }
              return this._root;
            };
            Tree2.prototype.remove = function(key) {
              this._root = this._remove(key, this._root, this._comparator);
            };
            Tree2.prototype._remove = function(i, t, comparator) {
              var x2;
              if (t === null)
                return null;
              t = splay(i, t, comparator);
              var cmp2 = comparator(i, t.key);
              if (cmp2 === 0) {
                if (t.left === null) {
                  x2 = t.right;
                } else {
                  x2 = splay(i, t.left, comparator);
                  x2.right = t.right;
                }
                this._size--;
                return x2;
              }
              return t;
            };
            Tree2.prototype.pop = function() {
              var node = this._root;
              if (node) {
                while (node.left) {
                  node = node.left;
                }
                this._root = splay(node.key, this._root, this._comparator);
                this._root = this._remove(node.key, this._root, this._comparator);
                return {
                  key: node.key,
                  data: node.data
                };
              }
              return null;
            };
            Tree2.prototype.findStatic = function(key) {
              var current = this._root;
              var compare = this._comparator;
              while (current) {
                var cmp2 = compare(key, current.key);
                if (cmp2 === 0)
                  return current;
                else if (cmp2 < 0)
                  current = current.left;
                else
                  current = current.right;
              }
              return null;
            };
            Tree2.prototype.find = function(key) {
              if (this._root) {
                this._root = splay(key, this._root, this._comparator);
                if (this._comparator(key, this._root.key) !== 0)
                  return null;
              }
              return this._root;
            };
            Tree2.prototype.contains = function(key) {
              var current = this._root;
              var compare = this._comparator;
              while (current) {
                var cmp2 = compare(key, current.key);
                if (cmp2 === 0)
                  return true;
                else if (cmp2 < 0)
                  current = current.left;
                else
                  current = current.right;
              }
              return false;
            };
            Tree2.prototype.forEach = function(visitor, ctx) {
              var current = this._root;
              var Q = [];
              var done = false;
              while (!done) {
                if (current !== null) {
                  Q.push(current);
                  current = current.left;
                } else {
                  if (Q.length !== 0) {
                    current = Q.pop();
                    visitor.call(ctx, current);
                    current = current.right;
                  } else
                    done = true;
                }
              }
              return this;
            };
            Tree2.prototype.range = function(low, high, fn, ctx) {
              var Q = [];
              var compare = this._comparator;
              var node = this._root;
              var cmp2;
              while (Q.length !== 0 || node) {
                if (node) {
                  Q.push(node);
                  node = node.left;
                } else {
                  node = Q.pop();
                  cmp2 = compare(node.key, high);
                  if (cmp2 > 0) {
                    break;
                  } else if (compare(node.key, low) >= 0) {
                    if (fn.call(ctx, node))
                      return this;
                  }
                  node = node.right;
                }
              }
              return this;
            };
            Tree2.prototype.keys = function() {
              var keys = [];
              this.forEach(function(_a) {
                var key = _a.key;
                return keys.push(key);
              });
              return keys;
            };
            Tree2.prototype.values = function() {
              var values = [];
              this.forEach(function(_a) {
                var data = _a.data;
                return values.push(data);
              });
              return values;
            };
            Tree2.prototype.min = function() {
              if (this._root)
                return this.minNode(this._root).key;
              return null;
            };
            Tree2.prototype.max = function() {
              if (this._root)
                return this.maxNode(this._root).key;
              return null;
            };
            Tree2.prototype.minNode = function(t) {
              if (t === void 0) {
                t = this._root;
              }
              if (t)
                while (t.left) {
                  t = t.left;
                }
              return t;
            };
            Tree2.prototype.maxNode = function(t) {
              if (t === void 0) {
                t = this._root;
              }
              if (t)
                while (t.right) {
                  t = t.right;
                }
              return t;
            };
            Tree2.prototype.at = function(index2) {
              var current = this._root;
              var done = false;
              var i = 0;
              var Q = [];
              while (!done) {
                if (current) {
                  Q.push(current);
                  current = current.left;
                } else {
                  if (Q.length > 0) {
                    current = Q.pop();
                    if (i === index2)
                      return current;
                    i++;
                    current = current.right;
                  } else
                    done = true;
                }
              }
              return null;
            };
            Tree2.prototype.next = function(d) {
              var root = this._root;
              var successor = null;
              if (d.right) {
                successor = d.right;
                while (successor.left) {
                  successor = successor.left;
                }
                return successor;
              }
              var comparator = this._comparator;
              while (root) {
                var cmp2 = comparator(d.key, root.key);
                if (cmp2 === 0)
                  break;
                else if (cmp2 < 0) {
                  successor = root;
                  root = root.left;
                } else
                  root = root.right;
              }
              return successor;
            };
            Tree2.prototype.prev = function(d) {
              var root = this._root;
              var predecessor = null;
              if (d.left !== null) {
                predecessor = d.left;
                while (predecessor.right) {
                  predecessor = predecessor.right;
                }
                return predecessor;
              }
              var comparator = this._comparator;
              while (root) {
                var cmp2 = comparator(d.key, root.key);
                if (cmp2 === 0)
                  break;
                else if (cmp2 < 0)
                  root = root.left;
                else {
                  predecessor = root;
                  root = root.right;
                }
              }
              return predecessor;
            };
            Tree2.prototype.clear = function() {
              this._root = null;
              this._size = 0;
              return this;
            };
            Tree2.prototype.toList = function() {
              return toList(this._root);
            };
            Tree2.prototype.load = function(keys, values, presort) {
              if (values === void 0) {
                values = [];
              }
              if (presort === void 0) {
                presort = false;
              }
              var size = keys.length;
              var comparator = this._comparator;
              if (presort)
                sort(keys, values, 0, size - 1, comparator);
              if (this._root === null) {
                this._root = loadRecursive(keys, values, 0, size);
                this._size = size;
              } else {
                var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
                size = this._size + size;
                this._root = sortedListToBST({
                  head: mergedList
                }, 0, size);
              }
              return this;
            };
            Tree2.prototype.isEmpty = function() {
              return this._root === null;
            };
            Object.defineProperty(Tree2.prototype, "size", {
              get: function get() {
                return this._size;
              },
              enumerable: true,
              configurable: true
            });
            Object.defineProperty(Tree2.prototype, "root", {
              get: function get() {
                return this._root;
              },
              enumerable: true,
              configurable: true
            });
            Tree2.prototype.toString = function(printNode) {
              if (printNode === void 0) {
                printNode = function printNode2(n) {
                  return String(n.key);
                };
              }
              var out = [];
              printRow(this._root, "", true, function(v) {
                return out.push(v);
              }, printNode);
              return out.join("");
            };
            Tree2.prototype.update = function(key, newKey, newData) {
              var comparator = this._comparator;
              var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;
              if (comparator(key, newKey) < 0) {
                right = insert(newKey, newData, right, comparator);
              } else {
                left = insert(newKey, newData, left, comparator);
              }
              this._root = merge(left, right, comparator);
            };
            Tree2.prototype.split = function(key) {
              return split(key, this._root, this._comparator);
            };
            return Tree2;
          }()
        );
        function loadRecursive(keys, values, start, end) {
          var size = end - start;
          if (size > 0) {
            var middle = start + Math.floor(size / 2);
            var key = keys[middle];
            var data = values[middle];
            var node = new Node2(key, data);
            node.left = loadRecursive(keys, values, start, middle);
            node.right = loadRecursive(keys, values, middle + 1, end);
            return node;
          }
          return null;
        }
        function createList(keys, values) {
          var head = new Node2(null, null);
          var p = head;
          for (var i = 0; i < keys.length; i++) {
            p = p.next = new Node2(keys[i], values[i]);
          }
          p.next = null;
          return head.next;
        }
        function toList(root) {
          var current = root;
          var Q = [];
          var done = false;
          var head = new Node2(null, null);
          var p = head;
          while (!done) {
            if (current) {
              Q.push(current);
              current = current.left;
            } else {
              if (Q.length > 0) {
                current = p = p.next = Q.pop();
                current = current.right;
              } else
                done = true;
            }
          }
          p.next = null;
          return head.next;
        }
        function sortedListToBST(list, start, end) {
          var size = end - start;
          if (size > 0) {
            var middle = start + Math.floor(size / 2);
            var left = sortedListToBST(list, start, middle);
            var root = list.head;
            root.left = left;
            list.head = list.head.next;
            root.right = sortedListToBST(list, middle + 1, end);
            return root;
          }
          return null;
        }
        function mergeLists(l1, l2, compare) {
          var head = new Node2(null, null);
          var p = head;
          var p1 = l1;
          var p2 = l2;
          while (p1 !== null && p2 !== null) {
            if (compare(p1.key, p2.key) < 0) {
              p.next = p1;
              p1 = p1.next;
            } else {
              p.next = p2;
              p2 = p2.next;
            }
            p = p.next;
          }
          if (p1 !== null) {
            p.next = p1;
          } else if (p2 !== null) {
            p.next = p2;
          }
          return head.next;
        }
        function sort(keys, values, left, right, compare) {
          if (left >= right)
            return;
          var pivot = keys[left + right >> 1];
          var i = left - 1;
          var j = right + 1;
          while (true) {
            do {
              i++;
            } while (compare(keys[i], pivot) < 0);
            do {
              j--;
            } while (compare(keys[j], pivot) > 0);
            if (i >= j)
              break;
            var tmp = keys[i];
            keys[i] = keys[j];
            keys[j] = tmp;
            tmp = values[i];
            values[i] = values[j];
            values[j] = tmp;
          }
          sort(keys, values, left, j, compare);
          sort(keys, values, j + 1, right, compare);
        }
        var isInBbox = function isInBbox2(bbox3, point2) {
          return bbox3.ll.x <= point2.x && point2.x <= bbox3.ur.x && bbox3.ll.y <= point2.y && point2.y <= bbox3.ur.y;
        };
        var getBboxOverlap = function getBboxOverlap2(b1, b2) {
          if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y)
            return null;
          var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;
          var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;
          var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;
          var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;
          return {
            ll: {
              x: lowerX,
              y: lowerY
            },
            ur: {
              x: upperX,
              y: upperY
            }
          };
        };
        var epsilon4 = Number.EPSILON;
        if (epsilon4 === void 0)
          epsilon4 = Math.pow(2, -52);
        var EPSILON_SQ = epsilon4 * epsilon4;
        var cmp = function cmp2(a, b) {
          if (-epsilon4 < a && a < epsilon4) {
            if (-epsilon4 < b && b < epsilon4) {
              return 0;
            }
          }
          var ab = a - b;
          if (ab * ab < EPSILON_SQ * a * b) {
            return 0;
          }
          return a < b ? -1 : 1;
        };
        var PtRounder = /* @__PURE__ */ function() {
          function PtRounder2() {
            _classCallCheck(this, PtRounder2);
            this.reset();
          }
          _createClass(PtRounder2, [{
            key: "reset",
            value: function reset() {
              this.xRounder = new CoordRounder();
              this.yRounder = new CoordRounder();
            }
          }, {
            key: "round",
            value: function round(x2, y2) {
              return {
                x: this.xRounder.round(x2),
                y: this.yRounder.round(y2)
              };
            }
          }]);
          return PtRounder2;
        }();
        var CoordRounder = /* @__PURE__ */ function() {
          function CoordRounder2() {
            _classCallCheck(this, CoordRounder2);
            this.tree = new Tree();
            this.round(0);
          }
          _createClass(CoordRounder2, [{
            key: "round",
            value: function round(coord) {
              var node = this.tree.add(coord);
              var prevNode = this.tree.prev(node);
              if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {
                this.tree.remove(coord);
                return prevNode.key;
              }
              var nextNode = this.tree.next(node);
              if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {
                this.tree.remove(coord);
                return nextNode.key;
              }
              return coord;
            }
          }]);
          return CoordRounder2;
        }();
        var rounder = new PtRounder();
        var crossProduct = function crossProduct2(a, b) {
          return a.x * b.y - a.y * b.x;
        };
        var dotProduct = function dotProduct2(a, b) {
          return a.x * b.x + a.y * b.y;
        };
        var compareVectorAngles = function compareVectorAngles2(basePt, endPt1, endPt2) {
          var v1 = {
            x: endPt1.x - basePt.x,
            y: endPt1.y - basePt.y
          };
          var v2 = {
            x: endPt2.x - basePt.x,
            y: endPt2.y - basePt.y
          };
          var kross = crossProduct(v1, v2);
          return cmp(kross, 0);
        };
        var length2 = function length3(v) {
          return Math.sqrt(dotProduct(v, v));
        };
        var sineOfAngle = function sineOfAngle2(pShared, pBase, pAngle) {
          var vBase = {
            x: pBase.x - pShared.x,
            y: pBase.y - pShared.y
          };
          var vAngle = {
            x: pAngle.x - pShared.x,
            y: pAngle.y - pShared.y
          };
          return crossProduct(vAngle, vBase) / length2(vAngle) / length2(vBase);
        };
        var cosineOfAngle = function cosineOfAngle2(pShared, pBase, pAngle) {
          var vBase = {
            x: pBase.x - pShared.x,
            y: pBase.y - pShared.y
          };
          var vAngle = {
            x: pAngle.x - pShared.x,
            y: pAngle.y - pShared.y
          };
          return dotProduct(vAngle, vBase) / length2(vAngle) / length2(vBase);
        };
        var horizontalIntersection = function horizontalIntersection2(pt, v, y2) {
          if (v.y === 0)
            return null;
          return {
            x: pt.x + v.x / v.y * (y2 - pt.y),
            y: y2
          };
        };
        var verticalIntersection = function verticalIntersection2(pt, v, x2) {
          if (v.x === 0)
            return null;
          return {
            x: x2,
            y: pt.y + v.y / v.x * (x2 - pt.x)
          };
        };
        var intersection = function intersection2(pt1, v1, pt2, v2) {
          if (v1.x === 0)
            return verticalIntersection(pt2, v2, pt1.x);
          if (v2.x === 0)
            return verticalIntersection(pt1, v1, pt2.x);
          if (v1.y === 0)
            return horizontalIntersection(pt2, v2, pt1.y);
          if (v2.y === 0)
            return horizontalIntersection(pt1, v1, pt2.y);
          var kross = crossProduct(v1, v2);
          if (kross == 0)
            return null;
          var ve = {
            x: pt2.x - pt1.x,
            y: pt2.y - pt1.y
          };
          var d1 = crossProduct(ve, v1) / kross;
          var d2 = crossProduct(ve, v2) / kross;
          var x12 = pt1.x + d2 * v1.x, x2 = pt2.x + d1 * v2.x;
          var y1 = pt1.y + d2 * v1.y, y2 = pt2.y + d1 * v2.y;
          var x3 = (x12 + x2) / 2;
          var y3 = (y1 + y2) / 2;
          return {
            x: x3,
            y: y3
          };
        };
        var SweepEvent = /* @__PURE__ */ function() {
          _createClass(SweepEvent2, null, [{
            key: "compare",
            // for ordering sweep events in the sweep event queue
            value: function compare(a, b) {
              var ptCmp = SweepEvent2.comparePoints(a.point, b.point);
              if (ptCmp !== 0)
                return ptCmp;
              if (a.point !== b.point)
                a.link(b);
              if (a.isLeft !== b.isLeft)
                return a.isLeft ? 1 : -1;
              return Segment.compare(a.segment, b.segment);
            }
            // for ordering points in sweep line order
          }, {
            key: "comparePoints",
            value: function comparePoints(aPt, bPt) {
              if (aPt.x < bPt.x)
                return -1;
              if (aPt.x > bPt.x)
                return 1;
              if (aPt.y < bPt.y)
                return -1;
              if (aPt.y > bPt.y)
                return 1;
              return 0;
            }
            // Warning: 'point' input will be modified and re-used (for performance)
          }]);
          function SweepEvent2(point2, isLeft) {
            _classCallCheck(this, SweepEvent2);
            if (point2.events === void 0)
              point2.events = [this];
            else
              point2.events.push(this);
            this.point = point2;
            this.isLeft = isLeft;
          }
          _createClass(SweepEvent2, [{
            key: "link",
            value: function link2(other) {
              if (other.point === this.point) {
                throw new Error("Tried to link already linked events");
              }
              var otherEvents = other.point.events;
              for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {
                var evt = otherEvents[i];
                this.point.events.push(evt);
                evt.point = this.point;
              }
              this.checkForConsuming();
            }
            /* Do a pass over our linked events and check to see if any pair
             * of segments match, and should be consumed. */
          }, {
            key: "checkForConsuming",
            value: function checkForConsuming() {
              var numEvents = this.point.events.length;
              for (var i = 0; i < numEvents; i++) {
                var evt1 = this.point.events[i];
                if (evt1.segment.consumedBy !== void 0)
                  continue;
                for (var j = i + 1; j < numEvents; j++) {
                  var evt2 = this.point.events[j];
                  if (evt2.consumedBy !== void 0)
                    continue;
                  if (evt1.otherSE.point.events !== evt2.otherSE.point.events)
                    continue;
                  evt1.segment.consume(evt2.segment);
                }
              }
            }
          }, {
            key: "getAvailableLinkedEvents",
            value: function getAvailableLinkedEvents() {
              var events = [];
              for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {
                var evt = this.point.events[i];
                if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
                  events.push(evt);
                }
              }
              return events;
            }
            /**
             * Returns a comparator function for sorting linked events that will
             * favor the event that will give us the smallest left-side angle.
             * All ring construction starts as low as possible heading to the right,
             * so by always turning left as sharp as possible we'll get polygons
             * without uncessary loops & holes.
             *
             * The comparator function has a compute cache such that it avoids
             * re-computing already-computed values.
             */
          }, {
            key: "getLeftmostComparator",
            value: function getLeftmostComparator(baseEvent) {
              var _this = this;
              var cache = /* @__PURE__ */ new Map();
              var fillCache = function fillCache2(linkedEvent) {
                var nextEvent = linkedEvent.otherSE;
                cache.set(linkedEvent, {
                  sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),
                  cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)
                });
              };
              return function(a, b) {
                if (!cache.has(a))
                  fillCache(a);
                if (!cache.has(b))
                  fillCache(b);
                var _cache$get = cache.get(a), asine = _cache$get.sine, acosine = _cache$get.cosine;
                var _cache$get2 = cache.get(b), bsine = _cache$get2.sine, bcosine = _cache$get2.cosine;
                if (asine >= 0 && bsine >= 0) {
                  if (acosine < bcosine)
                    return 1;
                  if (acosine > bcosine)
                    return -1;
                  return 0;
                }
                if (asine < 0 && bsine < 0) {
                  if (acosine < bcosine)
                    return -1;
                  if (acosine > bcosine)
                    return 1;
                  return 0;
                }
                if (bsine < asine)
                  return -1;
                if (bsine > asine)
                  return 1;
                return 0;
              };
            }
          }]);
          return SweepEvent2;
        }();
        var segmentId = 0;
        var Segment = /* @__PURE__ */ function() {
          _createClass(Segment2, null, [{
            key: "compare",
            /* This compare() function is for ordering segments in the sweep
             * line tree, and does so according to the following criteria:
             *
             * Consider the vertical line that lies an infinestimal step to the
             * right of the right-more of the two left endpoints of the input
             * segments. Imagine slowly moving a point up from negative infinity
             * in the increasing y direction. Which of the two segments will that
             * point intersect first? That segment comes 'before' the other one.
             *
             * If neither segment would be intersected by such a line, (if one
             * or more of the segments are vertical) then the line to be considered
             * is directly on the right-more of the two left inputs.
             */
            value: function compare(a, b) {
              var alx = a.leftSE.point.x;
              var blx = b.leftSE.point.x;
              var arx = a.rightSE.point.x;
              var brx = b.rightSE.point.x;
              if (brx < alx)
                return 1;
              if (arx < blx)
                return -1;
              var aly = a.leftSE.point.y;
              var bly = b.leftSE.point.y;
              var ary = a.rightSE.point.y;
              var bry = b.rightSE.point.y;
              if (alx < blx) {
                if (bly < aly && bly < ary)
                  return 1;
                if (bly > aly && bly > ary)
                  return -1;
                var aCmpBLeft = a.comparePoint(b.leftSE.point);
                if (aCmpBLeft < 0)
                  return 1;
                if (aCmpBLeft > 0)
                  return -1;
                var bCmpARight = b.comparePoint(a.rightSE.point);
                if (bCmpARight !== 0)
                  return bCmpARight;
                return -1;
              }
              if (alx > blx) {
                if (aly < bly && aly < bry)
                  return -1;
                if (aly > bly && aly > bry)
                  return 1;
                var bCmpALeft = b.comparePoint(a.leftSE.point);
                if (bCmpALeft !== 0)
                  return bCmpALeft;
                var aCmpBRight = a.comparePoint(b.rightSE.point);
                if (aCmpBRight < 0)
                  return 1;
                if (aCmpBRight > 0)
                  return -1;
                return 1;
              }
              if (aly < bly)
                return -1;
              if (aly > bly)
                return 1;
              if (arx < brx) {
                var _bCmpARight = b.comparePoint(a.rightSE.point);
                if (_bCmpARight !== 0)
                  return _bCmpARight;
              }
              if (arx > brx) {
                var _aCmpBRight = a.comparePoint(b.rightSE.point);
                if (_aCmpBRight < 0)
                  return 1;
                if (_aCmpBRight > 0)
                  return -1;
              }
              if (arx !== brx) {
                var ay = ary - aly;
                var ax = arx - alx;
                var by = bry - bly;
                var bx = brx - blx;
                if (ay > ax && by < bx)
                  return 1;
                if (ay < ax && by > bx)
                  return -1;
              }
              if (arx > brx)
                return 1;
              if (arx < brx)
                return -1;
              if (ary < bry)
                return -1;
              if (ary > bry)
                return 1;
              if (a.id < b.id)
                return -1;
              if (a.id > b.id)
                return 1;
              return 0;
            }
            /* Warning: a reference to ringWindings input will be stored,
             *  and possibly will be later modified */
          }]);
          function Segment2(leftSE, rightSE, rings, windings) {
            _classCallCheck(this, Segment2);
            this.id = ++segmentId;
            this.leftSE = leftSE;
            leftSE.segment = this;
            leftSE.otherSE = rightSE;
            this.rightSE = rightSE;
            rightSE.segment = this;
            rightSE.otherSE = leftSE;
            this.rings = rings;
            this.windings = windings;
          }
          _createClass(Segment2, [{
            key: "replaceRightSE",
            /* When a segment is split, the rightSE is replaced with a new sweep event */
            value: function replaceRightSE(newRightSE) {
              this.rightSE = newRightSE;
              this.rightSE.segment = this;
              this.rightSE.otherSE = this.leftSE;
              this.leftSE.otherSE = this.rightSE;
            }
          }, {
            key: "bbox",
            value: function bbox3() {
              var y1 = this.leftSE.point.y;
              var y2 = this.rightSE.point.y;
              return {
                ll: {
                  x: this.leftSE.point.x,
                  y: y1 < y2 ? y1 : y2
                },
                ur: {
                  x: this.rightSE.point.x,
                  y: y1 > y2 ? y1 : y2
                }
              };
            }
            /* A vector from the left point to the right */
          }, {
            key: "vector",
            value: function vector() {
              return {
                x: this.rightSE.point.x - this.leftSE.point.x,
                y: this.rightSE.point.y - this.leftSE.point.y
              };
            }
          }, {
            key: "isAnEndpoint",
            value: function isAnEndpoint(pt) {
              return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;
            }
            /* Compare this segment with a point.
             *
             * A point P is considered to be colinear to a segment if there
             * exists a distance D such that if we travel along the segment
             * from one * endpoint towards the other a distance D, we find
             * ourselves at point P.
             *
             * Return value indicates:
             *
             *   1: point lies above the segment (to the left of vertical)
             *   0: point is colinear to segment
             *  -1: point lies below the segment (to the right of vertical)
             */
          }, {
            key: "comparePoint",
            value: function comparePoint(point2) {
              if (this.isAnEndpoint(point2))
                return 0;
              var lPt = this.leftSE.point;
              var rPt = this.rightSE.point;
              var v = this.vector();
              if (lPt.x === rPt.x) {
                if (point2.x === lPt.x)
                  return 0;
                return point2.x < lPt.x ? 1 : -1;
              }
              var yDist = (point2.y - lPt.y) / v.y;
              var xFromYDist = lPt.x + yDist * v.x;
              if (point2.x === xFromYDist)
                return 0;
              var xDist = (point2.x - lPt.x) / v.x;
              var yFromXDist = lPt.y + xDist * v.y;
              if (point2.y === yFromXDist)
                return 0;
              return point2.y < yFromXDist ? -1 : 1;
            }
            /**
             * Given another segment, returns the first non-trivial intersection
             * between the two segments (in terms of sweep line ordering), if it exists.
             *
             * A 'non-trivial' intersection is one that will cause one or both of the
             * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
             *
             *   * endpoint of segA with endpoint of segB --> trivial
             *   * endpoint of segA with point along segB --> non-trivial
             *   * endpoint of segB with point along segA --> non-trivial
             *   * point along segA with point along segB --> non-trivial
             *
             * If no non-trivial intersection exists, return null
             * Else, return null.
             */
          }, {
            key: "getIntersection",
            value: function getIntersection(other) {
              var tBbox = this.bbox();
              var oBbox = other.bbox();
              var bboxOverlap = getBboxOverlap(tBbox, oBbox);
              if (bboxOverlap === null)
                return null;
              var tlp = this.leftSE.point;
              var trp = this.rightSE.point;
              var olp = other.leftSE.point;
              var orp = other.rightSE.point;
              var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
              var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
              var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
              var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
              if (touchesThisLSE && touchesOtherLSE) {
                if (touchesThisRSE && !touchesOtherRSE)
                  return trp;
                if (!touchesThisRSE && touchesOtherRSE)
                  return orp;
                return null;
              }
              if (touchesThisLSE) {
                if (touchesOtherRSE) {
                  if (tlp.x === orp.x && tlp.y === orp.y)
                    return null;
                }
                return tlp;
              }
              if (touchesOtherLSE) {
                if (touchesThisRSE) {
                  if (trp.x === olp.x && trp.y === olp.y)
                    return null;
                }
                return olp;
              }
              if (touchesThisRSE && touchesOtherRSE)
                return null;
              if (touchesThisRSE)
                return trp;
              if (touchesOtherRSE)
                return orp;
              var pt = intersection(tlp, this.vector(), olp, other.vector());
              if (pt === null)
                return null;
              if (!isInBbox(bboxOverlap, pt))
                return null;
              return rounder.round(pt.x, pt.y);
            }
            /**
             * Split the given segment into multiple segments on the given points.
             *  * Each existing segment will retain its leftSE and a new rightSE will be
             *    generated for it.
             *  * A new segment will be generated which will adopt the original segment's
             *    rightSE, and a new leftSE will be generated for it.
             *  * If there are more than two points given to split on, new segments
             *    in the middle will be generated with new leftSE and rightSE's.
             *  * An array of the newly generated SweepEvents will be returned.
             *
             * Warning: input array of points is modified
             */
          }, {
            key: "split",
            value: function split2(point2) {
              var newEvents = [];
              var alreadyLinked = point2.events !== void 0;
              var newLeftSE = new SweepEvent(point2, true);
              var newRightSE = new SweepEvent(point2, false);
              var oldRightSE = this.rightSE;
              this.replaceRightSE(newRightSE);
              newEvents.push(newRightSE);
              newEvents.push(newLeftSE);
              var newSeg = new Segment2(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());
              if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
                newSeg.swapEvents();
              }
              if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
                this.swapEvents();
              }
              if (alreadyLinked) {
                newLeftSE.checkForConsuming();
                newRightSE.checkForConsuming();
              }
              return newEvents;
            }
            /* Swap which event is left and right */
          }, {
            key: "swapEvents",
            value: function swapEvents() {
              var tmpEvt = this.rightSE;
              this.rightSE = this.leftSE;
              this.leftSE = tmpEvt;
              this.leftSE.isLeft = true;
              this.rightSE.isLeft = false;
              for (var i = 0, iMax = this.windings.length; i < iMax; i++) {
                this.windings[i] *= -1;
              }
            }
            /* Consume another segment. We take their rings under our wing
             * and mark them as consumed. Use for perfectly overlapping segments */
          }, {
            key: "consume",
            value: function consume(other) {
              var consumer = this;
              var consumee = other;
              while (consumer.consumedBy) {
                consumer = consumer.consumedBy;
              }
              while (consumee.consumedBy) {
                consumee = consumee.consumedBy;
              }
              var cmp2 = Segment2.compare(consumer, consumee);
              if (cmp2 === 0)
                return;
              if (cmp2 > 0) {
                var tmp = consumer;
                consumer = consumee;
                consumee = tmp;
              }
              if (consumer.prev === consumee) {
                var _tmp = consumer;
                consumer = consumee;
                consumee = _tmp;
              }
              for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {
                var ring = consumee.rings[i];
                var winding = consumee.windings[i];
                var index2 = consumer.rings.indexOf(ring);
                if (index2 === -1) {
                  consumer.rings.push(ring);
                  consumer.windings.push(winding);
                } else
                  consumer.windings[index2] += winding;
              }
              consumee.rings = null;
              consumee.windings = null;
              consumee.consumedBy = consumer;
              consumee.leftSE.consumedBy = consumer.leftSE;
              consumee.rightSE.consumedBy = consumer.rightSE;
            }
            /* The first segment previous segment chain that is in the result */
          }, {
            key: "prevInResult",
            value: function prevInResult() {
              if (this._prevInResult !== void 0)
                return this._prevInResult;
              if (!this.prev)
                this._prevInResult = null;
              else if (this.prev.isInResult())
                this._prevInResult = this.prev;
              else
                this._prevInResult = this.prev.prevInResult();
              return this._prevInResult;
            }
          }, {
            key: "beforeState",
            value: function beforeState() {
              if (this._beforeState !== void 0)
                return this._beforeState;
              if (!this.prev)
                this._beforeState = {
                  rings: [],
                  windings: [],
                  multiPolys: []
                };
              else {
                var seg = this.prev.consumedBy || this.prev;
                this._beforeState = seg.afterState();
              }
              return this._beforeState;
            }
          }, {
            key: "afterState",
            value: function afterState() {
              if (this._afterState !== void 0)
                return this._afterState;
              var beforeState = this.beforeState();
              this._afterState = {
                rings: beforeState.rings.slice(0),
                windings: beforeState.windings.slice(0),
                multiPolys: []
              };
              var ringsAfter = this._afterState.rings;
              var windingsAfter = this._afterState.windings;
              var mpsAfter = this._afterState.multiPolys;
              for (var i = 0, iMax = this.rings.length; i < iMax; i++) {
                var ring = this.rings[i];
                var winding = this.windings[i];
                var index2 = ringsAfter.indexOf(ring);
                if (index2 === -1) {
                  ringsAfter.push(ring);
                  windingsAfter.push(winding);
                } else
                  windingsAfter[index2] += winding;
              }
              var polysAfter = [];
              var polysExclude = [];
              for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {
                if (windingsAfter[_i] === 0)
                  continue;
                var _ring = ringsAfter[_i];
                var poly = _ring.poly;
                if (polysExclude.indexOf(poly) !== -1)
                  continue;
                if (_ring.isExterior)
                  polysAfter.push(poly);
                else {
                  if (polysExclude.indexOf(poly) === -1)
                    polysExclude.push(poly);
                  var _index = polysAfter.indexOf(_ring.poly);
                  if (_index !== -1)
                    polysAfter.splice(_index, 1);
                }
              }
              for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {
                var mp = polysAfter[_i2].multiPoly;
                if (mpsAfter.indexOf(mp) === -1)
                  mpsAfter.push(mp);
              }
              return this._afterState;
            }
            /* Is this segment part of the final result? */
          }, {
            key: "isInResult",
            value: function isInResult() {
              if (this.consumedBy)
                return false;
              if (this._isInResult !== void 0)
                return this._isInResult;
              var mpsBefore = this.beforeState().multiPolys;
              var mpsAfter = this.afterState().multiPolys;
              switch (operation.type) {
                case "union": {
                  var noBefores = mpsBefore.length === 0;
                  var noAfters = mpsAfter.length === 0;
                  this._isInResult = noBefores !== noAfters;
                  break;
                }
                case "intersection": {
                  var least;
                  var most;
                  if (mpsBefore.length < mpsAfter.length) {
                    least = mpsBefore.length;
                    most = mpsAfter.length;
                  } else {
                    least = mpsAfter.length;
                    most = mpsBefore.length;
                  }
                  this._isInResult = most === operation.numMultiPolys && least < most;
                  break;
                }
                case "xor": {
                  var diff = Math.abs(mpsBefore.length - mpsAfter.length);
                  this._isInResult = diff % 2 === 1;
                  break;
                }
                case "difference": {
                  var isJustSubject = function isJustSubject2(mps) {
                    return mps.length === 1 && mps[0].isSubject;
                  };
                  this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
                  break;
                }
                default:
                  throw new Error("Unrecognized operation type found ".concat(operation.type));
              }
              return this._isInResult;
            }
          }], [{
            key: "fromRing",
            value: function fromRing(pt1, pt2, ring) {
              var leftPt, rightPt, winding;
              var cmpPts = SweepEvent.comparePoints(pt1, pt2);
              if (cmpPts < 0) {
                leftPt = pt1;
                rightPt = pt2;
                winding = 1;
              } else if (cmpPts > 0) {
                leftPt = pt2;
                rightPt = pt1;
                winding = -1;
              } else
                throw new Error("Tried to create degenerate segment at [".concat(pt1.x, ", ").concat(pt1.y, "]"));
              var leftSE = new SweepEvent(leftPt, true);
              var rightSE = new SweepEvent(rightPt, false);
              return new Segment2(leftSE, rightSE, [ring], [winding]);
            }
          }]);
          return Segment2;
        }();
        var RingIn = /* @__PURE__ */ function() {
          function RingIn2(geomRing, poly, isExterior) {
            _classCallCheck(this, RingIn2);
            if (!Array.isArray(geomRing) || geomRing.length === 0) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            this.poly = poly;
            this.isExterior = isExterior;
            this.segments = [];
            if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);
            this.bbox = {
              ll: {
                x: firstPoint.x,
                y: firstPoint.y
              },
              ur: {
                x: firstPoint.x,
                y: firstPoint.y
              }
            };
            var prevPoint = firstPoint;
            for (var i = 1, iMax = geomRing.length; i < iMax; i++) {
              if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
                throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
              }
              var point2 = rounder.round(geomRing[i][0], geomRing[i][1]);
              if (point2.x === prevPoint.x && point2.y === prevPoint.y)
                continue;
              this.segments.push(Segment.fromRing(prevPoint, point2, this));
              if (point2.x < this.bbox.ll.x)
                this.bbox.ll.x = point2.x;
              if (point2.y < this.bbox.ll.y)
                this.bbox.ll.y = point2.y;
              if (point2.x > this.bbox.ur.x)
                this.bbox.ur.x = point2.x;
              if (point2.y > this.bbox.ur.y)
                this.bbox.ur.y = point2.y;
              prevPoint = point2;
            }
            if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {
              this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));
            }
          }
          _createClass(RingIn2, [{
            key: "getSweepEvents",
            value: function getSweepEvents() {
              var sweepEvents = [];
              for (var i = 0, iMax = this.segments.length; i < iMax; i++) {
                var segment = this.segments[i];
                sweepEvents.push(segment.leftSE);
                sweepEvents.push(segment.rightSE);
              }
              return sweepEvents;
            }
          }]);
          return RingIn2;
        }();
        var PolyIn = /* @__PURE__ */ function() {
          function PolyIn2(geomPoly, multiPoly) {
            _classCallCheck(this, PolyIn2);
            if (!Array.isArray(geomPoly)) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            this.exteriorRing = new RingIn(geomPoly[0], this, true);
            this.bbox = {
              ll: {
                x: this.exteriorRing.bbox.ll.x,
                y: this.exteriorRing.bbox.ll.y
              },
              ur: {
                x: this.exteriorRing.bbox.ur.x,
                y: this.exteriorRing.bbox.ur.y
              }
            };
            this.interiorRings = [];
            for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {
              var ring = new RingIn(geomPoly[i], this, false);
              if (ring.bbox.ll.x < this.bbox.ll.x)
                this.bbox.ll.x = ring.bbox.ll.x;
              if (ring.bbox.ll.y < this.bbox.ll.y)
                this.bbox.ll.y = ring.bbox.ll.y;
              if (ring.bbox.ur.x > this.bbox.ur.x)
                this.bbox.ur.x = ring.bbox.ur.x;
              if (ring.bbox.ur.y > this.bbox.ur.y)
                this.bbox.ur.y = ring.bbox.ur.y;
              this.interiorRings.push(ring);
            }
            this.multiPoly = multiPoly;
          }
          _createClass(PolyIn2, [{
            key: "getSweepEvents",
            value: function getSweepEvents() {
              var sweepEvents = this.exteriorRing.getSweepEvents();
              for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
                var ringSweepEvents = this.interiorRings[i].getSweepEvents();
                for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
                  sweepEvents.push(ringSweepEvents[j]);
                }
              }
              return sweepEvents;
            }
          }]);
          return PolyIn2;
        }();
        var MultiPolyIn = /* @__PURE__ */ function() {
          function MultiPolyIn2(geom, isSubject) {
            _classCallCheck(this, MultiPolyIn2);
            if (!Array.isArray(geom)) {
              throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
            }
            try {
              if (typeof geom[0][0][0] === "number")
                geom = [geom];
            } catch (ex) {
            }
            this.polys = [];
            this.bbox = {
              ll: {
                x: Number.POSITIVE_INFINITY,
                y: Number.POSITIVE_INFINITY
              },
              ur: {
                x: Number.NEGATIVE_INFINITY,
                y: Number.NEGATIVE_INFINITY
              }
            };
            for (var i = 0, iMax = geom.length; i < iMax; i++) {
              var poly = new PolyIn(geom[i], this);
              if (poly.bbox.ll.x < this.bbox.ll.x)
                this.bbox.ll.x = poly.bbox.ll.x;
              if (poly.bbox.ll.y < this.bbox.ll.y)
                this.bbox.ll.y = poly.bbox.ll.y;
              if (poly.bbox.ur.x > this.bbox.ur.x)
                this.bbox.ur.x = poly.bbox.ur.x;
              if (poly.bbox.ur.y > this.bbox.ur.y)
                this.bbox.ur.y = poly.bbox.ur.y;
              this.polys.push(poly);
            }
            this.isSubject = isSubject;
          }
          _createClass(MultiPolyIn2, [{
            key: "getSweepEvents",
            value: function getSweepEvents() {
              var sweepEvents = [];
              for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
                var polySweepEvents = this.polys[i].getSweepEvents();
                for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
                  sweepEvents.push(polySweepEvents[j]);
                }
              }
              return sweepEvents;
            }
          }]);
          return MultiPolyIn2;
        }();
        var RingOut = /* @__PURE__ */ function() {
          _createClass(RingOut2, null, [{
            key: "factory",
            /* Given the segments from the sweep line pass, compute & return a series
             * of closed rings from all the segments marked to be part of the result */
            value: function factory(allSegments) {
              var ringsOut = [];
              for (var i = 0, iMax = allSegments.length; i < iMax; i++) {
                var segment = allSegments[i];
                if (!segment.isInResult() || segment.ringOut)
                  continue;
                var prevEvent = null;
                var event = segment.leftSE;
                var nextEvent = segment.rightSE;
                var events = [event];
                var startingPoint = event.point;
                var intersectionLEs = [];
                while (true) {
                  prevEvent = event;
                  event = nextEvent;
                  events.push(event);
                  if (event.point === startingPoint)
                    break;
                  while (true) {
                    var availableLEs = event.getAvailableLinkedEvents();
                    if (availableLEs.length === 0) {
                      var firstPt = events[0].point;
                      var lastPt = events[events.length - 1].point;
                      throw new Error("Unable to complete output ring starting at [".concat(firstPt.x, ",") + " ".concat(firstPt.y, "]. Last matching segment found ends at") + " [".concat(lastPt.x, ", ").concat(lastPt.y, "]."));
                    }
                    if (availableLEs.length === 1) {
                      nextEvent = availableLEs[0].otherSE;
                      break;
                    }
                    var indexLE = null;
                    for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
                      if (intersectionLEs[j].point === event.point) {
                        indexLE = j;
                        break;
                      }
                    }
                    if (indexLE !== null) {
                      var intersectionLE = intersectionLEs.splice(indexLE)[0];
                      var ringEvents = events.splice(intersectionLE.index);
                      ringEvents.unshift(ringEvents[0].otherSE);
                      ringsOut.push(new RingOut2(ringEvents.reverse()));
                      continue;
                    }
                    intersectionLEs.push({
                      index: events.length,
                      point: event.point
                    });
                    var comparator = event.getLeftmostComparator(prevEvent);
                    nextEvent = availableLEs.sort(comparator)[0].otherSE;
                    break;
                  }
                }
                ringsOut.push(new RingOut2(events));
              }
              return ringsOut;
            }
          }]);
          function RingOut2(events) {
            _classCallCheck(this, RingOut2);
            this.events = events;
            for (var i = 0, iMax = events.length; i < iMax; i++) {
              events[i].segment.ringOut = this;
            }
            this.poly = null;
          }
          _createClass(RingOut2, [{
            key: "getGeom",
            value: function getGeom2() {
              var prevPt = this.events[0].point;
              var points = [prevPt];
              for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {
                var _pt = this.events[i].point;
                var _nextPt = this.events[i + 1].point;
                if (compareVectorAngles(_pt, prevPt, _nextPt) === 0)
                  continue;
                points.push(_pt);
                prevPt = _pt;
              }
              if (points.length === 1)
                return null;
              var pt = points[0];
              var nextPt = points[1];
              if (compareVectorAngles(pt, prevPt, nextPt) === 0)
                points.shift();
              points.push(points[0]);
              var step = this.isExteriorRing() ? 1 : -1;
              var iStart = this.isExteriorRing() ? 0 : points.length - 1;
              var iEnd = this.isExteriorRing() ? points.length : -1;
              var orderedPoints = [];
              for (var _i = iStart; _i != iEnd; _i += step) {
                orderedPoints.push([points[_i].x, points[_i].y]);
              }
              return orderedPoints;
            }
          }, {
            key: "isExteriorRing",
            value: function isExteriorRing() {
              if (this._isExteriorRing === void 0) {
                var enclosing = this.enclosingRing();
                this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
              }
              return this._isExteriorRing;
            }
          }, {
            key: "enclosingRing",
            value: function enclosingRing() {
              if (this._enclosingRing === void 0) {
                this._enclosingRing = this._calcEnclosingRing();
              }
              return this._enclosingRing;
            }
            /* Returns the ring that encloses this one, if any */
          }, {
            key: "_calcEnclosingRing",
            value: function _calcEnclosingRing() {
              var leftMostEvt = this.events[0];
              for (var i = 1, iMax = this.events.length; i < iMax; i++) {
                var evt = this.events[i];
                if (SweepEvent.compare(leftMostEvt, evt) > 0)
                  leftMostEvt = evt;
              }
              var prevSeg = leftMostEvt.segment.prevInResult();
              var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
              while (true) {
                if (!prevSeg)
                  return null;
                if (!prevPrevSeg)
                  return prevSeg.ringOut;
                if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
                  if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {
                    return prevSeg.ringOut;
                  } else
                    return prevSeg.ringOut.enclosingRing();
                }
                prevSeg = prevPrevSeg.prevInResult();
                prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
              }
            }
          }]);
          return RingOut2;
        }();
        var PolyOut = /* @__PURE__ */ function() {
          function PolyOut2(exteriorRing) {
            _classCallCheck(this, PolyOut2);
            this.exteriorRing = exteriorRing;
            exteriorRing.poly = this;
            this.interiorRings = [];
          }
          _createClass(PolyOut2, [{
            key: "addInterior",
            value: function addInterior(ring) {
              this.interiorRings.push(ring);
              ring.poly = this;
            }
          }, {
            key: "getGeom",
            value: function getGeom2() {
              var geom = [this.exteriorRing.getGeom()];
              if (geom[0] === null)
                return null;
              for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
                var ringGeom = this.interiorRings[i].getGeom();
                if (ringGeom === null)
                  continue;
                geom.push(ringGeom);
              }
              return geom;
            }
          }]);
          return PolyOut2;
        }();
        var MultiPolyOut = /* @__PURE__ */ function() {
          function MultiPolyOut2(rings) {
            _classCallCheck(this, MultiPolyOut2);
            this.rings = rings;
            this.polys = this._composePolys(rings);
          }
          _createClass(MultiPolyOut2, [{
            key: "getGeom",
            value: function getGeom2() {
              var geom = [];
              for (var i = 0, iMax = this.polys.length; i < iMax; i++) {
                var polyGeom = this.polys[i].getGeom();
                if (polyGeom === null)
                  continue;
                geom.push(polyGeom);
              }
              return geom;
            }
          }, {
            key: "_composePolys",
            value: function _composePolys(rings) {
              var polys = [];
              for (var i = 0, iMax = rings.length; i < iMax; i++) {
                var ring = rings[i];
                if (ring.poly)
                  continue;
                if (ring.isExteriorRing())
                  polys.push(new PolyOut(ring));
                else {
                  var enclosingRing = ring.enclosingRing();
                  if (!enclosingRing.poly)
                    polys.push(new PolyOut(enclosingRing));
                  enclosingRing.poly.addInterior(ring);
                }
              }
              return polys;
            }
          }]);
          return MultiPolyOut2;
        }();
        var SweepLine = /* @__PURE__ */ function() {
          function SweepLine2(queue) {
            var comparator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Segment.compare;
            _classCallCheck(this, SweepLine2);
            this.queue = queue;
            this.tree = new Tree(comparator);
            this.segments = [];
          }
          _createClass(SweepLine2, [{
            key: "process",
            value: function process2(event) {
              var segment = event.segment;
              var newEvents = [];
              if (event.consumedBy) {
                if (event.isLeft)
                  this.queue.remove(event.otherSE);
                else
                  this.tree.remove(segment);
                return newEvents;
              }
              var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);
              if (!node)
                throw new Error("Unable to find segment #".concat(segment.id, " ") + "[".concat(segment.leftSE.point.x, ", ").concat(segment.leftSE.point.y, "] -> ") + "[".concat(segment.rightSE.point.x, ", ").concat(segment.rightSE.point.y, "] ") + "in SweepLine tree. Please submit a bug report.");
              var prevNode = node;
              var nextNode = node;
              var prevSeg = void 0;
              var nextSeg = void 0;
              while (prevSeg === void 0) {
                prevNode = this.tree.prev(prevNode);
                if (prevNode === null)
                  prevSeg = null;
                else if (prevNode.key.consumedBy === void 0)
                  prevSeg = prevNode.key;
              }
              while (nextSeg === void 0) {
                nextNode = this.tree.next(nextNode);
                if (nextNode === null)
                  nextSeg = null;
                else if (nextNode.key.consumedBy === void 0)
                  nextSeg = nextNode.key;
              }
              if (event.isLeft) {
                var prevMySplitter = null;
                if (prevSeg) {
                  var prevInter = prevSeg.getIntersection(segment);
                  if (prevInter !== null) {
                    if (!segment.isAnEndpoint(prevInter))
                      prevMySplitter = prevInter;
                    if (!prevSeg.isAnEndpoint(prevInter)) {
                      var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
                      for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                        newEvents.push(newEventsFromSplit[i]);
                      }
                    }
                  }
                }
                var nextMySplitter = null;
                if (nextSeg) {
                  var nextInter = nextSeg.getIntersection(segment);
                  if (nextInter !== null) {
                    if (!segment.isAnEndpoint(nextInter))
                      nextMySplitter = nextInter;
                    if (!nextSeg.isAnEndpoint(nextInter)) {
                      var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
                      for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {
                        newEvents.push(_newEventsFromSplit[_i]);
                      }
                    }
                  }
                }
                if (prevMySplitter !== null || nextMySplitter !== null) {
                  var mySplitter = null;
                  if (prevMySplitter === null)
                    mySplitter = nextMySplitter;
                  else if (nextMySplitter === null)
                    mySplitter = prevMySplitter;
                  else {
                    var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);
                    mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
                  }
                  this.queue.remove(segment.rightSE);
                  newEvents.push(segment.rightSE);
                  var _newEventsFromSplit2 = segment.split(mySplitter);
                  for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {
                    newEvents.push(_newEventsFromSplit2[_i2]);
                  }
                }
                if (newEvents.length > 0) {
                  this.tree.remove(segment);
                  newEvents.push(event);
                } else {
                  this.segments.push(segment);
                  segment.prev = prevSeg;
                }
              } else {
                if (prevSeg && nextSeg) {
                  var inter = prevSeg.getIntersection(nextSeg);
                  if (inter !== null) {
                    if (!prevSeg.isAnEndpoint(inter)) {
                      var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);
                      for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {
                        newEvents.push(_newEventsFromSplit3[_i3]);
                      }
                    }
                    if (!nextSeg.isAnEndpoint(inter)) {
                      var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);
                      for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {
                        newEvents.push(_newEventsFromSplit4[_i4]);
                      }
                    }
                  }
                }
                this.tree.remove(segment);
              }
              return newEvents;
            }
            /* Safely split a segment that is currently in the datastructures
             * IE - a segment other than the one that is currently being processed. */
          }, {
            key: "_splitSafely",
            value: function _splitSafely(seg, pt) {
              this.tree.remove(seg);
              var rightSE = seg.rightSE;
              this.queue.remove(rightSE);
              var newEvents = seg.split(pt);
              newEvents.push(rightSE);
              if (seg.consumedBy === void 0)
                this.tree.insert(seg);
              return newEvents;
            }
          }]);
          return SweepLine2;
        }();
        var POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1e6;
        var POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== "undefined" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1e6;
        var Operation = /* @__PURE__ */ function() {
          function Operation2() {
            _classCallCheck(this, Operation2);
          }
          _createClass(Operation2, [{
            key: "run",
            value: function run(type, geom, moreGeoms) {
              operation.type = type;
              rounder.reset();
              var multipolys = [new MultiPolyIn(geom, true)];
              for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {
                multipolys.push(new MultiPolyIn(moreGeoms[i], false));
              }
              operation.numMultiPolys = multipolys.length;
              if (operation.type === "difference") {
                var subject = multipolys[0];
                var _i = 1;
                while (_i < multipolys.length) {
                  if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null)
                    _i++;
                  else
                    multipolys.splice(_i, 1);
                }
              }
              if (operation.type === "intersection") {
                for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {
                  var mpA = multipolys[_i2];
                  for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {
                    if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null)
                      return [];
                  }
                }
              }
              var queue = new Tree(SweepEvent.compare);
              for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {
                var sweepEvents = multipolys[_i3].getSweepEvents();
                for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {
                  queue.insert(sweepEvents[_j]);
                  if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                    throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big). Please file a bug report.");
                  }
                }
              }
              var sweepLine = new SweepLine(queue);
              var prevQueueSize = queue.size;
              var node = queue.pop();
              while (node) {
                var evt = node.key;
                if (queue.size === prevQueueSize) {
                  var seg = evt.segment;
                  throw new Error("Unable to pop() ".concat(evt.isLeft ? "left" : "right", " SweepEvent ") + "[".concat(evt.point.x, ", ").concat(evt.point.y, "] from segment #").concat(seg.id, " ") + "[".concat(seg.leftSE.point.x, ", ").concat(seg.leftSE.point.y, "] -> ") + "[".concat(seg.rightSE.point.x, ", ").concat(seg.rightSE.point.y, "] from queue. ") + "Please file a bug report.");
                }
                if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {
                  throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big). Please file a bug report.");
                }
                if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {
                  throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments). Please file a bug report.");
                }
                var newEvents = sweepLine.process(evt);
                for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {
                  var _evt = newEvents[_i4];
                  if (_evt.consumedBy === void 0)
                    queue.insert(_evt);
                }
                prevQueueSize = queue.size;
                node = queue.pop();
              }
              rounder.reset();
              var ringsOut = RingOut.factory(sweepLine.segments);
              var result = new MultiPolyOut(ringsOut);
              return result.getGeom();
            }
          }]);
          return Operation2;
        }();
        var operation = new Operation();
        var union = function union2(geom) {
          for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            moreGeoms[_key - 1] = arguments[_key];
          }
          return operation.run("union", geom, moreGeoms);
        };
        var intersection$1 = function intersection2(geom) {
          for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            moreGeoms[_key2 - 1] = arguments[_key2];
          }
          return operation.run("intersection", geom, moreGeoms);
        };
        var xor = function xor2(geom) {
          for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            moreGeoms[_key3 - 1] = arguments[_key3];
          }
          return operation.run("xor", geom, moreGeoms);
        };
        var difference = function difference2(subjectGeom) {
          for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
            clippingGeoms[_key4 - 1] = arguments[_key4];
          }
          return operation.run("difference", subjectGeom, clippingGeoms);
        };
        var index = {
          union,
          intersection: intersection$1,
          xor,
          difference
        };
        return index;
      });
    }
  });

  // node_modules/turf-jsts/jsts.min.js
  var require_jsts_min = __commonJS({
    "node_modules/turf-jsts/jsts.min.js"(exports, module) {
      !function(t, e) {
        "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.jsts = {});
      }(exports, function(t) {
        "use strict";
        function e() {
        }
        function n(t2) {
          this.message = t2 || "";
        }
        function i(t2) {
          this.message = t2 || "";
        }
        function r(t2) {
          this.message = t2 || "";
        }
        function o() {
        }
        function s(t2) {
          return null === t2 ? Mt : t2.color;
        }
        function a(t2) {
          return null === t2 ? null : t2.parent;
        }
        function u(t2, e3) {
          null !== t2 && (t2.color = e3);
        }
        function l(t2) {
          return null === t2 ? null : t2.left;
        }
        function c(t2) {
          return null === t2 ? null : t2.right;
        }
        function p() {
          this.root_ = null, this.size_ = 0;
        }
        function h() {
        }
        function f() {
          this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
        }
        function g() {
        }
        function d(t2) {
          this.message = t2 || "";
        }
        function y2() {
          this.array_ = [];
        }
        "fill" in Array.prototype || Object.defineProperty(Array.prototype, "fill", { configurable: true, value: function(t2) {
          if (void 0 === this || null === this)
            throw new TypeError(this + " is not an object");
          var e3 = Object(this), n2 = Math.max(Math.min(e3.length, 9007199254740991), 0) || 0, i2 = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;
          i2 = i2 < 0 ? Math.max(n2 + i2, 0) : Math.min(i2, n2);
          var r2 = 2 in arguments && void 0 !== arguments[2] ? parseInt(Number(arguments[2]), 10) || 0 : n2;
          for (r2 = r2 < 0 ? Math.max(n2 + arguments[2], 0) : Math.min(r2, n2); i2 < r2; )
            e3[i2] = t2, ++i2;
          return e3;
        }, writable: true }), Number.isFinite = Number.isFinite || function(t2) {
          return "number" == typeof t2 && isFinite(t2);
        }, Number.isInteger = Number.isInteger || function(t2) {
          return "number" == typeof t2 && isFinite(t2) && Math.floor(t2) === t2;
        }, Number.parseFloat = Number.parseFloat || parseFloat, Number.isNaN = Number.isNaN || function(t2) {
          return t2 != t2;
        }, Math.trunc = Math.trunc || function(t2) {
          return t2 < 0 ? Math.ceil(t2) : Math.floor(t2);
        };
        var _ = function() {
        };
        _.prototype.interfaces_ = function() {
          return [];
        }, _.prototype.getClass = function() {
          return _;
        }, _.prototype.equalsWithTolerance = function(t2, e3, n2) {
          return Math.abs(t2 - e3) <= n2;
        };
        var m = function(t2) {
          function e3(e4) {
            t2.call(this, e4), this.name = "IllegalArgumentException", this.message = e4, this.stack = new t2().stack;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3;
        }(Error), v = function() {
        }, I = { MAX_VALUE: { configurable: true } };
        v.isNaN = function(t2) {
          return Number.isNaN(t2);
        }, v.doubleToLongBits = function(t2) {
          return t2;
        }, v.longBitsToDouble = function(t2) {
          return t2;
        }, v.isInfinite = function(t2) {
          return !Number.isFinite(t2);
        }, I.MAX_VALUE.get = function() {
          return Number.MAX_VALUE;
        }, Object.defineProperties(v, I);
        var E = function() {
        }, x2 = function() {
        }, N = function() {
        }, C = function t2() {
          if (this.x = null, this.y = null, this.z = null, 0 === arguments.length)
            this.x = 0, this.y = 0, this.z = t2.NULL_ORDINATE;
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            this.x = e3.x, this.y = e3.y, this.z = e3.z;
          } else
            2 === arguments.length ? (this.x = arguments[0], this.y = arguments[1], this.z = t2.NULL_ORDINATE) : 3 === arguments.length && (this.x = arguments[0], this.y = arguments[1], this.z = arguments[2]);
        }, S = { DimensionalComparator: { configurable: true }, serialVersionUID: { configurable: true }, NULL_ORDINATE: { configurable: true }, X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true } };
        C.prototype.setOrdinate = function(t2, e3) {
          switch (t2) {
            case C.X:
              this.x = e3;
              break;
            case C.Y:
              this.y = e3;
              break;
            case C.Z:
              this.z = e3;
              break;
            default:
              throw new m("Invalid ordinate index: " + t2);
          }
        }, C.prototype.equals2D = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.x === t2.x && this.y === t2.y;
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return !!_.equalsWithTolerance(this.x, e3.x, n2) && !!_.equalsWithTolerance(this.y, e3.y, n2);
          }
        }, C.prototype.getOrdinate = function(t2) {
          switch (t2) {
            case C.X:
              return this.x;
            case C.Y:
              return this.y;
            case C.Z:
              return this.z;
          }
          throw new m("Invalid ordinate index: " + t2);
        }, C.prototype.equals3D = function(t2) {
          return this.x === t2.x && this.y === t2.y && (this.z === t2.z || v.isNaN(this.z)) && v.isNaN(t2.z);
        }, C.prototype.equals = function(t2) {
          return t2 instanceof C && this.equals2D(t2);
        }, C.prototype.equalInZ = function(t2, e3) {
          return _.equalsWithTolerance(this.z, t2.z, e3);
        }, C.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.x < e3.x ? -1 : this.x > e3.x ? 1 : this.y < e3.y ? -1 : this.y > e3.y ? 1 : 0;
        }, C.prototype.clone = function() {
        }, C.prototype.copy = function() {
          return new C(this);
        }, C.prototype.toString = function() {
          return "(" + this.x + ", " + this.y + ", " + this.z + ")";
        }, C.prototype.distance3D = function(t2) {
          var e3 = this.x - t2.x, n2 = this.y - t2.y, i2 = this.z - t2.z;
          return Math.sqrt(e3 * e3 + n2 * n2 + i2 * i2);
        }, C.prototype.distance = function(t2) {
          var e3 = this.x - t2.x, n2 = this.y - t2.y;
          return Math.sqrt(e3 * e3 + n2 * n2);
        }, C.prototype.hashCode = function() {
          var t2 = 17;
          return t2 = 37 * t2 + C.hashCode(this.x), t2 = 37 * t2 + C.hashCode(this.y);
        }, C.prototype.setCoordinate = function(t2) {
          this.x = t2.x, this.y = t2.y, this.z = t2.z;
        }, C.prototype.interfaces_ = function() {
          return [E, x2, e];
        }, C.prototype.getClass = function() {
          return C;
        }, C.hashCode = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = v.doubleToLongBits(t2);
            return Math.trunc((e3 ^ e3) >>> 32);
          }
        }, S.DimensionalComparator.get = function() {
          return L;
        }, S.serialVersionUID.get = function() {
          return 6683108902428367e3;
        }, S.NULL_ORDINATE.get = function() {
          return v.NaN;
        }, S.X.get = function() {
          return 0;
        }, S.Y.get = function() {
          return 1;
        }, S.Z.get = function() {
          return 2;
        }, Object.defineProperties(C, S);
        var L = function(t2) {
          if (this._dimensionsToTest = 2, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            if (2 !== e3 && 3 !== e3)
              throw new m("only 2 or 3 dimensions may be specified");
            this._dimensionsToTest = e3;
          }
        };
        L.prototype.compare = function(t2, e3) {
          var n2 = t2, i2 = e3, r2 = L.compare(n2.x, i2.x);
          if (0 !== r2)
            return r2;
          var o2 = L.compare(n2.y, i2.y);
          if (0 !== o2)
            return o2;
          if (this._dimensionsToTest <= 2)
            return 0;
          return L.compare(n2.z, i2.z);
        }, L.prototype.interfaces_ = function() {
          return [N];
        }, L.prototype.getClass = function() {
          return L;
        }, L.compare = function(t2, e3) {
          return t2 < e3 ? -1 : t2 > e3 ? 1 : v.isNaN(t2) ? v.isNaN(e3) ? 0 : -1 : v.isNaN(e3) ? 1 : 0;
        };
        var b = function() {
        };
        b.prototype.create = function() {
        }, b.prototype.interfaces_ = function() {
          return [];
        }, b.prototype.getClass = function() {
          return b;
        };
        var w = function() {
        }, O = { INTERIOR: { configurable: true }, BOUNDARY: { configurable: true }, EXTERIOR: { configurable: true }, NONE: { configurable: true } };
        w.prototype.interfaces_ = function() {
          return [];
        }, w.prototype.getClass = function() {
          return w;
        }, w.toLocationSymbol = function(t2) {
          switch (t2) {
            case w.EXTERIOR:
              return "e";
            case w.BOUNDARY:
              return "b";
            case w.INTERIOR:
              return "i";
            case w.NONE:
              return "-";
          }
          throw new m("Unknown location value: " + t2);
        }, O.INTERIOR.get = function() {
          return 0;
        }, O.BOUNDARY.get = function() {
          return 1;
        }, O.EXTERIOR.get = function() {
          return 2;
        }, O.NONE.get = function() {
          return -1;
        }, Object.defineProperties(w, O);
        var T = function(t2, e3) {
          return t2.interfaces_ && t2.interfaces_().indexOf(e3) > -1;
        }, R = function() {
        }, P = { LOG_10: { configurable: true } };
        R.prototype.interfaces_ = function() {
          return [];
        }, R.prototype.getClass = function() {
          return R;
        }, R.log10 = function(t2) {
          var e3 = Math.log(t2);
          return v.isInfinite(e3) ? e3 : v.isNaN(e3) ? e3 : e3 / R.LOG_10;
        }, R.min = function(t2, e3, n2, i2) {
          var r2 = t2;
          return e3 < r2 && (r2 = e3), n2 < r2 && (r2 = n2), i2 < r2 && (r2 = i2), r2;
        }, R.clamp = function() {
          if ("number" == typeof arguments[2] && "number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
            return t2 < e3 ? e3 : t2 > n2 ? n2 : t2;
          }
          if (Number.isInteger(arguments[2]) && Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            return i2 < r2 ? r2 : i2 > o2 ? o2 : i2;
          }
        }, R.wrap = function(t2, e3) {
          return t2 < 0 ? e3 - -t2 % e3 : t2 % e3;
        }, R.max = function() {
          if (3 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = t2;
            return e3 > i2 && (i2 = e3), n2 > i2 && (i2 = n2), i2;
          }
          if (4 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3], u2 = r2;
            return o2 > u2 && (u2 = o2), s2 > u2 && (u2 = s2), a2 > u2 && (u2 = a2), u2;
          }
        }, R.average = function(t2, e3) {
          return (t2 + e3) / 2;
        }, P.LOG_10.get = function() {
          return Math.log(10);
        }, Object.defineProperties(R, P);
        var D = function(t2) {
          this.str = t2;
        };
        D.prototype.append = function(t2) {
          this.str += t2;
        }, D.prototype.setCharAt = function(t2, e3) {
          this.str = this.str.substr(0, t2) + e3 + this.str.substr(t2 + 1);
        }, D.prototype.toString = function(t2) {
          return this.str;
        };
        var M = function(t2) {
          this.value = t2;
        };
        M.prototype.intValue = function() {
          return this.value;
        }, M.prototype.compareTo = function(t2) {
          return this.value < t2 ? -1 : this.value > t2 ? 1 : 0;
        }, M.isNaN = function(t2) {
          return Number.isNaN(t2);
        };
        var A = function() {
        };
        A.isWhitespace = function(t2) {
          return t2 <= 32 && t2 >= 0 || 127 === t2;
        }, A.toUpperCase = function(t2) {
          return t2.toUpperCase();
        };
        var F = function t2() {
          if (this._hi = 0, this._lo = 0, 0 === arguments.length)
            this.init(0);
          else if (1 === arguments.length) {
            if ("number" == typeof arguments[0]) {
              var e3 = arguments[0];
              this.init(e3);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.init(n2);
            } else if ("string" == typeof arguments[0]) {
              var i2 = arguments[0];
              t2.call(this, t2.parse(i2));
            }
          } else if (2 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1];
            this.init(r2, o2);
          }
        }, G = { PI: { configurable: true }, TWO_PI: { configurable: true }, PI_2: { configurable: true }, E: { configurable: true }, NaN: { configurable: true }, EPS: { configurable: true }, SPLIT: { configurable: true }, MAX_PRINT_DIGITS: { configurable: true }, TEN: { configurable: true }, ONE: { configurable: true }, SCI_NOT_EXPONENT_CHAR: { configurable: true }, SCI_NOT_ZERO: { configurable: true } };
        F.prototype.le = function(t2) {
          return (this._hi < t2._hi || this._hi === t2._hi) && this._lo <= t2._lo;
        }, F.prototype.extractSignificantDigits = function(t2, e3) {
          var n2 = this.abs(), i2 = F.magnitude(n2._hi), r2 = F.TEN.pow(i2);
          (n2 = n2.divide(r2)).gt(F.TEN) ? (n2 = n2.divide(F.TEN), i2 += 1) : n2.lt(F.ONE) && (n2 = n2.multiply(F.TEN), i2 -= 1);
          for (var o2 = i2 + 1, s2 = new D(), a2 = F.MAX_PRINT_DIGITS - 1, u2 = 0; u2 <= a2; u2++) {
            t2 && u2 === o2 && s2.append(".");
            var l2 = Math.trunc(n2._hi);
            if (l2 < 0)
              break;
            var c2 = false, p2 = 0;
            l2 > 9 ? (c2 = true, p2 = "9") : p2 = "0" + l2, s2.append(p2), n2 = n2.subtract(F.valueOf(l2)).multiply(F.TEN), c2 && n2.selfAdd(F.TEN);
            var h2 = true, f2 = F.magnitude(n2._hi);
            if (f2 < 0 && Math.abs(f2) >= a2 - u2 && (h2 = false), !h2)
              break;
          }
          return e3[0] = i2, s2.toString();
        }, F.prototype.sqr = function() {
          return this.multiply(this);
        }, F.prototype.doubleValue = function() {
          return this._hi + this._lo;
        }, F.prototype.subtract = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.add(t2.negate());
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return this.add(-e3);
          }
        }, F.prototype.equals = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this._hi === t2._hi && this._lo === t2._lo;
          }
        }, F.prototype.isZero = function() {
          return 0 === this._hi && 0 === this._lo;
        }, F.prototype.selfSubtract = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-t2._hi, -t2._lo);
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return this.isNaN() ? this : this.selfAdd(-e3, 0);
          }
        }, F.prototype.getSpecialNumberString = function() {
          return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
        }, F.prototype.min = function(t2) {
          return this.le(t2) ? this : t2;
        }, F.prototype.selfDivide = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof F) {
              var t2 = arguments[0];
              return this.selfDivide(t2._hi, t2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var e3 = arguments[0];
              return this.selfDivide(e3, 0);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = null, o2 = null, s2 = null, a2 = null, u2 = null, l2 = null, c2 = null, p2 = null;
            return u2 = this._hi / n2, l2 = F.SPLIT * u2, r2 = l2 - u2, p2 = F.SPLIT * n2, r2 = l2 - r2, o2 = u2 - r2, s2 = p2 - n2, c2 = u2 * n2, s2 = p2 - s2, a2 = n2 - s2, p2 = r2 * s2 - c2 + r2 * a2 + o2 * s2 + o2 * a2, l2 = (this._hi - c2 - p2 + this._lo - u2 * i2) / n2, p2 = u2 + l2, this._hi = p2, this._lo = u2 - p2 + l2, this;
          }
        }, F.prototype.dump = function() {
          return "DD<" + this._hi + ", " + this._lo + ">";
        }, F.prototype.divide = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0], e3 = null, n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a2 = null, u2 = null;
            n2 = (o2 = this._hi / t2._hi) - (e3 = (s2 = F.SPLIT * o2) - (e3 = s2 - o2)), u2 = e3 * (i2 = (u2 = F.SPLIT * t2._hi) - (i2 = u2 - t2._hi)) - (a2 = o2 * t2._hi) + e3 * (r2 = t2._hi - i2) + n2 * i2 + n2 * r2, s2 = (this._hi - a2 - u2 + this._lo - o2 * t2._lo) / t2._hi;
            return new F(u2 = o2 + s2, o2 - u2 + s2);
          }
          if ("number" == typeof arguments[0]) {
            var l2 = arguments[0];
            return v.isNaN(l2) ? F.createNaN() : F.copy(this).selfDivide(l2, 0);
          }
        }, F.prototype.ge = function(t2) {
          return (this._hi > t2._hi || this._hi === t2._hi) && this._lo >= t2._lo;
        }, F.prototype.pow = function(t2) {
          if (0 === t2)
            return F.valueOf(1);
          var e3 = new F(this), n2 = F.valueOf(1), i2 = Math.abs(t2);
          if (i2 > 1)
            for (; i2 > 0; )
              i2 % 2 == 1 && n2.selfMultiply(e3), (i2 /= 2) > 0 && (e3 = e3.sqr());
          else
            n2 = e3;
          return t2 < 0 ? n2.reciprocal() : n2;
        }, F.prototype.ceil = function() {
          if (this.isNaN())
            return F.NaN;
          var t2 = Math.ceil(this._hi), e3 = 0;
          return t2 === this._hi && (e3 = Math.ceil(this._lo)), new F(t2, e3);
        }, F.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._hi < e3._hi ? -1 : this._hi > e3._hi ? 1 : this._lo < e3._lo ? -1 : this._lo > e3._lo ? 1 : 0;
        }, F.prototype.rint = function() {
          if (this.isNaN())
            return this;
          return this.add(0.5).floor();
        }, F.prototype.setValue = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return this.init(t2), this;
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return this.init(e3), this;
          }
        }, F.prototype.max = function(t2) {
          return this.ge(t2) ? this : t2;
        }, F.prototype.sqrt = function() {
          if (this.isZero())
            return F.valueOf(0);
          if (this.isNegative())
            return F.NaN;
          var t2 = 1 / Math.sqrt(this._hi), e3 = this._hi * t2, n2 = F.valueOf(e3), i2 = this.subtract(n2.sqr())._hi * (0.5 * t2);
          return n2.add(i2);
        }, F.prototype.selfAdd = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof F) {
              var t2 = arguments[0];
              return this.selfAdd(t2._hi, t2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var e3 = arguments[0], n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a2 = null;
              return r2 = this._hi + e3, s2 = r2 - this._hi, o2 = r2 - s2, o2 = e3 - s2 + (this._hi - o2), a2 = o2 + this._lo, n2 = r2 + a2, i2 = a2 + (r2 - n2), this._hi = n2 + i2, this._lo = i2 + (n2 - this._hi), this;
            }
          } else if (2 === arguments.length) {
            var u2 = arguments[0], l2 = arguments[1], c2 = null, p2 = null, h2 = null, f2 = null, g2 = null, d2 = null, y3 = null;
            f2 = this._hi + u2, p2 = this._lo + l2, g2 = f2 - (d2 = f2 - this._hi), h2 = p2 - (y3 = p2 - this._lo);
            var _2 = (c2 = f2 + (d2 = (g2 = u2 - d2 + (this._hi - g2)) + p2)) + (d2 = (h2 = l2 - y3 + (this._lo - h2)) + (d2 + (f2 - c2))), m2 = d2 + (c2 - _2);
            return this._hi = _2, this._lo = m2, this;
          }
        }, F.prototype.selfMultiply = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof F) {
              var t2 = arguments[0];
              return this.selfMultiply(t2._hi, t2._lo);
            }
            if ("number" == typeof arguments[0]) {
              var e3 = arguments[0];
              return this.selfMultiply(e3, 0);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = null, o2 = null, s2 = null, a2 = null, u2 = null, l2 = null;
            r2 = (u2 = F.SPLIT * this._hi) - this._hi, l2 = F.SPLIT * n2, r2 = u2 - r2, o2 = this._hi - r2, s2 = l2 - n2;
            var c2 = (u2 = this._hi * n2) + (l2 = r2 * (s2 = l2 - s2) - u2 + r2 * (a2 = n2 - s2) + o2 * s2 + o2 * a2 + (this._hi * i2 + this._lo * n2)), p2 = l2 + (r2 = u2 - c2);
            return this._hi = c2, this._lo = p2, this;
          }
        }, F.prototype.selfSqr = function() {
          return this.selfMultiply(this);
        }, F.prototype.floor = function() {
          if (this.isNaN())
            return F.NaN;
          var t2 = Math.floor(this._hi), e3 = 0;
          return t2 === this._hi && (e3 = Math.floor(this._lo)), new F(t2, e3);
        }, F.prototype.negate = function() {
          return this.isNaN() ? this : new F(-this._hi, -this._lo);
        }, F.prototype.clone = function() {
        }, F.prototype.multiply = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return t2.isNaN() ? F.createNaN() : F.copy(this).selfMultiply(t2);
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return v.isNaN(e3) ? F.createNaN() : F.copy(this).selfMultiply(e3, 0);
          }
        }, F.prototype.isNaN = function() {
          return v.isNaN(this._hi);
        }, F.prototype.intValue = function() {
          return Math.trunc(this._hi);
        }, F.prototype.toString = function() {
          var t2 = F.magnitude(this._hi);
          return t2 >= -3 && t2 <= 20 ? this.toStandardNotation() : this.toSciNotation();
        }, F.prototype.toStandardNotation = function() {
          var t2 = this.getSpecialNumberString();
          if (null !== t2)
            return t2;
          var e3 = new Array(1).fill(null), n2 = this.extractSignificantDigits(true, e3), i2 = e3[0] + 1, r2 = n2;
          if ("." === n2.charAt(0))
            r2 = "0" + n2;
          else if (i2 < 0)
            r2 = "0." + F.stringOfChar("0", -i2) + n2;
          else if (-1 === n2.indexOf(".")) {
            var o2 = i2 - n2.length;
            r2 = n2 + F.stringOfChar("0", o2) + ".0";
          }
          return this.isNegative() ? "-" + r2 : r2;
        }, F.prototype.reciprocal = function() {
          var t2 = null, e3 = null, n2 = null, i2 = null, r2 = null, o2 = null, s2 = null, a2 = null;
          e3 = (r2 = 1 / this._hi) - (t2 = (o2 = F.SPLIT * r2) - (t2 = o2 - r2)), n2 = (a2 = F.SPLIT * this._hi) - this._hi;
          var u2 = r2 + (o2 = (1 - (s2 = r2 * this._hi) - (a2 = t2 * (n2 = a2 - n2) - s2 + t2 * (i2 = this._hi - n2) + e3 * n2 + e3 * i2) - r2 * this._lo) / this._hi);
          return new F(u2, r2 - u2 + o2);
        }, F.prototype.toSciNotation = function() {
          if (this.isZero())
            return F.SCI_NOT_ZERO;
          var t2 = this.getSpecialNumberString();
          if (null !== t2)
            return t2;
          var e3 = new Array(1).fill(null), n2 = this.extractSignificantDigits(false, e3), i2 = F.SCI_NOT_EXPONENT_CHAR + e3[0];
          if ("0" === n2.charAt(0))
            throw new Error("Found leading zero: " + n2);
          var r2 = "";
          n2.length > 1 && (r2 = n2.substring(1));
          var o2 = n2.charAt(0) + "." + r2;
          return this.isNegative() ? "-" + o2 + i2 : o2 + i2;
        }, F.prototype.abs = function() {
          return this.isNaN() ? F.NaN : this.isNegative() ? this.negate() : new F(this);
        }, F.prototype.isPositive = function() {
          return (this._hi > 0 || 0 === this._hi) && this._lo > 0;
        }, F.prototype.lt = function(t2) {
          return (this._hi < t2._hi || this._hi === t2._hi) && this._lo < t2._lo;
        }, F.prototype.add = function() {
          if (arguments[0] instanceof F) {
            var t2 = arguments[0];
            return F.copy(this).selfAdd(t2);
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return F.copy(this).selfAdd(e3);
          }
        }, F.prototype.init = function() {
          if (1 === arguments.length) {
            if ("number" == typeof arguments[0]) {
              var t2 = arguments[0];
              this._hi = t2, this._lo = 0;
            } else if (arguments[0] instanceof F) {
              var e3 = arguments[0];
              this._hi = e3._hi, this._lo = e3._lo;
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this._hi = n2, this._lo = i2;
          }
        }, F.prototype.gt = function(t2) {
          return (this._hi > t2._hi || this._hi === t2._hi) && this._lo > t2._lo;
        }, F.prototype.isNegative = function() {
          return (this._hi < 0 || 0 === this._hi) && this._lo < 0;
        }, F.prototype.trunc = function() {
          return this.isNaN() ? F.NaN : this.isPositive() ? this.floor() : this.ceil();
        }, F.prototype.signum = function() {
          return this._hi > 0 ? 1 : this._hi < 0 ? -1 : this._lo > 0 ? 1 : this._lo < 0 ? -1 : 0;
        }, F.prototype.interfaces_ = function() {
          return [e, E, x2];
        }, F.prototype.getClass = function() {
          return F;
        }, F.sqr = function(t2) {
          return F.valueOf(t2).selfMultiply(t2);
        }, F.valueOf = function() {
          if ("string" == typeof arguments[0]) {
            var t2 = arguments[0];
            return F.parse(t2);
          }
          if ("number" == typeof arguments[0]) {
            var e3 = arguments[0];
            return new F(e3);
          }
        }, F.sqrt = function(t2) {
          return F.valueOf(t2).sqrt();
        }, F.parse = function(t2) {
          for (var e3 = 0, n2 = t2.length; A.isWhitespace(t2.charAt(e3)); )
            e3++;
          var i2 = false;
          if (e3 < n2) {
            var r2 = t2.charAt(e3);
            "-" !== r2 && "+" !== r2 || (e3++, "-" === r2 && (i2 = true));
          }
          for (var o2 = new F(), s2 = 0, a2 = 0, u2 = 0; !(e3 >= n2); ) {
            var l2 = t2.charAt(e3);
            if (e3++, A.isDigit(l2)) {
              var c2 = l2 - "0";
              o2.selfMultiply(F.TEN), o2.selfAdd(c2), s2++;
            } else {
              if ("." !== l2) {
                if ("e" === l2 || "E" === l2) {
                  var p2 = t2.substring(e3);
                  try {
                    u2 = M.parseInt(p2);
                  } catch (e4) {
                    throw e4 instanceof Error ? new Error("Invalid exponent " + p2 + " in string " + t2) : e4;
                  }
                  break;
                }
                throw new Error("Unexpected character '" + l2 + "' at position " + e3 + " in string " + t2);
              }
              a2 = s2;
            }
          }
          var h2 = o2, f2 = s2 - a2 - u2;
          if (0 === f2)
            h2 = o2;
          else if (f2 > 0) {
            var g2 = F.TEN.pow(f2);
            h2 = o2.divide(g2);
          } else if (f2 < 0) {
            var d2 = F.TEN.pow(-f2);
            h2 = o2.multiply(d2);
          }
          return i2 ? h2.negate() : h2;
        }, F.createNaN = function() {
          return new F(v.NaN, v.NaN);
        }, F.copy = function(t2) {
          return new F(t2);
        }, F.magnitude = function(t2) {
          var e3 = Math.abs(t2), n2 = Math.log(e3) / Math.log(10), i2 = Math.trunc(Math.floor(n2));
          return 10 * Math.pow(10, i2) <= e3 && (i2 += 1), i2;
        }, F.stringOfChar = function(t2, e3) {
          for (var n2 = new D(), i2 = 0; i2 < e3; i2++)
            n2.append(t2);
          return n2.toString();
        }, G.PI.get = function() {
          return new F(3.141592653589793, 12246467991473532e-32);
        }, G.TWO_PI.get = function() {
          return new F(6.283185307179586, 24492935982947064e-32);
        }, G.PI_2.get = function() {
          return new F(1.5707963267948966, 6123233995736766e-32);
        }, G.E.get = function() {
          return new F(2.718281828459045, 14456468917292502e-32);
        }, G.NaN.get = function() {
          return new F(v.NaN, v.NaN);
        }, G.EPS.get = function() {
          return 123259516440783e-46;
        }, G.SPLIT.get = function() {
          return 134217729;
        }, G.MAX_PRINT_DIGITS.get = function() {
          return 32;
        }, G.TEN.get = function() {
          return F.valueOf(10);
        }, G.ONE.get = function() {
          return F.valueOf(1);
        }, G.SCI_NOT_EXPONENT_CHAR.get = function() {
          return "E";
        }, G.SCI_NOT_ZERO.get = function() {
          return "0.0E0";
        }, Object.defineProperties(F, G);
        var q = function() {
        }, B2 = { DP_SAFE_EPSILON: { configurable: true } };
        q.prototype.interfaces_ = function() {
          return [];
        }, q.prototype.getClass = function() {
          return q;
        }, q.orientationIndex = function(t2, e3, n2) {
          var i2 = q.orientationIndexFilter(t2, e3, n2);
          if (i2 <= 1)
            return i2;
          var r2 = F.valueOf(e3.x).selfAdd(-t2.x), o2 = F.valueOf(e3.y).selfAdd(-t2.y), s2 = F.valueOf(n2.x).selfAdd(-e3.x), a2 = F.valueOf(n2.y).selfAdd(-e3.y);
          return r2.selfMultiply(a2).selfSubtract(o2.selfMultiply(s2)).signum();
        }, q.signOfDet2x2 = function(t2, e3, n2, i2) {
          return t2.multiply(i2).selfSubtract(e3.multiply(n2)).signum();
        }, q.intersection = function(t2, e3, n2, i2) {
          var r2 = F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(F.valueOf(e3.x).selfSubtract(t2.x)), o2 = F.valueOf(i2.x).selfSubtract(n2.x).selfMultiply(F.valueOf(e3.y).selfSubtract(t2.y)), s2 = r2.subtract(o2), a2 = F.valueOf(i2.x).selfSubtract(n2.x).selfMultiply(F.valueOf(t2.y).selfSubtract(n2.y)), u2 = F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(F.valueOf(t2.x).selfSubtract(n2.x)), l2 = a2.subtract(u2).selfDivide(s2).doubleValue(), c2 = F.valueOf(t2.x).selfAdd(F.valueOf(e3.x).selfSubtract(t2.x).selfMultiply(l2)).doubleValue(), p2 = F.valueOf(e3.x).selfSubtract(t2.x).selfMultiply(F.valueOf(t2.y).selfSubtract(n2.y)), h2 = F.valueOf(e3.y).selfSubtract(t2.y).selfMultiply(F.valueOf(t2.x).selfSubtract(n2.x)), f2 = p2.subtract(h2).selfDivide(s2).doubleValue(), g2 = F.valueOf(n2.y).selfAdd(F.valueOf(i2.y).selfSubtract(n2.y).selfMultiply(f2)).doubleValue();
          return new C(c2, g2);
        }, q.orientationIndexFilter = function(t2, e3, n2) {
          var i2 = null, r2 = (t2.x - n2.x) * (e3.y - n2.y), o2 = (t2.y - n2.y) * (e3.x - n2.x), s2 = r2 - o2;
          if (r2 > 0) {
            if (o2 <= 0)
              return q.signum(s2);
            i2 = r2 + o2;
          } else {
            if (!(r2 < 0))
              return q.signum(s2);
            if (o2 >= 0)
              return q.signum(s2);
            i2 = -r2 - o2;
          }
          var a2 = q.DP_SAFE_EPSILON * i2;
          return s2 >= a2 || -s2 >= a2 ? q.signum(s2) : 2;
        }, q.signum = function(t2) {
          return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
        }, B2.DP_SAFE_EPSILON.get = function() {
          return 1e-15;
        }, Object.defineProperties(q, B2);
        var V = function() {
        }, U = { X: { configurable: true }, Y: { configurable: true }, Z: { configurable: true }, M: { configurable: true } };
        U.X.get = function() {
          return 0;
        }, U.Y.get = function() {
          return 1;
        }, U.Z.get = function() {
          return 2;
        }, U.M.get = function() {
          return 3;
        }, V.prototype.setOrdinate = function(t2, e3, n2) {
        }, V.prototype.size = function() {
        }, V.prototype.getOrdinate = function(t2, e3) {
        }, V.prototype.getCoordinate = function() {
        }, V.prototype.getCoordinateCopy = function(t2) {
        }, V.prototype.getDimension = function() {
        }, V.prototype.getX = function(t2) {
        }, V.prototype.clone = function() {
        }, V.prototype.expandEnvelope = function(t2) {
        }, V.prototype.copy = function() {
        }, V.prototype.getY = function(t2) {
        }, V.prototype.toCoordinateArray = function() {
        }, V.prototype.interfaces_ = function() {
          return [x2];
        }, V.prototype.getClass = function() {
          return V;
        }, Object.defineProperties(V, U);
        var z = function() {
        }, X = function(t2) {
          function e3() {
            t2.call(this, "Projective point not representable on the Cartesian plane.");
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(z), Y = function() {
        };
        Y.arraycopy = function(t2, e3, n2, i2, r2) {
          for (var o2 = 0, s2 = e3; s2 < e3 + r2; s2++)
            n2[i2 + o2] = t2[s2], o2++;
        }, Y.getProperty = function(t2) {
          return { "line.separator": "\n" }[t2];
        };
        var k = function t2() {
          if (this.x = null, this.y = null, this.w = null, 0 === arguments.length)
            this.x = 0, this.y = 0, this.w = 1;
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            this.x = e3.x, this.y = e3.y, this.w = 1;
          } else if (2 === arguments.length) {
            if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
              var n2 = arguments[0], i2 = arguments[1];
              this.x = n2, this.y = i2, this.w = 1;
            } else if (arguments[0] instanceof t2 && arguments[1] instanceof t2) {
              var r2 = arguments[0], o2 = arguments[1];
              this.x = r2.y * o2.w - o2.y * r2.w, this.y = o2.x * r2.w - r2.x * o2.w, this.w = r2.x * o2.y - o2.x * r2.y;
            } else if (arguments[0] instanceof C && arguments[1] instanceof C) {
              var s2 = arguments[0], a2 = arguments[1];
              this.x = s2.y - a2.y, this.y = a2.x - s2.x, this.w = s2.x * a2.y - a2.x * s2.y;
            }
          } else if (3 === arguments.length) {
            var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2];
            this.x = u2, this.y = l2, this.w = c2;
          } else if (4 === arguments.length) {
            var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2], g2 = arguments[3], d2 = p2.y - h2.y, y3 = h2.x - p2.x, _2 = p2.x * h2.y - h2.x * p2.y, m2 = f2.y - g2.y, v2 = g2.x - f2.x, I2 = f2.x * g2.y - g2.x * f2.y;
            this.x = y3 * I2 - v2 * _2, this.y = m2 * _2 - d2 * I2, this.w = d2 * v2 - m2 * y3;
          }
        };
        k.prototype.getY = function() {
          var t2 = this.y / this.w;
          if (v.isNaN(t2) || v.isInfinite(t2))
            throw new X();
          return t2;
        }, k.prototype.getX = function() {
          var t2 = this.x / this.w;
          if (v.isNaN(t2) || v.isInfinite(t2))
            throw new X();
          return t2;
        }, k.prototype.getCoordinate = function() {
          var t2 = new C();
          return t2.x = this.getX(), t2.y = this.getY(), t2;
        }, k.prototype.interfaces_ = function() {
          return [];
        }, k.prototype.getClass = function() {
          return k;
        }, k.intersection = function(t2, e3, n2, i2) {
          var r2 = t2.y - e3.y, o2 = e3.x - t2.x, s2 = t2.x * e3.y - e3.x * t2.y, a2 = n2.y - i2.y, u2 = i2.x - n2.x, l2 = n2.x * i2.y - i2.x * n2.y, c2 = r2 * u2 - a2 * o2, p2 = (o2 * l2 - u2 * s2) / c2, h2 = (a2 * s2 - r2 * l2) / c2;
          if (v.isNaN(p2) || v.isInfinite(p2) || v.isNaN(h2) || v.isInfinite(h2))
            throw new X();
          return new C(p2, h2);
        };
        var j = function t2() {
          if (this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, 0 === arguments.length)
            this.init();
          else if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var e3 = arguments[0];
              this.init(e3.x, e3.x, e3.y, e3.y);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.init(n2);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this.init(i2.x, r2.x, i2.y, r2.y);
          } else if (4 === arguments.length) {
            var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2], u2 = arguments[3];
            this.init(o2, s2, a2, u2);
          }
        }, H = { serialVersionUID: { configurable: true } };
        j.prototype.getArea = function() {
          return this.getWidth() * this.getHeight();
        }, j.prototype.equals = function(t2) {
          if (!(t2 instanceof j))
            return false;
          var e3 = t2;
          return this.isNull() ? e3.isNull() : this._maxx === e3.getMaxX() && this._maxy === e3.getMaxY() && this._minx === e3.getMinX() && this._miny === e3.getMinY();
        }, j.prototype.intersection = function(t2) {
          if (this.isNull() || t2.isNull() || !this.intersects(t2))
            return new j();
          var e3 = this._minx > t2._minx ? this._minx : t2._minx, n2 = this._miny > t2._miny ? this._miny : t2._miny, i2 = this._maxx < t2._maxx ? this._maxx : t2._maxx, r2 = this._maxy < t2._maxy ? this._maxy : t2._maxy;
          return new j(e3, i2, n2, r2);
        }, j.prototype.isNull = function() {
          return this._maxx < this._minx;
        }, j.prototype.getMaxX = function() {
          return this._maxx;
        }, j.prototype.covers = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              return this.covers(t2.x, t2.y);
            }
            if (arguments[0] instanceof j) {
              var e3 = arguments[0];
              return !this.isNull() && !e3.isNull() && (e3.getMinX() >= this._minx && e3.getMaxX() <= this._maxx && e3.getMinY() >= this._miny && e3.getMaxY() <= this._maxy);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return !this.isNull() && (n2 >= this._minx && n2 <= this._maxx && i2 >= this._miny && i2 <= this._maxy);
          }
        }, j.prototype.intersects = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof j) {
              var t2 = arguments[0];
              return !this.isNull() && !t2.isNull() && !(t2._minx > this._maxx || t2._maxx < this._minx || t2._miny > this._maxy || t2._maxy < this._miny);
            }
            if (arguments[0] instanceof C) {
              var e3 = arguments[0];
              return this.intersects(e3.x, e3.y);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return !this.isNull() && !(n2 > this._maxx || n2 < this._minx || i2 > this._maxy || i2 < this._miny);
          }
        }, j.prototype.getMinY = function() {
          return this._miny;
        }, j.prototype.getMinX = function() {
          return this._minx;
        }, j.prototype.expandToInclude = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              this.expandToInclude(t2.x, t2.y);
            } else if (arguments[0] instanceof j) {
              var e3 = arguments[0];
              if (e3.isNull())
                return null;
              this.isNull() ? (this._minx = e3.getMinX(), this._maxx = e3.getMaxX(), this._miny = e3.getMinY(), this._maxy = e3.getMaxY()) : (e3._minx < this._minx && (this._minx = e3._minx), e3._maxx > this._maxx && (this._maxx = e3._maxx), e3._miny < this._miny && (this._miny = e3._miny), e3._maxy > this._maxy && (this._maxy = e3._maxy));
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this.isNull() ? (this._minx = n2, this._maxx = n2, this._miny = i2, this._maxy = i2) : (n2 < this._minx && (this._minx = n2), n2 > this._maxx && (this._maxx = n2), i2 < this._miny && (this._miny = i2), i2 > this._maxy && (this._maxy = i2));
          }
        }, j.prototype.minExtent = function() {
          if (this.isNull())
            return 0;
          var t2 = this.getWidth(), e3 = this.getHeight();
          return t2 < e3 ? t2 : e3;
        }, j.prototype.getWidth = function() {
          return this.isNull() ? 0 : this._maxx - this._minx;
        }, j.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.isNull() ? e3.isNull() ? 0 : -1 : e3.isNull() ? 1 : this._minx < e3._minx ? -1 : this._minx > e3._minx ? 1 : this._miny < e3._miny ? -1 : this._miny > e3._miny ? 1 : this._maxx < e3._maxx ? -1 : this._maxx > e3._maxx ? 1 : this._maxy < e3._maxy ? -1 : this._maxy > e3._maxy ? 1 : 0;
        }, j.prototype.translate = function(t2, e3) {
          if (this.isNull())
            return null;
          this.init(this.getMinX() + t2, this.getMaxX() + t2, this.getMinY() + e3, this.getMaxY() + e3);
        }, j.prototype.toString = function() {
          return "Env[" + this._minx + " : " + this._maxx + ", " + this._miny + " : " + this._maxy + "]";
        }, j.prototype.setToNull = function() {
          this._minx = 0, this._maxx = -1, this._miny = 0, this._maxy = -1;
        }, j.prototype.getHeight = function() {
          return this.isNull() ? 0 : this._maxy - this._miny;
        }, j.prototype.maxExtent = function() {
          if (this.isNull())
            return 0;
          var t2 = this.getWidth(), e3 = this.getHeight();
          return t2 > e3 ? t2 : e3;
        }, j.prototype.expandBy = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.expandBy(t2, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this.isNull())
              return null;
            this._minx -= e3, this._maxx += e3, this._miny -= n2, this._maxy += n2, (this._minx > this._maxx || this._miny > this._maxy) && this.setToNull();
          }
        }, j.prototype.contains = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof j) {
              var t2 = arguments[0];
              return this.covers(t2);
            }
            if (arguments[0] instanceof C) {
              var e3 = arguments[0];
              return this.covers(e3);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return this.covers(n2, i2);
          }
        }, j.prototype.centre = function() {
          return this.isNull() ? null : new C((this.getMinX() + this.getMaxX()) / 2, (this.getMinY() + this.getMaxY()) / 2);
        }, j.prototype.init = function() {
          if (0 === arguments.length)
            this.setToNull();
          else if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              this.init(t2.x, t2.x, t2.y, t2.y);
            } else if (arguments[0] instanceof j) {
              var e3 = arguments[0];
              this._minx = e3._minx, this._maxx = e3._maxx, this._miny = e3._miny, this._maxy = e3._maxy;
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this.init(n2.x, i2.x, n2.y, i2.y);
          } else if (4 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
            r2 < o2 ? (this._minx = r2, this._maxx = o2) : (this._minx = o2, this._maxx = r2), s2 < a2 ? (this._miny = s2, this._maxy = a2) : (this._miny = a2, this._maxy = s2);
          }
        }, j.prototype.getMaxY = function() {
          return this._maxy;
        }, j.prototype.distance = function(t2) {
          if (this.intersects(t2))
            return 0;
          var e3 = 0;
          this._maxx < t2._minx ? e3 = t2._minx - this._maxx : this._minx > t2._maxx && (e3 = this._minx - t2._maxx);
          var n2 = 0;
          return this._maxy < t2._miny ? n2 = t2._miny - this._maxy : this._miny > t2._maxy && (n2 = this._miny - t2._maxy), 0 === e3 ? n2 : 0 === n2 ? e3 : Math.sqrt(e3 * e3 + n2 * n2);
        }, j.prototype.hashCode = function() {
          var t2 = 17;
          return t2 = 37 * t2 + C.hashCode(this._minx), t2 = 37 * t2 + C.hashCode(this._maxx), t2 = 37 * t2 + C.hashCode(this._miny), t2 = 37 * t2 + C.hashCode(this._maxy);
        }, j.prototype.interfaces_ = function() {
          return [E, e];
        }, j.prototype.getClass = function() {
          return j;
        }, j.intersects = function() {
          if (3 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
            return n2.x >= (t2.x < e3.x ? t2.x : e3.x) && n2.x <= (t2.x > e3.x ? t2.x : e3.x) && n2.y >= (t2.y < e3.y ? t2.y : e3.y) && n2.y <= (t2.y > e3.y ? t2.y : e3.y);
          }
          if (4 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = arguments[3], a2 = Math.min(o2.x, s2.x), u2 = Math.max(o2.x, s2.x), l2 = Math.min(i2.x, r2.x), c2 = Math.max(i2.x, r2.x);
            return !(l2 > u2) && (!(c2 < a2) && (a2 = Math.min(o2.y, s2.y), u2 = Math.max(o2.y, s2.y), l2 = Math.min(i2.y, r2.y), c2 = Math.max(i2.y, r2.y), !(l2 > u2) && !(c2 < a2)));
          }
        }, H.serialVersionUID.get = function() {
          return 5873921885273102e3;
        }, Object.defineProperties(j, H);
        var W = { typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/, emptyTypeStr: /^\s*(\w+)\s*EMPTY\s*$/, spaces: /\s+/, parenComma: /\)\s*,\s*\(/, doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/, trimParens: /^\s*\(?(.*?)\)?\s*$/ }, K = function(t2) {
          this.geometryFactory = t2 || new _e();
        };
        K.prototype.read = function(t2) {
          var e3, n2, i2;
          t2 = t2.replace(/[\n\r]/g, " ");
          var r2 = W.typeStr.exec(t2);
          if (-1 !== t2.search("EMPTY") && ((r2 = W.emptyTypeStr.exec(t2))[2] = void 0), r2 && (n2 = r2[1].toLowerCase(), i2 = r2[2], Q[n2] && (e3 = Q[n2].apply(this, [i2]))), void 0 === e3)
            throw new Error("Could not parse WKT " + t2);
          return e3;
        }, K.prototype.write = function(t2) {
          return this.extractGeometry(t2);
        }, K.prototype.extractGeometry = function(t2) {
          var e3 = t2.getGeometryType().toLowerCase();
          if (!J[e3])
            return null;
          var n2 = e3.toUpperCase();
          return t2.isEmpty() ? n2 + " EMPTY" : n2 + "(" + J[e3].apply(this, [t2]) + ")";
        };
        var J = { coordinate: function(t2) {
          return t2.x + " " + t2.y;
        }, point: function(t2) {
          return J.coordinate.call(this, t2._coordinates._coordinates[0]);
        }, multipoint: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push("(" + J.point.apply(this, [t2._geometries[n2]]) + ")");
          return e3.join(",");
        }, linestring: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._points._coordinates.length; n2 < i2; ++n2)
            e3.push(J.coordinate.apply(this, [t2._points._coordinates[n2]]));
          return e3.join(",");
        }, linearring: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._points._coordinates.length; n2 < i2; ++n2)
            e3.push(J.coordinate.apply(this, [t2._points._coordinates[n2]]));
          return e3.join(",");
        }, multilinestring: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push("(" + J.linestring.apply(this, [t2._geometries[n2]]) + ")");
          return e3.join(",");
        }, polygon: function(t2) {
          var e3 = [];
          e3.push("(" + J.linestring.apply(this, [t2._shell]) + ")");
          for (var n2 = 0, i2 = t2._holes.length; n2 < i2; ++n2)
            e3.push("(" + J.linestring.apply(this, [t2._holes[n2]]) + ")");
          return e3.join(",");
        }, multipolygon: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push("(" + J.polygon.apply(this, [t2._geometries[n2]]) + ")");
          return e3.join(",");
        }, geometrycollection: function(t2) {
          for (var e3 = [], n2 = 0, i2 = t2._geometries.length; n2 < i2; ++n2)
            e3.push(this.extractGeometry(t2._geometries[n2]));
          return e3.join(",");
        } }, Q = { point: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createPoint();
          var e3 = t2.trim().split(W.spaces);
          return this.geometryFactory.createPoint(new C(Number.parseFloat(e3[0]), Number.parseFloat(e3[1])));
        }, multipoint: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createMultiPoint();
          for (var e3, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.point.apply(this, [e3]));
          return this.geometryFactory.createMultiPoint(i2);
        }, linestring: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createLineString();
          for (var e3, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].trim().split(W.spaces), i2.push(new C(Number.parseFloat(e3[0]), Number.parseFloat(e3[1])));
          return this.geometryFactory.createLineString(i2);
        }, linearring: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createLinearRing();
          for (var e3, n2 = t2.trim().split(","), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].trim().split(W.spaces), i2.push(new C(Number.parseFloat(e3[0]), Number.parseFloat(e3[1])));
          return this.geometryFactory.createLinearRing(i2);
        }, multilinestring: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createMultiLineString();
          for (var e3, n2 = t2.trim().split(W.parenComma), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.linestring.apply(this, [e3]));
          return this.geometryFactory.createMultiLineString(i2);
        }, polygon: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createPolygon();
          for (var e3, n2, i2, r2, o2 = t2.trim().split(W.parenComma), s2 = [], a2 = 0, u2 = o2.length; a2 < u2; ++a2)
            e3 = o2[a2].replace(W.trimParens, "$1"), n2 = Q.linestring.apply(this, [e3]), i2 = this.geometryFactory.createLinearRing(n2._points), 0 === a2 ? r2 = i2 : s2.push(i2);
          return this.geometryFactory.createPolygon(r2, s2);
        }, multipolygon: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createMultiPolygon();
          for (var e3, n2 = t2.trim().split(W.doubleParenComma), i2 = [], r2 = 0, o2 = n2.length; r2 < o2; ++r2)
            e3 = n2[r2].replace(W.trimParens, "$1"), i2.push(Q.polygon.apply(this, [e3]));
          return this.geometryFactory.createMultiPolygon(i2);
        }, geometrycollection: function(t2) {
          if (void 0 === t2)
            return this.geometryFactory.createGeometryCollection();
          for (var e3 = (t2 = t2.replace(/,\s*([A-Za-z])/g, "|$1")).trim().split("|"), n2 = [], i2 = 0, r2 = e3.length; i2 < r2; ++i2)
            n2.push(this.read(e3[i2]));
          return this.geometryFactory.createGeometryCollection(n2);
        } }, Z = function(t2) {
          this.parser = new K(t2);
        };
        Z.prototype.write = function(t2) {
          return this.parser.write(t2);
        }, Z.toLineString = function(t2, e3) {
          if (2 !== arguments.length)
            throw new Error("Not implemented");
          return "LINESTRING ( " + t2.x + " " + t2.y + ", " + e3.x + " " + e3.y + " )";
        };
        var $ = function(t2) {
          function e3(e4) {
            t2.call(this, e4), this.name = "RuntimeException", this.message = e4, this.stack = new t2().stack;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3;
        }(Error), tt = function(t2) {
          function e3() {
            if (t2.call(this), 0 === arguments.length)
              t2.call(this);
            else if (1 === arguments.length) {
              var e4 = arguments[0];
              t2.call(this, e4);
            }
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }($), et = function() {
        };
        et.prototype.interfaces_ = function() {
          return [];
        }, et.prototype.getClass = function() {
          return et;
        }, et.shouldNeverReachHere = function() {
          if (0 === arguments.length)
            et.shouldNeverReachHere(null);
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            throw new tt("Should never reach here" + (null !== t2 ? ": " + t2 : ""));
          }
        }, et.isTrue = function() {
          var t2, e3;
          if (1 === arguments.length)
            t2 = arguments[0], et.isTrue(t2, null);
          else if (2 === arguments.length && (t2 = arguments[0], e3 = arguments[1], !t2))
            throw null === e3 ? new tt() : new tt(e3);
        }, et.equals = function() {
          var t2, e3, n2;
          if (2 === arguments.length)
            t2 = arguments[0], e3 = arguments[1], et.equals(t2, e3, null);
          else if (3 === arguments.length && (t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], !e3.equals(t2)))
            throw new tt("Expected " + t2 + " but encountered " + e3 + (null !== n2 ? ": " + n2 : ""));
        };
        var nt = function() {
          this._result = null, this._inputLines = Array(2).fill().map(function() {
            return Array(2);
          }), this._intPt = new Array(2).fill(null), this._intLineIndex = null, this._isProper = null, this._pa = null, this._pb = null, this._precisionModel = null, this._intPt[0] = new C(), this._intPt[1] = new C(), this._pa = this._intPt[0], this._pb = this._intPt[1], this._result = 0;
        }, it = { DONT_INTERSECT: { configurable: true }, DO_INTERSECT: { configurable: true }, COLLINEAR: { configurable: true }, NO_INTERSECTION: { configurable: true }, POINT_INTERSECTION: { configurable: true }, COLLINEAR_INTERSECTION: { configurable: true } };
        nt.prototype.getIndexAlongSegment = function(t2, e3) {
          return this.computeIntLineIndex(), this._intLineIndex[t2][e3];
        }, nt.prototype.getTopologySummary = function() {
          var t2 = new D();
          return this.isEndPoint() && t2.append(" endpoint"), this._isProper && t2.append(" proper"), this.isCollinear() && t2.append(" collinear"), t2.toString();
        }, nt.prototype.computeIntersection = function(t2, e3, n2, i2) {
          this._inputLines[0][0] = t2, this._inputLines[0][1] = e3, this._inputLines[1][0] = n2, this._inputLines[1][1] = i2, this._result = this.computeIntersect(t2, e3, n2, i2);
        }, nt.prototype.getIntersectionNum = function() {
          return this._result;
        }, nt.prototype.computeIntLineIndex = function() {
          if (0 === arguments.length)
            null === this._intLineIndex && (this._intLineIndex = Array(2).fill().map(function() {
              return Array(2);
            }), this.computeIntLineIndex(0), this.computeIntLineIndex(1));
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this.getEdgeDistance(t2, 0) > this.getEdgeDistance(t2, 1) ? (this._intLineIndex[t2][0] = 0, this._intLineIndex[t2][1] = 1) : (this._intLineIndex[t2][0] = 1, this._intLineIndex[t2][1] = 0);
          }
        }, nt.prototype.isProper = function() {
          return this.hasIntersection() && this._isProper;
        }, nt.prototype.setPrecisionModel = function(t2) {
          this._precisionModel = t2;
        }, nt.prototype.isInteriorIntersection = function() {
          if (0 === arguments.length)
            return !!this.isInteriorIntersection(0) || !!this.isInteriorIntersection(1);
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e3 = 0; e3 < this._result; e3++)
              if (!this._intPt[e3].equals2D(this._inputLines[t2][0]) && !this._intPt[e3].equals2D(this._inputLines[t2][1]))
                return true;
            return false;
          }
        }, nt.prototype.getIntersection = function(t2) {
          return this._intPt[t2];
        }, nt.prototype.isEndPoint = function() {
          return this.hasIntersection() && !this._isProper;
        }, nt.prototype.hasIntersection = function() {
          return this._result !== nt.NO_INTERSECTION;
        }, nt.prototype.getEdgeDistance = function(t2, e3) {
          return nt.computeEdgeDistance(this._intPt[e3], this._inputLines[t2][0], this._inputLines[t2][1]);
        }, nt.prototype.isCollinear = function() {
          return this._result === nt.COLLINEAR_INTERSECTION;
        }, nt.prototype.toString = function() {
          return Z.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + " - " + Z.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary();
        }, nt.prototype.getEndpoint = function(t2, e3) {
          return this._inputLines[t2][e3];
        }, nt.prototype.isIntersection = function(t2) {
          for (var e3 = 0; e3 < this._result; e3++)
            if (this._intPt[e3].equals2D(t2))
              return true;
          return false;
        }, nt.prototype.getIntersectionAlongSegment = function(t2, e3) {
          return this.computeIntLineIndex(), this._intPt[this._intLineIndex[t2][e3]];
        }, nt.prototype.interfaces_ = function() {
          return [];
        }, nt.prototype.getClass = function() {
          return nt;
        }, nt.computeEdgeDistance = function(t2, e3, n2) {
          var i2 = Math.abs(n2.x - e3.x), r2 = Math.abs(n2.y - e3.y), o2 = -1;
          if (t2.equals(e3))
            o2 = 0;
          else if (t2.equals(n2))
            o2 = i2 > r2 ? i2 : r2;
          else {
            var s2 = Math.abs(t2.x - e3.x), a2 = Math.abs(t2.y - e3.y);
            0 !== (o2 = i2 > r2 ? s2 : a2) || t2.equals(e3) || (o2 = Math.max(s2, a2));
          }
          return et.isTrue(!(0 === o2 && !t2.equals(e3)), "Bad distance calculation"), o2;
        }, nt.nonRobustComputeEdgeDistance = function(t2, e3, n2) {
          var i2 = t2.x - e3.x, r2 = t2.y - e3.y, o2 = Math.sqrt(i2 * i2 + r2 * r2);
          return et.isTrue(!(0 === o2 && !t2.equals(e3)), "Invalid distance calculation"), o2;
        }, it.DONT_INTERSECT.get = function() {
          return 0;
        }, it.DO_INTERSECT.get = function() {
          return 1;
        }, it.COLLINEAR.get = function() {
          return 2;
        }, it.NO_INTERSECTION.get = function() {
          return 0;
        }, it.POINT_INTERSECTION.get = function() {
          return 1;
        }, it.COLLINEAR_INTERSECTION.get = function() {
          return 2;
        }, Object.defineProperties(nt, it);
        var rt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.isInSegmentEnvelopes = function(t3) {
            var e4 = new j(this._inputLines[0][0], this._inputLines[0][1]), n2 = new j(this._inputLines[1][0], this._inputLines[1][1]);
            return e4.contains(t3) && n2.contains(t3);
          }, e3.prototype.computeIntersection = function() {
            if (3 !== arguments.length)
              return t2.prototype.computeIntersection.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            if (this._isProper = false, j.intersects(n2, i2, e4) && 0 === at.orientationIndex(n2, i2, e4) && 0 === at.orientationIndex(i2, n2, e4))
              return this._isProper = true, (e4.equals(n2) || e4.equals(i2)) && (this._isProper = false), this._result = t2.POINT_INTERSECTION, null;
            this._result = t2.NO_INTERSECTION;
          }, e3.prototype.normalizeToMinimum = function(t3, e4, n2, i2, r2) {
            r2.x = this.smallestInAbsValue(t3.x, e4.x, n2.x, i2.x), r2.y = this.smallestInAbsValue(t3.y, e4.y, n2.y, i2.y), t3.x -= r2.x, t3.y -= r2.y, e4.x -= r2.x, e4.y -= r2.y, n2.x -= r2.x, n2.y -= r2.y, i2.x -= r2.x, i2.y -= r2.y;
          }, e3.prototype.safeHCoordinateIntersection = function(t3, n2, i2, r2) {
            var o2 = null;
            try {
              o2 = k.intersection(t3, n2, i2, r2);
            } catch (s2) {
              if (!(s2 instanceof X))
                throw s2;
              o2 = e3.nearestEndpoint(t3, n2, i2, r2);
            }
            return o2;
          }, e3.prototype.intersection = function(t3, n2, i2, r2) {
            var o2 = this.intersectionWithNormalization(t3, n2, i2, r2);
            return this.isInSegmentEnvelopes(o2) || (o2 = new C(e3.nearestEndpoint(t3, n2, i2, r2))), null !== this._precisionModel && this._precisionModel.makePrecise(o2), o2;
          }, e3.prototype.smallestInAbsValue = function(t3, e4, n2, i2) {
            var r2 = t3, o2 = Math.abs(r2);
            return Math.abs(e4) < o2 && (r2 = e4, o2 = Math.abs(e4)), Math.abs(n2) < o2 && (r2 = n2, o2 = Math.abs(n2)), Math.abs(i2) < o2 && (r2 = i2), r2;
          }, e3.prototype.checkDD = function(t3, e4, n2, i2, r2) {
            var o2 = q.intersection(t3, e4, n2, i2), s2 = this.isInSegmentEnvelopes(o2);
            Y.out.println("DD in env = " + s2 + "  --------------------- " + o2), r2.distance(o2) > 1e-4 && Y.out.println("Distance = " + r2.distance(o2));
          }, e3.prototype.intersectionWithNormalization = function(t3, e4, n2, i2) {
            var r2 = new C(t3), o2 = new C(e4), s2 = new C(n2), a2 = new C(i2), u2 = new C();
            this.normalizeToEnvCentre(r2, o2, s2, a2, u2);
            var l2 = this.safeHCoordinateIntersection(r2, o2, s2, a2);
            return l2.x += u2.x, l2.y += u2.y, l2;
          }, e3.prototype.computeCollinearIntersection = function(e4, n2, i2, r2) {
            var o2 = j.intersects(e4, n2, i2), s2 = j.intersects(e4, n2, r2), a2 = j.intersects(i2, r2, e4), u2 = j.intersects(i2, r2, n2);
            return o2 && s2 ? (this._intPt[0] = i2, this._intPt[1] = r2, t2.COLLINEAR_INTERSECTION) : a2 && u2 ? (this._intPt[0] = e4, this._intPt[1] = n2, t2.COLLINEAR_INTERSECTION) : o2 && a2 ? (this._intPt[0] = i2, this._intPt[1] = e4, !i2.equals(e4) || s2 || u2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : o2 && u2 ? (this._intPt[0] = i2, this._intPt[1] = n2, !i2.equals(n2) || s2 || a2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : s2 && a2 ? (this._intPt[0] = r2, this._intPt[1] = e4, !r2.equals(e4) || o2 || u2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : s2 && u2 ? (this._intPt[0] = r2, this._intPt[1] = n2, !r2.equals(n2) || o2 || a2 ? t2.COLLINEAR_INTERSECTION : t2.POINT_INTERSECTION) : t2.NO_INTERSECTION;
          }, e3.prototype.normalizeToEnvCentre = function(t3, e4, n2, i2, r2) {
            var o2 = t3.x < e4.x ? t3.x : e4.x, s2 = t3.y < e4.y ? t3.y : e4.y, a2 = t3.x > e4.x ? t3.x : e4.x, u2 = t3.y > e4.y ? t3.y : e4.y, l2 = n2.x < i2.x ? n2.x : i2.x, c2 = n2.y < i2.y ? n2.y : i2.y, p2 = n2.x > i2.x ? n2.x : i2.x, h2 = n2.y > i2.y ? n2.y : i2.y, f2 = ((o2 > l2 ? o2 : l2) + (a2 < p2 ? a2 : p2)) / 2, g2 = ((s2 > c2 ? s2 : c2) + (u2 < h2 ? u2 : h2)) / 2;
            r2.x = f2, r2.y = g2, t3.x -= r2.x, t3.y -= r2.y, e4.x -= r2.x, e4.y -= r2.y, n2.x -= r2.x, n2.y -= r2.y, i2.x -= r2.x, i2.y -= r2.y;
          }, e3.prototype.computeIntersect = function(e4, n2, i2, r2) {
            if (this._isProper = false, !j.intersects(e4, n2, i2, r2))
              return t2.NO_INTERSECTION;
            var o2 = at.orientationIndex(e4, n2, i2), s2 = at.orientationIndex(e4, n2, r2);
            if (o2 > 0 && s2 > 0 || o2 < 0 && s2 < 0)
              return t2.NO_INTERSECTION;
            var a2 = at.orientationIndex(i2, r2, e4), u2 = at.orientationIndex(i2, r2, n2);
            if (a2 > 0 && u2 > 0 || a2 < 0 && u2 < 0)
              return t2.NO_INTERSECTION;
            return 0 === o2 && 0 === s2 && 0 === a2 && 0 === u2 ? this.computeCollinearIntersection(e4, n2, i2, r2) : (0 === o2 || 0 === s2 || 0 === a2 || 0 === u2 ? (this._isProper = false, e4.equals2D(i2) || e4.equals2D(r2) ? this._intPt[0] = e4 : n2.equals2D(i2) || n2.equals2D(r2) ? this._intPt[0] = n2 : 0 === o2 ? this._intPt[0] = new C(i2) : 0 === s2 ? this._intPt[0] = new C(r2) : 0 === a2 ? this._intPt[0] = new C(e4) : 0 === u2 && (this._intPt[0] = new C(n2))) : (this._isProper = true, this._intPt[0] = this.intersection(e4, n2, i2, r2)), t2.POINT_INTERSECTION);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.nearestEndpoint = function(t3, e4, n2, i2) {
            var r2 = t3, o2 = at.distancePointLine(t3, n2, i2), s2 = at.distancePointLine(e4, n2, i2);
            return s2 < o2 && (o2 = s2, r2 = e4), (s2 = at.distancePointLine(n2, t3, e4)) < o2 && (o2 = s2, r2 = n2), (s2 = at.distancePointLine(i2, t3, e4)) < o2 && (o2 = s2, r2 = i2), r2;
          }, e3;
        }(nt), ot = function() {
        };
        ot.prototype.interfaces_ = function() {
          return [];
        }, ot.prototype.getClass = function() {
          return ot;
        }, ot.orientationIndex = function(t2, e3, n2) {
          var i2 = e3.x - t2.x, r2 = e3.y - t2.y, o2 = n2.x - e3.x, s2 = n2.y - e3.y;
          return ot.signOfDet2x2(i2, r2, o2, s2);
        }, ot.signOfDet2x2 = function(t2, e3, n2, i2) {
          var r2 = null, o2 = null, s2 = null;
          if (r2 = 1, 0 === t2 || 0 === i2)
            return 0 === e3 || 0 === n2 ? 0 : e3 > 0 ? n2 > 0 ? -r2 : r2 : n2 > 0 ? r2 : -r2;
          if (0 === e3 || 0 === n2)
            return i2 > 0 ? t2 > 0 ? r2 : -r2 : t2 > 0 ? -r2 : r2;
          if (e3 > 0 ? i2 > 0 ? e3 <= i2 || (r2 = -r2, o2 = t2, t2 = n2, n2 = o2, o2 = e3, e3 = i2, i2 = o2) : e3 <= -i2 ? (r2 = -r2, n2 = -n2, i2 = -i2) : (o2 = t2, t2 = -n2, n2 = o2, o2 = e3, e3 = -i2, i2 = o2) : i2 > 0 ? -e3 <= i2 ? (r2 = -r2, t2 = -t2, e3 = -e3) : (o2 = -t2, t2 = n2, n2 = o2, o2 = -e3, e3 = i2, i2 = o2) : e3 >= i2 ? (t2 = -t2, e3 = -e3, n2 = -n2, i2 = -i2) : (r2 = -r2, o2 = -t2, t2 = -n2, n2 = o2, o2 = -e3, e3 = -i2, i2 = o2), t2 > 0) {
            if (!(n2 > 0))
              return r2;
            if (!(t2 <= n2))
              return r2;
          } else {
            if (n2 > 0)
              return -r2;
            if (!(t2 >= n2))
              return -r2;
            r2 = -r2, t2 = -t2, n2 = -n2;
          }
          for (; ; ) {
            if (s2 = Math.floor(n2 / t2), n2 -= s2 * t2, (i2 -= s2 * e3) < 0)
              return -r2;
            if (i2 > e3)
              return r2;
            if (t2 > n2 + n2) {
              if (e3 < i2 + i2)
                return r2;
            } else {
              if (e3 > i2 + i2)
                return -r2;
              n2 = t2 - n2, i2 = e3 - i2, r2 = -r2;
            }
            if (0 === i2)
              return 0 === n2 ? 0 : -r2;
            if (0 === n2)
              return r2;
            if (s2 = Math.floor(t2 / n2), t2 -= s2 * n2, (e3 -= s2 * i2) < 0)
              return r2;
            if (e3 > i2)
              return -r2;
            if (n2 > t2 + t2) {
              if (i2 < e3 + e3)
                return -r2;
            } else {
              if (i2 > e3 + e3)
                return r2;
              t2 = n2 - t2, e3 = i2 - e3, r2 = -r2;
            }
            if (0 === e3)
              return 0 === t2 ? 0 : r2;
            if (0 === t2)
              return -r2;
          }
        };
        var st = function() {
          this._p = null, this._crossingCount = 0, this._isPointOnSegment = false;
          var t2 = arguments[0];
          this._p = t2;
        };
        st.prototype.countSegment = function(t2, e3) {
          if (t2.x < this._p.x && e3.x < this._p.x)
            return null;
          if (this._p.x === e3.x && this._p.y === e3.y)
            return this._isPointOnSegment = true, null;
          if (t2.y === this._p.y && e3.y === this._p.y) {
            var n2 = t2.x, i2 = e3.x;
            return n2 > i2 && (n2 = e3.x, i2 = t2.x), this._p.x >= n2 && this._p.x <= i2 && (this._isPointOnSegment = true), null;
          }
          if (t2.y > this._p.y && e3.y <= this._p.y || e3.y > this._p.y && t2.y <= this._p.y) {
            var r2 = t2.x - this._p.x, o2 = t2.y - this._p.y, s2 = e3.x - this._p.x, a2 = e3.y - this._p.y, u2 = ot.signOfDet2x2(r2, o2, s2, a2);
            if (0 === u2)
              return this._isPointOnSegment = true, null;
            a2 < o2 && (u2 = -u2), u2 > 0 && this._crossingCount++;
          }
        }, st.prototype.isPointInPolygon = function() {
          return this.getLocation() !== w.EXTERIOR;
        }, st.prototype.getLocation = function() {
          return this._isPointOnSegment ? w.BOUNDARY : this._crossingCount % 2 == 1 ? w.INTERIOR : w.EXTERIOR;
        }, st.prototype.isOnSegment = function() {
          return this._isPointOnSegment;
        }, st.prototype.interfaces_ = function() {
          return [];
        }, st.prototype.getClass = function() {
          return st;
        }, st.locatePointInRing = function() {
          if (arguments[0] instanceof C && T(arguments[1], V)) {
            for (var t2 = arguments[0], e3 = arguments[1], n2 = new st(t2), i2 = new C(), r2 = new C(), o2 = 1; o2 < e3.size(); o2++)
              if (e3.getCoordinate(o2, i2), e3.getCoordinate(o2 - 1, r2), n2.countSegment(i2, r2), n2.isOnSegment())
                return n2.getLocation();
            return n2.getLocation();
          }
          if (arguments[0] instanceof C && arguments[1] instanceof Array) {
            for (var s2 = arguments[0], a2 = arguments[1], u2 = new st(s2), l2 = 1; l2 < a2.length; l2++) {
              var c2 = a2[l2], p2 = a2[l2 - 1];
              if (u2.countSegment(c2, p2), u2.isOnSegment())
                return u2.getLocation();
            }
            return u2.getLocation();
          }
        };
        var at = function() {
        }, ut = { CLOCKWISE: { configurable: true }, RIGHT: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, LEFT: { configurable: true }, COLLINEAR: { configurable: true }, STRAIGHT: { configurable: true } };
        at.prototype.interfaces_ = function() {
          return [];
        }, at.prototype.getClass = function() {
          return at;
        }, at.orientationIndex = function(t2, e3, n2) {
          return q.orientationIndex(t2, e3, n2);
        }, at.signedArea = function() {
          if (arguments[0] instanceof Array) {
            var t2 = arguments[0];
            if (t2.length < 3)
              return 0;
            for (var e3 = 0, n2 = t2[0].x, i2 = 1; i2 < t2.length - 1; i2++) {
              var r2 = t2[i2].x - n2, o2 = t2[i2 + 1].y;
              e3 += r2 * (t2[i2 - 1].y - o2);
            }
            return e3 / 2;
          }
          if (T(arguments[0], V)) {
            var s2 = arguments[0], a2 = s2.size();
            if (a2 < 3)
              return 0;
            var u2 = new C(), l2 = new C(), c2 = new C();
            s2.getCoordinate(0, l2), s2.getCoordinate(1, c2);
            var p2 = l2.x;
            c2.x -= p2;
            for (var h2 = 0, f2 = 1; f2 < a2 - 1; f2++)
              u2.y = l2.y, l2.x = c2.x, l2.y = c2.y, s2.getCoordinate(f2 + 1, c2), c2.x -= p2, h2 += l2.x * (u2.y - c2.y);
            return h2 / 2;
          }
        }, at.distanceLineLine = function(t2, e3, n2, i2) {
          if (t2.equals(e3))
            return at.distancePointLine(t2, n2, i2);
          if (n2.equals(i2))
            return at.distancePointLine(i2, t2, e3);
          var r2 = false;
          if (j.intersects(t2, e3, n2, i2)) {
            var o2 = (e3.x - t2.x) * (i2.y - n2.y) - (e3.y - t2.y) * (i2.x - n2.x);
            if (0 === o2)
              r2 = true;
            else {
              var s2 = (t2.y - n2.y) * (i2.x - n2.x) - (t2.x - n2.x) * (i2.y - n2.y), a2 = ((t2.y - n2.y) * (e3.x - t2.x) - (t2.x - n2.x) * (e3.y - t2.y)) / o2, u2 = s2 / o2;
              (u2 < 0 || u2 > 1 || a2 < 0 || a2 > 1) && (r2 = true);
            }
          } else
            r2 = true;
          return r2 ? R.min(at.distancePointLine(t2, n2, i2), at.distancePointLine(e3, n2, i2), at.distancePointLine(n2, t2, e3), at.distancePointLine(i2, t2, e3)) : 0;
        }, at.isPointInRing = function(t2, e3) {
          return at.locatePointInRing(t2, e3) !== w.EXTERIOR;
        }, at.computeLength = function(t2) {
          var e3 = t2.size();
          if (e3 <= 1)
            return 0;
          var n2 = 0, i2 = new C();
          t2.getCoordinate(0, i2);
          for (var r2 = i2.x, o2 = i2.y, s2 = 1; s2 < e3; s2++) {
            t2.getCoordinate(s2, i2);
            var a2 = i2.x, u2 = i2.y, l2 = a2 - r2, c2 = u2 - o2;
            n2 += Math.sqrt(l2 * l2 + c2 * c2), r2 = a2, o2 = u2;
          }
          return n2;
        }, at.isCCW = function(t2) {
          var e3 = t2.length - 1;
          if (e3 < 3)
            throw new m("Ring has fewer than 4 points, so orientation cannot be determined");
          for (var n2 = t2[0], i2 = 0, r2 = 1; r2 <= e3; r2++) {
            var o2 = t2[r2];
            o2.y > n2.y && (n2 = o2, i2 = r2);
          }
          var s2 = i2;
          do {
            (s2 -= 1) < 0 && (s2 = e3);
          } while (t2[s2].equals2D(n2) && s2 !== i2);
          var a2 = i2;
          do {
            a2 = (a2 + 1) % e3;
          } while (t2[a2].equals2D(n2) && a2 !== i2);
          var u2 = t2[s2], l2 = t2[a2];
          if (u2.equals2D(n2) || l2.equals2D(n2) || u2.equals2D(l2))
            return false;
          var c2 = at.computeOrientation(u2, n2, l2), p2 = false;
          return p2 = 0 === c2 ? u2.x > l2.x : c2 > 0, p2;
        }, at.locatePointInRing = function(t2, e3) {
          return st.locatePointInRing(t2, e3);
        }, at.distancePointLinePerpendicular = function(t2, e3, n2) {
          var i2 = (n2.x - e3.x) * (n2.x - e3.x) + (n2.y - e3.y) * (n2.y - e3.y), r2 = ((e3.y - t2.y) * (n2.x - e3.x) - (e3.x - t2.x) * (n2.y - e3.y)) / i2;
          return Math.abs(r2) * Math.sqrt(i2);
        }, at.computeOrientation = function(t2, e3, n2) {
          return at.orientationIndex(t2, e3, n2);
        }, at.distancePointLine = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            if (0 === e3.length)
              throw new m("Line array must contain at least one vertex");
            for (var n2 = t2.distance(e3[0]), i2 = 0; i2 < e3.length - 1; i2++) {
              var r2 = at.distancePointLine(t2, e3[i2], e3[i2 + 1]);
              r2 < n2 && (n2 = r2);
            }
            return n2;
          }
          if (3 === arguments.length) {
            var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            if (s2.x === a2.x && s2.y === a2.y)
              return o2.distance(s2);
            var u2 = (a2.x - s2.x) * (a2.x - s2.x) + (a2.y - s2.y) * (a2.y - s2.y), l2 = ((o2.x - s2.x) * (a2.x - s2.x) + (o2.y - s2.y) * (a2.y - s2.y)) / u2;
            if (l2 <= 0)
              return o2.distance(s2);
            if (l2 >= 1)
              return o2.distance(a2);
            var c2 = ((s2.y - o2.y) * (a2.x - s2.x) - (s2.x - o2.x) * (a2.y - s2.y)) / u2;
            return Math.abs(c2) * Math.sqrt(u2);
          }
        }, at.isOnLine = function(t2, e3) {
          for (var n2 = new rt(), i2 = 1; i2 < e3.length; i2++) {
            var r2 = e3[i2 - 1], o2 = e3[i2];
            if (n2.computeIntersection(t2, r2, o2), n2.hasIntersection())
              return true;
          }
          return false;
        }, ut.CLOCKWISE.get = function() {
          return -1;
        }, ut.RIGHT.get = function() {
          return at.CLOCKWISE;
        }, ut.COUNTERCLOCKWISE.get = function() {
          return 1;
        }, ut.LEFT.get = function() {
          return at.COUNTERCLOCKWISE;
        }, ut.COLLINEAR.get = function() {
          return 0;
        }, ut.STRAIGHT.get = function() {
          return at.COLLINEAR;
        }, Object.defineProperties(at, ut);
        var lt = function() {
        };
        lt.prototype.filter = function(t2) {
        }, lt.prototype.interfaces_ = function() {
          return [];
        }, lt.prototype.getClass = function() {
          return lt;
        };
        var ct = function() {
          var t2 = arguments[0];
          this._envelope = null, this._factory = null, this._SRID = null, this._userData = null, this._factory = t2, this._SRID = t2.getSRID();
        }, pt = { serialVersionUID: { configurable: true }, SORTINDEX_POINT: { configurable: true }, SORTINDEX_MULTIPOINT: { configurable: true }, SORTINDEX_LINESTRING: { configurable: true }, SORTINDEX_LINEARRING: { configurable: true }, SORTINDEX_MULTILINESTRING: { configurable: true }, SORTINDEX_POLYGON: { configurable: true }, SORTINDEX_MULTIPOLYGON: { configurable: true }, SORTINDEX_GEOMETRYCOLLECTION: { configurable: true }, geometryChangedFilter: { configurable: true } };
        ct.prototype.isGeometryCollection = function() {
          return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION;
        }, ct.prototype.getFactory = function() {
          return this._factory;
        }, ct.prototype.getGeometryN = function(t2) {
          return this;
        }, ct.prototype.getArea = function() {
          return 0;
        }, ct.prototype.isRectangle = function() {
          return false;
        }, ct.prototype.equals = function() {
          if (arguments[0] instanceof ct) {
            var t2 = arguments[0];
            return null !== t2 && this.equalsTopo(t2);
          }
          if (arguments[0] instanceof Object) {
            var e3 = arguments[0];
            if (!(e3 instanceof ct))
              return false;
            var n2 = e3;
            return this.equalsExact(n2);
          }
        }, ct.prototype.equalsExact = function(t2) {
          return this === t2 || this.equalsExact(t2, 0);
        }, ct.prototype.geometryChanged = function() {
          this.apply(ct.geometryChangedFilter);
        }, ct.prototype.geometryChangedAction = function() {
          this._envelope = null;
        }, ct.prototype.equalsNorm = function(t2) {
          return null !== t2 && this.norm().equalsExact(t2.norm());
        }, ct.prototype.getLength = function() {
          return 0;
        }, ct.prototype.getNumGeometries = function() {
          return 1;
        }, ct.prototype.compareTo = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = t2;
            return this.getSortIndex() !== e3.getSortIndex() ? this.getSortIndex() - e3.getSortIndex() : this.isEmpty() && e3.isEmpty() ? 0 : this.isEmpty() ? -1 : e3.isEmpty() ? 1 : this.compareToSameClass(t2);
          }
          if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return this.getSortIndex() !== n2.getSortIndex() ? this.getSortIndex() - n2.getSortIndex() : this.isEmpty() && n2.isEmpty() ? 0 : this.isEmpty() ? -1 : n2.isEmpty() ? 1 : this.compareToSameClass(n2, i2);
          }
        }, ct.prototype.getUserData = function() {
          return this._userData;
        }, ct.prototype.getSRID = function() {
          return this._SRID;
        }, ct.prototype.getEnvelope = function() {
          return this.getFactory().toGeometry(this.getEnvelopeInternal());
        }, ct.prototype.checkNotGeometryCollection = function(t2) {
          if (t2.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION)
            throw new m("This method does not support GeometryCollection arguments");
        }, ct.prototype.equal = function(t2, e3, n2) {
          return 0 === n2 ? t2.equals(e3) : t2.distance(e3) <= n2;
        }, ct.prototype.norm = function() {
          var t2 = this.copy();
          return t2.normalize(), t2;
        }, ct.prototype.getPrecisionModel = function() {
          return this._factory.getPrecisionModel();
        }, ct.prototype.getEnvelopeInternal = function() {
          return null === this._envelope && (this._envelope = this.computeEnvelopeInternal()), new j(this._envelope);
        }, ct.prototype.setSRID = function(t2) {
          this._SRID = t2;
        }, ct.prototype.setUserData = function(t2) {
          this._userData = t2;
        }, ct.prototype.compare = function(t2, e3) {
          for (var n2 = t2.iterator(), i2 = e3.iterator(); n2.hasNext() && i2.hasNext(); ) {
            var r2 = n2.next(), o2 = i2.next(), s2 = r2.compareTo(o2);
            if (0 !== s2)
              return s2;
          }
          return n2.hasNext() ? 1 : i2.hasNext() ? -1 : 0;
        }, ct.prototype.hashCode = function() {
          return this.getEnvelopeInternal().hashCode();
        }, ct.prototype.isGeometryCollectionOrDerived = function() {
          return this.getSortIndex() === ct.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === ct.SORTINDEX_MULTIPOINT || this.getSortIndex() === ct.SORTINDEX_MULTILINESTRING || this.getSortIndex() === ct.SORTINDEX_MULTIPOLYGON;
        }, ct.prototype.interfaces_ = function() {
          return [x2, E, e];
        }, ct.prototype.getClass = function() {
          return ct;
        }, ct.hasNonEmptyElements = function(t2) {
          for (var e3 = 0; e3 < t2.length; e3++)
            if (!t2[e3].isEmpty())
              return true;
          return false;
        }, ct.hasNullElements = function(t2) {
          for (var e3 = 0; e3 < t2.length; e3++)
            if (null === t2[e3])
              return true;
          return false;
        }, pt.serialVersionUID.get = function() {
          return 8763622679187377e3;
        }, pt.SORTINDEX_POINT.get = function() {
          return 0;
        }, pt.SORTINDEX_MULTIPOINT.get = function() {
          return 1;
        }, pt.SORTINDEX_LINESTRING.get = function() {
          return 2;
        }, pt.SORTINDEX_LINEARRING.get = function() {
          return 3;
        }, pt.SORTINDEX_MULTILINESTRING.get = function() {
          return 4;
        }, pt.SORTINDEX_POLYGON.get = function() {
          return 5;
        }, pt.SORTINDEX_MULTIPOLYGON.get = function() {
          return 6;
        }, pt.SORTINDEX_GEOMETRYCOLLECTION.get = function() {
          return 7;
        }, pt.geometryChangedFilter.get = function() {
          return ht;
        }, Object.defineProperties(ct, pt);
        var ht = function() {
        };
        ht.interfaces_ = function() {
          return [lt];
        }, ht.filter = function(t2) {
          t2.geometryChangedAction();
        };
        var ft = function() {
        };
        ft.prototype.filter = function(t2) {
        }, ft.prototype.interfaces_ = function() {
          return [];
        }, ft.prototype.getClass = function() {
          return ft;
        };
        var gt = function() {
        }, dt = { Mod2BoundaryNodeRule: { configurable: true }, EndPointBoundaryNodeRule: { configurable: true }, MultiValentEndPointBoundaryNodeRule: { configurable: true }, MonoValentEndPointBoundaryNodeRule: { configurable: true }, MOD2_BOUNDARY_RULE: { configurable: true }, ENDPOINT_BOUNDARY_RULE: { configurable: true }, MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true }, OGC_SFS_BOUNDARY_RULE: { configurable: true } };
        gt.prototype.isInBoundary = function(t2) {
        }, gt.prototype.interfaces_ = function() {
          return [];
        }, gt.prototype.getClass = function() {
          return gt;
        }, dt.Mod2BoundaryNodeRule.get = function() {
          return yt;
        }, dt.EndPointBoundaryNodeRule.get = function() {
          return _t;
        }, dt.MultiValentEndPointBoundaryNodeRule.get = function() {
          return mt;
        }, dt.MonoValentEndPointBoundaryNodeRule.get = function() {
          return vt;
        }, dt.MOD2_BOUNDARY_RULE.get = function() {
          return new yt();
        }, dt.ENDPOINT_BOUNDARY_RULE.get = function() {
          return new _t();
        }, dt.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
          return new mt();
        }, dt.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function() {
          return new vt();
        }, dt.OGC_SFS_BOUNDARY_RULE.get = function() {
          return gt.MOD2_BOUNDARY_RULE;
        }, Object.defineProperties(gt, dt);
        var yt = function() {
        };
        yt.prototype.isInBoundary = function(t2) {
          return t2 % 2 == 1;
        }, yt.prototype.interfaces_ = function() {
          return [gt];
        }, yt.prototype.getClass = function() {
          return yt;
        };
        var _t = function() {
        };
        _t.prototype.isInBoundary = function(t2) {
          return t2 > 0;
        }, _t.prototype.interfaces_ = function() {
          return [gt];
        }, _t.prototype.getClass = function() {
          return _t;
        };
        var mt = function() {
        };
        mt.prototype.isInBoundary = function(t2) {
          return t2 > 1;
        }, mt.prototype.interfaces_ = function() {
          return [gt];
        }, mt.prototype.getClass = function() {
          return mt;
        };
        var vt = function() {
        };
        vt.prototype.isInBoundary = function(t2) {
          return 1 === t2;
        }, vt.prototype.interfaces_ = function() {
          return [gt];
        }, vt.prototype.getClass = function() {
          return vt;
        };
        var It = function() {
        };
        It.prototype.add = function() {
        }, It.prototype.addAll = function() {
        }, It.prototype.isEmpty = function() {
        }, It.prototype.iterator = function() {
        }, It.prototype.size = function() {
        }, It.prototype.toArray = function() {
        }, It.prototype.remove = function() {
        }, (n.prototype = new Error()).name = "IndexOutOfBoundsException";
        var Et = function() {
        };
        Et.prototype.hasNext = function() {
        }, Et.prototype.next = function() {
        }, Et.prototype.remove = function() {
        };
        var xt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.get = function() {
          }, e3.prototype.set = function() {
          }, e3.prototype.isEmpty = function() {
          }, e3;
        }(It);
        (i.prototype = new Error()).name = "NoSuchElementException";
        var Nt = function(t2) {
          function e3() {
            t2.call(this), this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.ensureCapacity = function() {
          }, e3.prototype.interfaces_ = function() {
            return [t2, It];
          }, e3.prototype.add = function(t3) {
            return 1 === arguments.length ? this.array_.push(t3) : this.array_.splice(arguments[0], arguments[1]), true;
          }, e3.prototype.clear = function() {
            this.array_ = [];
          }, e3.prototype.addAll = function(t3) {
            for (var e4 = t3.iterator(); e4.hasNext(); )
              this.add(e4.next());
            return true;
          }, e3.prototype.set = function(t3, e4) {
            var n2 = this.array_[t3];
            return this.array_[t3] = e4, n2;
          }, e3.prototype.iterator = function() {
            return new Ct(this);
          }, e3.prototype.get = function(t3) {
            if (t3 < 0 || t3 >= this.size())
              throw new n();
            return this.array_[t3];
          }, e3.prototype.isEmpty = function() {
            return 0 === this.array_.length;
          }, e3.prototype.size = function() {
            return this.array_.length;
          }, e3.prototype.toArray = function() {
            for (var t3 = [], e4 = 0, n2 = this.array_.length; e4 < n2; e4++)
              t3.push(this.array_[e4]);
            return t3;
          }, e3.prototype.remove = function(t3) {
            for (var e4 = false, n2 = 0, i2 = this.array_.length; n2 < i2; n2++)
              if (this.array_[n2] === t3) {
                this.array_.splice(n2, 1), e4 = true;
                break;
              }
            return e4;
          }, e3;
        }(xt), Ct = function(t2) {
          function e3(e4) {
            t2.call(this), this.arrayList_ = e4, this.position_ = 0;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.next = function() {
            if (this.position_ === this.arrayList_.size())
              throw new i();
            return this.arrayList_.get(this.position_++);
          }, e3.prototype.hasNext = function() {
            return this.position_ < this.arrayList_.size();
          }, e3.prototype.set = function(t3) {
            return this.arrayList_.set(this.position_ - 1, t3);
          }, e3.prototype.remove = function() {
            this.arrayList_.remove(this.arrayList_.get(this.position_));
          }, e3;
        }(Et), St = function(t2) {
          function e3() {
            if (t2.call(this), 0 === arguments.length)
              ;
            else if (1 === arguments.length) {
              var e4 = arguments[0];
              this.ensureCapacity(e4.length), this.add(e4, true);
            } else if (2 === arguments.length) {
              var n3 = arguments[0], i2 = arguments[1];
              this.ensureCapacity(n3.length), this.add(n3, i2);
            }
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { coordArrayType: { configurable: true } };
          return n2.coordArrayType.get = function() {
            return new Array(0).fill(null);
          }, e3.prototype.getCoordinate = function(t3) {
            return this.get(t3);
          }, e3.prototype.addAll = function() {
            if (2 === arguments.length) {
              for (var e4 = arguments[0], n3 = arguments[1], i2 = false, r2 = e4.iterator(); r2.hasNext(); )
                this.add(r2.next(), n3), i2 = true;
              return i2;
            }
            return t2.prototype.addAll.apply(this, arguments);
          }, e3.prototype.clone = function() {
            for (var e4 = t2.prototype.clone.call(this), n3 = 0; n3 < this.size(); n3++)
              e4.add(n3, this.get(n3).copy());
            return e4;
          }, e3.prototype.toCoordinateArray = function() {
            return this.toArray(e3.coordArrayType);
          }, e3.prototype.add = function() {
            if (1 === arguments.length) {
              var e4 = arguments[0];
              t2.prototype.add.call(this, e4);
            } else if (2 === arguments.length) {
              if (arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                var n3 = arguments[0], i2 = arguments[1];
                return this.add(n3, i2, true), true;
              }
              if (arguments[0] instanceof C && "boolean" == typeof arguments[1]) {
                var r2 = arguments[0];
                if (!arguments[1] && this.size() >= 1) {
                  if (this.get(this.size() - 1).equals2D(r2))
                    return null;
                }
                t2.prototype.add.call(this, r2);
              } else if (arguments[0] instanceof Object && "boolean" == typeof arguments[1]) {
                var o2 = arguments[0], s2 = arguments[1];
                return this.add(o2, s2), true;
              }
            } else if (3 === arguments.length) {
              if ("boolean" == typeof arguments[2] && arguments[0] instanceof Array && "boolean" == typeof arguments[1]) {
                var a2 = arguments[0], u2 = arguments[1];
                if (arguments[2])
                  for (var l2 = 0; l2 < a2.length; l2++)
                    this.add(a2[l2], u2);
                else
                  for (var c2 = a2.length - 1; c2 >= 0; c2--)
                    this.add(a2[c2], u2);
                return true;
              }
              if ("boolean" == typeof arguments[2] && Number.isInteger(arguments[0]) && arguments[1] instanceof C) {
                var p2 = arguments[0], h2 = arguments[1];
                if (!arguments[2]) {
                  var f2 = this.size();
                  if (f2 > 0) {
                    if (p2 > 0) {
                      if (this.get(p2 - 1).equals2D(h2))
                        return null;
                    }
                    if (p2 < f2) {
                      if (this.get(p2).equals2D(h2))
                        return null;
                    }
                  }
                }
                t2.prototype.add.call(this, p2, h2);
              }
            } else if (4 === arguments.length) {
              var g2 = arguments[0], d2 = arguments[1], y3 = arguments[2], _2 = arguments[3], m2 = 1;
              y3 > _2 && (m2 = -1);
              for (var v2 = y3; v2 !== _2; v2 += m2)
                this.add(g2[v2], d2);
              return true;
            }
          }, e3.prototype.closeRing = function() {
            this.size() > 0 && this.add(new C(this.get(0)), false);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, Object.defineProperties(e3, n2), e3;
        }(Nt), Lt = function() {
        }, bt = { ForwardComparator: { configurable: true }, BidirectionalComparator: { configurable: true }, coordArrayType: { configurable: true } };
        bt.ForwardComparator.get = function() {
          return wt;
        }, bt.BidirectionalComparator.get = function() {
          return Ot;
        }, bt.coordArrayType.get = function() {
          return new Array(0).fill(null);
        }, Lt.prototype.interfaces_ = function() {
          return [];
        }, Lt.prototype.getClass = function() {
          return Lt;
        }, Lt.isRing = function(t2) {
          return !(t2.length < 4) && !!t2[0].equals2D(t2[t2.length - 1]);
        }, Lt.ptNotInList = function(t2, e3) {
          for (var n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2];
            if (Lt.indexOf(i2, e3) < 0)
              return i2;
          }
          return null;
        }, Lt.scroll = function(t2, e3) {
          var n2 = Lt.indexOf(e3, t2);
          if (n2 < 0)
            return null;
          var i2 = new Array(t2.length).fill(null);
          Y.arraycopy(t2, n2, i2, 0, t2.length - n2), Y.arraycopy(t2, 0, i2, t2.length - n2, n2), Y.arraycopy(i2, 0, t2, 0, t2.length);
        }, Lt.equals = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            if (t2 === e3)
              return true;
            if (null === t2 || null === e3)
              return false;
            if (t2.length !== e3.length)
              return false;
            for (var n2 = 0; n2 < t2.length; n2++)
              if (!t2[n2].equals(e3[n2]))
                return false;
            return true;
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            if (i2 === r2)
              return true;
            if (null === i2 || null === r2)
              return false;
            if (i2.length !== r2.length)
              return false;
            for (var s2 = 0; s2 < i2.length; s2++)
              if (0 !== o2.compare(i2[s2], r2[s2]))
                return false;
            return true;
          }
        }, Lt.intersection = function(t2, e3) {
          for (var n2 = new St(), i2 = 0; i2 < t2.length; i2++)
            e3.intersects(t2[i2]) && n2.add(t2[i2], true);
          return n2.toCoordinateArray();
        }, Lt.hasRepeatedPoints = function(t2) {
          for (var e3 = 1; e3 < t2.length; e3++)
            if (t2[e3 - 1].equals(t2[e3]))
              return true;
          return false;
        }, Lt.removeRepeatedPoints = function(t2) {
          if (!Lt.hasRepeatedPoints(t2))
            return t2;
          return new St(t2, false).toCoordinateArray();
        }, Lt.reverse = function(t2) {
          for (var e3 = t2.length - 1, n2 = Math.trunc(e3 / 2), i2 = 0; i2 <= n2; i2++) {
            var r2 = t2[i2];
            t2[i2] = t2[e3 - i2], t2[e3 - i2] = r2;
          }
        }, Lt.removeNull = function(t2) {
          for (var e3 = 0, n2 = 0; n2 < t2.length; n2++)
            null !== t2[n2] && e3++;
          var i2 = new Array(e3).fill(null);
          if (0 === e3)
            return i2;
          for (var r2 = 0, o2 = 0; o2 < t2.length; o2++)
            null !== t2[o2] && (i2[r2++] = t2[o2]);
          return i2;
        }, Lt.copyDeep = function() {
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e3 = new Array(t2.length).fill(null), n2 = 0; n2 < t2.length; n2++)
              e3[n2] = new C(t2[n2]);
            return e3;
          }
          if (5 === arguments.length)
            for (var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = arguments[3], a2 = arguments[4], u2 = 0; u2 < a2; u2++)
              o2[s2 + u2] = new C(i2[r2 + u2]);
        }, Lt.isEqualReversed = function(t2, e3) {
          for (var n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2], r2 = e3[t2.length - n2 - 1];
            if (0 !== i2.compareTo(r2))
              return false;
          }
          return true;
        }, Lt.envelope = function(t2) {
          for (var e3 = new j(), n2 = 0; n2 < t2.length; n2++)
            e3.expandToInclude(t2[n2]);
          return e3;
        }, Lt.toCoordinateArray = function(t2) {
          return t2.toArray(Lt.coordArrayType);
        }, Lt.atLeastNCoordinatesOrNothing = function(t2, e3) {
          return e3.length >= t2 ? e3 : [];
        }, Lt.indexOf = function(t2, e3) {
          for (var n2 = 0; n2 < e3.length; n2++)
            if (t2.equals(e3[n2]))
              return n2;
          return -1;
        }, Lt.increasingDirection = function(t2) {
          for (var e3 = 0; e3 < Math.trunc(t2.length / 2); e3++) {
            var n2 = t2.length - 1 - e3, i2 = t2[e3].compareTo(t2[n2]);
            if (0 !== i2)
              return i2;
          }
          return 1;
        }, Lt.compare = function(t2, e3) {
          for (var n2 = 0; n2 < t2.length && n2 < e3.length; ) {
            var i2 = t2[n2].compareTo(e3[n2]);
            if (0 !== i2)
              return i2;
            n2++;
          }
          return n2 < e3.length ? -1 : n2 < t2.length ? 1 : 0;
        }, Lt.minCoordinate = function(t2) {
          for (var e3 = null, n2 = 0; n2 < t2.length; n2++)
            (null === e3 || e3.compareTo(t2[n2]) > 0) && (e3 = t2[n2]);
          return e3;
        }, Lt.extract = function(t2, e3, n2) {
          e3 = R.clamp(e3, 0, t2.length);
          var i2 = (n2 = R.clamp(n2, -1, t2.length)) - e3 + 1;
          n2 < 0 && (i2 = 0), e3 >= t2.length && (i2 = 0), n2 < e3 && (i2 = 0);
          var r2 = new Array(i2).fill(null);
          if (0 === i2)
            return r2;
          for (var o2 = 0, s2 = e3; s2 <= n2; s2++)
            r2[o2++] = t2[s2];
          return r2;
        }, Object.defineProperties(Lt, bt);
        var wt = function() {
        };
        wt.prototype.compare = function(t2, e3) {
          return Lt.compare(t2, e3);
        }, wt.prototype.interfaces_ = function() {
          return [N];
        }, wt.prototype.getClass = function() {
          return wt;
        };
        var Ot = function() {
        };
        Ot.prototype.compare = function(t2, e3) {
          var n2 = t2, i2 = e3;
          if (n2.length < i2.length)
            return -1;
          if (n2.length > i2.length)
            return 1;
          if (0 === n2.length)
            return 0;
          var r2 = Lt.compare(n2, i2);
          return Lt.isEqualReversed(n2, i2) ? 0 : r2;
        }, Ot.prototype.OLDcompare = function(t2, e3) {
          var n2 = t2, i2 = e3;
          if (n2.length < i2.length)
            return -1;
          if (n2.length > i2.length)
            return 1;
          if (0 === n2.length)
            return 0;
          for (var r2 = Lt.increasingDirection(n2), o2 = Lt.increasingDirection(i2), s2 = r2 > 0 ? 0 : n2.length - 1, a2 = o2 > 0 ? 0 : n2.length - 1, u2 = 0; u2 < n2.length; u2++) {
            var l2 = n2[s2].compareTo(i2[a2]);
            if (0 !== l2)
              return l2;
            s2 += r2, a2 += o2;
          }
          return 0;
        }, Ot.prototype.interfaces_ = function() {
          return [N];
        }, Ot.prototype.getClass = function() {
          return Ot;
        };
        var Tt = function() {
        };
        Tt.prototype.get = function() {
        }, Tt.prototype.put = function() {
        }, Tt.prototype.size = function() {
        }, Tt.prototype.values = function() {
        }, Tt.prototype.entrySet = function() {
        };
        var Rt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3;
        }(Tt);
        (r.prototype = new Error()).name = "OperationNotSupported", (o.prototype = new It()).contains = function() {
        };
        var Pt = function(t2) {
          function e3() {
            t2.call(this), this.array_ = [], arguments[0] instanceof It && this.addAll(arguments[0]);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.contains = function(t3) {
            for (var e4 = 0, n2 = this.array_.length; e4 < n2; e4++) {
              if (this.array_[e4] === t3)
                return true;
            }
            return false;
          }, e3.prototype.add = function(t3) {
            return !this.contains(t3) && (this.array_.push(t3), true);
          }, e3.prototype.addAll = function(t3) {
            for (var e4 = t3.iterator(); e4.hasNext(); )
              this.add(e4.next());
            return true;
          }, e3.prototype.remove = function(t3) {
            throw new Error();
          }, e3.prototype.size = function() {
            return this.array_.length;
          }, e3.prototype.isEmpty = function() {
            return 0 === this.array_.length;
          }, e3.prototype.toArray = function() {
            for (var t3 = [], e4 = 0, n2 = this.array_.length; e4 < n2; e4++)
              t3.push(this.array_[e4]);
            return t3;
          }, e3.prototype.iterator = function() {
            return new Dt(this);
          }, e3;
        }(o), Dt = function(t2) {
          function e3(e4) {
            t2.call(this), this.hashSet_ = e4, this.position_ = 0;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.next = function() {
            if (this.position_ === this.hashSet_.size())
              throw new i();
            return this.hashSet_.array_[this.position_++];
          }, e3.prototype.hasNext = function() {
            return this.position_ < this.hashSet_.size();
          }, e3.prototype.remove = function() {
            throw new r();
          }, e3;
        }(Et), Mt = 0;
        (p.prototype = new Rt()).get = function(t2) {
          for (var e3 = this.root_; null !== e3; ) {
            var n2 = t2.compareTo(e3.key);
            if (n2 < 0)
              e3 = e3.left;
            else {
              if (!(n2 > 0))
                return e3.value;
              e3 = e3.right;
            }
          }
          return null;
        }, p.prototype.put = function(t2, e3) {
          if (null === this.root_)
            return this.root_ = { key: t2, value: e3, left: null, right: null, parent: null, color: Mt, getValue: function() {
              return this.value;
            }, getKey: function() {
              return this.key;
            } }, this.size_ = 1, null;
          var n2, i2, r2 = this.root_;
          do {
            if (n2 = r2, (i2 = t2.compareTo(r2.key)) < 0)
              r2 = r2.left;
            else {
              if (!(i2 > 0)) {
                var o2 = r2.value;
                return r2.value = e3, o2;
              }
              r2 = r2.right;
            }
          } while (null !== r2);
          var s2 = { key: t2, left: null, right: null, value: e3, parent: n2, color: Mt, getValue: function() {
            return this.value;
          }, getKey: function() {
            return this.key;
          } };
          return i2 < 0 ? n2.left = s2 : n2.right = s2, this.fixAfterInsertion(s2), this.size_++, null;
        }, p.prototype.fixAfterInsertion = function(t2) {
          for (t2.color = 1; null != t2 && t2 !== this.root_ && 1 === t2.parent.color; )
            if (a(t2) === l(a(a(t2)))) {
              var e3 = c(a(a(t2)));
              1 === s(e3) ? (u(a(t2), Mt), u(e3, Mt), u(a(a(t2)), 1), t2 = a(a(t2))) : (t2 === c(a(t2)) && (t2 = a(t2), this.rotateLeft(t2)), u(a(t2), Mt), u(a(a(t2)), 1), this.rotateRight(a(a(t2))));
            } else {
              var n2 = l(a(a(t2)));
              1 === s(n2) ? (u(a(t2), Mt), u(n2, Mt), u(a(a(t2)), 1), t2 = a(a(t2))) : (t2 === l(a(t2)) && (t2 = a(t2), this.rotateRight(t2)), u(a(t2), Mt), u(a(a(t2)), 1), this.rotateLeft(a(a(t2))));
            }
          this.root_.color = Mt;
        }, p.prototype.values = function() {
          var t2 = new Nt(), e3 = this.getFirstEntry();
          if (null !== e3)
            for (t2.add(e3.value); null !== (e3 = p.successor(e3)); )
              t2.add(e3.value);
          return t2;
        }, p.prototype.entrySet = function() {
          var t2 = new Pt(), e3 = this.getFirstEntry();
          if (null !== e3)
            for (t2.add(e3); null !== (e3 = p.successor(e3)); )
              t2.add(e3);
          return t2;
        }, p.prototype.rotateLeft = function(t2) {
          if (null != t2) {
            var e3 = t2.right;
            t2.right = e3.left, null != e3.left && (e3.left.parent = t2), e3.parent = t2.parent, null === t2.parent ? this.root_ = e3 : t2.parent.left === t2 ? t2.parent.left = e3 : t2.parent.right = e3, e3.left = t2, t2.parent = e3;
          }
        }, p.prototype.rotateRight = function(t2) {
          if (null != t2) {
            var e3 = t2.left;
            t2.left = e3.right, null != e3.right && (e3.right.parent = t2), e3.parent = t2.parent, null === t2.parent ? this.root_ = e3 : t2.parent.right === t2 ? t2.parent.right = e3 : t2.parent.left = e3, e3.right = t2, t2.parent = e3;
          }
        }, p.prototype.getFirstEntry = function() {
          var t2 = this.root_;
          if (null != t2)
            for (; null != t2.left; )
              t2 = t2.left;
          return t2;
        }, p.successor = function(t2) {
          if (null === t2)
            return null;
          if (null !== t2.right) {
            for (var e3 = t2.right; null !== e3.left; )
              e3 = e3.left;
            return e3;
          }
          for (var n2 = t2.parent, i2 = t2; null !== n2 && i2 === n2.right; )
            i2 = n2, n2 = n2.parent;
          return n2;
        }, p.prototype.size = function() {
          return this.size_;
        };
        var At = function() {
        };
        At.prototype.interfaces_ = function() {
          return [];
        }, At.prototype.getClass = function() {
          return At;
        }, h.prototype = new o(), (f.prototype = new h()).contains = function(t2) {
          for (var e3 = 0, n2 = this.array_.length; e3 < n2; e3++) {
            if (0 === this.array_[e3].compareTo(t2))
              return true;
          }
          return false;
        }, f.prototype.add = function(t2) {
          if (this.contains(t2))
            return false;
          for (var e3 = 0, n2 = this.array_.length; e3 < n2; e3++) {
            if (1 === this.array_[e3].compareTo(t2))
              return this.array_.splice(e3, 0, t2), true;
          }
          return this.array_.push(t2), true;
        }, f.prototype.addAll = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); )
            this.add(e3.next());
          return true;
        }, f.prototype.remove = function(t2) {
          throw new r();
        }, f.prototype.size = function() {
          return this.array_.length;
        }, f.prototype.isEmpty = function() {
          return 0 === this.array_.length;
        }, f.prototype.toArray = function() {
          for (var t2 = [], e3 = 0, n2 = this.array_.length; e3 < n2; e3++)
            t2.push(this.array_[e3]);
          return t2;
        }, f.prototype.iterator = function() {
          return new Ft(this);
        };
        var Ft = function(t2) {
          this.treeSet_ = t2, this.position_ = 0;
        };
        Ft.prototype.next = function() {
          if (this.position_ === this.treeSet_.size())
            throw new i();
          return this.treeSet_.array_[this.position_++];
        }, Ft.prototype.hasNext = function() {
          return this.position_ < this.treeSet_.size();
        }, Ft.prototype.remove = function() {
          throw new r();
        };
        var Gt = function() {
        };
        Gt.sort = function() {
          var t2, e3, n2, i2, r2 = arguments[0];
          if (1 === arguments.length)
            i2 = function(t3, e4) {
              return t3.compareTo(e4);
            }, r2.sort(i2);
          else if (2 === arguments.length)
            n2 = arguments[1], i2 = function(t3, e4) {
              return n2.compare(t3, e4);
            }, r2.sort(i2);
          else if (3 === arguments.length) {
            (e3 = r2.slice(arguments[1], arguments[2])).sort();
            var o2 = r2.slice(0, arguments[1]).concat(e3, r2.slice(arguments[2], r2.length));
            for (r2.splice(0, r2.length), t2 = 0; t2 < o2.length; t2++)
              r2.push(o2[t2]);
          } else if (4 === arguments.length)
            for (e3 = r2.slice(arguments[1], arguments[2]), n2 = arguments[3], i2 = function(t3, e4) {
              return n2.compare(t3, e4);
            }, e3.sort(i2), o2 = r2.slice(0, arguments[1]).concat(e3, r2.slice(arguments[2], r2.length)), r2.splice(0, r2.length), t2 = 0; t2 < o2.length; t2++)
              r2.push(o2[t2]);
        }, Gt.asList = function(t2) {
          for (var e3 = new Nt(), n2 = 0, i2 = t2.length; n2 < i2; n2++)
            e3.add(t2[n2]);
          return e3;
        };
        var qt = function() {
        }, Bt = { P: { configurable: true }, L: { configurable: true }, A: { configurable: true }, FALSE: { configurable: true }, TRUE: { configurable: true }, DONTCARE: { configurable: true }, SYM_FALSE: { configurable: true }, SYM_TRUE: { configurable: true }, SYM_DONTCARE: { configurable: true }, SYM_P: { configurable: true }, SYM_L: { configurable: true }, SYM_A: { configurable: true } };
        Bt.P.get = function() {
          return 0;
        }, Bt.L.get = function() {
          return 1;
        }, Bt.A.get = function() {
          return 2;
        }, Bt.FALSE.get = function() {
          return -1;
        }, Bt.TRUE.get = function() {
          return -2;
        }, Bt.DONTCARE.get = function() {
          return -3;
        }, Bt.SYM_FALSE.get = function() {
          return "F";
        }, Bt.SYM_TRUE.get = function() {
          return "T";
        }, Bt.SYM_DONTCARE.get = function() {
          return "*";
        }, Bt.SYM_P.get = function() {
          return "0";
        }, Bt.SYM_L.get = function() {
          return "1";
        }, Bt.SYM_A.get = function() {
          return "2";
        }, qt.prototype.interfaces_ = function() {
          return [];
        }, qt.prototype.getClass = function() {
          return qt;
        }, qt.toDimensionSymbol = function(t2) {
          switch (t2) {
            case qt.FALSE:
              return qt.SYM_FALSE;
            case qt.TRUE:
              return qt.SYM_TRUE;
            case qt.DONTCARE:
              return qt.SYM_DONTCARE;
            case qt.P:
              return qt.SYM_P;
            case qt.L:
              return qt.SYM_L;
            case qt.A:
              return qt.SYM_A;
          }
          throw new m("Unknown dimension value: " + t2);
        }, qt.toDimensionValue = function(t2) {
          switch (A.toUpperCase(t2)) {
            case qt.SYM_FALSE:
              return qt.FALSE;
            case qt.SYM_TRUE:
              return qt.TRUE;
            case qt.SYM_DONTCARE:
              return qt.DONTCARE;
            case qt.SYM_P:
              return qt.P;
            case qt.SYM_L:
              return qt.L;
            case qt.SYM_A:
              return qt.A;
          }
          throw new m("Unknown dimension symbol: " + t2);
        }, Object.defineProperties(qt, Bt);
        var Vt = function() {
        };
        Vt.prototype.filter = function(t2) {
        }, Vt.prototype.interfaces_ = function() {
          return [];
        }, Vt.prototype.getClass = function() {
          return Vt;
        };
        var Ut = function() {
        };
        Ut.prototype.filter = function(t2, e3) {
        }, Ut.prototype.isDone = function() {
        }, Ut.prototype.isGeometryChanged = function() {
        }, Ut.prototype.interfaces_ = function() {
          return [];
        }, Ut.prototype.getClass = function() {
          return Ut;
        };
        var zt = function(t2) {
          function e3(e4, n3) {
            if (t2.call(this, n3), this._geometries = e4 || [], t2.hasNullElements(this._geometries))
              throw new m("geometries must not contain null elements");
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            for (var t3 = new j(), e4 = 0; e4 < this._geometries.length; e4++)
              t3.expandToInclude(this._geometries[e4].getEnvelopeInternal());
            return t3;
          }, e3.prototype.getGeometryN = function(t3) {
            return this._geometries[t3];
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_GEOMETRYCOLLECTION;
          }, e3.prototype.getCoordinates = function() {
            for (var t3 = new Array(this.getNumPoints()).fill(null), e4 = -1, n3 = 0; n3 < this._geometries.length; n3++)
              for (var i2 = this._geometries[n3].getCoordinates(), r2 = 0; r2 < i2.length; r2++)
                t3[++e4] = i2[r2];
            return t3;
          }, e3.prototype.getArea = function() {
            for (var t3 = 0, e4 = 0; e4 < this._geometries.length; e4++)
              t3 += this._geometries[e4].getArea();
            return t3;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              if (!this.isEquivalentClass(e4))
                return false;
              var i2 = e4;
              if (this._geometries.length !== i2._geometries.length)
                return false;
              for (var r2 = 0; r2 < this._geometries.length; r2++)
                if (!this._geometries[r2].equalsExact(i2._geometries[r2], n3))
                  return false;
              return true;
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
            for (var t3 = 0; t3 < this._geometries.length; t3++)
              this._geometries[t3].normalize();
            Gt.sort(this._geometries);
          }, e3.prototype.getCoordinate = function() {
            return this.isEmpty() ? null : this._geometries[0].getCoordinate();
          }, e3.prototype.getBoundaryDimension = function() {
            for (var t3 = qt.FALSE, e4 = 0; e4 < this._geometries.length; e4++)
              t3 = Math.max(t3, this._geometries[e4].getBoundaryDimension());
            return t3;
          }, e3.prototype.getDimension = function() {
            for (var t3 = qt.FALSE, e4 = 0; e4 < this._geometries.length; e4++)
              t3 = Math.max(t3, this._geometries[e4].getDimension());
            return t3;
          }, e3.prototype.getLength = function() {
            for (var t3 = 0, e4 = 0; e4 < this._geometries.length; e4++)
              t3 += this._geometries[e4].getLength();
            return t3;
          }, e3.prototype.getNumPoints = function() {
            for (var t3 = 0, e4 = 0; e4 < this._geometries.length; e4++)
              t3 += this._geometries[e4].getNumPoints();
            return t3;
          }, e3.prototype.getNumGeometries = function() {
            return this._geometries.length;
          }, e3.prototype.reverse = function() {
            for (var t3 = this._geometries.length, e4 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
              e4[n3] = this._geometries[n3].reverse();
            return this.getFactory().createGeometryCollection(e4);
          }, e3.prototype.compareToSameClass = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0], e4 = new f(Gt.asList(this._geometries)), n3 = new f(Gt.asList(t3._geometries));
              return this.compare(e4, n3);
            }
            if (2 === arguments.length) {
              for (var i2 = arguments[0], r2 = arguments[1], o2 = i2, s2 = this.getNumGeometries(), a2 = o2.getNumGeometries(), u2 = 0; u2 < s2 && u2 < a2; ) {
                var l2 = this.getGeometryN(u2), c2 = o2.getGeometryN(u2), p2 = l2.compareToSameClass(c2, r2);
                if (0 !== p2)
                  return p2;
                u2++;
              }
              return u2 < s2 ? 1 : u2 < a2 ? -1 : 0;
            }
          }, e3.prototype.apply = function() {
            if (T(arguments[0], ft))
              for (var t3 = arguments[0], e4 = 0; e4 < this._geometries.length; e4++)
                this._geometries[e4].apply(t3);
            else if (T(arguments[0], Ut)) {
              var n3 = arguments[0];
              if (0 === this._geometries.length)
                return null;
              for (var i2 = 0; i2 < this._geometries.length && (this._geometries[i2].apply(n3), !n3.isDone()); i2++)
                ;
              n3.isGeometryChanged() && this.geometryChanged();
            } else if (T(arguments[0], Vt)) {
              var r2 = arguments[0];
              r2.filter(this);
              for (var o2 = 0; o2 < this._geometries.length; o2++)
                this._geometries[o2].apply(r2);
            } else if (T(arguments[0], lt)) {
              var s2 = arguments[0];
              s2.filter(this);
              for (var a2 = 0; a2 < this._geometries.length; a2++)
                this._geometries[a2].apply(s2);
            }
          }, e3.prototype.getBoundary = function() {
            return this.checkNotGeometryCollection(this), et.shouldNeverReachHere(), null;
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            e4._geometries = new Array(this._geometries.length).fill(null);
            for (var n3 = 0; n3 < this._geometries.length; n3++)
              e4._geometries[n3] = this._geometries[n3].clone();
            return e4;
          }, e3.prototype.getGeometryType = function() {
            return "GeometryCollection";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.isEmpty = function() {
            for (var t3 = 0; t3 < this._geometries.length; t3++)
              if (!this._geometries[t3].isEmpty())
                return false;
            return true;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -5694727726395021e3;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), Xt = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_MULTILINESTRING;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && t2.prototype.equalsExact.call(this, e4, n3);
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.getBoundaryDimension = function() {
            return this.isClosed() ? qt.FALSE : 0;
          }, e3.prototype.isClosed = function() {
            if (this.isEmpty())
              return false;
            for (var t3 = 0; t3 < this._geometries.length; t3++)
              if (!this._geometries[t3].isClosed())
                return false;
            return true;
          }, e3.prototype.getDimension = function() {
            return 1;
          }, e3.prototype.reverse = function() {
            for (var t3 = this._geometries.length, e4 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
              e4[t3 - 1 - n3] = this._geometries[n3].reverse();
            return this.getFactory().createMultiLineString(e4);
          }, e3.prototype.getBoundary = function() {
            return new Yt(this).getBoundary();
          }, e3.prototype.getGeometryType = function() {
            return "MultiLineString";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [At];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return 8166665132445434e3;
          }, Object.defineProperties(e3, n2), e3;
        }(zt), Yt = function() {
          if (this._geom = null, this._geomFact = null, this._bnRule = null, this._endpointMap = null, 1 === arguments.length) {
            var t2 = arguments[0], e3 = gt.MOD2_BOUNDARY_RULE;
            this._geom = t2, this._geomFact = t2.getFactory(), this._bnRule = e3;
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this._geom = n2, this._geomFact = n2.getFactory(), this._bnRule = i2;
          }
        };
        Yt.prototype.boundaryMultiLineString = function(t2) {
          if (this._geom.isEmpty())
            return this.getEmptyMultiPoint();
          var e3 = this.computeBoundaryCoordinates(t2);
          return 1 === e3.length ? this._geomFact.createPoint(e3[0]) : this._geomFact.createMultiPointFromCoords(e3);
        }, Yt.prototype.getBoundary = function() {
          return this._geom instanceof Kt ? this.boundaryLineString(this._geom) : this._geom instanceof Xt ? this.boundaryMultiLineString(this._geom) : this._geom.getBoundary();
        }, Yt.prototype.boundaryLineString = function(t2) {
          if (this._geom.isEmpty())
            return this.getEmptyMultiPoint();
          if (t2.isClosed()) {
            return this._bnRule.isInBoundary(2) ? t2.getStartPoint() : this._geomFact.createMultiPoint();
          }
          return this._geomFact.createMultiPoint([t2.getStartPoint(), t2.getEndPoint()]);
        }, Yt.prototype.getEmptyMultiPoint = function() {
          return this._geomFact.createMultiPoint();
        }, Yt.prototype.computeBoundaryCoordinates = function(t2) {
          var e3 = new Nt();
          this._endpointMap = new p();
          for (var n2 = 0; n2 < t2.getNumGeometries(); n2++) {
            var i2 = t2.getGeometryN(n2);
            0 !== i2.getNumPoints() && (this.addEndpoint(i2.getCoordinateN(0)), this.addEndpoint(i2.getCoordinateN(i2.getNumPoints() - 1)));
          }
          for (var r2 = this._endpointMap.entrySet().iterator(); r2.hasNext(); ) {
            var o2 = r2.next(), s2 = o2.getValue().count;
            this._bnRule.isInBoundary(s2) && e3.add(o2.getKey());
          }
          return Lt.toCoordinateArray(e3);
        }, Yt.prototype.addEndpoint = function(t2) {
          var e3 = this._endpointMap.get(t2);
          null === e3 && (e3 = new kt(), this._endpointMap.put(t2, e3)), e3.count++;
        }, Yt.prototype.interfaces_ = function() {
          return [];
        }, Yt.prototype.getClass = function() {
          return Yt;
        }, Yt.getBoundary = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new Yt(t2).getBoundary();
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return new Yt(e3, n2).getBoundary();
          }
        };
        var kt = function() {
          this.count = null;
        };
        kt.prototype.interfaces_ = function() {
          return [];
        }, kt.prototype.getClass = function() {
          return kt;
        };
        var jt = function() {
        }, Ht = { NEWLINE: { configurable: true }, SIMPLE_ORDINATE_FORMAT: { configurable: true } };
        jt.prototype.interfaces_ = function() {
          return [];
        }, jt.prototype.getClass = function() {
          return jt;
        }, jt.chars = function(t2, e3) {
          for (var n2 = new Array(e3).fill(null), i2 = 0; i2 < e3; i2++)
            n2[i2] = t2;
          return String(n2);
        }, jt.getStackTrace = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = new function() {
            }(), n2 = new function() {
            }(e3);
            return t2.printStackTrace(n2), e3.toString();
          }
          if (2 === arguments.length) {
            for (var i2 = arguments[0], r2 = arguments[1], o2 = "", s2 = new function() {
            }(new function() {
            }(jt.getStackTrace(i2))), a2 = 0; a2 < r2; a2++)
              try {
                o2 += s2.readLine() + jt.NEWLINE;
              } catch (t3) {
                if (!(t3 instanceof g))
                  throw t3;
                et.shouldNeverReachHere();
              }
            return o2;
          }
        }, jt.split = function(t2, e3) {
          for (var n2 = e3.length, i2 = new Nt(), r2 = "" + t2, o2 = r2.indexOf(e3); o2 >= 0; ) {
            var s2 = r2.substring(0, o2);
            i2.add(s2), o2 = (r2 = r2.substring(o2 + n2)).indexOf(e3);
          }
          r2.length > 0 && i2.add(r2);
          for (var a2 = new Array(i2.size()).fill(null), u2 = 0; u2 < a2.length; u2++)
            a2[u2] = i2.get(u2);
          return a2;
        }, jt.toString = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return jt.SIMPLE_ORDINATE_FORMAT.format(t2);
          }
        }, jt.spaces = function(t2) {
          return jt.chars(" ", t2);
        }, Ht.NEWLINE.get = function() {
          return Y.getProperty("line.separator");
        }, Ht.SIMPLE_ORDINATE_FORMAT.get = function() {
          return new function() {
          }("0.#");
        }, Object.defineProperties(jt, Ht);
        var Wt = function() {
        };
        Wt.prototype.interfaces_ = function() {
          return [];
        }, Wt.prototype.getClass = function() {
          return Wt;
        }, Wt.copyCoord = function(t2, e3, n2, i2) {
          for (var r2 = Math.min(t2.getDimension(), n2.getDimension()), o2 = 0; o2 < r2; o2++)
            n2.setOrdinate(i2, o2, t2.getOrdinate(e3, o2));
        }, Wt.isRing = function(t2) {
          var e3 = t2.size();
          return 0 === e3 || !(e3 <= 3) && (t2.getOrdinate(0, V.X) === t2.getOrdinate(e3 - 1, V.X) && t2.getOrdinate(0, V.Y) === t2.getOrdinate(e3 - 1, V.Y));
        }, Wt.isEqual = function(t2, e3) {
          var n2 = t2.size();
          if (n2 !== e3.size())
            return false;
          for (var i2 = Math.min(t2.getDimension(), e3.getDimension()), r2 = 0; r2 < n2; r2++)
            for (var o2 = 0; o2 < i2; o2++) {
              var s2 = t2.getOrdinate(r2, o2), a2 = e3.getOrdinate(r2, o2);
              if (t2.getOrdinate(r2, o2) !== e3.getOrdinate(r2, o2) && (!v.isNaN(s2) || !v.isNaN(a2)))
                return false;
            }
          return true;
        }, Wt.extend = function(t2, e3, n2) {
          var i2 = t2.create(n2, e3.getDimension()), r2 = e3.size();
          if (Wt.copy(e3, 0, i2, 0, r2), r2 > 0)
            for (var o2 = r2; o2 < n2; o2++)
              Wt.copy(e3, r2 - 1, i2, o2, 1);
          return i2;
        }, Wt.reverse = function(t2) {
          for (var e3 = t2.size() - 1, n2 = Math.trunc(e3 / 2), i2 = 0; i2 <= n2; i2++)
            Wt.swap(t2, i2, e3 - i2);
        }, Wt.swap = function(t2, e3, n2) {
          if (e3 === n2)
            return null;
          for (var i2 = 0; i2 < t2.getDimension(); i2++) {
            var r2 = t2.getOrdinate(e3, i2);
            t2.setOrdinate(e3, i2, t2.getOrdinate(n2, i2)), t2.setOrdinate(n2, i2, r2);
          }
        }, Wt.copy = function(t2, e3, n2, i2, r2) {
          for (var o2 = 0; o2 < r2; o2++)
            Wt.copyCoord(t2, e3 + o2, n2, i2 + o2);
        }, Wt.toString = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = t2.size();
            if (0 === e3)
              return "()";
            var n2 = t2.getDimension(), i2 = new D();
            i2.append("(");
            for (var r2 = 0; r2 < e3; r2++) {
              r2 > 0 && i2.append(" ");
              for (var o2 = 0; o2 < n2; o2++)
                o2 > 0 && i2.append(","), i2.append(jt.toString(t2.getOrdinate(r2, o2)));
            }
            return i2.append(")"), i2.toString();
          }
        }, Wt.ensureValidRing = function(t2, e3) {
          var n2 = e3.size();
          if (0 === n2)
            return e3;
          if (n2 <= 3)
            return Wt.createClosedRing(t2, e3, 4);
          return e3.getOrdinate(0, V.X) === e3.getOrdinate(n2 - 1, V.X) && e3.getOrdinate(0, V.Y) === e3.getOrdinate(n2 - 1, V.Y) ? e3 : Wt.createClosedRing(t2, e3, n2 + 1);
        }, Wt.createClosedRing = function(t2, e3, n2) {
          var i2 = t2.create(n2, e3.getDimension()), r2 = e3.size();
          Wt.copy(e3, 0, i2, 0, r2);
          for (var o2 = r2; o2 < n2; o2++)
            Wt.copy(e3, 0, i2, o2, 1);
          return i2;
        };
        var Kt = function(t2) {
          function e3(e4, n3) {
            t2.call(this, n3), this._points = null, this.init(e4);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            return this.isEmpty() ? new j() : this._points.expandEnvelope(new j());
          }, e3.prototype.isRing = function() {
            return this.isClosed() && this.isSimple();
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_LINESTRING;
          }, e3.prototype.getCoordinates = function() {
            return this._points.toCoordinateArray();
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              if (!this.isEquivalentClass(e4))
                return false;
              var i2 = e4;
              if (this._points.size() !== i2._points.size())
                return false;
              for (var r2 = 0; r2 < this._points.size(); r2++)
                if (!this.equal(this._points.getCoordinate(r2), i2._points.getCoordinate(r2), n3))
                  return false;
              return true;
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
            for (var t3 = 0; t3 < Math.trunc(this._points.size() / 2); t3++) {
              var e4 = this._points.size() - 1 - t3;
              if (!this._points.getCoordinate(t3).equals(this._points.getCoordinate(e4)))
                return this._points.getCoordinate(t3).compareTo(this._points.getCoordinate(e4)) > 0 && Wt.reverse(this._points), null;
            }
          }, e3.prototype.getCoordinate = function() {
            return this.isEmpty() ? null : this._points.getCoordinate(0);
          }, e3.prototype.getBoundaryDimension = function() {
            return this.isClosed() ? qt.FALSE : 0;
          }, e3.prototype.isClosed = function() {
            return !this.isEmpty() && this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1));
          }, e3.prototype.getEndPoint = function() {
            return this.isEmpty() ? null : this.getPointN(this.getNumPoints() - 1);
          }, e3.prototype.getDimension = function() {
            return 1;
          }, e3.prototype.getLength = function() {
            return at.computeLength(this._points);
          }, e3.prototype.getNumPoints = function() {
            return this._points.size();
          }, e3.prototype.reverse = function() {
            var t3 = this._points.copy();
            Wt.reverse(t3);
            return this.getFactory().createLineString(t3);
          }, e3.prototype.compareToSameClass = function() {
            if (1 === arguments.length) {
              for (var t3 = arguments[0], e4 = 0, n3 = 0; e4 < this._points.size() && n3 < t3._points.size(); ) {
                var i2 = this._points.getCoordinate(e4).compareTo(t3._points.getCoordinate(n3));
                if (0 !== i2)
                  return i2;
                e4++, n3++;
              }
              return e4 < this._points.size() ? 1 : n3 < t3._points.size() ? -1 : 0;
            }
            if (2 === arguments.length) {
              var r2 = arguments[0];
              return arguments[1].compare(this._points, r2._points);
            }
          }, e3.prototype.apply = function() {
            if (T(arguments[0], ft))
              for (var t3 = arguments[0], e4 = 0; e4 < this._points.size(); e4++)
                t3.filter(this._points.getCoordinate(e4));
            else if (T(arguments[0], Ut)) {
              var n3 = arguments[0];
              if (0 === this._points.size())
                return null;
              for (var i2 = 0; i2 < this._points.size() && (n3.filter(this._points, i2), !n3.isDone()); i2++)
                ;
              n3.isGeometryChanged() && this.geometryChanged();
            } else if (T(arguments[0], Vt)) {
              arguments[0].filter(this);
            } else if (T(arguments[0], lt)) {
              arguments[0].filter(this);
            }
          }, e3.prototype.getBoundary = function() {
            return new Yt(this).getBoundary();
          }, e3.prototype.isEquivalentClass = function(t3) {
            return t3 instanceof e3;
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            return e4._points = this._points.clone(), e4;
          }, e3.prototype.getCoordinateN = function(t3) {
            return this._points.getCoordinate(t3);
          }, e3.prototype.getGeometryType = function() {
            return "LineString";
          }, e3.prototype.copy = function() {
            return new e3(this._points.copy(), this._factory);
          }, e3.prototype.getCoordinateSequence = function() {
            return this._points;
          }, e3.prototype.isEmpty = function() {
            return 0 === this._points.size();
          }, e3.prototype.init = function(t3) {
            if (null === t3 && (t3 = this.getFactory().getCoordinateSequenceFactory().create([])), 1 === t3.size())
              throw new m("Invalid number of points in LineString (found " + t3.size() + " - must be 0 or >= 2)");
            this._points = t3;
          }, e3.prototype.isCoordinate = function(t3) {
            for (var e4 = 0; e4 < this._points.size(); e4++)
              if (this._points.getCoordinate(e4).equals(t3))
                return true;
            return false;
          }, e3.prototype.getStartPoint = function() {
            return this.isEmpty() ? null : this.getPointN(0);
          }, e3.prototype.getPointN = function(t3) {
            return this.getFactory().createPoint(this._points.getCoordinate(t3));
          }, e3.prototype.interfaces_ = function() {
            return [At];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return 3110669828065365500;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), Jt = function() {
        };
        Jt.prototype.interfaces_ = function() {
          return [];
        }, Jt.prototype.getClass = function() {
          return Jt;
        };
        var Qt = function(t2) {
          function e3(e4, n3) {
            t2.call(this, n3), this._coordinates = e4 || null, this.init(this._coordinates);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            if (this.isEmpty())
              return new j();
            var t3 = new j();
            return t3.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0)), t3;
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_POINT;
          }, e3.prototype.getCoordinates = function() {
            return this.isEmpty() ? [] : [this.getCoordinate()];
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && (!(!this.isEmpty() || !e4.isEmpty()) || this.isEmpty() === e4.isEmpty() && this.equal(e4.getCoordinate(), this.getCoordinate(), n3));
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
          }, e3.prototype.getCoordinate = function() {
            return 0 !== this._coordinates.size() ? this._coordinates.getCoordinate(0) : null;
          }, e3.prototype.getBoundaryDimension = function() {
            return qt.FALSE;
          }, e3.prototype.getDimension = function() {
            return 0;
          }, e3.prototype.getNumPoints = function() {
            return this.isEmpty() ? 0 : 1;
          }, e3.prototype.reverse = function() {
            return this.copy();
          }, e3.prototype.getX = function() {
            if (null === this.getCoordinate())
              throw new Error("getX called on empty Point");
            return this.getCoordinate().x;
          }, e3.prototype.compareToSameClass = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0];
              return this.getCoordinate().compareTo(t3.getCoordinate());
            }
            if (2 === arguments.length) {
              var e4 = arguments[0];
              return arguments[1].compare(this._coordinates, e4._coordinates);
            }
          }, e3.prototype.apply = function() {
            if (T(arguments[0], ft)) {
              var t3 = arguments[0];
              if (this.isEmpty())
                return null;
              t3.filter(this.getCoordinate());
            } else if (T(arguments[0], Ut)) {
              var e4 = arguments[0];
              if (this.isEmpty())
                return null;
              e4.filter(this._coordinates, 0), e4.isGeometryChanged() && this.geometryChanged();
            } else if (T(arguments[0], Vt)) {
              arguments[0].filter(this);
            } else if (T(arguments[0], lt)) {
              arguments[0].filter(this);
            }
          }, e3.prototype.getBoundary = function() {
            return this.getFactory().createGeometryCollection(null);
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            return e4._coordinates = this._coordinates.clone(), e4;
          }, e3.prototype.getGeometryType = function() {
            return "Point";
          }, e3.prototype.copy = function() {
            return new e3(this._coordinates.copy(), this._factory);
          }, e3.prototype.getCoordinateSequence = function() {
            return this._coordinates;
          }, e3.prototype.getY = function() {
            if (null === this.getCoordinate())
              throw new Error("getY called on empty Point");
            return this.getCoordinate().y;
          }, e3.prototype.isEmpty = function() {
            return 0 === this._coordinates.size();
          }, e3.prototype.init = function(t3) {
            null === t3 && (t3 = this.getFactory().getCoordinateSequenceFactory().create([])), et.isTrue(t3.size() <= 1), this._coordinates = t3;
          }, e3.prototype.isSimple = function() {
            return true;
          }, e3.prototype.interfaces_ = function() {
            return [Jt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return 4902022702746615e3;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), Zt = function() {
        };
        Zt.prototype.interfaces_ = function() {
          return [];
        }, Zt.prototype.getClass = function() {
          return Zt;
        };
        var $t = function(t2) {
          function e3(e4, n3, i2) {
            if (t2.call(this, i2), this._shell = null, this._holes = null, null === e4 && (e4 = this.getFactory().createLinearRing()), null === n3 && (n3 = []), t2.hasNullElements(n3))
              throw new m("holes must not contain null elements");
            if (e4.isEmpty() && t2.hasNonEmptyElements(n3))
              throw new m("shell is empty but holes are not");
            this._shell = e4, this._holes = n3;
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.computeEnvelopeInternal = function() {
            return this._shell.getEnvelopeInternal();
          }, e3.prototype.getSortIndex = function() {
            return t2.SORTINDEX_POLYGON;
          }, e3.prototype.getCoordinates = function() {
            if (this.isEmpty())
              return [];
            for (var t3 = new Array(this.getNumPoints()).fill(null), e4 = -1, n3 = this._shell.getCoordinates(), i2 = 0; i2 < n3.length; i2++)
              t3[++e4] = n3[i2];
            for (var r2 = 0; r2 < this._holes.length; r2++)
              for (var o2 = this._holes[r2].getCoordinates(), s2 = 0; s2 < o2.length; s2++)
                t3[++e4] = o2[s2];
            return t3;
          }, e3.prototype.getArea = function() {
            var t3 = 0;
            t3 += Math.abs(at.signedArea(this._shell.getCoordinateSequence()));
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3 -= Math.abs(at.signedArea(this._holes[e4].getCoordinateSequence()));
            return t3;
          }, e3.prototype.isRectangle = function() {
            if (0 !== this.getNumInteriorRing())
              return false;
            if (null === this._shell)
              return false;
            if (5 !== this._shell.getNumPoints())
              return false;
            for (var t3 = this._shell.getCoordinateSequence(), e4 = this.getEnvelopeInternal(), n3 = 0; n3 < 5; n3++) {
              var i2 = t3.getX(n3);
              if (i2 !== e4.getMinX() && i2 !== e4.getMaxX())
                return false;
              var r2 = t3.getY(n3);
              if (r2 !== e4.getMinY() && r2 !== e4.getMaxY())
                return false;
            }
            for (var o2 = t3.getX(0), s2 = t3.getY(0), a2 = 1; a2 <= 4; a2++) {
              var u2 = t3.getX(a2), l2 = t3.getY(a2);
              if (u2 !== o2 === (l2 !== s2))
                return false;
              o2 = u2, s2 = l2;
            }
            return true;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              if (!this.isEquivalentClass(e4))
                return false;
              var i2 = e4, r2 = this._shell, o2 = i2._shell;
              if (!r2.equalsExact(o2, n3))
                return false;
              if (this._holes.length !== i2._holes.length)
                return false;
              for (var s2 = 0; s2 < this._holes.length; s2++)
                if (!this._holes[s2].equalsExact(i2._holes[s2], n3))
                  return false;
              return true;
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.normalize = function() {
            if (0 === arguments.length) {
              this.normalize(this._shell, true);
              for (var t3 = 0; t3 < this._holes.length; t3++)
                this.normalize(this._holes[t3], false);
              Gt.sort(this._holes);
            } else if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              if (e4.isEmpty())
                return null;
              var i2 = new Array(e4.getCoordinates().length - 1).fill(null);
              Y.arraycopy(e4.getCoordinates(), 0, i2, 0, i2.length);
              var r2 = Lt.minCoordinate(e4.getCoordinates());
              Lt.scroll(i2, r2), Y.arraycopy(i2, 0, e4.getCoordinates(), 0, i2.length), e4.getCoordinates()[i2.length] = i2[0], at.isCCW(e4.getCoordinates()) === n3 && Lt.reverse(e4.getCoordinates());
            }
          }, e3.prototype.getCoordinate = function() {
            return this._shell.getCoordinate();
          }, e3.prototype.getNumInteriorRing = function() {
            return this._holes.length;
          }, e3.prototype.getBoundaryDimension = function() {
            return 1;
          }, e3.prototype.getDimension = function() {
            return 2;
          }, e3.prototype.getLength = function() {
            var t3 = 0;
            t3 += this._shell.getLength();
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3 += this._holes[e4].getLength();
            return t3;
          }, e3.prototype.getNumPoints = function() {
            for (var t3 = this._shell.getNumPoints(), e4 = 0; e4 < this._holes.length; e4++)
              t3 += this._holes[e4].getNumPoints();
            return t3;
          }, e3.prototype.reverse = function() {
            var t3 = this.copy();
            t3._shell = this._shell.copy().reverse(), t3._holes = new Array(this._holes.length).fill(null);
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3._holes[e4] = this._holes[e4].copy().reverse();
            return t3;
          }, e3.prototype.convexHull = function() {
            return this.getExteriorRing().convexHull();
          }, e3.prototype.compareToSameClass = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0], e4 = this._shell, n3 = t3._shell;
              return e4.compareToSameClass(n3);
            }
            if (2 === arguments.length) {
              var i2 = arguments[0], r2 = arguments[1], o2 = i2, s2 = this._shell, a2 = o2._shell, u2 = s2.compareToSameClass(a2, r2);
              if (0 !== u2)
                return u2;
              for (var l2 = this.getNumInteriorRing(), c2 = o2.getNumInteriorRing(), p2 = 0; p2 < l2 && p2 < c2; ) {
                var h2 = this.getInteriorRingN(p2), f2 = o2.getInteriorRingN(p2), g2 = h2.compareToSameClass(f2, r2);
                if (0 !== g2)
                  return g2;
                p2++;
              }
              return p2 < l2 ? 1 : p2 < c2 ? -1 : 0;
            }
          }, e3.prototype.apply = function(t3) {
            if (T(t3, ft)) {
              this._shell.apply(t3);
              for (var e4 = 0; e4 < this._holes.length; e4++)
                this._holes[e4].apply(t3);
            } else if (T(t3, Ut)) {
              if (this._shell.apply(t3), !t3.isDone())
                for (var n3 = 0; n3 < this._holes.length && (this._holes[n3].apply(t3), !t3.isDone()); n3++)
                  ;
              t3.isGeometryChanged() && this.geometryChanged();
            } else if (T(t3, Vt))
              t3.filter(this);
            else if (T(t3, lt)) {
              t3.filter(this), this._shell.apply(t3);
              for (var i2 = 0; i2 < this._holes.length; i2++)
                this._holes[i2].apply(t3);
            }
          }, e3.prototype.getBoundary = function() {
            if (this.isEmpty())
              return this.getFactory().createMultiLineString();
            var t3 = new Array(this._holes.length + 1).fill(null);
            t3[0] = this._shell;
            for (var e4 = 0; e4 < this._holes.length; e4++)
              t3[e4 + 1] = this._holes[e4];
            return t3.length <= 1 ? this.getFactory().createLinearRing(t3[0].getCoordinateSequence()) : this.getFactory().createMultiLineString(t3);
          }, e3.prototype.clone = function() {
            var e4 = t2.prototype.clone.call(this);
            e4._shell = this._shell.clone(), e4._holes = new Array(this._holes.length).fill(null);
            for (var n3 = 0; n3 < this._holes.length; n3++)
              e4._holes[n3] = this._holes[n3].clone();
            return e4;
          }, e3.prototype.getGeometryType = function() {
            return "Polygon";
          }, e3.prototype.copy = function() {
            for (var t3 = this._shell.copy(), n3 = new Array(this._holes.length).fill(null), i2 = 0; i2 < n3.length; i2++)
              n3[i2] = this._holes[i2].copy();
            return new e3(t3, n3, this._factory);
          }, e3.prototype.getExteriorRing = function() {
            return this._shell;
          }, e3.prototype.isEmpty = function() {
            return this._shell.isEmpty();
          }, e3.prototype.getInteriorRingN = function(t3) {
            return this._holes[t3];
          }, e3.prototype.interfaces_ = function() {
            return [Zt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -3494792200821764600;
          }, Object.defineProperties(e3, n2), e3;
        }(ct), te = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_MULTIPOINT;
          }, e3.prototype.isValid = function() {
            return true;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && t2.prototype.equalsExact.call(this, e4, n3);
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.getCoordinate = function() {
            if (1 === arguments.length) {
              var e4 = arguments[0];
              return this._geometries[e4].getCoordinate();
            }
            return t2.prototype.getCoordinate.apply(this, arguments);
          }, e3.prototype.getBoundaryDimension = function() {
            return qt.FALSE;
          }, e3.prototype.getDimension = function() {
            return 0;
          }, e3.prototype.getBoundary = function() {
            return this.getFactory().createGeometryCollection(null);
          }, e3.prototype.getGeometryType = function() {
            return "MultiPoint";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [Jt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -8048474874175356e3;
          }, Object.defineProperties(e3, n2), e3;
        }(zt), ee = function(t2) {
          function e3(e4, n3) {
            e4 instanceof C && n3 instanceof _e && (e4 = n3.getCoordinateSequenceFactory().create(e4)), t2.call(this, e4, n3), this.validateConstruction();
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { MINIMUM_VALID_SIZE: { configurable: true }, serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_LINEARRING;
          }, e3.prototype.getBoundaryDimension = function() {
            return qt.FALSE;
          }, e3.prototype.isClosed = function() {
            return !!this.isEmpty() || t2.prototype.isClosed.call(this);
          }, e3.prototype.reverse = function() {
            var t3 = this._points.copy();
            Wt.reverse(t3);
            return this.getFactory().createLinearRing(t3);
          }, e3.prototype.validateConstruction = function() {
            if (!this.isEmpty() && !t2.prototype.isClosed.call(this))
              throw new m("Points of LinearRing do not form a closed linestring");
            if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < e3.MINIMUM_VALID_SIZE)
              throw new m("Invalid number of points in LinearRing (found " + this.getCoordinateSequence().size() + " - must be 0 or >= 4)");
          }, e3.prototype.getGeometryType = function() {
            return "LinearRing";
          }, e3.prototype.copy = function() {
            return new e3(this._points.copy(), this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.MINIMUM_VALID_SIZE.get = function() {
            return 4;
          }, n2.serialVersionUID.get = function() {
            return -4261142084085851600;
          }, Object.defineProperties(e3, n2), e3;
        }(Kt), ne = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { serialVersionUID: { configurable: true } };
          return e3.prototype.getSortIndex = function() {
            return ct.SORTINDEX_MULTIPOLYGON;
          }, e3.prototype.equalsExact = function() {
            if (2 === arguments.length) {
              var e4 = arguments[0], n3 = arguments[1];
              return !!this.isEquivalentClass(e4) && t2.prototype.equalsExact.call(this, e4, n3);
            }
            return t2.prototype.equalsExact.apply(this, arguments);
          }, e3.prototype.getBoundaryDimension = function() {
            return 1;
          }, e3.prototype.getDimension = function() {
            return 2;
          }, e3.prototype.reverse = function() {
            for (var t3 = this._geometries.length, e4 = new Array(t3).fill(null), n3 = 0; n3 < this._geometries.length; n3++)
              e4[n3] = this._geometries[n3].reverse();
            return this.getFactory().createMultiPolygon(e4);
          }, e3.prototype.getBoundary = function() {
            if (this.isEmpty())
              return this.getFactory().createMultiLineString();
            for (var t3 = new Nt(), e4 = 0; e4 < this._geometries.length; e4++)
              for (var n3 = this._geometries[e4].getBoundary(), i2 = 0; i2 < n3.getNumGeometries(); i2++)
                t3.add(n3.getGeometryN(i2));
            var r2 = new Array(t3.size()).fill(null);
            return this.getFactory().createMultiLineString(t3.toArray(r2));
          }, e3.prototype.getGeometryType = function() {
            return "MultiPolygon";
          }, e3.prototype.copy = function() {
            for (var t3 = new Array(this._geometries.length).fill(null), n3 = 0; n3 < t3.length; n3++)
              t3[n3] = this._geometries[n3].copy();
            return new e3(t3, this._factory);
          }, e3.prototype.interfaces_ = function() {
            return [Zt];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.serialVersionUID.get = function() {
            return -551033529766975900;
          }, Object.defineProperties(e3, n2), e3;
        }(zt), ie = function(t2) {
          this._factory = t2 || null, this._isUserDataCopied = false;
        }, re = { NoOpGeometryOperation: { configurable: true }, CoordinateOperation: { configurable: true }, CoordinateSequenceOperation: { configurable: true } };
        ie.prototype.setCopyUserData = function(t2) {
          this._isUserDataCopied = t2;
        }, ie.prototype.edit = function(t2, e3) {
          if (null === t2)
            return null;
          var n2 = this.editInternal(t2, e3);
          return this._isUserDataCopied && n2.setUserData(t2.getUserData()), n2;
        }, ie.prototype.editInternal = function(t2, e3) {
          return null === this._factory && (this._factory = t2.getFactory()), t2 instanceof zt ? this.editGeometryCollection(t2, e3) : t2 instanceof $t ? this.editPolygon(t2, e3) : t2 instanceof Qt ? e3.edit(t2, this._factory) : t2 instanceof Kt ? e3.edit(t2, this._factory) : (et.shouldNeverReachHere("Unsupported Geometry class: " + t2.getClass().getName()), null);
        }, ie.prototype.editGeometryCollection = function(t2, e3) {
          for (var n2 = e3.edit(t2, this._factory), i2 = new Nt(), r2 = 0; r2 < n2.getNumGeometries(); r2++) {
            var o2 = this.edit(n2.getGeometryN(r2), e3);
            null === o2 || o2.isEmpty() || i2.add(o2);
          }
          return n2.getClass() === te ? this._factory.createMultiPoint(i2.toArray([])) : n2.getClass() === Xt ? this._factory.createMultiLineString(i2.toArray([])) : n2.getClass() === ne ? this._factory.createMultiPolygon(i2.toArray([])) : this._factory.createGeometryCollection(i2.toArray([]));
        }, ie.prototype.editPolygon = function(t2, e3) {
          var n2 = e3.edit(t2, this._factory);
          if (null === n2 && (n2 = this._factory.createPolygon(null)), n2.isEmpty())
            return n2;
          var i2 = this.edit(n2.getExteriorRing(), e3);
          if (null === i2 || i2.isEmpty())
            return this._factory.createPolygon();
          for (var r2 = new Nt(), o2 = 0; o2 < n2.getNumInteriorRing(); o2++) {
            var s2 = this.edit(n2.getInteriorRingN(o2), e3);
            null === s2 || s2.isEmpty() || r2.add(s2);
          }
          return this._factory.createPolygon(i2, r2.toArray([]));
        }, ie.prototype.interfaces_ = function() {
          return [];
        }, ie.prototype.getClass = function() {
          return ie;
        }, ie.GeometryEditorOperation = function() {
        }, re.NoOpGeometryOperation.get = function() {
          return oe;
        }, re.CoordinateOperation.get = function() {
          return se;
        }, re.CoordinateSequenceOperation.get = function() {
          return ae;
        }, Object.defineProperties(ie, re);
        var oe = function() {
        };
        oe.prototype.edit = function(t2, e3) {
          return t2;
        }, oe.prototype.interfaces_ = function() {
          return [ie.GeometryEditorOperation];
        }, oe.prototype.getClass = function() {
          return oe;
        };
        var se = function() {
        };
        se.prototype.edit = function(t2, e3) {
          var n2 = this.editCoordinates(t2.getCoordinates(), t2);
          return null === n2 ? t2 : t2 instanceof ee ? e3.createLinearRing(n2) : t2 instanceof Kt ? e3.createLineString(n2) : t2 instanceof Qt ? n2.length > 0 ? e3.createPoint(n2[0]) : e3.createPoint() : t2;
        }, se.prototype.interfaces_ = function() {
          return [ie.GeometryEditorOperation];
        }, se.prototype.getClass = function() {
          return se;
        };
        var ae = function() {
        };
        ae.prototype.edit = function(t2, e3) {
          return t2 instanceof ee ? e3.createLinearRing(this.edit(t2.getCoordinateSequence(), t2)) : t2 instanceof Kt ? e3.createLineString(this.edit(t2.getCoordinateSequence(), t2)) : t2 instanceof Qt ? e3.createPoint(this.edit(t2.getCoordinateSequence(), t2)) : t2;
        }, ae.prototype.interfaces_ = function() {
          return [ie.GeometryEditorOperation];
        }, ae.prototype.getClass = function() {
          return ae;
        };
        var ue = function() {
          if (this._dimension = 3, this._coordinates = null, 1 === arguments.length) {
            if (arguments[0] instanceof Array)
              this._coordinates = arguments[0], this._dimension = 3;
            else if (Number.isInteger(arguments[0])) {
              var t2 = arguments[0];
              this._coordinates = new Array(t2).fill(null);
              for (var e3 = 0; e3 < t2; e3++)
                this._coordinates[e3] = new C();
            } else if (T(arguments[0], V)) {
              var n2 = arguments[0];
              if (null === n2)
                return this._coordinates = new Array(0).fill(null), null;
              this._dimension = n2.getDimension(), this._coordinates = new Array(n2.size()).fill(null);
              for (var i2 = 0; i2 < this._coordinates.length; i2++)
                this._coordinates[i2] = n2.getCoordinateCopy(i2);
            }
          } else if (2 === arguments.length) {
            if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {
              var r2 = arguments[0], o2 = arguments[1];
              this._coordinates = r2, this._dimension = o2, null === r2 && (this._coordinates = new Array(0).fill(null));
            } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {
              var s2 = arguments[0], a2 = arguments[1];
              this._coordinates = new Array(s2).fill(null), this._dimension = a2;
              for (var u2 = 0; u2 < s2; u2++)
                this._coordinates[u2] = new C();
            }
          }
        }, le = { serialVersionUID: { configurable: true } };
        ue.prototype.setOrdinate = function(t2, e3, n2) {
          switch (e3) {
            case V.X:
              this._coordinates[t2].x = n2;
              break;
            case V.Y:
              this._coordinates[t2].y = n2;
              break;
            case V.Z:
              this._coordinates[t2].z = n2;
              break;
            default:
              throw new m("invalid ordinateIndex");
          }
        }, ue.prototype.size = function() {
          return this._coordinates.length;
        }, ue.prototype.getOrdinate = function(t2, e3) {
          switch (e3) {
            case V.X:
              return this._coordinates[t2].x;
            case V.Y:
              return this._coordinates[t2].y;
            case V.Z:
              return this._coordinates[t2].z;
          }
          return v.NaN;
        }, ue.prototype.getCoordinate = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this._coordinates[t2];
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            n2.x = this._coordinates[e3].x, n2.y = this._coordinates[e3].y, n2.z = this._coordinates[e3].z;
          }
        }, ue.prototype.getCoordinateCopy = function(t2) {
          return new C(this._coordinates[t2]);
        }, ue.prototype.getDimension = function() {
          return this._dimension;
        }, ue.prototype.getX = function(t2) {
          return this._coordinates[t2].x;
        }, ue.prototype.clone = function() {
          for (var t2 = new Array(this.size()).fill(null), e3 = 0; e3 < this._coordinates.length; e3++)
            t2[e3] = this._coordinates[e3].clone();
          return new ue(t2, this._dimension);
        }, ue.prototype.expandEnvelope = function(t2) {
          for (var e3 = 0; e3 < this._coordinates.length; e3++)
            t2.expandToInclude(this._coordinates[e3]);
          return t2;
        }, ue.prototype.copy = function() {
          for (var t2 = new Array(this.size()).fill(null), e3 = 0; e3 < this._coordinates.length; e3++)
            t2[e3] = this._coordinates[e3].copy();
          return new ue(t2, this._dimension);
        }, ue.prototype.toString = function() {
          if (this._coordinates.length > 0) {
            var t2 = new D(17 * this._coordinates.length);
            t2.append("("), t2.append(this._coordinates[0]);
            for (var e3 = 1; e3 < this._coordinates.length; e3++)
              t2.append(", "), t2.append(this._coordinates[e3]);
            return t2.append(")"), t2.toString();
          }
          return "()";
        }, ue.prototype.getY = function(t2) {
          return this._coordinates[t2].y;
        }, ue.prototype.toCoordinateArray = function() {
          return this._coordinates;
        }, ue.prototype.interfaces_ = function() {
          return [V, e];
        }, ue.prototype.getClass = function() {
          return ue;
        }, le.serialVersionUID.get = function() {
          return -915438501601840600;
        }, Object.defineProperties(ue, le);
        var ce = function() {
        }, pe = { serialVersionUID: { configurable: true }, instanceObject: { configurable: true } };
        ce.prototype.readResolve = function() {
          return ce.instance();
        }, ce.prototype.create = function() {
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return new ue(t2);
            }
            if (T(arguments[0], V)) {
              var e3 = arguments[0];
              return new ue(e3);
            }
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            return i2 > 3 && (i2 = 3), i2 < 2 ? new ue(n2) : new ue(n2, i2);
          }
        }, ce.prototype.interfaces_ = function() {
          return [b, e];
        }, ce.prototype.getClass = function() {
          return ce;
        }, ce.instance = function() {
          return ce.instanceObject;
        }, pe.serialVersionUID.get = function() {
          return -4099577099607551500;
        }, pe.instanceObject.get = function() {
          return new ce();
        }, Object.defineProperties(ce, pe);
        var he = function(t2) {
          function e3() {
            t2.call(this), this.map_ = /* @__PURE__ */ new Map();
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.get = function(t3) {
            return this.map_.get(t3) || null;
          }, e3.prototype.put = function(t3, e4) {
            return this.map_.set(t3, e4), e4;
          }, e3.prototype.values = function() {
            for (var t3 = new Nt(), e4 = this.map_.values(), n2 = e4.next(); !n2.done; )
              t3.add(n2.value), n2 = e4.next();
            return t3;
          }, e3.prototype.entrySet = function() {
            var t3 = new Pt();
            return this.map_.entries().forEach(function(e4) {
              return t3.add(e4);
            }), t3;
          }, e3.prototype.size = function() {
            return this.map_.size();
          }, e3;
        }(Tt), fe = function t2() {
          if (this._modelType = null, this._scale = null, 0 === arguments.length)
            this._modelType = t2.FLOATING;
          else if (1 === arguments.length) {
            if (arguments[0] instanceof de) {
              var e3 = arguments[0];
              this._modelType = e3, e3 === t2.FIXED && this.setScale(1);
            } else if ("number" == typeof arguments[0]) {
              var n2 = arguments[0];
              this._modelType = t2.FIXED, this.setScale(n2);
            } else if (arguments[0] instanceof t2) {
              var i2 = arguments[0];
              this._modelType = i2._modelType, this._scale = i2._scale;
            }
          }
        }, ge = { serialVersionUID: { configurable: true }, maximumPreciseValue: { configurable: true } };
        fe.prototype.equals = function(t2) {
          if (!(t2 instanceof fe))
            return false;
          var e3 = t2;
          return this._modelType === e3._modelType && this._scale === e3._scale;
        }, fe.prototype.compareTo = function(t2) {
          var e3 = t2, n2 = this.getMaximumSignificantDigits(), i2 = e3.getMaximumSignificantDigits();
          return new M(n2).compareTo(new M(i2));
        }, fe.prototype.getScale = function() {
          return this._scale;
        }, fe.prototype.isFloating = function() {
          return this._modelType === fe.FLOATING || this._modelType === fe.FLOATING_SINGLE;
        }, fe.prototype.getType = function() {
          return this._modelType;
        }, fe.prototype.toString = function() {
          var t2 = "UNKNOWN";
          return this._modelType === fe.FLOATING ? t2 = "Floating" : this._modelType === fe.FLOATING_SINGLE ? t2 = "Floating-Single" : this._modelType === fe.FIXED && (t2 = "Fixed (Scale=" + this.getScale() + ")"), t2;
        }, fe.prototype.makePrecise = function() {
          if ("number" == typeof arguments[0]) {
            var t2 = arguments[0];
            if (v.isNaN(t2))
              return t2;
            if (this._modelType === fe.FLOATING_SINGLE) {
              return t2;
            }
            return this._modelType === fe.FIXED ? Math.round(t2 * this._scale) / this._scale : t2;
          }
          if (arguments[0] instanceof C) {
            var e3 = arguments[0];
            if (this._modelType === fe.FLOATING)
              return null;
            e3.x = this.makePrecise(e3.x), e3.y = this.makePrecise(e3.y);
          }
        }, fe.prototype.getMaximumSignificantDigits = function() {
          var t2 = 16;
          return this._modelType === fe.FLOATING ? t2 = 16 : this._modelType === fe.FLOATING_SINGLE ? t2 = 6 : this._modelType === fe.FIXED && (t2 = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)))), t2;
        }, fe.prototype.setScale = function(t2) {
          this._scale = Math.abs(t2);
        }, fe.prototype.interfaces_ = function() {
          return [e, E];
        }, fe.prototype.getClass = function() {
          return fe;
        }, fe.mostPrecise = function(t2, e3) {
          return t2.compareTo(e3) >= 0 ? t2 : e3;
        }, ge.serialVersionUID.get = function() {
          return 7777263578777804e3;
        }, ge.maximumPreciseValue.get = function() {
          return 9007199254740992;
        }, Object.defineProperties(fe, ge);
        var de = function t2(e3) {
          this._name = e3 || null, t2.nameToTypeMap.put(e3, this);
        }, ye = { serialVersionUID: { configurable: true }, nameToTypeMap: { configurable: true } };
        de.prototype.readResolve = function() {
          return de.nameToTypeMap.get(this._name);
        }, de.prototype.toString = function() {
          return this._name;
        }, de.prototype.interfaces_ = function() {
          return [e];
        }, de.prototype.getClass = function() {
          return de;
        }, ye.serialVersionUID.get = function() {
          return -552860263173159e4;
        }, ye.nameToTypeMap.get = function() {
          return new he();
        }, Object.defineProperties(de, ye), fe.Type = de, fe.FIXED = new de("FIXED"), fe.FLOATING = new de("FLOATING"), fe.FLOATING_SINGLE = new de("FLOATING SINGLE");
        var _e = function t2() {
          this._precisionModel = new fe(), this._SRID = 0, this._coordinateSequenceFactory = t2.getDefaultCoordinateSequenceFactory(), 0 === arguments.length || (1 === arguments.length ? T(arguments[0], b) ? this._coordinateSequenceFactory = arguments[0] : arguments[0] instanceof fe && (this._precisionModel = arguments[0]) : 2 === arguments.length ? (this._precisionModel = arguments[0], this._SRID = arguments[1]) : 3 === arguments.length && (this._precisionModel = arguments[0], this._SRID = arguments[1], this._coordinateSequenceFactory = arguments[2]));
        }, me = { serialVersionUID: { configurable: true } };
        _e.prototype.toGeometry = function(t2) {
          return t2.isNull() ? this.createPoint(null) : t2.getMinX() === t2.getMaxX() && t2.getMinY() === t2.getMaxY() ? this.createPoint(new C(t2.getMinX(), t2.getMinY())) : t2.getMinX() === t2.getMaxX() || t2.getMinY() === t2.getMaxY() ? this.createLineString([new C(t2.getMinX(), t2.getMinY()), new C(t2.getMaxX(), t2.getMaxY())]) : this.createPolygon(this.createLinearRing([new C(t2.getMinX(), t2.getMinY()), new C(t2.getMinX(), t2.getMaxY()), new C(t2.getMaxX(), t2.getMaxY()), new C(t2.getMaxX(), t2.getMinY()), new C(t2.getMinX(), t2.getMinY())]), null);
        }, _e.prototype.createLineString = function(t2) {
          return t2 ? t2 instanceof Array ? new Kt(this.getCoordinateSequenceFactory().create(t2), this) : T(t2, V) ? new Kt(t2, this) : void 0 : new Kt(this.getCoordinateSequenceFactory().create([]), this);
        }, _e.prototype.createMultiLineString = function() {
          if (0 === arguments.length)
            return new Xt(null, this);
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new Xt(t2, this);
          }
        }, _e.prototype.buildGeometry = function(t2) {
          for (var e3 = null, n2 = false, i2 = false, r2 = t2.iterator(); r2.hasNext(); ) {
            var o2 = r2.next(), s2 = o2.getClass();
            null === e3 && (e3 = s2), s2 !== e3 && (n2 = true), o2.isGeometryCollectionOrDerived() && (i2 = true);
          }
          if (null === e3)
            return this.createGeometryCollection();
          if (n2 || i2)
            return this.createGeometryCollection(_e.toGeometryArray(t2));
          var a2 = t2.iterator().next();
          if (t2.size() > 1) {
            if (a2 instanceof $t)
              return this.createMultiPolygon(_e.toPolygonArray(t2));
            if (a2 instanceof Kt)
              return this.createMultiLineString(_e.toLineStringArray(t2));
            if (a2 instanceof Qt)
              return this.createMultiPoint(_e.toPointArray(t2));
            et.shouldNeverReachHere("Unhandled class: " + a2.getClass().getName());
          }
          return a2;
        }, _e.prototype.createMultiPointFromCoords = function(t2) {
          return this.createMultiPoint(null !== t2 ? this.getCoordinateSequenceFactory().create(t2) : null);
        }, _e.prototype.createPoint = function() {
          if (0 === arguments.length)
            return this.createPoint(this.getCoordinateSequenceFactory().create([]));
          if (1 === arguments.length) {
            if (arguments[0] instanceof C) {
              var t2 = arguments[0];
              return this.createPoint(null !== t2 ? this.getCoordinateSequenceFactory().create([t2]) : null);
            }
            if (T(arguments[0], V)) {
              var e3 = arguments[0];
              return new Qt(e3, this);
            }
          }
        }, _e.prototype.getCoordinateSequenceFactory = function() {
          return this._coordinateSequenceFactory;
        }, _e.prototype.createPolygon = function() {
          if (0 === arguments.length)
            return new $t(null, null, this);
          if (1 === arguments.length) {
            if (T(arguments[0], V)) {
              var t2 = arguments[0];
              return this.createPolygon(this.createLinearRing(t2));
            }
            if (arguments[0] instanceof Array) {
              var e3 = arguments[0];
              return this.createPolygon(this.createLinearRing(e3));
            }
            if (arguments[0] instanceof ee) {
              var n2 = arguments[0];
              return this.createPolygon(n2, null);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            return new $t(i2, r2, this);
          }
        }, _e.prototype.getSRID = function() {
          return this._SRID;
        }, _e.prototype.createGeometryCollection = function() {
          if (0 === arguments.length)
            return new zt(null, this);
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new zt(t2, this);
          }
        }, _e.prototype.createGeometry = function(t2) {
          return new ie(this).edit(t2, { edit: function() {
            if (2 === arguments.length) {
              var t3 = arguments[0];
              return this._coordinateSequenceFactory.create(t3);
            }
          } });
        }, _e.prototype.getPrecisionModel = function() {
          return this._precisionModel;
        }, _e.prototype.createLinearRing = function() {
          if (0 === arguments.length)
            return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return this.createLinearRing(null !== t2 ? this.getCoordinateSequenceFactory().create(t2) : null);
            }
            if (T(arguments[0], V)) {
              var e3 = arguments[0];
              return new ee(e3, this);
            }
          }
        }, _e.prototype.createMultiPolygon = function() {
          if (0 === arguments.length)
            return new ne(null, this);
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new ne(t2, this);
          }
        }, _e.prototype.createMultiPoint = function() {
          if (0 === arguments.length)
            return new te(null, this);
          if (1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var t2 = arguments[0];
              return new te(t2, this);
            }
            if (arguments[0] instanceof Array) {
              var e3 = arguments[0];
              return this.createMultiPoint(null !== e3 ? this.getCoordinateSequenceFactory().create(e3) : null);
            }
            if (T(arguments[0], V)) {
              var n2 = arguments[0];
              if (null === n2)
                return this.createMultiPoint(new Array(0).fill(null));
              for (var i2 = new Array(n2.size()).fill(null), r2 = 0; r2 < n2.size(); r2++) {
                var o2 = this.getCoordinateSequenceFactory().create(1, n2.getDimension());
                Wt.copy(n2, r2, o2, 0, 1), i2[r2] = this.createPoint(o2);
              }
              return this.createMultiPoint(i2);
            }
          }
        }, _e.prototype.interfaces_ = function() {
          return [e];
        }, _e.prototype.getClass = function() {
          return _e;
        }, _e.toMultiPolygonArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toGeometryArray = function(t2) {
          if (null === t2)
            return null;
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.getDefaultCoordinateSequenceFactory = function() {
          return ce.instance();
        }, _e.toMultiLineStringArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toLineStringArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toMultiPointArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toLinearRingArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toPointArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.toPolygonArray = function(t2) {
          var e3 = new Array(t2.size()).fill(null);
          return t2.toArray(e3);
        }, _e.createPointFromInternalCoord = function(t2, e3) {
          return e3.getPrecisionModel().makePrecise(t2), e3.getFactory().createPoint(t2);
        }, me.serialVersionUID.get = function() {
          return -6820524753094096e3;
        }, Object.defineProperties(_e, me);
        var ve = ["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon"], Ie = function(t2) {
          this.geometryFactory = t2 || new _e();
        };
        Ie.prototype.read = function(t2) {
          var e3, n2 = (e3 = "string" == typeof t2 ? JSON.parse(t2) : t2).type;
          if (!Ee[n2])
            throw new Error("Unknown GeoJSON type: " + e3.type);
          return -1 !== ve.indexOf(n2) ? Ee[n2].apply(this, [e3.coordinates]) : "GeometryCollection" === n2 ? Ee[n2].apply(this, [e3.geometries]) : Ee[n2].apply(this, [e3]);
        }, Ie.prototype.write = function(t2) {
          var e3 = t2.getGeometryType();
          if (!xe[e3])
            throw new Error("Geometry is not supported");
          return xe[e3].apply(this, [t2]);
        };
        var Ee = { Feature: function(t2) {
          var e3 = {};
          for (var n2 in t2)
            e3[n2] = t2[n2];
          if (t2.geometry) {
            var i2 = t2.geometry.type;
            if (!Ee[i2])
              throw new Error("Unknown GeoJSON type: " + t2.type);
            e3.geometry = this.read(t2.geometry);
          }
          return t2.bbox && (e3.bbox = Ee.bbox.apply(this, [t2.bbox])), e3;
        }, FeatureCollection: function(t2) {
          var e3 = {};
          if (t2.features) {
            e3.features = [];
            for (var n2 = 0; n2 < t2.features.length; ++n2)
              e3.features.push(this.read(t2.features[n2]));
          }
          return t2.bbox && (e3.bbox = this.parse.bbox.apply(this, [t2.bbox])), e3;
        }, coordinates: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
            var i2 = t2[n2];
            e3.push(new C(i2[0], i2[1]));
          }
          return e3;
        }, bbox: function(t2) {
          return this.geometryFactory.createLinearRing([new C(t2[0], t2[1]), new C(t2[2], t2[1]), new C(t2[2], t2[3]), new C(t2[0], t2[3]), new C(t2[0], t2[1])]);
        }, Point: function(t2) {
          var e3 = new C(t2[0], t2[1]);
          return this.geometryFactory.createPoint(e3);
        }, MultiPoint: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2)
            e3.push(Ee.Point.apply(this, [t2[n2]]));
          return this.geometryFactory.createMultiPoint(e3);
        }, LineString: function(t2) {
          var e3 = Ee.coordinates.apply(this, [t2]);
          return this.geometryFactory.createLineString(e3);
        }, MultiLineString: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2)
            e3.push(Ee.LineString.apply(this, [t2[n2]]));
          return this.geometryFactory.createMultiLineString(e3);
        }, Polygon: function(t2) {
          for (var e3 = Ee.coordinates.apply(this, [t2[0]]), n2 = this.geometryFactory.createLinearRing(e3), i2 = [], r2 = 1; r2 < t2.length; ++r2) {
            var o2 = t2[r2], s2 = Ee.coordinates.apply(this, [o2]), a2 = this.geometryFactory.createLinearRing(s2);
            i2.push(a2);
          }
          return this.geometryFactory.createPolygon(n2, i2);
        }, MultiPolygon: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
            var i2 = t2[n2];
            e3.push(Ee.Polygon.apply(this, [i2]));
          }
          return this.geometryFactory.createMultiPolygon(e3);
        }, GeometryCollection: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2.length; ++n2) {
            var i2 = t2[n2];
            e3.push(this.read(i2));
          }
          return this.geometryFactory.createGeometryCollection(e3);
        } }, xe = { coordinate: function(t2) {
          return [t2.x, t2.y];
        }, Point: function(t2) {
          return { type: "Point", coordinates: xe.coordinate.apply(this, [t2.getCoordinate()]) };
        }, MultiPoint: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = xe.Point.apply(this, [i2]);
            e3.push(r2.coordinates);
          }
          return { type: "MultiPoint", coordinates: e3 };
        }, LineString: function(t2) {
          for (var e3 = [], n2 = t2.getCoordinates(), i2 = 0; i2 < n2.length; ++i2) {
            var r2 = n2[i2];
            e3.push(xe.coordinate.apply(this, [r2]));
          }
          return { type: "LineString", coordinates: e3 };
        }, MultiLineString: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = xe.LineString.apply(this, [i2]);
            e3.push(r2.coordinates);
          }
          return { type: "MultiLineString", coordinates: e3 };
        }, Polygon: function(t2) {
          var e3 = [], n2 = xe.LineString.apply(this, [t2._shell]);
          e3.push(n2.coordinates);
          for (var i2 = 0; i2 < t2._holes.length; ++i2) {
            var r2 = t2._holes[i2], o2 = xe.LineString.apply(this, [r2]);
            e3.push(o2.coordinates);
          }
          return { type: "Polygon", coordinates: e3 };
        }, MultiPolygon: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = xe.Polygon.apply(this, [i2]);
            e3.push(r2.coordinates);
          }
          return { type: "MultiPolygon", coordinates: e3 };
        }, GeometryCollection: function(t2) {
          for (var e3 = [], n2 = 0; n2 < t2._geometries.length; ++n2) {
            var i2 = t2._geometries[n2], r2 = i2.getGeometryType();
            e3.push(xe[r2].apply(this, [i2]));
          }
          return { type: "GeometryCollection", geometries: e3 };
        } }, Ne = function(t2) {
          this.geometryFactory = t2 || new _e(), this.precisionModel = this.geometryFactory.getPrecisionModel(), this.parser = new Ie(this.geometryFactory);
        };
        Ne.prototype.read = function(t2) {
          var e3 = this.parser.read(t2);
          return this.precisionModel.getType() === fe.FIXED && this.reducePrecision(e3), e3;
        }, Ne.prototype.reducePrecision = function(t2) {
          var e3, n2;
          if (t2.coordinate)
            this.precisionModel.makePrecise(t2.coordinate);
          else if (t2.points)
            for (e3 = 0, n2 = t2.points.length; e3 < n2; e3++)
              this.precisionModel.makePrecise(t2.points[e3]);
          else if (t2.geometries)
            for (e3 = 0, n2 = t2.geometries.length; e3 < n2; e3++)
              this.reducePrecision(t2.geometries[e3]);
        };
        var Ce = function() {
          this.parser = new Ie(this.geometryFactory);
        };
        Ce.prototype.write = function(t2) {
          return this.parser.write(t2);
        };
        var Se = function() {
        }, Le = { ON: { configurable: true }, LEFT: { configurable: true }, RIGHT: { configurable: true } };
        Se.prototype.interfaces_ = function() {
          return [];
        }, Se.prototype.getClass = function() {
          return Se;
        }, Se.opposite = function(t2) {
          return t2 === Se.LEFT ? Se.RIGHT : t2 === Se.RIGHT ? Se.LEFT : t2;
        }, Le.ON.get = function() {
          return 0;
        }, Le.LEFT.get = function() {
          return 1;
        }, Le.RIGHT.get = function() {
          return 2;
        }, Object.defineProperties(Se, Le), (d.prototype = new Error()).name = "EmptyStackException", (y2.prototype = new xt()).add = function(t2) {
          return this.array_.push(t2), true;
        }, y2.prototype.get = function(t2) {
          if (t2 < 0 || t2 >= this.size())
            throw new Error();
          return this.array_[t2];
        }, y2.prototype.push = function(t2) {
          return this.array_.push(t2), t2;
        }, y2.prototype.pop = function(t2) {
          if (0 === this.array_.length)
            throw new d();
          return this.array_.pop();
        }, y2.prototype.peek = function() {
          if (0 === this.array_.length)
            throw new d();
          return this.array_[this.array_.length - 1];
        }, y2.prototype.empty = function() {
          return 0 === this.array_.length;
        }, y2.prototype.isEmpty = function() {
          return this.empty();
        }, y2.prototype.search = function(t2) {
          return this.array_.indexOf(t2);
        }, y2.prototype.size = function() {
          return this.array_.length;
        }, y2.prototype.toArray = function() {
          for (var t2 = [], e3 = 0, n2 = this.array_.length; e3 < n2; e3++)
            t2.push(this.array_[e3]);
          return t2;
        };
        var be = function() {
          this._minIndex = -1, this._minCoord = null, this._minDe = null, this._orientedDe = null;
        };
        be.prototype.getCoordinate = function() {
          return this._minCoord;
        }, be.prototype.getRightmostSide = function(t2, e3) {
          var n2 = this.getRightmostSideOfSegment(t2, e3);
          return n2 < 0 && (n2 = this.getRightmostSideOfSegment(t2, e3 - 1)), n2 < 0 && (this._minCoord = null, this.checkForRightmostCoordinate(t2)), n2;
        }, be.prototype.findRightmostEdgeAtVertex = function() {
          var t2 = this._minDe.getEdge().getCoordinates();
          et.isTrue(this._minIndex > 0 && this._minIndex < t2.length, "rightmost point expected to be interior vertex of edge");
          var e3 = t2[this._minIndex - 1], n2 = t2[this._minIndex + 1], i2 = at.computeOrientation(this._minCoord, n2, e3), r2 = false;
          e3.y < this._minCoord.y && n2.y < this._minCoord.y && i2 === at.COUNTERCLOCKWISE ? r2 = true : e3.y > this._minCoord.y && n2.y > this._minCoord.y && i2 === at.CLOCKWISE && (r2 = true), r2 && (this._minIndex = this._minIndex - 1);
        }, be.prototype.getRightmostSideOfSegment = function(t2, e3) {
          var n2 = t2.getEdge().getCoordinates();
          if (e3 < 0 || e3 + 1 >= n2.length)
            return -1;
          if (n2[e3].y === n2[e3 + 1].y)
            return -1;
          var i2 = Se.LEFT;
          return n2[e3].y < n2[e3 + 1].y && (i2 = Se.RIGHT), i2;
        }, be.prototype.getEdge = function() {
          return this._orientedDe;
        }, be.prototype.checkForRightmostCoordinate = function(t2) {
          for (var e3 = t2.getEdge().getCoordinates(), n2 = 0; n2 < e3.length - 1; n2++)
            (null === this._minCoord || e3[n2].x > this._minCoord.x) && (this._minDe = t2, this._minIndex = n2, this._minCoord = e3[n2]);
        }, be.prototype.findRightmostEdgeAtNode = function() {
          var t2 = this._minDe.getNode().getEdges();
          this._minDe = t2.getRightmostEdge(), this._minDe.isForward() || (this._minDe = this._minDe.getSym(), this._minIndex = this._minDe.getEdge().getCoordinates().length - 1);
        }, be.prototype.findEdge = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            n2.isForward() && this.checkForRightmostCoordinate(n2);
          }
          et.isTrue(0 !== this._minIndex || this._minCoord.equals(this._minDe.getCoordinate()), "inconsistency in rightmost processing"), 0 === this._minIndex ? this.findRightmostEdgeAtNode() : this.findRightmostEdgeAtVertex(), this._orientedDe = this._minDe;
          this.getRightmostSide(this._minDe, this._minIndex) === Se.LEFT && (this._orientedDe = this._minDe.getSym());
        }, be.prototype.interfaces_ = function() {
          return [];
        }, be.prototype.getClass = function() {
          return be;
        };
        var we = function(t2) {
          function e3(n2, i2) {
            t2.call(this, e3.msgWithCoord(n2, i2)), this.pt = i2 ? new C(i2) : null, this.name = "TopologyException";
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.getCoordinate = function() {
            return this.pt;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.msgWithCoord = function(t3, e4) {
            return e4 ? t3 : t3 + " [ " + e4 + " ]";
          }, e3;
        }($), Oe = function() {
          this.array_ = [];
        };
        Oe.prototype.addLast = function(t2) {
          this.array_.push(t2);
        }, Oe.prototype.removeFirst = function() {
          return this.array_.shift();
        }, Oe.prototype.isEmpty = function() {
          return 0 === this.array_.length;
        };
        var Te = function() {
          this._finder = null, this._dirEdgeList = new Nt(), this._nodes = new Nt(), this._rightMostCoord = null, this._env = null, this._finder = new be();
        };
        Te.prototype.clearVisitedEdges = function() {
          for (var t2 = this._dirEdgeList.iterator(); t2.hasNext(); ) {
            t2.next().setVisited(false);
          }
        }, Te.prototype.getRightmostCoordinate = function() {
          return this._rightMostCoord;
        }, Te.prototype.computeNodeDepth = function(t2) {
          for (var e3 = null, n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (i2.isVisited() || i2.getSym().isVisited()) {
              e3 = i2;
              break;
            }
          }
          if (null === e3)
            throw new we("unable to find edge to compute depths at " + t2.getCoordinate());
          t2.getEdges().computeDepths(e3);
          for (var r2 = t2.getEdges().iterator(); r2.hasNext(); ) {
            var o2 = r2.next();
            o2.setVisited(true), this.copySymDepths(o2);
          }
        }, Te.prototype.computeDepth = function(t2) {
          this.clearVisitedEdges();
          var e3 = this._finder.getEdge();
          e3.setEdgeDepths(Se.RIGHT, t2), this.copySymDepths(e3), this.computeDepths(e3);
        }, Te.prototype.create = function(t2) {
          this.addReachable(t2), this._finder.findEdge(this._dirEdgeList), this._rightMostCoord = this._finder.getCoordinate();
        }, Te.prototype.findResultEdges = function() {
          for (var t2 = this._dirEdgeList.iterator(); t2.hasNext(); ) {
            var e3 = t2.next();
            e3.getDepth(Se.RIGHT) >= 1 && e3.getDepth(Se.LEFT) <= 0 && !e3.isInteriorAreaEdge() && e3.setInResult(true);
          }
        }, Te.prototype.computeDepths = function(t2) {
          var e3 = new Pt(), n2 = new Oe(), i2 = t2.getNode();
          for (n2.addLast(i2), e3.add(i2), t2.setVisited(true); !n2.isEmpty(); ) {
            var r2 = n2.removeFirst();
            e3.add(r2), this.computeNodeDepth(r2);
            for (var o2 = r2.getEdges().iterator(); o2.hasNext(); ) {
              var s2 = o2.next().getSym();
              if (!s2.isVisited()) {
                var a2 = s2.getNode();
                e3.contains(a2) || (n2.addLast(a2), e3.add(a2));
              }
            }
          }
        }, Te.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._rightMostCoord.x < e3._rightMostCoord.x ? -1 : this._rightMostCoord.x > e3._rightMostCoord.x ? 1 : 0;
        }, Te.prototype.getEnvelope = function() {
          if (null === this._env) {
            for (var t2 = new j(), e3 = this._dirEdgeList.iterator(); e3.hasNext(); )
              for (var n2 = e3.next().getEdge().getCoordinates(), i2 = 0; i2 < n2.length - 1; i2++)
                t2.expandToInclude(n2[i2]);
            this._env = t2;
          }
          return this._env;
        }, Te.prototype.addReachable = function(t2) {
          var e3 = new y2();
          for (e3.add(t2); !e3.empty(); ) {
            var n2 = e3.pop();
            this.add(n2, e3);
          }
        }, Te.prototype.copySymDepths = function(t2) {
          var e3 = t2.getSym();
          e3.setDepth(Se.LEFT, t2.getDepth(Se.RIGHT)), e3.setDepth(Se.RIGHT, t2.getDepth(Se.LEFT));
        }, Te.prototype.add = function(t2, e3) {
          t2.setVisited(true), this._nodes.add(t2);
          for (var n2 = t2.getEdges().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            this._dirEdgeList.add(i2);
            var r2 = i2.getSym().getNode();
            r2.isVisited() || e3.push(r2);
          }
        }, Te.prototype.getNodes = function() {
          return this._nodes;
        }, Te.prototype.getDirectedEdges = function() {
          return this._dirEdgeList;
        }, Te.prototype.interfaces_ = function() {
          return [E];
        }, Te.prototype.getClass = function() {
          return Te;
        };
        var Re = function t2() {
          if (this.location = null, 1 === arguments.length) {
            if (arguments[0] instanceof Array) {
              var e3 = arguments[0];
              this.init(e3.length);
            } else if (Number.isInteger(arguments[0])) {
              var n2 = arguments[0];
              this.init(1), this.location[Se.ON] = n2;
            } else if (arguments[0] instanceof t2) {
              var i2 = arguments[0];
              if (this.init(i2.location.length), null !== i2)
                for (var r2 = 0; r2 < this.location.length; r2++)
                  this.location[r2] = i2.location[r2];
            }
          } else if (3 === arguments.length) {
            var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            this.init(3), this.location[Se.ON] = o2, this.location[Se.LEFT] = s2, this.location[Se.RIGHT] = a2;
          }
        };
        Re.prototype.setAllLocations = function(t2) {
          for (var e3 = 0; e3 < this.location.length; e3++)
            this.location[e3] = t2;
        }, Re.prototype.isNull = function() {
          for (var t2 = 0; t2 < this.location.length; t2++)
            if (this.location[t2] !== w.NONE)
              return false;
          return true;
        }, Re.prototype.setAllLocationsIfNull = function(t2) {
          for (var e3 = 0; e3 < this.location.length; e3++)
            this.location[e3] === w.NONE && (this.location[e3] = t2);
        }, Re.prototype.isLine = function() {
          return 1 === this.location.length;
        }, Re.prototype.merge = function(t2) {
          if (t2.location.length > this.location.length) {
            var e3 = new Array(3).fill(null);
            e3[Se.ON] = this.location[Se.ON], e3[Se.LEFT] = w.NONE, e3[Se.RIGHT] = w.NONE, this.location = e3;
          }
          for (var n2 = 0; n2 < this.location.length; n2++)
            this.location[n2] === w.NONE && n2 < t2.location.length && (this.location[n2] = t2.location[n2]);
        }, Re.prototype.getLocations = function() {
          return this.location;
        }, Re.prototype.flip = function() {
          if (this.location.length <= 1)
            return null;
          var t2 = this.location[Se.LEFT];
          this.location[Se.LEFT] = this.location[Se.RIGHT], this.location[Se.RIGHT] = t2;
        }, Re.prototype.toString = function() {
          var t2 = new D();
          return this.location.length > 1 && t2.append(w.toLocationSymbol(this.location[Se.LEFT])), t2.append(w.toLocationSymbol(this.location[Se.ON])), this.location.length > 1 && t2.append(w.toLocationSymbol(this.location[Se.RIGHT])), t2.toString();
        }, Re.prototype.setLocations = function(t2, e3, n2) {
          this.location[Se.ON] = t2, this.location[Se.LEFT] = e3, this.location[Se.RIGHT] = n2;
        }, Re.prototype.get = function(t2) {
          return t2 < this.location.length ? this.location[t2] : w.NONE;
        }, Re.prototype.isArea = function() {
          return this.location.length > 1;
        }, Re.prototype.isAnyNull = function() {
          for (var t2 = 0; t2 < this.location.length; t2++)
            if (this.location[t2] === w.NONE)
              return true;
          return false;
        }, Re.prototype.setLocation = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setLocation(Se.ON, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this.location[e3] = n2;
          }
        }, Re.prototype.init = function(t2) {
          this.location = new Array(t2).fill(null), this.setAllLocations(w.NONE);
        }, Re.prototype.isEqualOnSide = function(t2, e3) {
          return this.location[e3] === t2.location[e3];
        }, Re.prototype.allPositionsEqual = function(t2) {
          for (var e3 = 0; e3 < this.location.length; e3++)
            if (this.location[e3] !== t2)
              return false;
          return true;
        }, Re.prototype.interfaces_ = function() {
          return [];
        }, Re.prototype.getClass = function() {
          return Re;
        };
        var Pe = function t2() {
          if (this.elt = new Array(2).fill(null), 1 === arguments.length) {
            if (Number.isInteger(arguments[0])) {
              var e3 = arguments[0];
              this.elt[0] = new Re(e3), this.elt[1] = new Re(e3);
            } else if (arguments[0] instanceof t2) {
              var n2 = arguments[0];
              this.elt[0] = new Re(n2.elt[0]), this.elt[1] = new Re(n2.elt[1]);
            }
          } else if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            this.elt[0] = new Re(w.NONE), this.elt[1] = new Re(w.NONE), this.elt[i2].setLocation(r2);
          } else if (3 === arguments.length) {
            var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2];
            this.elt[0] = new Re(o2, s2, a2), this.elt[1] = new Re(o2, s2, a2);
          } else if (4 === arguments.length) {
            var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2], p2 = arguments[3];
            this.elt[0] = new Re(w.NONE, w.NONE, w.NONE), this.elt[1] = new Re(w.NONE, w.NONE, w.NONE), this.elt[u2].setLocations(l2, c2, p2);
          }
        };
        Pe.prototype.getGeometryCount = function() {
          var t2 = 0;
          return this.elt[0].isNull() || t2++, this.elt[1].isNull() || t2++, t2;
        }, Pe.prototype.setAllLocations = function(t2, e3) {
          this.elt[t2].setAllLocations(e3);
        }, Pe.prototype.isNull = function(t2) {
          return this.elt[t2].isNull();
        }, Pe.prototype.setAllLocationsIfNull = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setAllLocationsIfNull(0, t2), this.setAllLocationsIfNull(1, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this.elt[e3].setAllLocationsIfNull(n2);
          }
        }, Pe.prototype.isLine = function(t2) {
          return this.elt[t2].isLine();
        }, Pe.prototype.merge = function(t2) {
          for (var e3 = 0; e3 < 2; e3++)
            null === this.elt[e3] && null !== t2.elt[e3] ? this.elt[e3] = new Re(t2.elt[e3]) : this.elt[e3].merge(t2.elt[e3]);
        }, Pe.prototype.flip = function() {
          this.elt[0].flip(), this.elt[1].flip();
        }, Pe.prototype.getLocation = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.elt[t2].get(Se.ON);
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return this.elt[e3].get(n2);
          }
        }, Pe.prototype.toString = function() {
          var t2 = new D();
          return null !== this.elt[0] && (t2.append("A:"), t2.append(this.elt[0].toString())), null !== this.elt[1] && (t2.append(" B:"), t2.append(this.elt[1].toString())), t2.toString();
        }, Pe.prototype.isArea = function() {
          if (0 === arguments.length)
            return this.elt[0].isArea() || this.elt[1].isArea();
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.elt[t2].isArea();
          }
        }, Pe.prototype.isAnyNull = function(t2) {
          return this.elt[t2].isAnyNull();
        }, Pe.prototype.setLocation = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this.elt[t2].setLocation(Se.ON, e3);
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this.elt[n2].setLocation(i2, r2);
          }
        }, Pe.prototype.isEqualOnSide = function(t2, e3) {
          return this.elt[0].isEqualOnSide(t2.elt[0], e3) && this.elt[1].isEqualOnSide(t2.elt[1], e3);
        }, Pe.prototype.allPositionsEqual = function(t2, e3) {
          return this.elt[t2].allPositionsEqual(e3);
        }, Pe.prototype.toLine = function(t2) {
          this.elt[t2].isArea() && (this.elt[t2] = new Re(this.elt[t2].location[0]));
        }, Pe.prototype.interfaces_ = function() {
          return [];
        }, Pe.prototype.getClass = function() {
          return Pe;
        }, Pe.toLineLabel = function(t2) {
          for (var e3 = new Pe(w.NONE), n2 = 0; n2 < 2; n2++)
            e3.setLocation(n2, t2.getLocation(n2));
          return e3;
        };
        var De = function() {
          this._startDe = null, this._maxNodeDegree = -1, this._edges = new Nt(), this._pts = new Nt(), this._label = new Pe(w.NONE), this._ring = null, this._isHole = null, this._shell = null, this._holes = new Nt(), this._geometryFactory = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._geometryFactory = e3, this.computePoints(t2), this.computeRing();
        };
        De.prototype.computeRing = function() {
          if (null !== this._ring)
            return null;
          for (var t2 = new Array(this._pts.size()).fill(null), e3 = 0; e3 < this._pts.size(); e3++)
            t2[e3] = this._pts.get(e3);
          this._ring = this._geometryFactory.createLinearRing(t2), this._isHole = at.isCCW(this._ring.getCoordinates());
        }, De.prototype.isIsolated = function() {
          return 1 === this._label.getGeometryCount();
        }, De.prototype.computePoints = function(t2) {
          this._startDe = t2;
          var e3 = t2, n2 = true;
          do {
            if (null === e3)
              throw new we("Found null DirectedEdge");
            if (e3.getEdgeRing() === this)
              throw new we("Directed Edge visited twice during ring-building at " + e3.getCoordinate());
            this._edges.add(e3);
            var i2 = e3.getLabel();
            et.isTrue(i2.isArea()), this.mergeLabel(i2), this.addPoints(e3.getEdge(), e3.isForward(), n2), n2 = false, this.setEdgeRing(e3, this), e3 = this.getNext(e3);
          } while (e3 !== this._startDe);
        }, De.prototype.getLinearRing = function() {
          return this._ring;
        }, De.prototype.getCoordinate = function(t2) {
          return this._pts.get(t2);
        }, De.prototype.computeMaxNodeDegree = function() {
          this._maxNodeDegree = 0;
          var t2 = this._startDe;
          do {
            var e3 = t2.getNode().getEdges().getOutgoingDegree(this);
            e3 > this._maxNodeDegree && (this._maxNodeDegree = e3), t2 = this.getNext(t2);
          } while (t2 !== this._startDe);
          this._maxNodeDegree *= 2;
        }, De.prototype.addPoints = function(t2, e3, n2) {
          var i2 = t2.getCoordinates();
          if (e3) {
            var r2 = 1;
            n2 && (r2 = 0);
            for (var o2 = r2; o2 < i2.length; o2++)
              this._pts.add(i2[o2]);
          } else {
            var s2 = i2.length - 2;
            n2 && (s2 = i2.length - 1);
            for (var a2 = s2; a2 >= 0; a2--)
              this._pts.add(i2[a2]);
          }
        }, De.prototype.isHole = function() {
          return this._isHole;
        }, De.prototype.setInResult = function() {
          var t2 = this._startDe;
          do {
            t2.getEdge().setInResult(true), t2 = t2.getNext();
          } while (t2 !== this._startDe);
        }, De.prototype.containsPoint = function(t2) {
          var e3 = this.getLinearRing();
          if (!e3.getEnvelopeInternal().contains(t2))
            return false;
          if (!at.isPointInRing(t2, e3.getCoordinates()))
            return false;
          for (var n2 = this._holes.iterator(); n2.hasNext(); ) {
            if (n2.next().containsPoint(t2))
              return false;
          }
          return true;
        }, De.prototype.addHole = function(t2) {
          this._holes.add(t2);
        }, De.prototype.isShell = function() {
          return null === this._shell;
        }, De.prototype.getLabel = function() {
          return this._label;
        }, De.prototype.getEdges = function() {
          return this._edges;
        }, De.prototype.getMaxNodeDegree = function() {
          return this._maxNodeDegree < 0 && this.computeMaxNodeDegree(), this._maxNodeDegree;
        }, De.prototype.getShell = function() {
          return this._shell;
        }, De.prototype.mergeLabel = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.mergeLabel(t2, 0), this.mergeLabel(t2, 1);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = e3.getLocation(n2, Se.RIGHT);
            if (i2 === w.NONE)
              return null;
            if (this._label.getLocation(n2) === w.NONE)
              return this._label.setLocation(n2, i2), null;
          }
        }, De.prototype.setShell = function(t2) {
          this._shell = t2, null !== t2 && t2.addHole(this);
        }, De.prototype.toPolygon = function(t2) {
          for (var e3 = new Array(this._holes.size()).fill(null), n2 = 0; n2 < this._holes.size(); n2++)
            e3[n2] = this._holes.get(n2).getLinearRing();
          return t2.createPolygon(this.getLinearRing(), e3);
        }, De.prototype.interfaces_ = function() {
          return [];
        }, De.prototype.getClass = function() {
          return De;
        };
        var Me = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            t2.call(this, e4, n2);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.setEdgeRing = function(t3, e4) {
            t3.setMinEdgeRing(e4);
          }, e3.prototype.getNext = function(t3) {
            return t3.getNextMin();
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(De), Ae = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            t2.call(this, e4, n2);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.buildMinimalRings = function() {
            var t3 = new Nt(), e4 = this._startDe;
            do {
              if (null === e4.getMinEdgeRing()) {
                var n2 = new Me(e4, this._geometryFactory);
                t3.add(n2);
              }
              e4 = e4.getNext();
            } while (e4 !== this._startDe);
            return t3;
          }, e3.prototype.setEdgeRing = function(t3, e4) {
            t3.setEdgeRing(e4);
          }, e3.prototype.linkDirectedEdgesForMinimalEdgeRings = function() {
            var t3 = this._startDe;
            do {
              t3.getNode().getEdges().linkMinimalDirectedEdges(this), t3 = t3.getNext();
            } while (t3 !== this._startDe);
          }, e3.prototype.getNext = function(t3) {
            return t3.getNext();
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(De), Fe = function() {
          if (this._label = null, this._isInResult = false, this._isCovered = false, this._isCoveredSet = false, this._isVisited = false, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._label = t2;
          }
        };
        Fe.prototype.setVisited = function(t2) {
          this._isVisited = t2;
        }, Fe.prototype.setInResult = function(t2) {
          this._isInResult = t2;
        }, Fe.prototype.isCovered = function() {
          return this._isCovered;
        }, Fe.prototype.isCoveredSet = function() {
          return this._isCoveredSet;
        }, Fe.prototype.setLabel = function(t2) {
          this._label = t2;
        }, Fe.prototype.getLabel = function() {
          return this._label;
        }, Fe.prototype.setCovered = function(t2) {
          this._isCovered = t2, this._isCoveredSet = true;
        }, Fe.prototype.updateIM = function(t2) {
          et.isTrue(this._label.getGeometryCount() >= 2, "found partial label"), this.computeIM(t2);
        }, Fe.prototype.isInResult = function() {
          return this._isInResult;
        }, Fe.prototype.isVisited = function() {
          return this._isVisited;
        }, Fe.prototype.interfaces_ = function() {
          return [];
        }, Fe.prototype.getClass = function() {
          return Fe;
        };
        var Ge = function(t2) {
          function e3() {
            t2.call(this), this._coord = null, this._edges = null;
            var e4 = arguments[0], n2 = arguments[1];
            this._coord = e4, this._edges = n2, this._label = new Pe(0, w.NONE);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.isIncidentEdgeInResult = function() {
            for (var t3 = this.getEdges().getEdges().iterator(); t3.hasNext(); ) {
              if (t3.next().getEdge().isInResult())
                return true;
            }
            return false;
          }, e3.prototype.isIsolated = function() {
            return 1 === this._label.getGeometryCount();
          }, e3.prototype.getCoordinate = function() {
            return this._coord;
          }, e3.prototype.print = function(t3) {
            t3.println("node " + this._coord + " lbl: " + this._label);
          }, e3.prototype.computeIM = function(t3) {
          }, e3.prototype.computeMergedLocation = function(t3, e4) {
            var n2 = w.NONE;
            if (n2 = this._label.getLocation(e4), !t3.isNull(e4)) {
              var i2 = t3.getLocation(e4);
              n2 !== w.BOUNDARY && (n2 = i2);
            }
            return n2;
          }, e3.prototype.setLabel = function() {
            if (2 !== arguments.length)
              return t2.prototype.setLabel.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1];
            null === this._label ? this._label = new Pe(e4, n2) : this._label.setLocation(e4, n2);
          }, e3.prototype.getEdges = function() {
            return this._edges;
          }, e3.prototype.mergeLabel = function() {
            if (arguments[0] instanceof e3) {
              var t3 = arguments[0];
              this.mergeLabel(t3._label);
            } else if (arguments[0] instanceof Pe)
              for (var n2 = arguments[0], i2 = 0; i2 < 2; i2++) {
                var r2 = this.computeMergedLocation(n2, i2);
                this._label.getLocation(i2) === w.NONE && this._label.setLocation(i2, r2);
              }
          }, e3.prototype.add = function(t3) {
            this._edges.insert(t3), t3.setNode(this);
          }, e3.prototype.setLabelBoundary = function(t3) {
            if (null === this._label)
              return null;
            var e4 = w.NONE;
            null !== this._label && (e4 = this._label.getLocation(t3));
            var n2 = null;
            switch (e4) {
              case w.BOUNDARY:
                n2 = w.INTERIOR;
                break;
              case w.INTERIOR:
              default:
                n2 = w.BOUNDARY;
            }
            this._label.setLocation(t3, n2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Fe), qe = function() {
          this.nodeMap = new p(), this.nodeFact = null;
          var t2 = arguments[0];
          this.nodeFact = t2;
        };
        qe.prototype.find = function(t2) {
          return this.nodeMap.get(t2);
        }, qe.prototype.addNode = function() {
          if (arguments[0] instanceof C) {
            var t2 = arguments[0], e3 = this.nodeMap.get(t2);
            return null === e3 && (e3 = this.nodeFact.createNode(t2), this.nodeMap.put(t2, e3)), e3;
          }
          if (arguments[0] instanceof Ge) {
            var n2 = arguments[0], i2 = this.nodeMap.get(n2.getCoordinate());
            return null === i2 ? (this.nodeMap.put(n2.getCoordinate(), n2), n2) : (i2.mergeLabel(n2), i2);
          }
        }, qe.prototype.print = function(t2) {
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, qe.prototype.iterator = function() {
          return this.nodeMap.values().iterator();
        }, qe.prototype.values = function() {
          return this.nodeMap.values();
        }, qe.prototype.getBoundaryNodes = function(t2) {
          for (var e3 = new Nt(), n2 = this.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            i2.getLabel().getLocation(t2) === w.BOUNDARY && e3.add(i2);
          }
          return e3;
        }, qe.prototype.add = function(t2) {
          var e3 = t2.getCoordinate();
          this.addNode(e3).add(t2);
        }, qe.prototype.interfaces_ = function() {
          return [];
        }, qe.prototype.getClass = function() {
          return qe;
        };
        var Be = function() {
        }, Ve = { NE: { configurable: true }, NW: { configurable: true }, SW: { configurable: true }, SE: { configurable: true } };
        Be.prototype.interfaces_ = function() {
          return [];
        }, Be.prototype.getClass = function() {
          return Be;
        }, Be.isNorthern = function(t2) {
          return t2 === Be.NE || t2 === Be.NW;
        }, Be.isOpposite = function(t2, e3) {
          if (t2 === e3)
            return false;
          return 2 === (t2 - e3 + 4) % 4;
        }, Be.commonHalfPlane = function(t2, e3) {
          if (t2 === e3)
            return t2;
          if (2 === (t2 - e3 + 4) % 4)
            return -1;
          var n2 = t2 < e3 ? t2 : e3;
          return 0 === n2 && 3 === (t2 > e3 ? t2 : e3) ? 3 : n2;
        }, Be.isInHalfPlane = function(t2, e3) {
          return e3 === Be.SE ? t2 === Be.SE || t2 === Be.SW : t2 === e3 || t2 === e3 + 1;
        }, Be.quadrant = function() {
          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t2 = arguments[0], e3 = arguments[1];
            if (0 === t2 && 0 === e3)
              throw new m("Cannot compute the quadrant for point ( " + t2 + ", " + e3 + " )");
            return t2 >= 0 ? e3 >= 0 ? Be.NE : Be.SE : e3 >= 0 ? Be.NW : Be.SW;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof C) {
            var n2 = arguments[0], i2 = arguments[1];
            if (i2.x === n2.x && i2.y === n2.y)
              throw new m("Cannot compute the quadrant for two identical points " + n2);
            return i2.x >= n2.x ? i2.y >= n2.y ? Be.NE : Be.SE : i2.y >= n2.y ? Be.NW : Be.SW;
          }
        }, Ve.NE.get = function() {
          return 0;
        }, Ve.NW.get = function() {
          return 1;
        }, Ve.SW.get = function() {
          return 2;
        }, Ve.SE.get = function() {
          return 3;
        }, Object.defineProperties(Be, Ve);
        var Ue = function() {
          if (this._edge = null, this._label = null, this._node = null, this._p0 = null, this._p1 = null, this._dx = null, this._dy = null, this._quadrant = null, 1 === arguments.length) {
            var t2 = arguments[0];
            this._edge = t2;
          } else if (3 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            this._edge = e3, this.init(n2, i2), this._label = null;
          } else if (4 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
            this._edge = r2, this.init(o2, s2), this._label = a2;
          }
        };
        Ue.prototype.compareDirection = function(t2) {
          return this._dx === t2._dx && this._dy === t2._dy ? 0 : this._quadrant > t2._quadrant ? 1 : this._quadrant < t2._quadrant ? -1 : at.computeOrientation(t2._p0, t2._p1, this._p1);
        }, Ue.prototype.getDy = function() {
          return this._dy;
        }, Ue.prototype.getCoordinate = function() {
          return this._p0;
        }, Ue.prototype.setNode = function(t2) {
          this._node = t2;
        }, Ue.prototype.print = function(t2) {
          var e3 = Math.atan2(this._dy, this._dx), n2 = this.getClass().getName(), i2 = n2.lastIndexOf("."), r2 = n2.substring(i2 + 1);
          t2.print("  " + r2 + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + e3 + "   " + this._label);
        }, Ue.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.compareDirection(e3);
        }, Ue.prototype.getDirectedCoordinate = function() {
          return this._p1;
        }, Ue.prototype.getDx = function() {
          return this._dx;
        }, Ue.prototype.getLabel = function() {
          return this._label;
        }, Ue.prototype.getEdge = function() {
          return this._edge;
        }, Ue.prototype.getQuadrant = function() {
          return this._quadrant;
        }, Ue.prototype.getNode = function() {
          return this._node;
        }, Ue.prototype.toString = function() {
          var t2 = Math.atan2(this._dy, this._dx), e3 = this.getClass().getName(), n2 = e3.lastIndexOf(".");
          return "  " + e3.substring(n2 + 1) + ": " + this._p0 + " - " + this._p1 + " " + this._quadrant + ":" + t2 + "   " + this._label;
        }, Ue.prototype.computeLabel = function(t2) {
        }, Ue.prototype.init = function(t2, e3) {
          this._p0 = t2, this._p1 = e3, this._dx = e3.x - t2.x, this._dy = e3.y - t2.y, this._quadrant = Be.quadrant(this._dx, this._dy), et.isTrue(!(0 === this._dx && 0 === this._dy), "EdgeEnd with identical endpoints found");
        }, Ue.prototype.interfaces_ = function() {
          return [E];
        }, Ue.prototype.getClass = function() {
          return Ue;
        };
        var ze = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            if (t2.call(this, e4), this._isForward = null, this._isInResult = false, this._isVisited = false, this._sym = null, this._next = null, this._nextMin = null, this._edgeRing = null, this._minEdgeRing = null, this._depth = [0, -999, -999], this._isForward = n2, n2)
              this.init(e4.getCoordinate(0), e4.getCoordinate(1));
            else {
              var i2 = e4.getNumPoints() - 1;
              this.init(e4.getCoordinate(i2), e4.getCoordinate(i2 - 1));
            }
            this.computeDirectedLabel();
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.getNextMin = function() {
            return this._nextMin;
          }, e3.prototype.getDepth = function(t3) {
            return this._depth[t3];
          }, e3.prototype.setVisited = function(t3) {
            this._isVisited = t3;
          }, e3.prototype.computeDirectedLabel = function() {
            this._label = new Pe(this._edge.getLabel()), this._isForward || this._label.flip();
          }, e3.prototype.getNext = function() {
            return this._next;
          }, e3.prototype.setDepth = function(t3, e4) {
            if (-999 !== this._depth[t3] && this._depth[t3] !== e4)
              throw new we("assigned depths do not match", this.getCoordinate());
            this._depth[t3] = e4;
          }, e3.prototype.isInteriorAreaEdge = function() {
            for (var t3 = true, e4 = 0; e4 < 2; e4++)
              this._label.isArea(e4) && this._label.getLocation(e4, Se.LEFT) === w.INTERIOR && this._label.getLocation(e4, Se.RIGHT) === w.INTERIOR || (t3 = false);
            return t3;
          }, e3.prototype.setNextMin = function(t3) {
            this._nextMin = t3;
          }, e3.prototype.print = function(e4) {
            t2.prototype.print.call(this, e4), e4.print(" " + this._depth[Se.LEFT] + "/" + this._depth[Se.RIGHT]), e4.print(" (" + this.getDepthDelta() + ")"), this._isInResult && e4.print(" inResult");
          }, e3.prototype.setMinEdgeRing = function(t3) {
            this._minEdgeRing = t3;
          }, e3.prototype.isLineEdge = function() {
            var t3 = this._label.isLine(0) || this._label.isLine(1), e4 = !this._label.isArea(0) || this._label.allPositionsEqual(0, w.EXTERIOR), n2 = !this._label.isArea(1) || this._label.allPositionsEqual(1, w.EXTERIOR);
            return t3 && e4 && n2;
          }, e3.prototype.setEdgeRing = function(t3) {
            this._edgeRing = t3;
          }, e3.prototype.getMinEdgeRing = function() {
            return this._minEdgeRing;
          }, e3.prototype.getDepthDelta = function() {
            var t3 = this._edge.getDepthDelta();
            return this._isForward || (t3 = -t3), t3;
          }, e3.prototype.setInResult = function(t3) {
            this._isInResult = t3;
          }, e3.prototype.getSym = function() {
            return this._sym;
          }, e3.prototype.isForward = function() {
            return this._isForward;
          }, e3.prototype.getEdge = function() {
            return this._edge;
          }, e3.prototype.printEdge = function(t3) {
            this.print(t3), t3.print(" "), this._isForward ? this._edge.print(t3) : this._edge.printReverse(t3);
          }, e3.prototype.setSym = function(t3) {
            this._sym = t3;
          }, e3.prototype.setVisitedEdge = function(t3) {
            this.setVisited(t3), this._sym.setVisited(t3);
          }, e3.prototype.setEdgeDepths = function(t3, e4) {
            var n2 = this.getEdge().getDepthDelta();
            this._isForward || (n2 = -n2);
            var i2 = 1;
            t3 === Se.LEFT && (i2 = -1);
            var r2 = Se.opposite(t3), o2 = e4 + n2 * i2;
            this.setDepth(t3, e4), this.setDepth(r2, o2);
          }, e3.prototype.getEdgeRing = function() {
            return this._edgeRing;
          }, e3.prototype.isInResult = function() {
            return this._isInResult;
          }, e3.prototype.setNext = function(t3) {
            this._next = t3;
          }, e3.prototype.isVisited = function() {
            return this._isVisited;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.depthFactor = function(t3, e4) {
            return t3 === w.EXTERIOR && e4 === w.INTERIOR ? 1 : t3 === w.INTERIOR && e4 === w.EXTERIOR ? -1 : 0;
          }, e3;
        }(Ue), Xe = function() {
        };
        Xe.prototype.createNode = function(t2) {
          return new Ge(t2, null);
        }, Xe.prototype.interfaces_ = function() {
          return [];
        }, Xe.prototype.getClass = function() {
          return Xe;
        };
        var Ye = function() {
          if (this._edges = new Nt(), this._nodes = null, this._edgeEndList = new Nt(), 0 === arguments.length)
            this._nodes = new qe(new Xe());
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._nodes = new qe(t2);
          }
        };
        Ye.prototype.printEdges = function(t2) {
          t2.println("Edges:");
          for (var e3 = 0; e3 < this._edges.size(); e3++) {
            t2.println("edge " + e3 + ":");
            var n2 = this._edges.get(e3);
            n2.print(t2), n2.eiList.print(t2);
          }
        }, Ye.prototype.find = function(t2) {
          return this._nodes.find(t2);
        }, Ye.prototype.addNode = function() {
          if (arguments[0] instanceof Ge) {
            var t2 = arguments[0];
            return this._nodes.addNode(t2);
          }
          if (arguments[0] instanceof C) {
            var e3 = arguments[0];
            return this._nodes.addNode(e3);
          }
        }, Ye.prototype.getNodeIterator = function() {
          return this._nodes.iterator();
        }, Ye.prototype.linkResultDirectedEdges = function() {
          for (var t2 = this._nodes.iterator(); t2.hasNext(); ) {
            t2.next().getEdges().linkResultDirectedEdges();
          }
        }, Ye.prototype.debugPrintln = function(t2) {
          Y.out.println(t2);
        }, Ye.prototype.isBoundaryNode = function(t2, e3) {
          var n2 = this._nodes.find(e3);
          if (null === n2)
            return false;
          var i2 = n2.getLabel();
          return null !== i2 && i2.getLocation(t2) === w.BOUNDARY;
        }, Ye.prototype.linkAllDirectedEdges = function() {
          for (var t2 = this._nodes.iterator(); t2.hasNext(); ) {
            t2.next().getEdges().linkAllDirectedEdges();
          }
        }, Ye.prototype.matchInSameDirection = function(t2, e3, n2, i2) {
          return !!t2.equals(n2) && (at.computeOrientation(t2, e3, i2) === at.COLLINEAR && Be.quadrant(t2, e3) === Be.quadrant(n2, i2));
        }, Ye.prototype.getEdgeEnds = function() {
          return this._edgeEndList;
        }, Ye.prototype.debugPrint = function(t2) {
          Y.out.print(t2);
        }, Ye.prototype.getEdgeIterator = function() {
          return this._edges.iterator();
        }, Ye.prototype.findEdgeInSameDirection = function(t2, e3) {
          for (var n2 = 0; n2 < this._edges.size(); n2++) {
            var i2 = this._edges.get(n2), r2 = i2.getCoordinates();
            if (this.matchInSameDirection(t2, e3, r2[0], r2[1]))
              return i2;
            if (this.matchInSameDirection(t2, e3, r2[r2.length - 1], r2[r2.length - 2]))
              return i2;
          }
          return null;
        }, Ye.prototype.insertEdge = function(t2) {
          this._edges.add(t2);
        }, Ye.prototype.findEdgeEnd = function(t2) {
          for (var e3 = this.getEdgeEnds().iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            if (n2.getEdge() === t2)
              return n2;
          }
          return null;
        }, Ye.prototype.addEdges = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            this._edges.add(n2);
            var i2 = new ze(n2, true), r2 = new ze(n2, false);
            i2.setSym(r2), r2.setSym(i2), this.add(i2), this.add(r2);
          }
        }, Ye.prototype.add = function(t2) {
          this._nodes.add(t2), this._edgeEndList.add(t2);
        }, Ye.prototype.getNodes = function() {
          return this._nodes.values();
        }, Ye.prototype.findEdge = function(t2, e3) {
          for (var n2 = 0; n2 < this._edges.size(); n2++) {
            var i2 = this._edges.get(n2), r2 = i2.getCoordinates();
            if (t2.equals(r2[0]) && e3.equals(r2[1]))
              return i2;
          }
          return null;
        }, Ye.prototype.interfaces_ = function() {
          return [];
        }, Ye.prototype.getClass = function() {
          return Ye;
        }, Ye.linkResultDirectedEdges = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            e3.next().getEdges().linkResultDirectedEdges();
          }
        };
        var ke = function() {
          this._geometryFactory = null, this._shellList = new Nt();
          var t2 = arguments[0];
          this._geometryFactory = t2;
        };
        ke.prototype.sortShellsAndHoles = function(t2, e3, n2) {
          for (var i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2.isHole() ? n2.add(r2) : e3.add(r2);
          }
        }, ke.prototype.computePolygons = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().toPolygon(this._geometryFactory);
            e3.add(i2);
          }
          return e3;
        }, ke.prototype.placeFreeHoles = function(t2, e3) {
          for (var n2 = e3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (null === i2.getShell()) {
              var r2 = this.findEdgeRingContaining(i2, t2);
              if (null === r2)
                throw new we("unable to assign hole to a shell", i2.getCoordinate(0));
              i2.setShell(r2);
            }
          }
        }, ke.prototype.buildMinimalEdgeRings = function(t2, e3, n2) {
          for (var i2 = new Nt(), r2 = t2.iterator(); r2.hasNext(); ) {
            var o2 = r2.next();
            if (o2.getMaxNodeDegree() > 2) {
              o2.linkDirectedEdgesForMinimalEdgeRings();
              var s2 = o2.buildMinimalRings(), a2 = this.findShell(s2);
              null !== a2 ? (this.placePolygonHoles(a2, s2), e3.add(a2)) : n2.addAll(s2);
            } else
              i2.add(o2);
          }
          return i2;
        }, ke.prototype.containsPoint = function(t2) {
          for (var e3 = this._shellList.iterator(); e3.hasNext(); ) {
            if (e3.next().containsPoint(t2))
              return true;
          }
          return false;
        }, ke.prototype.buildMaximalEdgeRings = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (i2.isInResult() && i2.getLabel().isArea() && null === i2.getEdgeRing()) {
              var r2 = new Ae(i2, this._geometryFactory);
              e3.add(r2), r2.setInResult();
            }
          }
          return e3;
        }, ke.prototype.placePolygonHoles = function(t2, e3) {
          for (var n2 = e3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            i2.isHole() && i2.setShell(t2);
          }
        }, ke.prototype.getPolygons = function() {
          return this.computePolygons(this._shellList);
        }, ke.prototype.findEdgeRingContaining = function(t2, e3) {
          for (var n2 = t2.getLinearRing(), i2 = n2.getEnvelopeInternal(), r2 = n2.getCoordinateN(0), o2 = null, s2 = null, a2 = e3.iterator(); a2.hasNext(); ) {
            var u2 = a2.next(), l2 = u2.getLinearRing(), c2 = l2.getEnvelopeInternal();
            null !== o2 && (s2 = o2.getLinearRing().getEnvelopeInternal());
            var p2 = false;
            c2.contains(i2) && at.isPointInRing(r2, l2.getCoordinates()) && (p2 = true), p2 && (null === o2 || s2.contains(c2)) && (o2 = u2);
          }
          return o2;
        }, ke.prototype.findShell = function(t2) {
          for (var e3 = 0, n2 = null, i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2.isHole() || (n2 = r2, e3++);
          }
          return et.isTrue(e3 <= 1, "found two shells in MinimalEdgeRing list"), n2;
        }, ke.prototype.add = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.add(t2.getEdgeEnds(), t2.getNodes());
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            Ye.linkResultDirectedEdges(n2);
            var i2 = this.buildMaximalEdgeRings(e3), r2 = new Nt(), o2 = this.buildMinimalEdgeRings(i2, this._shellList, r2);
            this.sortShellsAndHoles(o2, this._shellList, r2), this.placeFreeHoles(this._shellList, r2);
          }
        }, ke.prototype.interfaces_ = function() {
          return [];
        }, ke.prototype.getClass = function() {
          return ke;
        };
        var je = function() {
        };
        je.prototype.getBounds = function() {
        }, je.prototype.interfaces_ = function() {
          return [];
        }, je.prototype.getClass = function() {
          return je;
        };
        var He = function() {
          this._bounds = null, this._item = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._bounds = t2, this._item = e3;
        };
        He.prototype.getItem = function() {
          return this._item;
        }, He.prototype.getBounds = function() {
          return this._bounds;
        }, He.prototype.interfaces_ = function() {
          return [je, e];
        }, He.prototype.getClass = function() {
          return He;
        };
        var We = function() {
          this._size = null, this._items = null, this._size = 0, this._items = new Nt(), this._items.add(null);
        };
        We.prototype.poll = function() {
          if (this.isEmpty())
            return null;
          var t2 = this._items.get(1);
          return this._items.set(1, this._items.get(this._size)), this._size -= 1, this.reorder(1), t2;
        }, We.prototype.size = function() {
          return this._size;
        }, We.prototype.reorder = function(t2) {
          for (var e3 = null, n2 = this._items.get(t2); 2 * t2 <= this._size && ((e3 = 2 * t2) !== this._size && this._items.get(e3 + 1).compareTo(this._items.get(e3)) < 0 && e3++, this._items.get(e3).compareTo(n2) < 0); t2 = e3)
            this._items.set(t2, this._items.get(e3));
          this._items.set(t2, n2);
        }, We.prototype.clear = function() {
          this._size = 0, this._items.clear();
        }, We.prototype.isEmpty = function() {
          return 0 === this._size;
        }, We.prototype.add = function(t2) {
          this._items.add(null), this._size += 1;
          var e3 = this._size;
          for (this._items.set(0, t2); t2.compareTo(this._items.get(Math.trunc(e3 / 2))) < 0; e3 /= 2)
            this._items.set(e3, this._items.get(Math.trunc(e3 / 2)));
          this._items.set(e3, t2);
        }, We.prototype.interfaces_ = function() {
          return [];
        }, We.prototype.getClass = function() {
          return We;
        };
        var Ke = function() {
        };
        Ke.prototype.visitItem = function(t2) {
        }, Ke.prototype.interfaces_ = function() {
          return [];
        }, Ke.prototype.getClass = function() {
          return Ke;
        };
        var Je = function() {
        };
        Je.prototype.insert = function(t2, e3) {
        }, Je.prototype.remove = function(t2, e3) {
        }, Je.prototype.query = function() {
        }, Je.prototype.interfaces_ = function() {
          return [];
        }, Je.prototype.getClass = function() {
          return Je;
        };
        var Qe = function() {
          if (this._childBoundables = new Nt(), this._bounds = null, this._level = null, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this._level = t2;
          }
        }, Ze = { serialVersionUID: { configurable: true } };
        Qe.prototype.getLevel = function() {
          return this._level;
        }, Qe.prototype.size = function() {
          return this._childBoundables.size();
        }, Qe.prototype.getChildBoundables = function() {
          return this._childBoundables;
        }, Qe.prototype.addChildBoundable = function(t2) {
          et.isTrue(null === this._bounds), this._childBoundables.add(t2);
        }, Qe.prototype.isEmpty = function() {
          return this._childBoundables.isEmpty();
        }, Qe.prototype.getBounds = function() {
          return null === this._bounds && (this._bounds = this.computeBounds()), this._bounds;
        }, Qe.prototype.interfaces_ = function() {
          return [je, e];
        }, Qe.prototype.getClass = function() {
          return Qe;
        }, Ze.serialVersionUID.get = function() {
          return 6493722185909574e3;
        }, Object.defineProperties(Qe, Ze);
        var $e = function() {
        };
        $e.reverseOrder = function() {
          return { compare: function(t2, e3) {
            return e3.compareTo(t2);
          } };
        }, $e.min = function(t2) {
          return $e.sort(t2), t2.get(0);
        }, $e.sort = function(t2, e3) {
          var n2 = t2.toArray();
          e3 ? Gt.sort(n2, e3) : Gt.sort(n2);
          for (var i2 = t2.iterator(), r2 = 0, o2 = n2.length; r2 < o2; r2++)
            i2.next(), i2.set(n2[r2]);
        }, $e.singletonList = function(t2) {
          var e3 = new Nt();
          return e3.add(t2), e3;
        };
        var tn = function() {
          this._boundable1 = null, this._boundable2 = null, this._distance = null, this._itemDistance = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._boundable1 = t2, this._boundable2 = e3, this._itemDistance = n2, this._distance = this.distance();
        };
        tn.prototype.expandToQueue = function(t2, e3) {
          var n2 = tn.isComposite(this._boundable1), i2 = tn.isComposite(this._boundable2);
          if (n2 && i2)
            return tn.area(this._boundable1) > tn.area(this._boundable2) ? (this.expand(this._boundable1, this._boundable2, t2, e3), null) : (this.expand(this._boundable2, this._boundable1, t2, e3), null);
          if (n2)
            return this.expand(this._boundable1, this._boundable2, t2, e3), null;
          if (i2)
            return this.expand(this._boundable2, this._boundable1, t2, e3), null;
          throw new m("neither boundable is composite");
        }, tn.prototype.isLeaves = function() {
          return !(tn.isComposite(this._boundable1) || tn.isComposite(this._boundable2));
        }, tn.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._distance < e3._distance ? -1 : this._distance > e3._distance ? 1 : 0;
        }, tn.prototype.expand = function(t2, e3, n2, i2) {
          for (var r2 = t2.getChildBoundables().iterator(); r2.hasNext(); ) {
            var o2 = r2.next(), s2 = new tn(o2, e3, this._itemDistance);
            s2.getDistance() < i2 && n2.add(s2);
          }
        }, tn.prototype.getBoundable = function(t2) {
          return 0 === t2 ? this._boundable1 : this._boundable2;
        }, tn.prototype.getDistance = function() {
          return this._distance;
        }, tn.prototype.distance = function() {
          return this.isLeaves() ? this._itemDistance.distance(this._boundable1, this._boundable2) : this._boundable1.getBounds().distance(this._boundable2.getBounds());
        }, tn.prototype.interfaces_ = function() {
          return [E];
        }, tn.prototype.getClass = function() {
          return tn;
        }, tn.area = function(t2) {
          return t2.getBounds().getArea();
        }, tn.isComposite = function(t2) {
          return t2 instanceof Qe;
        };
        var en = function t2() {
          if (this._root = null, this._built = false, this._itemBoundables = new Nt(), this._nodeCapacity = null, 0 === arguments.length) {
            var e3 = t2.DEFAULT_NODE_CAPACITY;
            this._nodeCapacity = e3;
          } else if (1 === arguments.length) {
            var n2 = arguments[0];
            et.isTrue(n2 > 1, "Node capacity must be greater than 1"), this._nodeCapacity = n2;
          }
        }, nn = { IntersectsOp: { configurable: true }, serialVersionUID: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
        en.prototype.getNodeCapacity = function() {
          return this._nodeCapacity;
        }, en.prototype.lastNode = function(t2) {
          return t2.get(t2.size() - 1);
        }, en.prototype.size = function() {
          if (0 === arguments.length)
            return this.isEmpty() ? 0 : (this.build(), this.size(this._root));
          if (1 === arguments.length) {
            for (var t2 = 0, e3 = arguments[0].getChildBoundables().iterator(); e3.hasNext(); ) {
              var n2 = e3.next();
              n2 instanceof Qe ? t2 += this.size(n2) : n2 instanceof He && (t2 += 1);
            }
            return t2;
          }
        }, en.prototype.removeItem = function(t2, e3) {
          for (var n2 = null, i2 = t2.getChildBoundables().iterator(); i2.hasNext(); ) {
            var r2 = i2.next();
            r2 instanceof He && r2.getItem() === e3 && (n2 = r2);
          }
          return null !== n2 && (t2.getChildBoundables().remove(n2), true);
        }, en.prototype.itemsTree = function() {
          if (0 === arguments.length) {
            this.build();
            var t2 = this.itemsTree(this._root);
            return null === t2 ? new Nt() : t2;
          }
          if (1 === arguments.length) {
            for (var e3 = arguments[0], n2 = new Nt(), i2 = e3.getChildBoundables().iterator(); i2.hasNext(); ) {
              var r2 = i2.next();
              if (r2 instanceof Qe) {
                var o2 = this.itemsTree(r2);
                null !== o2 && n2.add(o2);
              } else
                r2 instanceof He ? n2.add(r2.getItem()) : et.shouldNeverReachHere();
            }
            return n2.size() <= 0 ? null : n2;
          }
        }, en.prototype.insert = function(t2, e3) {
          et.isTrue(!this._built, "Cannot insert items into an STR packed R-tree after it has been built."), this._itemBoundables.add(new He(t2, e3));
        }, en.prototype.boundablesAtLevel = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = new Nt();
            return this.boundablesAtLevel(t2, this._root, e3), e3;
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            if (et.isTrue(n2 > -2), i2.getLevel() === n2)
              return r2.add(i2), null;
            for (var o2 = i2.getChildBoundables().iterator(); o2.hasNext(); ) {
              var s2 = o2.next();
              s2 instanceof Qe ? this.boundablesAtLevel(n2, s2, r2) : (et.isTrue(s2 instanceof He), -1 === n2 && r2.add(s2));
            }
            return null;
          }
        }, en.prototype.query = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.build();
            var e3 = new Nt();
            return this.isEmpty() ? e3 : (this.getIntersectsOp().intersects(this._root.getBounds(), t2) && this.query(t2, this._root, e3), e3);
          }
          if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            if (this.build(), this.isEmpty())
              return null;
            this.getIntersectsOp().intersects(this._root.getBounds(), n2) && this.query(n2, this._root, i2);
          } else if (3 === arguments.length) {
            if (T(arguments[2], Ke) && arguments[0] instanceof Object && arguments[1] instanceof Qe)
              for (var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = o2.getChildBoundables(), u2 = 0; u2 < a2.size(); u2++) {
                var l2 = a2.get(u2);
                this.getIntersectsOp().intersects(l2.getBounds(), r2) && (l2 instanceof Qe ? this.query(r2, l2, s2) : l2 instanceof He ? s2.visitItem(l2.getItem()) : et.shouldNeverReachHere());
              }
            else if (T(arguments[2], xt) && arguments[0] instanceof Object && arguments[1] instanceof Qe)
              for (var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = p2.getChildBoundables(), g2 = 0; g2 < f2.size(); g2++) {
                var d2 = f2.get(g2);
                this.getIntersectsOp().intersects(d2.getBounds(), c2) && (d2 instanceof Qe ? this.query(c2, d2, h2) : d2 instanceof He ? h2.add(d2.getItem()) : et.shouldNeverReachHere());
              }
          }
        }, en.prototype.build = function() {
          if (this._built)
            return null;
          this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1), this._itemBoundables = null, this._built = true;
        }, en.prototype.getRoot = function() {
          return this.build(), this._root;
        }, en.prototype.remove = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            return this.build(), !!this.getIntersectsOp().intersects(this._root.getBounds(), t2) && this.remove(t2, this._root, e3);
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = this.removeItem(i2, r2);
            if (o2)
              return true;
            for (var s2 = null, a2 = i2.getChildBoundables().iterator(); a2.hasNext(); ) {
              var u2 = a2.next();
              if (this.getIntersectsOp().intersects(u2.getBounds(), n2) && (u2 instanceof Qe && (o2 = this.remove(n2, u2, r2)))) {
                s2 = u2;
                break;
              }
            }
            return null !== s2 && s2.getChildBoundables().isEmpty() && i2.getChildBoundables().remove(s2), o2;
          }
        }, en.prototype.createHigherLevels = function(t2, e3) {
          et.isTrue(!t2.isEmpty());
          var n2 = this.createParentBoundables(t2, e3 + 1);
          return 1 === n2.size() ? n2.get(0) : this.createHigherLevels(n2, e3 + 1);
        }, en.prototype.depth = function() {
          if (0 === arguments.length)
            return this.isEmpty() ? 0 : (this.build(), this.depth(this._root));
          if (1 === arguments.length) {
            for (var t2 = 0, e3 = arguments[0].getChildBoundables().iterator(); e3.hasNext(); ) {
              var n2 = e3.next();
              if (n2 instanceof Qe) {
                var i2 = this.depth(n2);
                i2 > t2 && (t2 = i2);
              }
            }
            return t2 + 1;
          }
        }, en.prototype.createParentBoundables = function(t2, e3) {
          et.isTrue(!t2.isEmpty());
          var n2 = new Nt();
          n2.add(this.createNode(e3));
          var i2 = new Nt(t2);
          $e.sort(i2, this.getComparator());
          for (var r2 = i2.iterator(); r2.hasNext(); ) {
            var o2 = r2.next();
            this.lastNode(n2).getChildBoundables().size() === this.getNodeCapacity() && n2.add(this.createNode(e3)), this.lastNode(n2).addChildBoundable(o2);
          }
          return n2;
        }, en.prototype.isEmpty = function() {
          return this._built ? this._root.isEmpty() : this._itemBoundables.isEmpty();
        }, en.prototype.interfaces_ = function() {
          return [e];
        }, en.prototype.getClass = function() {
          return en;
        }, en.compareDoubles = function(t2, e3) {
          return t2 > e3 ? 1 : t2 < e3 ? -1 : 0;
        }, nn.IntersectsOp.get = function() {
          return rn;
        }, nn.serialVersionUID.get = function() {
          return -3886435814360241e3;
        }, nn.DEFAULT_NODE_CAPACITY.get = function() {
          return 10;
        }, Object.defineProperties(en, nn);
        var rn = function() {
        }, on = function() {
        };
        on.prototype.distance = function(t2, e3) {
        }, on.prototype.interfaces_ = function() {
          return [];
        }, on.prototype.getClass = function() {
          return on;
        };
        var sn = function(t2) {
          function n2(e3) {
            e3 = e3 || n2.DEFAULT_NODE_CAPACITY, t2.call(this, e3);
          }
          t2 && (n2.__proto__ = t2), (n2.prototype = Object.create(t2 && t2.prototype)).constructor = n2;
          var i2 = { STRtreeNode: { configurable: true }, serialVersionUID: { configurable: true }, xComparator: { configurable: true }, yComparator: { configurable: true }, intersectsOp: { configurable: true }, DEFAULT_NODE_CAPACITY: { configurable: true } };
          return n2.prototype.createParentBoundablesFromVerticalSlices = function(t3, e3) {
            et.isTrue(t3.length > 0);
            for (var n3 = new Nt(), i3 = 0; i3 < t3.length; i3++)
              n3.addAll(this.createParentBoundablesFromVerticalSlice(t3[i3], e3));
            return n3;
          }, n2.prototype.createNode = function(t3) {
            return new an(t3);
          }, n2.prototype.size = function() {
            return 0 === arguments.length ? t2.prototype.size.call(this) : t2.prototype.size.apply(this, arguments);
          }, n2.prototype.insert = function() {
            if (2 !== arguments.length)
              return t2.prototype.insert.apply(this, arguments);
            var e3 = arguments[0], n3 = arguments[1];
            if (e3.isNull())
              return null;
            t2.prototype.insert.call(this, e3, n3);
          }, n2.prototype.getIntersectsOp = function() {
            return n2.intersectsOp;
          }, n2.prototype.verticalSlices = function(t3, e3) {
            for (var n3 = Math.trunc(Math.ceil(t3.size() / e3)), i3 = new Array(e3).fill(null), r2 = t3.iterator(), o2 = 0; o2 < e3; o2++) {
              i3[o2] = new Nt();
              for (var s2 = 0; r2.hasNext() && s2 < n3; ) {
                var a2 = r2.next();
                i3[o2].add(a2), s2++;
              }
            }
            return i3;
          }, n2.prototype.query = function() {
            if (1 === arguments.length) {
              var e3 = arguments[0];
              return t2.prototype.query.call(this, e3);
            }
            if (2 === arguments.length) {
              var n3 = arguments[0], i3 = arguments[1];
              t2.prototype.query.call(this, n3, i3);
            } else if (3 === arguments.length) {
              if (T(arguments[2], Ke) && arguments[0] instanceof Object && arguments[1] instanceof Qe) {
                var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
                t2.prototype.query.call(this, r2, o2, s2);
              } else if (T(arguments[2], xt) && arguments[0] instanceof Object && arguments[1] instanceof Qe) {
                var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2];
                t2.prototype.query.call(this, a2, u2, l2);
              }
            }
          }, n2.prototype.getComparator = function() {
            return n2.yComparator;
          }, n2.prototype.createParentBoundablesFromVerticalSlice = function(e3, n3) {
            return t2.prototype.createParentBoundables.call(this, e3, n3);
          }, n2.prototype.remove = function() {
            if (2 === arguments.length) {
              var e3 = arguments[0], n3 = arguments[1];
              return t2.prototype.remove.call(this, e3, n3);
            }
            return t2.prototype.remove.apply(this, arguments);
          }, n2.prototype.depth = function() {
            return 0 === arguments.length ? t2.prototype.depth.call(this) : t2.prototype.depth.apply(this, arguments);
          }, n2.prototype.createParentBoundables = function(t3, e3) {
            et.isTrue(!t3.isEmpty());
            var i3 = Math.trunc(Math.ceil(t3.size() / this.getNodeCapacity())), r2 = new Nt(t3);
            $e.sort(r2, n2.xComparator);
            var o2 = this.verticalSlices(r2, Math.trunc(Math.ceil(Math.sqrt(i3))));
            return this.createParentBoundablesFromVerticalSlices(o2, e3);
          }, n2.prototype.nearestNeighbour = function() {
            if (1 === arguments.length) {
              if (T(arguments[0], on)) {
                var t3 = arguments[0], e3 = new tn(this.getRoot(), this.getRoot(), t3);
                return this.nearestNeighbour(e3);
              }
              if (arguments[0] instanceof tn) {
                var i3 = arguments[0];
                return this.nearestNeighbour(i3, v.POSITIVE_INFINITY);
              }
            } else if (2 === arguments.length) {
              if (arguments[0] instanceof n2 && T(arguments[1], on)) {
                var r2 = arguments[0], o2 = arguments[1], s2 = new tn(this.getRoot(), r2.getRoot(), o2);
                return this.nearestNeighbour(s2);
              }
              if (arguments[0] instanceof tn && "number" == typeof arguments[1]) {
                var a2 = arguments[0], u2 = arguments[1], l2 = null, c2 = new We();
                for (c2.add(a2); !c2.isEmpty() && u2 > 0; ) {
                  var p2 = c2.poll(), h2 = p2.getDistance();
                  if (h2 >= u2)
                    break;
                  p2.isLeaves() ? (u2 = h2, l2 = p2) : p2.expandToQueue(c2, u2);
                }
                return [l2.getBoundable(0).getItem(), l2.getBoundable(1).getItem()];
              }
            } else if (3 === arguments.length) {
              var f2 = arguments[0], g2 = arguments[1], d2 = arguments[2], y3 = new He(f2, g2), _2 = new tn(this.getRoot(), y3, d2);
              return this.nearestNeighbour(_2)[0];
            }
          }, n2.prototype.interfaces_ = function() {
            return [Je, e];
          }, n2.prototype.getClass = function() {
            return n2;
          }, n2.centreX = function(t3) {
            return n2.avg(t3.getMinX(), t3.getMaxX());
          }, n2.avg = function(t3, e3) {
            return (t3 + e3) / 2;
          }, n2.centreY = function(t3) {
            return n2.avg(t3.getMinY(), t3.getMaxY());
          }, i2.STRtreeNode.get = function() {
            return an;
          }, i2.serialVersionUID.get = function() {
            return 259274702368956900;
          }, i2.xComparator.get = function() {
            return { interfaces_: function() {
              return [N];
            }, compare: function(e3, i3) {
              return t2.compareDoubles(n2.centreX(e3.getBounds()), n2.centreX(i3.getBounds()));
            } };
          }, i2.yComparator.get = function() {
            return { interfaces_: function() {
              return [N];
            }, compare: function(e3, i3) {
              return t2.compareDoubles(n2.centreY(e3.getBounds()), n2.centreY(i3.getBounds()));
            } };
          }, i2.intersectsOp.get = function() {
            return { interfaces_: function() {
              return [t2.IntersectsOp];
            }, intersects: function(t3, e3) {
              return t3.intersects(e3);
            } };
          }, i2.DEFAULT_NODE_CAPACITY.get = function() {
            return 10;
          }, Object.defineProperties(n2, i2), n2;
        }(en), an = function(t2) {
          function e3() {
            var e4 = arguments[0];
            t2.call(this, e4);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.computeBounds = function() {
            for (var t3 = null, e4 = this.getChildBoundables().iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              null === t3 ? t3 = new j(n2.getBounds()) : t3.expandToInclude(n2.getBounds());
            }
            return t3;
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Qe), un = function() {
        };
        un.prototype.interfaces_ = function() {
          return [];
        }, un.prototype.getClass = function() {
          return un;
        }, un.relativeSign = function(t2, e3) {
          return t2 < e3 ? -1 : t2 > e3 ? 1 : 0;
        }, un.compare = function(t2, e3, n2) {
          if (e3.equals2D(n2))
            return 0;
          var i2 = un.relativeSign(e3.x, n2.x), r2 = un.relativeSign(e3.y, n2.y);
          switch (t2) {
            case 0:
              return un.compareValue(i2, r2);
            case 1:
              return un.compareValue(r2, i2);
            case 2:
              return un.compareValue(r2, -i2);
            case 3:
              return un.compareValue(-i2, r2);
            case 4:
              return un.compareValue(-i2, -r2);
            case 5:
              return un.compareValue(-r2, -i2);
            case 6:
              return un.compareValue(-r2, i2);
            case 7:
              return un.compareValue(i2, -r2);
          }
          return et.shouldNeverReachHere("invalid octant value"), 0;
        }, un.compareValue = function(t2, e3) {
          return t2 < 0 ? -1 : t2 > 0 ? 1 : e3 < 0 ? -1 : e3 > 0 ? 1 : 0;
        };
        var ln = function() {
          this._segString = null, this.coord = null, this.segmentIndex = null, this._segmentOctant = null, this._isInterior = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
          this._segString = t2, this.coord = new C(e3), this.segmentIndex = n2, this._segmentOctant = i2, this._isInterior = !e3.equals2D(t2.getCoordinate(n2));
        };
        ln.prototype.getCoordinate = function() {
          return this.coord;
        }, ln.prototype.print = function(t2) {
          t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex);
        }, ln.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.segmentIndex < e3.segmentIndex ? -1 : this.segmentIndex > e3.segmentIndex ? 1 : this.coord.equals2D(e3.coord) ? 0 : un.compare(this._segmentOctant, this.coord, e3.coord);
        }, ln.prototype.isEndPoint = function(t2) {
          return 0 === this.segmentIndex && !this._isInterior || this.segmentIndex === t2;
        }, ln.prototype.isInterior = function() {
          return this._isInterior;
        }, ln.prototype.interfaces_ = function() {
          return [E];
        }, ln.prototype.getClass = function() {
          return ln;
        };
        var cn = function() {
          this._nodeMap = new p(), this._edge = null;
          var t2 = arguments[0];
          this._edge = t2;
        };
        cn.prototype.getSplitCoordinates = function() {
          var t2 = new St();
          this.addEndpoints();
          for (var e3 = this.iterator(), n2 = e3.next(); e3.hasNext(); ) {
            var i2 = e3.next();
            this.addEdgeCoordinates(n2, i2, t2), n2 = i2;
          }
          return t2.toCoordinateArray();
        }, cn.prototype.addCollapsedNodes = function() {
          var t2 = new Nt();
          this.findCollapsesFromInsertedNodes(t2), this.findCollapsesFromExistingVertices(t2);
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next().intValue();
            this.add(this._edge.getCoordinate(n2), n2);
          }
        }, cn.prototype.print = function(t2) {
          t2.println("Intersections:");
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, cn.prototype.findCollapsesFromExistingVertices = function(t2) {
          for (var e3 = 0; e3 < this._edge.size() - 2; e3++) {
            var n2 = this._edge.getCoordinate(e3), i2 = this._edge.getCoordinate(e3 + 2);
            n2.equals2D(i2) && t2.add(new M(e3 + 1));
          }
        }, cn.prototype.addEdgeCoordinates = function(t2, e3, n2) {
          var i2 = this._edge.getCoordinate(e3.segmentIndex), r2 = e3.isInterior() || !e3.coord.equals2D(i2);
          n2.add(new C(t2.coord), false);
          for (var o2 = t2.segmentIndex + 1; o2 <= e3.segmentIndex; o2++)
            n2.add(this._edge.getCoordinate(o2));
          r2 && n2.add(new C(e3.coord));
        }, cn.prototype.iterator = function() {
          return this._nodeMap.values().iterator();
        }, cn.prototype.addSplitEdges = function(t2) {
          this.addEndpoints(), this.addCollapsedNodes();
          for (var e3 = this.iterator(), n2 = e3.next(); e3.hasNext(); ) {
            var i2 = e3.next(), r2 = this.createSplitEdge(n2, i2);
            t2.add(r2), n2 = i2;
          }
        }, cn.prototype.findCollapseIndex = function(t2, e3, n2) {
          if (!t2.coord.equals2D(e3.coord))
            return false;
          var i2 = e3.segmentIndex - t2.segmentIndex;
          return e3.isInterior() || i2--, 1 === i2 && (n2[0] = t2.segmentIndex + 1, true);
        }, cn.prototype.findCollapsesFromInsertedNodes = function(t2) {
          for (var e3 = new Array(1).fill(null), n2 = this.iterator(), i2 = n2.next(); n2.hasNext(); ) {
            var r2 = n2.next();
            this.findCollapseIndex(i2, r2, e3) && t2.add(new M(e3[0])), i2 = r2;
          }
        }, cn.prototype.getEdge = function() {
          return this._edge;
        }, cn.prototype.addEndpoints = function() {
          var t2 = this._edge.size() - 1;
          this.add(this._edge.getCoordinate(0), 0), this.add(this._edge.getCoordinate(t2), t2);
        }, cn.prototype.createSplitEdge = function(t2, e3) {
          var n2 = e3.segmentIndex - t2.segmentIndex + 2, i2 = this._edge.getCoordinate(e3.segmentIndex), r2 = e3.isInterior() || !e3.coord.equals2D(i2);
          r2 || n2--;
          var o2 = new Array(n2).fill(null), s2 = 0;
          o2[s2++] = new C(t2.coord);
          for (var a2 = t2.segmentIndex + 1; a2 <= e3.segmentIndex; a2++)
            o2[s2++] = this._edge.getCoordinate(a2);
          return r2 && (o2[s2] = new C(e3.coord)), new gn(o2, this._edge.getData());
        }, cn.prototype.add = function(t2, e3) {
          var n2 = new ln(this._edge, t2, e3, this._edge.getSegmentOctant(e3)), i2 = this._nodeMap.get(n2);
          return null !== i2 ? (et.isTrue(i2.coord.equals2D(t2), "Found equal nodes with different coordinates"), i2) : (this._nodeMap.put(n2, n2), n2);
        }, cn.prototype.checkSplitEdgesCorrectness = function(t2) {
          var e3 = this._edge.getCoordinates(), n2 = t2.get(0).getCoordinate(0);
          if (!n2.equals2D(e3[0]))
            throw new $("bad split edge start point at " + n2);
          var i2 = t2.get(t2.size() - 1).getCoordinates(), r2 = i2[i2.length - 1];
          if (!r2.equals2D(e3[e3.length - 1]))
            throw new $("bad split edge end point at " + r2);
        }, cn.prototype.interfaces_ = function() {
          return [];
        }, cn.prototype.getClass = function() {
          return cn;
        };
        var pn = function() {
        };
        pn.prototype.interfaces_ = function() {
          return [];
        }, pn.prototype.getClass = function() {
          return pn;
        }, pn.octant = function() {
          if ("number" == typeof arguments[0] && "number" == typeof arguments[1]) {
            var t2 = arguments[0], e3 = arguments[1];
            if (0 === t2 && 0 === e3)
              throw new m("Cannot compute the octant for point ( " + t2 + ", " + e3 + " )");
            var n2 = Math.abs(t2), i2 = Math.abs(e3);
            return t2 >= 0 ? e3 >= 0 ? n2 >= i2 ? 0 : 1 : n2 >= i2 ? 7 : 6 : e3 >= 0 ? n2 >= i2 ? 3 : 2 : n2 >= i2 ? 4 : 5;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof C) {
            var r2 = arguments[0], o2 = arguments[1], s2 = o2.x - r2.x, a2 = o2.y - r2.y;
            if (0 === s2 && 0 === a2)
              throw new m("Cannot compute the octant for two identical points " + r2);
            return pn.octant(s2, a2);
          }
        };
        var hn = function() {
        };
        hn.prototype.getCoordinates = function() {
        }, hn.prototype.size = function() {
        }, hn.prototype.getCoordinate = function(t2) {
        }, hn.prototype.isClosed = function() {
        }, hn.prototype.setData = function(t2) {
        }, hn.prototype.getData = function() {
        }, hn.prototype.interfaces_ = function() {
          return [];
        }, hn.prototype.getClass = function() {
          return hn;
        };
        var fn = function() {
        };
        fn.prototype.addIntersection = function(t2, e3) {
        }, fn.prototype.interfaces_ = function() {
          return [hn];
        }, fn.prototype.getClass = function() {
          return fn;
        };
        var gn = function() {
          this._nodeList = new cn(this), this._pts = null, this._data = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._pts = t2, this._data = e3;
        };
        gn.prototype.getCoordinates = function() {
          return this._pts;
        }, gn.prototype.size = function() {
          return this._pts.length;
        }, gn.prototype.getCoordinate = function(t2) {
          return this._pts[t2];
        }, gn.prototype.isClosed = function() {
          return this._pts[0].equals(this._pts[this._pts.length - 1]);
        }, gn.prototype.getSegmentOctant = function(t2) {
          return t2 === this._pts.length - 1 ? -1 : this.safeOctant(this.getCoordinate(t2), this.getCoordinate(t2 + 1));
        }, gn.prototype.setData = function(t2) {
          this._data = t2;
        }, gn.prototype.safeOctant = function(t2, e3) {
          return t2.equals2D(e3) ? 0 : pn.octant(t2, e3);
        }, gn.prototype.getData = function() {
          return this._data;
        }, gn.prototype.addIntersection = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this.addIntersectionNode(t2, e3);
          } else if (4 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[3], o2 = new C(n2.getIntersection(r2));
            this.addIntersection(o2, i2);
          }
        }, gn.prototype.toString = function() {
          return Z.toLineString(new ue(this._pts));
        }, gn.prototype.getNodeList = function() {
          return this._nodeList;
        }, gn.prototype.addIntersectionNode = function(t2, e3) {
          var n2 = e3, i2 = n2 + 1;
          if (i2 < this._pts.length) {
            var r2 = this._pts[i2];
            t2.equals2D(r2) && (n2 = i2);
          }
          return this._nodeList.add(t2, n2);
        }, gn.prototype.addIntersections = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.getIntersectionNum(); i2++)
            this.addIntersection(t2, e3, n2, i2);
        }, gn.prototype.interfaces_ = function() {
          return [fn];
        }, gn.prototype.getClass = function() {
          return gn;
        }, gn.getNodedSubstrings = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = new Nt();
            return gn.getNodedSubstrings(t2, e3), e3;
          }
          if (2 === arguments.length)
            for (var n2 = arguments[0], i2 = arguments[1], r2 = n2.iterator(); r2.hasNext(); ) {
              r2.next().getNodeList().addSplitEdges(i2);
            }
        };
        var dn = function() {
          if (this.p0 = null, this.p1 = null, 0 === arguments.length)
            this.p0 = new C(), this.p1 = new C();
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this.p0 = new C(t2.p0), this.p1 = new C(t2.p1);
          } else if (2 === arguments.length)
            this.p0 = arguments[0], this.p1 = arguments[1];
          else if (4 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = arguments[3];
            this.p0 = new C(e3, n2), this.p1 = new C(i2, r2);
          }
        }, yn = { serialVersionUID: { configurable: true } };
        dn.prototype.minX = function() {
          return Math.min(this.p0.x, this.p1.x);
        }, dn.prototype.orientationIndex = function() {
          if (arguments[0] instanceof dn) {
            var t2 = arguments[0], e3 = at.orientationIndex(this.p0, this.p1, t2.p0), n2 = at.orientationIndex(this.p0, this.p1, t2.p1);
            return e3 >= 0 && n2 >= 0 ? Math.max(e3, n2) : e3 <= 0 && n2 <= 0 ? Math.max(e3, n2) : 0;
          }
          if (arguments[0] instanceof C) {
            var i2 = arguments[0];
            return at.orientationIndex(this.p0, this.p1, i2);
          }
        }, dn.prototype.toGeometry = function(t2) {
          return t2.createLineString([this.p0, this.p1]);
        }, dn.prototype.isVertical = function() {
          return this.p0.x === this.p1.x;
        }, dn.prototype.equals = function(t2) {
          if (!(t2 instanceof dn))
            return false;
          var e3 = t2;
          return this.p0.equals(e3.p0) && this.p1.equals(e3.p1);
        }, dn.prototype.intersection = function(t2) {
          var e3 = new rt();
          return e3.computeIntersection(this.p0, this.p1, t2.p0, t2.p1), e3.hasIntersection() ? e3.getIntersection(0) : null;
        }, dn.prototype.project = function() {
          if (arguments[0] instanceof C) {
            var t2 = arguments[0];
            if (t2.equals(this.p0) || t2.equals(this.p1))
              return new C(t2);
            var e3 = this.projectionFactor(t2), n2 = new C();
            return n2.x = this.p0.x + e3 * (this.p1.x - this.p0.x), n2.y = this.p0.y + e3 * (this.p1.y - this.p0.y), n2;
          }
          if (arguments[0] instanceof dn) {
            var i2 = arguments[0], r2 = this.projectionFactor(i2.p0), o2 = this.projectionFactor(i2.p1);
            if (r2 >= 1 && o2 >= 1)
              return null;
            if (r2 <= 0 && o2 <= 0)
              return null;
            var s2 = this.project(i2.p0);
            r2 < 0 && (s2 = this.p0), r2 > 1 && (s2 = this.p1);
            var a2 = this.project(i2.p1);
            return o2 < 0 && (a2 = this.p0), o2 > 1 && (a2 = this.p1), new dn(s2, a2);
          }
        }, dn.prototype.normalize = function() {
          this.p1.compareTo(this.p0) < 0 && this.reverse();
        }, dn.prototype.angle = function() {
          return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x);
        }, dn.prototype.getCoordinate = function(t2) {
          return 0 === t2 ? this.p0 : this.p1;
        }, dn.prototype.distancePerpendicular = function(t2) {
          return at.distancePointLinePerpendicular(t2, this.p0, this.p1);
        }, dn.prototype.minY = function() {
          return Math.min(this.p0.y, this.p1.y);
        }, dn.prototype.midPoint = function() {
          return dn.midPoint(this.p0, this.p1);
        }, dn.prototype.projectionFactor = function(t2) {
          if (t2.equals(this.p0))
            return 0;
          if (t2.equals(this.p1))
            return 1;
          var e3 = this.p1.x - this.p0.x, n2 = this.p1.y - this.p0.y, i2 = e3 * e3 + n2 * n2;
          if (i2 <= 0)
            return v.NaN;
          return ((t2.x - this.p0.x) * e3 + (t2.y - this.p0.y) * n2) / i2;
        }, dn.prototype.closestPoints = function(t2) {
          var e3 = this.intersection(t2);
          if (null !== e3)
            return [e3, e3];
          var n2 = new Array(2).fill(null), i2 = v.MAX_VALUE, r2 = null, o2 = this.closestPoint(t2.p0);
          i2 = o2.distance(t2.p0), n2[0] = o2, n2[1] = t2.p0;
          var s2 = this.closestPoint(t2.p1);
          (r2 = s2.distance(t2.p1)) < i2 && (i2 = r2, n2[0] = s2, n2[1] = t2.p1);
          var a2 = t2.closestPoint(this.p0);
          (r2 = a2.distance(this.p0)) < i2 && (i2 = r2, n2[0] = this.p0, n2[1] = a2);
          var u2 = t2.closestPoint(this.p1);
          return (r2 = u2.distance(this.p1)) < i2 && (i2 = r2, n2[0] = this.p1, n2[1] = u2), n2;
        }, dn.prototype.closestPoint = function(t2) {
          var e3 = this.projectionFactor(t2);
          if (e3 > 0 && e3 < 1)
            return this.project(t2);
          return this.p0.distance(t2) < this.p1.distance(t2) ? this.p0 : this.p1;
        }, dn.prototype.maxX = function() {
          return Math.max(this.p0.x, this.p1.x);
        }, dn.prototype.getLength = function() {
          return this.p0.distance(this.p1);
        }, dn.prototype.compareTo = function(t2) {
          var e3 = t2, n2 = this.p0.compareTo(e3.p0);
          return 0 !== n2 ? n2 : this.p1.compareTo(e3.p1);
        }, dn.prototype.reverse = function() {
          var t2 = this.p0;
          this.p0 = this.p1, this.p1 = t2;
        }, dn.prototype.equalsTopo = function(t2) {
          return this.p0.equals(t2.p0) && (this.p1.equals(t2.p1) || this.p0.equals(t2.p1)) && this.p1.equals(t2.p0);
        }, dn.prototype.lineIntersection = function(t2) {
          try {
            return k.intersection(this.p0, this.p1, t2.p0, t2.p1);
          } catch (t3) {
            if (!(t3 instanceof X))
              throw t3;
          }
          return null;
        }, dn.prototype.maxY = function() {
          return Math.max(this.p0.y, this.p1.y);
        }, dn.prototype.pointAlongOffset = function(t2, e3) {
          var n2 = this.p0.x + t2 * (this.p1.x - this.p0.x), i2 = this.p0.y + t2 * (this.p1.y - this.p0.y), r2 = this.p1.x - this.p0.x, o2 = this.p1.y - this.p0.y, s2 = Math.sqrt(r2 * r2 + o2 * o2), a2 = 0, u2 = 0;
          if (0 !== e3) {
            if (s2 <= 0)
              throw new Error("Cannot compute offset from zero-length line segment");
            a2 = e3 * r2 / s2, u2 = e3 * o2 / s2;
          }
          return new C(n2 - u2, i2 + a2);
        }, dn.prototype.setCoordinates = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setCoordinates(t2.p0, t2.p1);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this.p0.x = e3.x, this.p0.y = e3.y, this.p1.x = n2.x, this.p1.y = n2.y;
          }
        }, dn.prototype.segmentFraction = function(t2) {
          var e3 = this.projectionFactor(t2);
          return e3 < 0 ? e3 = 0 : (e3 > 1 || v.isNaN(e3)) && (e3 = 1), e3;
        }, dn.prototype.toString = function() {
          return "LINESTRING( " + this.p0.x + " " + this.p0.y + ", " + this.p1.x + " " + this.p1.y + ")";
        }, dn.prototype.isHorizontal = function() {
          return this.p0.y === this.p1.y;
        }, dn.prototype.distance = function() {
          if (arguments[0] instanceof dn) {
            var t2 = arguments[0];
            return at.distanceLineLine(this.p0, this.p1, t2.p0, t2.p1);
          }
          if (arguments[0] instanceof C) {
            var e3 = arguments[0];
            return at.distancePointLine(e3, this.p0, this.p1);
          }
        }, dn.prototype.pointAlong = function(t2) {
          var e3 = new C();
          return e3.x = this.p0.x + t2 * (this.p1.x - this.p0.x), e3.y = this.p0.y + t2 * (this.p1.y - this.p0.y), e3;
        }, dn.prototype.hashCode = function() {
          var t2 = v.doubleToLongBits(this.p0.x);
          t2 ^= 31 * v.doubleToLongBits(this.p0.y);
          var e3 = Math.trunc(t2) ^ Math.trunc(t2 >> 32), n2 = v.doubleToLongBits(this.p1.x);
          n2 ^= 31 * v.doubleToLongBits(this.p1.y);
          return e3 ^ (Math.trunc(n2) ^ Math.trunc(n2 >> 32));
        }, dn.prototype.interfaces_ = function() {
          return [E, e];
        }, dn.prototype.getClass = function() {
          return dn;
        }, dn.midPoint = function(t2, e3) {
          return new C((t2.x + e3.x) / 2, (t2.y + e3.y) / 2);
        }, yn.serialVersionUID.get = function() {
          return 3252005833466256400;
        }, Object.defineProperties(dn, yn);
        var _n = function() {
          this.tempEnv1 = new j(), this.tempEnv2 = new j(), this._overlapSeg1 = new dn(), this._overlapSeg2 = new dn();
        };
        _n.prototype.overlap = function() {
          if (2 === arguments.length)
            ;
          else if (4 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
            t2.getLineSegment(e3, this._overlapSeg1), n2.getLineSegment(i2, this._overlapSeg2), this.overlap(this._overlapSeg1, this._overlapSeg2);
          }
        }, _n.prototype.interfaces_ = function() {
          return [];
        }, _n.prototype.getClass = function() {
          return _n;
        };
        var mn = function() {
          this._pts = null, this._start = null, this._end = null, this._env = null, this._context = null, this._id = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
          this._pts = t2, this._start = e3, this._end = n2, this._context = i2;
        };
        mn.prototype.getLineSegment = function(t2, e3) {
          e3.p0 = this._pts[t2], e3.p1 = this._pts[t2 + 1];
        }, mn.prototype.computeSelect = function(t2, e3, n2, i2) {
          var r2 = this._pts[e3], o2 = this._pts[n2];
          if (i2.tempEnv1.init(r2, o2), n2 - e3 == 1)
            return i2.select(this, e3), null;
          if (!t2.intersects(i2.tempEnv1))
            return null;
          var s2 = Math.trunc((e3 + n2) / 2);
          e3 < s2 && this.computeSelect(t2, e3, s2, i2), s2 < n2 && this.computeSelect(t2, s2, n2, i2);
        }, mn.prototype.getCoordinates = function() {
          for (var t2 = new Array(this._end - this._start + 1).fill(null), e3 = 0, n2 = this._start; n2 <= this._end; n2++)
            t2[e3++] = this._pts[n2];
          return t2;
        }, mn.prototype.computeOverlaps = function(t2, e3) {
          this.computeOverlapsInternal(this._start, this._end, t2, t2._start, t2._end, e3);
        }, mn.prototype.setId = function(t2) {
          this._id = t2;
        }, mn.prototype.select = function(t2, e3) {
          this.computeSelect(t2, this._start, this._end, e3);
        }, mn.prototype.getEnvelope = function() {
          if (null === this._env) {
            var t2 = this._pts[this._start], e3 = this._pts[this._end];
            this._env = new j(t2, e3);
          }
          return this._env;
        }, mn.prototype.getEndIndex = function() {
          return this._end;
        }, mn.prototype.getStartIndex = function() {
          return this._start;
        }, mn.prototype.getContext = function() {
          return this._context;
        }, mn.prototype.getId = function() {
          return this._id;
        }, mn.prototype.computeOverlapsInternal = function(t2, e3, n2, i2, r2, o2) {
          var s2 = this._pts[t2], a2 = this._pts[e3], u2 = n2._pts[i2], l2 = n2._pts[r2];
          if (e3 - t2 == 1 && r2 - i2 == 1)
            return o2.overlap(this, t2, n2, i2), null;
          if (o2.tempEnv1.init(s2, a2), o2.tempEnv2.init(u2, l2), !o2.tempEnv1.intersects(o2.tempEnv2))
            return null;
          var c2 = Math.trunc((t2 + e3) / 2), p2 = Math.trunc((i2 + r2) / 2);
          t2 < c2 && (i2 < p2 && this.computeOverlapsInternal(t2, c2, n2, i2, p2, o2), p2 < r2 && this.computeOverlapsInternal(t2, c2, n2, p2, r2, o2)), c2 < e3 && (i2 < p2 && this.computeOverlapsInternal(c2, e3, n2, i2, p2, o2), p2 < r2 && this.computeOverlapsInternal(c2, e3, n2, p2, r2, o2));
        }, mn.prototype.interfaces_ = function() {
          return [];
        }, mn.prototype.getClass = function() {
          return mn;
        };
        var vn = function() {
        };
        vn.prototype.interfaces_ = function() {
          return [];
        }, vn.prototype.getClass = function() {
          return vn;
        }, vn.getChainStartIndices = function(t2) {
          var e3 = 0, n2 = new Nt();
          n2.add(new M(e3));
          do {
            var i2 = vn.findChainEnd(t2, e3);
            n2.add(new M(i2)), e3 = i2;
          } while (e3 < t2.length - 1);
          return vn.toIntArray(n2);
        }, vn.findChainEnd = function(t2, e3) {
          for (var n2 = e3; n2 < t2.length - 1 && t2[n2].equals2D(t2[n2 + 1]); )
            n2++;
          if (n2 >= t2.length - 1)
            return t2.length - 1;
          for (var i2 = Be.quadrant(t2[n2], t2[n2 + 1]), r2 = e3 + 1; r2 < t2.length; ) {
            if (!t2[r2 - 1].equals2D(t2[r2])) {
              if (Be.quadrant(t2[r2 - 1], t2[r2]) !== i2)
                break;
            }
            r2++;
          }
          return r2 - 1;
        }, vn.getChains = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return vn.getChains(t2, null);
          }
          if (2 === arguments.length) {
            for (var e3 = arguments[0], n2 = arguments[1], i2 = new Nt(), r2 = vn.getChainStartIndices(e3), o2 = 0; o2 < r2.length - 1; o2++) {
              var s2 = new mn(e3, r2[o2], r2[o2 + 1], n2);
              i2.add(s2);
            }
            return i2;
          }
        }, vn.toIntArray = function(t2) {
          for (var e3 = new Array(t2.size()).fill(null), n2 = 0; n2 < e3.length; n2++)
            e3[n2] = t2.get(n2).intValue();
          return e3;
        };
        var In = function() {
        };
        In.prototype.computeNodes = function(t2) {
        }, In.prototype.getNodedSubstrings = function() {
        }, In.prototype.interfaces_ = function() {
          return [];
        }, In.prototype.getClass = function() {
          return In;
        };
        var En = function() {
          if (this._segInt = null, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setSegmentIntersector(t2);
          }
        };
        En.prototype.setSegmentIntersector = function(t2) {
          this._segInt = t2;
        }, En.prototype.interfaces_ = function() {
          return [In];
        }, En.prototype.getClass = function() {
          return En;
        };
        var xn = function(t2) {
          function e3(e4) {
            e4 ? t2.call(this, e4) : t2.call(this), this._monoChains = new Nt(), this._index = new sn(), this._idCounter = 0, this._nodedSegStrings = null, this._nOverlaps = 0;
          }
          t2 && (e3.__proto__ = t2), (e3.prototype = Object.create(t2 && t2.prototype)).constructor = e3;
          var n2 = { SegmentOverlapAction: { configurable: true } };
          return e3.prototype.getMonotoneChains = function() {
            return this._monoChains;
          }, e3.prototype.getNodedSubstrings = function() {
            return gn.getNodedSubstrings(this._nodedSegStrings);
          }, e3.prototype.getIndex = function() {
            return this._index;
          }, e3.prototype.add = function(t3) {
            for (var e4 = vn.getChains(t3.getCoordinates(), t3).iterator(); e4.hasNext(); ) {
              var n3 = e4.next();
              n3.setId(this._idCounter++), this._index.insert(n3.getEnvelope(), n3), this._monoChains.add(n3);
            }
          }, e3.prototype.computeNodes = function(t3) {
            this._nodedSegStrings = t3;
            for (var e4 = t3.iterator(); e4.hasNext(); )
              this.add(e4.next());
            this.intersectChains();
          }, e3.prototype.intersectChains = function() {
            for (var t3 = new Nn(this._segInt), e4 = this._monoChains.iterator(); e4.hasNext(); )
              for (var n3 = e4.next(), i2 = this._index.query(n3.getEnvelope()).iterator(); i2.hasNext(); ) {
                var r2 = i2.next();
                if (r2.getId() > n3.getId() && (n3.computeOverlaps(r2, t3), this._nOverlaps++), this._segInt.isDone())
                  return null;
              }
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, n2.SegmentOverlapAction.get = function() {
            return Nn;
          }, Object.defineProperties(e3, n2), e3;
        }(En), Nn = function(t2) {
          function e3() {
            t2.call(this), this._si = null;
            var e4 = arguments[0];
            this._si = e4;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.overlap = function() {
            if (4 !== arguments.length)
              return t2.prototype.overlap.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = arguments[3], o2 = e4.getContext(), s2 = i2.getContext();
            this._si.processIntersections(o2, n2, s2, r2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(_n), Cn = function t2() {
          if (this._quadrantSegments = t2.DEFAULT_QUADRANT_SEGMENTS, this._endCapStyle = t2.CAP_ROUND, this._joinStyle = t2.JOIN_ROUND, this._mitreLimit = t2.DEFAULT_MITRE_LIMIT, this._isSingleSided = false, this._simplifyFactor = t2.DEFAULT_SIMPLIFY_FACTOR, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var e3 = arguments[0];
            this.setQuadrantSegments(e3);
          } else if (2 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1];
            this.setQuadrantSegments(n2), this.setEndCapStyle(i2);
          } else if (4 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3];
            this.setQuadrantSegments(r2), this.setEndCapStyle(o2), this.setJoinStyle(s2), this.setMitreLimit(a2);
          }
        }, Sn = { CAP_ROUND: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, JOIN_ROUND: { configurable: true }, JOIN_MITRE: { configurable: true }, JOIN_BEVEL: { configurable: true }, DEFAULT_QUADRANT_SEGMENTS: { configurable: true }, DEFAULT_MITRE_LIMIT: { configurable: true }, DEFAULT_SIMPLIFY_FACTOR: { configurable: true } };
        Cn.prototype.getEndCapStyle = function() {
          return this._endCapStyle;
        }, Cn.prototype.isSingleSided = function() {
          return this._isSingleSided;
        }, Cn.prototype.setQuadrantSegments = function(t2) {
          this._quadrantSegments = t2, 0 === this._quadrantSegments && (this._joinStyle = Cn.JOIN_BEVEL), this._quadrantSegments < 0 && (this._joinStyle = Cn.JOIN_MITRE, this._mitreLimit = Math.abs(this._quadrantSegments)), t2 <= 0 && (this._quadrantSegments = 1), this._joinStyle !== Cn.JOIN_ROUND && (this._quadrantSegments = Cn.DEFAULT_QUADRANT_SEGMENTS);
        }, Cn.prototype.getJoinStyle = function() {
          return this._joinStyle;
        }, Cn.prototype.setJoinStyle = function(t2) {
          this._joinStyle = t2;
        }, Cn.prototype.setSimplifyFactor = function(t2) {
          this._simplifyFactor = t2 < 0 ? 0 : t2;
        }, Cn.prototype.getSimplifyFactor = function() {
          return this._simplifyFactor;
        }, Cn.prototype.getQuadrantSegments = function() {
          return this._quadrantSegments;
        }, Cn.prototype.setEndCapStyle = function(t2) {
          this._endCapStyle = t2;
        }, Cn.prototype.getMitreLimit = function() {
          return this._mitreLimit;
        }, Cn.prototype.setMitreLimit = function(t2) {
          this._mitreLimit = t2;
        }, Cn.prototype.setSingleSided = function(t2) {
          this._isSingleSided = t2;
        }, Cn.prototype.interfaces_ = function() {
          return [];
        }, Cn.prototype.getClass = function() {
          return Cn;
        }, Cn.bufferDistanceError = function(t2) {
          var e3 = Math.PI / 2 / t2;
          return 1 - Math.cos(e3 / 2);
        }, Sn.CAP_ROUND.get = function() {
          return 1;
        }, Sn.CAP_FLAT.get = function() {
          return 2;
        }, Sn.CAP_SQUARE.get = function() {
          return 3;
        }, Sn.JOIN_ROUND.get = function() {
          return 1;
        }, Sn.JOIN_MITRE.get = function() {
          return 2;
        }, Sn.JOIN_BEVEL.get = function() {
          return 3;
        }, Sn.DEFAULT_QUADRANT_SEGMENTS.get = function() {
          return 8;
        }, Sn.DEFAULT_MITRE_LIMIT.get = function() {
          return 5;
        }, Sn.DEFAULT_SIMPLIFY_FACTOR.get = function() {
          return 0.01;
        }, Object.defineProperties(Cn, Sn);
        var Ln = function(t2) {
          this._distanceTol = null, this._isDeleted = null, this._angleOrientation = at.COUNTERCLOCKWISE, this._inputLine = t2 || null;
        }, bn = { INIT: { configurable: true }, DELETE: { configurable: true }, KEEP: { configurable: true }, NUM_PTS_TO_CHECK: { configurable: true } };
        Ln.prototype.isDeletable = function(t2, e3, n2, i2) {
          var r2 = this._inputLine[t2], o2 = this._inputLine[e3], s2 = this._inputLine[n2];
          return !!this.isConcave(r2, o2, s2) && (!!this.isShallow(r2, o2, s2, i2) && this.isShallowSampled(r2, o2, t2, n2, i2));
        }, Ln.prototype.deleteShallowConcavities = function() {
          for (var t2 = 1, e3 = this.findNextNonDeletedIndex(t2), n2 = this.findNextNonDeletedIndex(e3), i2 = false; n2 < this._inputLine.length; ) {
            var r2 = false;
            this.isDeletable(t2, e3, n2, this._distanceTol) && (this._isDeleted[e3] = Ln.DELETE, r2 = true, i2 = true), t2 = r2 ? n2 : e3, e3 = this.findNextNonDeletedIndex(t2), n2 = this.findNextNonDeletedIndex(e3);
          }
          return i2;
        }, Ln.prototype.isShallowConcavity = function(t2, e3, n2, i2) {
          if (!(at.computeOrientation(t2, e3, n2) === this._angleOrientation))
            return false;
          return at.distancePointLine(e3, t2, n2) < i2;
        }, Ln.prototype.isShallowSampled = function(t2, e3, n2, i2, r2) {
          var o2 = Math.trunc((i2 - n2) / Ln.NUM_PTS_TO_CHECK);
          o2 <= 0 && (o2 = 1);
          for (var s2 = n2; s2 < i2; s2 += o2)
            if (!this.isShallow(t2, e3, this._inputLine[s2], r2))
              return false;
          return true;
        }, Ln.prototype.isConcave = function(t2, e3, n2) {
          var i2 = at.computeOrientation(t2, e3, n2) === this._angleOrientation;
          return i2;
        }, Ln.prototype.simplify = function(t2) {
          this._distanceTol = Math.abs(t2), t2 < 0 && (this._angleOrientation = at.CLOCKWISE), this._isDeleted = new Array(this._inputLine.length).fill(null);
          var e3 = false;
          do {
            e3 = this.deleteShallowConcavities();
          } while (e3);
          return this.collapseLine();
        }, Ln.prototype.findNextNonDeletedIndex = function(t2) {
          for (var e3 = t2 + 1; e3 < this._inputLine.length && this._isDeleted[e3] === Ln.DELETE; )
            e3++;
          return e3;
        }, Ln.prototype.isShallow = function(t2, e3, n2, i2) {
          return at.distancePointLine(e3, t2, n2) < i2;
        }, Ln.prototype.collapseLine = function() {
          for (var t2 = new St(), e3 = 0; e3 < this._inputLine.length; e3++)
            this._isDeleted[e3] !== Ln.DELETE && t2.add(this._inputLine[e3]);
          return t2.toCoordinateArray();
        }, Ln.prototype.interfaces_ = function() {
          return [];
        }, Ln.prototype.getClass = function() {
          return Ln;
        }, Ln.simplify = function(t2, e3) {
          return new Ln(t2).simplify(e3);
        }, bn.INIT.get = function() {
          return 0;
        }, bn.DELETE.get = function() {
          return 1;
        }, bn.KEEP.get = function() {
          return 1;
        }, bn.NUM_PTS_TO_CHECK.get = function() {
          return 10;
        }, Object.defineProperties(Ln, bn);
        var wn = function() {
          this._ptList = null, this._precisionModel = null, this._minimimVertexDistance = 0, this._ptList = new Nt();
        }, On = { COORDINATE_ARRAY_TYPE: { configurable: true } };
        wn.prototype.getCoordinates = function() {
          return this._ptList.toArray(wn.COORDINATE_ARRAY_TYPE);
        }, wn.prototype.setPrecisionModel = function(t2) {
          this._precisionModel = t2;
        }, wn.prototype.addPt = function(t2) {
          var e3 = new C(t2);
          if (this._precisionModel.makePrecise(e3), this.isRedundant(e3))
            return null;
          this._ptList.add(e3);
        }, wn.prototype.revere = function() {
        }, wn.prototype.addPts = function(t2, e3) {
          if (e3)
            for (var n2 = 0; n2 < t2.length; n2++)
              this.addPt(t2[n2]);
          else
            for (var i2 = t2.length - 1; i2 >= 0; i2--)
              this.addPt(t2[i2]);
        }, wn.prototype.isRedundant = function(t2) {
          if (this._ptList.size() < 1)
            return false;
          var e3 = this._ptList.get(this._ptList.size() - 1);
          return t2.distance(e3) < this._minimimVertexDistance;
        }, wn.prototype.toString = function() {
          return new _e().createLineString(this.getCoordinates()).toString();
        }, wn.prototype.closeRing = function() {
          if (this._ptList.size() < 1)
            return null;
          var t2 = new C(this._ptList.get(0)), e3 = this._ptList.get(this._ptList.size() - 1);
          if (t2.equals(e3))
            return null;
          this._ptList.add(t2);
        }, wn.prototype.setMinimumVertexDistance = function(t2) {
          this._minimimVertexDistance = t2;
        }, wn.prototype.interfaces_ = function() {
          return [];
        }, wn.prototype.getClass = function() {
          return wn;
        }, On.COORDINATE_ARRAY_TYPE.get = function() {
          return new Array(0).fill(null);
        }, Object.defineProperties(wn, On);
        var Tn = function() {
        }, Rn = { PI_TIMES_2: { configurable: true }, PI_OVER_2: { configurable: true }, PI_OVER_4: { configurable: true }, COUNTERCLOCKWISE: { configurable: true }, CLOCKWISE: { configurable: true }, NONE: { configurable: true } };
        Tn.prototype.interfaces_ = function() {
          return [];
        }, Tn.prototype.getClass = function() {
          return Tn;
        }, Tn.toDegrees = function(t2) {
          return 180 * t2 / Math.PI;
        }, Tn.normalize = function(t2) {
          for (; t2 > Math.PI; )
            t2 -= Tn.PI_TIMES_2;
          for (; t2 <= -Math.PI; )
            t2 += Tn.PI_TIMES_2;
          return t2;
        }, Tn.angle = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return Math.atan2(t2.y, t2.x);
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = n2.x - e3.x, r2 = n2.y - e3.y;
            return Math.atan2(r2, i2);
          }
        }, Tn.isAcute = function(t2, e3, n2) {
          var i2 = t2.x - e3.x, r2 = t2.y - e3.y;
          return i2 * (n2.x - e3.x) + r2 * (n2.y - e3.y) > 0;
        }, Tn.isObtuse = function(t2, e3, n2) {
          var i2 = t2.x - e3.x, r2 = t2.y - e3.y;
          return i2 * (n2.x - e3.x) + r2 * (n2.y - e3.y) < 0;
        }, Tn.interiorAngle = function(t2, e3, n2) {
          var i2 = Tn.angle(e3, t2), r2 = Tn.angle(e3, n2);
          return Math.abs(r2 - i2);
        }, Tn.normalizePositive = function(t2) {
          if (t2 < 0) {
            for (; t2 < 0; )
              t2 += Tn.PI_TIMES_2;
            t2 >= Tn.PI_TIMES_2 && (t2 = 0);
          } else {
            for (; t2 >= Tn.PI_TIMES_2; )
              t2 -= Tn.PI_TIMES_2;
            t2 < 0 && (t2 = 0);
          }
          return t2;
        }, Tn.angleBetween = function(t2, e3, n2) {
          var i2 = Tn.angle(e3, t2), r2 = Tn.angle(e3, n2);
          return Tn.diff(i2, r2);
        }, Tn.diff = function(t2, e3) {
          var n2 = null;
          return (n2 = t2 < e3 ? e3 - t2 : t2 - e3) > Math.PI && (n2 = 2 * Math.PI - n2), n2;
        }, Tn.toRadians = function(t2) {
          return t2 * Math.PI / 180;
        }, Tn.getTurn = function(t2, e3) {
          var n2 = Math.sin(e3 - t2);
          return n2 > 0 ? Tn.COUNTERCLOCKWISE : n2 < 0 ? Tn.CLOCKWISE : Tn.NONE;
        }, Tn.angleBetweenOriented = function(t2, e3, n2) {
          var i2 = Tn.angle(e3, t2), r2 = Tn.angle(e3, n2) - i2;
          return r2 <= -Math.PI ? r2 + Tn.PI_TIMES_2 : r2 > Math.PI ? r2 - Tn.PI_TIMES_2 : r2;
        }, Rn.PI_TIMES_2.get = function() {
          return 2 * Math.PI;
        }, Rn.PI_OVER_2.get = function() {
          return Math.PI / 2;
        }, Rn.PI_OVER_4.get = function() {
          return Math.PI / 4;
        }, Rn.COUNTERCLOCKWISE.get = function() {
          return at.COUNTERCLOCKWISE;
        }, Rn.CLOCKWISE.get = function() {
          return at.CLOCKWISE;
        }, Rn.NONE.get = function() {
          return at.COLLINEAR;
        }, Object.defineProperties(Tn, Rn);
        var Pn = function t2() {
          this._maxCurveSegmentError = 0, this._filletAngleQuantum = null, this._closingSegLengthFactor = 1, this._segList = null, this._distance = 0, this._precisionModel = null, this._bufParams = null, this._li = null, this._s0 = null, this._s1 = null, this._s2 = null, this._seg0 = new dn(), this._seg1 = new dn(), this._offset0 = new dn(), this._offset1 = new dn(), this._side = 0, this._hasNarrowConcaveAngle = false;
          var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
          this._precisionModel = e3, this._bufParams = n2, this._li = new rt(), this._filletAngleQuantum = Math.PI / 2 / n2.getQuadrantSegments(), n2.getQuadrantSegments() >= 8 && n2.getJoinStyle() === Cn.JOIN_ROUND && (this._closingSegLengthFactor = t2.MAX_CLOSING_SEG_LEN_FACTOR), this.init(i2);
        }, Dn = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: true }, INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true }, MAX_CLOSING_SEG_LEN_FACTOR: { configurable: true } };
        Pn.prototype.addNextSegment = function(t2, e3) {
          if (this._s0 = this._s1, this._s1 = this._s2, this._s2 = t2, this._seg0.setCoordinates(this._s0, this._s1), this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0), this._seg1.setCoordinates(this._s1, this._s2), this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1), this._s1.equals(this._s2))
            return null;
          var n2 = at.computeOrientation(this._s0, this._s1, this._s2), i2 = n2 === at.CLOCKWISE && this._side === Se.LEFT || n2 === at.COUNTERCLOCKWISE && this._side === Se.RIGHT;
          0 === n2 ? this.addCollinear(e3) : i2 ? this.addOutsideTurn(n2, e3) : this.addInsideTurn(n2, e3);
        }, Pn.prototype.addLineEndCap = function(t2, e3) {
          var n2 = new dn(t2, e3), i2 = new dn();
          this.computeOffsetSegment(n2, Se.LEFT, this._distance, i2);
          var r2 = new dn();
          this.computeOffsetSegment(n2, Se.RIGHT, this._distance, r2);
          var o2 = e3.x - t2.x, s2 = e3.y - t2.y, a2 = Math.atan2(s2, o2);
          switch (this._bufParams.getEndCapStyle()) {
            case Cn.CAP_ROUND:
              this._segList.addPt(i2.p1), this.addFilletArc(e3, a2 + Math.PI / 2, a2 - Math.PI / 2, at.CLOCKWISE, this._distance), this._segList.addPt(r2.p1);
              break;
            case Cn.CAP_FLAT:
              this._segList.addPt(i2.p1), this._segList.addPt(r2.p1);
              break;
            case Cn.CAP_SQUARE:
              var u2 = new C();
              u2.x = Math.abs(this._distance) * Math.cos(a2), u2.y = Math.abs(this._distance) * Math.sin(a2);
              var l2 = new C(i2.p1.x + u2.x, i2.p1.y + u2.y), c2 = new C(r2.p1.x + u2.x, r2.p1.y + u2.y);
              this._segList.addPt(l2), this._segList.addPt(c2);
          }
        }, Pn.prototype.getCoordinates = function() {
          return this._segList.getCoordinates();
        }, Pn.prototype.addMitreJoin = function(t2, e3, n2, i2) {
          var r2 = true, o2 = null;
          try {
            o2 = k.intersection(e3.p0, e3.p1, n2.p0, n2.p1);
            (i2 <= 0 ? 1 : o2.distance(t2) / Math.abs(i2)) > this._bufParams.getMitreLimit() && (r2 = false);
          } catch (t3) {
            if (!(t3 instanceof X))
              throw t3;
            o2 = new C(0, 0), r2 = false;
          }
          r2 ? this._segList.addPt(o2) : this.addLimitedMitreJoin(e3, n2, i2, this._bufParams.getMitreLimit());
        }, Pn.prototype.addFilletCorner = function(t2, e3, n2, i2, r2) {
          var o2 = e3.x - t2.x, s2 = e3.y - t2.y, a2 = Math.atan2(s2, o2), u2 = n2.x - t2.x, l2 = n2.y - t2.y, c2 = Math.atan2(l2, u2);
          i2 === at.CLOCKWISE ? a2 <= c2 && (a2 += 2 * Math.PI) : a2 >= c2 && (a2 -= 2 * Math.PI), this._segList.addPt(e3), this.addFilletArc(t2, a2, c2, i2, r2), this._segList.addPt(n2);
        }, Pn.prototype.addOutsideTurn = function(t2, e3) {
          if (this._offset0.p1.distance(this._offset1.p0) < this._distance * Pn.OFFSET_SEGMENT_SEPARATION_FACTOR)
            return this._segList.addPt(this._offset0.p1), null;
          this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance) : this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL ? this.addBevelJoin(this._offset0, this._offset1) : (e3 && this._segList.addPt(this._offset0.p1), this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, t2, this._distance), this._segList.addPt(this._offset1.p0));
        }, Pn.prototype.createSquare = function(t2) {
          this._segList.addPt(new C(t2.x + this._distance, t2.y + this._distance)), this._segList.addPt(new C(t2.x + this._distance, t2.y - this._distance)), this._segList.addPt(new C(t2.x - this._distance, t2.y - this._distance)), this._segList.addPt(new C(t2.x - this._distance, t2.y + this._distance)), this._segList.closeRing();
        }, Pn.prototype.addSegments = function(t2, e3) {
          this._segList.addPts(t2, e3);
        }, Pn.prototype.addFirstSegment = function() {
          this._segList.addPt(this._offset1.p0);
        }, Pn.prototype.addLastSegment = function() {
          this._segList.addPt(this._offset1.p1);
        }, Pn.prototype.initSideSegments = function(t2, e3, n2) {
          this._s1 = t2, this._s2 = e3, this._side = n2, this._seg1.setCoordinates(t2, e3), this.computeOffsetSegment(this._seg1, n2, this._distance, this._offset1);
        }, Pn.prototype.addLimitedMitreJoin = function(t2, e3, n2, i2) {
          var r2 = this._seg0.p1, o2 = Tn.angle(r2, this._seg0.p0), s2 = Tn.angleBetweenOriented(this._seg0.p0, r2, this._seg1.p1) / 2, a2 = Tn.normalize(o2 + s2), u2 = Tn.normalize(a2 + Math.PI), l2 = i2 * n2, c2 = n2 - l2 * Math.abs(Math.sin(s2)), p2 = r2.x + l2 * Math.cos(u2), h2 = r2.y + l2 * Math.sin(u2), f2 = new C(p2, h2), g2 = new dn(r2, f2), d2 = g2.pointAlongOffset(1, c2), y3 = g2.pointAlongOffset(1, -c2);
          this._side === Se.LEFT ? (this._segList.addPt(d2), this._segList.addPt(y3)) : (this._segList.addPt(y3), this._segList.addPt(d2));
        }, Pn.prototype.computeOffsetSegment = function(t2, e3, n2, i2) {
          var r2 = e3 === Se.LEFT ? 1 : -1, o2 = t2.p1.x - t2.p0.x, s2 = t2.p1.y - t2.p0.y, a2 = Math.sqrt(o2 * o2 + s2 * s2), u2 = r2 * n2 * o2 / a2, l2 = r2 * n2 * s2 / a2;
          i2.p0.x = t2.p0.x - l2, i2.p0.y = t2.p0.y + u2, i2.p1.x = t2.p1.x - l2, i2.p1.y = t2.p1.y + u2;
        }, Pn.prototype.addFilletArc = function(t2, e3, n2, i2, r2) {
          var o2 = i2 === at.CLOCKWISE ? -1 : 1, s2 = Math.abs(e3 - n2), a2 = Math.trunc(s2 / this._filletAngleQuantum + 0.5);
          if (a2 < 1)
            return null;
          for (var u2 = s2 / a2, l2 = 0, c2 = new C(); l2 < s2; ) {
            var p2 = e3 + o2 * l2;
            c2.x = t2.x + r2 * Math.cos(p2), c2.y = t2.y + r2 * Math.sin(p2), this._segList.addPt(c2), l2 += u2;
          }
        }, Pn.prototype.addInsideTurn = function(t2, e3) {
          if (this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1), this._li.hasIntersection())
            this._segList.addPt(this._li.getIntersection(0));
          else if (this._hasNarrowConcaveAngle = true, this._offset0.p1.distance(this._offset1.p0) < this._distance * Pn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)
            this._segList.addPt(this._offset0.p1);
          else {
            if (this._segList.addPt(this._offset0.p1), this._closingSegLengthFactor > 0) {
              var n2 = new C((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(n2);
              var i2 = new C((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));
              this._segList.addPt(i2);
            } else
              this._segList.addPt(this._s1);
            this._segList.addPt(this._offset1.p0);
          }
        }, Pn.prototype.createCircle = function(t2) {
          var e3 = new C(t2.x + this._distance, t2.y);
          this._segList.addPt(e3), this.addFilletArc(t2, 0, 2 * Math.PI, -1, this._distance), this._segList.closeRing();
        }, Pn.prototype.addBevelJoin = function(t2, e3) {
          this._segList.addPt(t2.p1), this._segList.addPt(e3.p0);
        }, Pn.prototype.init = function(t2) {
          this._distance = t2, this._maxCurveSegmentError = t2 * (1 - Math.cos(this._filletAngleQuantum / 2)), this._segList = new wn(), this._segList.setPrecisionModel(this._precisionModel), this._segList.setMinimumVertexDistance(t2 * Pn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);
        }, Pn.prototype.addCollinear = function(t2) {
          this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);
          this._li.getIntersectionNum() >= 2 && (this._bufParams.getJoinStyle() === Cn.JOIN_BEVEL || this._bufParams.getJoinStyle() === Cn.JOIN_MITRE ? (t2 && this._segList.addPt(this._offset0.p1), this._segList.addPt(this._offset1.p0)) : this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, at.CLOCKWISE, this._distance));
        }, Pn.prototype.closeRing = function() {
          this._segList.closeRing();
        }, Pn.prototype.hasNarrowConcaveAngle = function() {
          return this._hasNarrowConcaveAngle;
        }, Pn.prototype.interfaces_ = function() {
          return [];
        }, Pn.prototype.getClass = function() {
          return Pn;
        }, Dn.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function() {
          return 1e-3;
        }, Dn.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
          return 1e-3;
        }, Dn.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function() {
          return 1e-6;
        }, Dn.MAX_CLOSING_SEG_LEN_FACTOR.get = function() {
          return 80;
        }, Object.defineProperties(Pn, Dn);
        var Mn = function() {
          this._distance = 0, this._precisionModel = null, this._bufParams = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._precisionModel = t2, this._bufParams = e3;
        };
        Mn.prototype.getOffsetCurve = function(t2, e3) {
          if (this._distance = e3, 0 === e3)
            return null;
          var n2 = e3 < 0, i2 = Math.abs(e3), r2 = this.getSegGen(i2);
          t2.length <= 1 ? this.computePointCurve(t2[0], r2) : this.computeOffsetCurve(t2, n2, r2);
          var o2 = r2.getCoordinates();
          return n2 && Lt.reverse(o2), o2;
        }, Mn.prototype.computeSingleSidedBufferCurve = function(t2, e3, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          if (e3) {
            n2.addSegments(t2, true);
            var r2 = Ln.simplify(t2, -i2), o2 = r2.length - 1;
            n2.initSideSegments(r2[o2], r2[o2 - 1], Se.LEFT), n2.addFirstSegment();
            for (var s2 = o2 - 2; s2 >= 0; s2--)
              n2.addNextSegment(r2[s2], true);
          } else {
            n2.addSegments(t2, false);
            var a2 = Ln.simplify(t2, i2), u2 = a2.length - 1;
            n2.initSideSegments(a2[0], a2[1], Se.LEFT), n2.addFirstSegment();
            for (var l2 = 2; l2 <= u2; l2++)
              n2.addNextSegment(a2[l2], true);
          }
          n2.addLastSegment(), n2.closeRing();
        }, Mn.prototype.computeRingBufferCurve = function(t2, e3, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          e3 === Se.RIGHT && (i2 = -i2);
          var r2 = Ln.simplify(t2, i2), o2 = r2.length - 1;
          n2.initSideSegments(r2[o2 - 1], r2[0], e3);
          for (var s2 = 1; s2 <= o2; s2++) {
            var a2 = 1 !== s2;
            n2.addNextSegment(r2[s2], a2);
          }
          n2.closeRing();
        }, Mn.prototype.computeLineBufferCurve = function(t2, e3) {
          var n2 = this.simplifyTolerance(this._distance), i2 = Ln.simplify(t2, n2), r2 = i2.length - 1;
          e3.initSideSegments(i2[0], i2[1], Se.LEFT);
          for (var o2 = 2; o2 <= r2; o2++)
            e3.addNextSegment(i2[o2], true);
          e3.addLastSegment(), e3.addLineEndCap(i2[r2 - 1], i2[r2]);
          var s2 = Ln.simplify(t2, -n2), a2 = s2.length - 1;
          e3.initSideSegments(s2[a2], s2[a2 - 1], Se.LEFT);
          for (var u2 = a2 - 2; u2 >= 0; u2--)
            e3.addNextSegment(s2[u2], true);
          e3.addLastSegment(), e3.addLineEndCap(s2[1], s2[0]), e3.closeRing();
        }, Mn.prototype.computePointCurve = function(t2, e3) {
          switch (this._bufParams.getEndCapStyle()) {
            case Cn.CAP_ROUND:
              e3.createCircle(t2);
              break;
            case Cn.CAP_SQUARE:
              e3.createSquare(t2);
          }
        }, Mn.prototype.getLineCurve = function(t2, e3) {
          if (this._distance = e3, e3 < 0 && !this._bufParams.isSingleSided())
            return null;
          if (0 === e3)
            return null;
          var n2 = Math.abs(e3), i2 = this.getSegGen(n2);
          if (t2.length <= 1)
            this.computePointCurve(t2[0], i2);
          else if (this._bufParams.isSingleSided()) {
            var r2 = e3 < 0;
            this.computeSingleSidedBufferCurve(t2, r2, i2);
          } else
            this.computeLineBufferCurve(t2, i2);
          return i2.getCoordinates();
        }, Mn.prototype.getBufferParameters = function() {
          return this._bufParams;
        }, Mn.prototype.simplifyTolerance = function(t2) {
          return t2 * this._bufParams.getSimplifyFactor();
        }, Mn.prototype.getRingCurve = function(t2, e3, n2) {
          if (this._distance = n2, t2.length <= 2)
            return this.getLineCurve(t2, n2);
          if (0 === n2)
            return Mn.copyCoordinates(t2);
          var i2 = this.getSegGen(n2);
          return this.computeRingBufferCurve(t2, e3, i2), i2.getCoordinates();
        }, Mn.prototype.computeOffsetCurve = function(t2, e3, n2) {
          var i2 = this.simplifyTolerance(this._distance);
          if (e3) {
            var r2 = Ln.simplify(t2, -i2), o2 = r2.length - 1;
            n2.initSideSegments(r2[o2], r2[o2 - 1], Se.LEFT), n2.addFirstSegment();
            for (var s2 = o2 - 2; s2 >= 0; s2--)
              n2.addNextSegment(r2[s2], true);
          } else {
            var a2 = Ln.simplify(t2, i2), u2 = a2.length - 1;
            n2.initSideSegments(a2[0], a2[1], Se.LEFT), n2.addFirstSegment();
            for (var l2 = 2; l2 <= u2; l2++)
              n2.addNextSegment(a2[l2], true);
          }
          n2.addLastSegment();
        }, Mn.prototype.getSegGen = function(t2) {
          return new Pn(this._precisionModel, this._bufParams, t2);
        }, Mn.prototype.interfaces_ = function() {
          return [];
        }, Mn.prototype.getClass = function() {
          return Mn;
        }, Mn.copyCoordinates = function(t2) {
          for (var e3 = new Array(t2.length).fill(null), n2 = 0; n2 < e3.length; n2++)
            e3[n2] = new C(t2[n2]);
          return e3;
        };
        var An = function() {
          this._subgraphs = null, this._seg = new dn(), this._cga = new at();
          var t2 = arguments[0];
          this._subgraphs = t2;
        }, Fn = { DepthSegment: { configurable: true } };
        An.prototype.findStabbedSegments = function() {
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e3 = new Nt(), n2 = this._subgraphs.iterator(); n2.hasNext(); ) {
              var i2 = n2.next(), r2 = i2.getEnvelope();
              t2.y < r2.getMinY() || t2.y > r2.getMaxY() || this.findStabbedSegments(t2, i2.getDirectedEdges(), e3);
            }
            return e3;
          }
          if (3 === arguments.length) {
            if (T(arguments[2], xt) && arguments[0] instanceof C && arguments[1] instanceof ze)
              for (var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2], u2 = s2.getEdge().getCoordinates(), l2 = 0; l2 < u2.length - 1; l2++) {
                this._seg.p0 = u2[l2], this._seg.p1 = u2[l2 + 1], this._seg.p0.y > this._seg.p1.y && this._seg.reverse();
                if (!(Math.max(this._seg.p0.x, this._seg.p1.x) < o2.x) && !(this._seg.isHorizontal() || o2.y < this._seg.p0.y || o2.y > this._seg.p1.y || at.computeOrientation(this._seg.p0, this._seg.p1, o2) === at.RIGHT)) {
                  var c2 = s2.getDepth(Se.LEFT);
                  this._seg.p0.equals(u2[l2]) || (c2 = s2.getDepth(Se.RIGHT));
                  var p2 = new Gn(this._seg, c2);
                  a2.add(p2);
                }
              }
            else if (T(arguments[2], xt) && arguments[0] instanceof C && T(arguments[1], xt))
              for (var h2 = arguments[0], f2 = arguments[1], g2 = arguments[2], d2 = f2.iterator(); d2.hasNext(); ) {
                var y3 = d2.next();
                y3.isForward() && this.findStabbedSegments(h2, y3, g2);
              }
          }
        }, An.prototype.getDepth = function(t2) {
          var e3 = this.findStabbedSegments(t2);
          if (0 === e3.size())
            return 0;
          return $e.min(e3)._leftDepth;
        }, An.prototype.interfaces_ = function() {
          return [];
        }, An.prototype.getClass = function() {
          return An;
        }, Fn.DepthSegment.get = function() {
          return Gn;
        }, Object.defineProperties(An, Fn);
        var Gn = function() {
          this._upwardSeg = null, this._leftDepth = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._upwardSeg = new dn(t2), this._leftDepth = e3;
        };
        Gn.prototype.compareTo = function(t2) {
          var e3 = t2;
          if (this._upwardSeg.minX() >= e3._upwardSeg.maxX())
            return 1;
          if (this._upwardSeg.maxX() <= e3._upwardSeg.minX())
            return -1;
          var n2 = this._upwardSeg.orientationIndex(e3._upwardSeg);
          return 0 !== n2 ? n2 : 0 != (n2 = -1 * e3._upwardSeg.orientationIndex(this._upwardSeg)) ? n2 : this._upwardSeg.compareTo(e3._upwardSeg);
        }, Gn.prototype.compareX = function(t2, e3) {
          var n2 = t2.p0.compareTo(e3.p0);
          return 0 !== n2 ? n2 : t2.p1.compareTo(e3.p1);
        }, Gn.prototype.toString = function() {
          return this._upwardSeg.toString();
        }, Gn.prototype.interfaces_ = function() {
          return [E];
        }, Gn.prototype.getClass = function() {
          return Gn;
        };
        var qn = function(t2, e3, n2) {
          this.p0 = t2 || null, this.p1 = e3 || null, this.p2 = n2 || null;
        };
        qn.prototype.area = function() {
          return qn.area(this.p0, this.p1, this.p2);
        }, qn.prototype.signedArea = function() {
          return qn.signedArea(this.p0, this.p1, this.p2);
        }, qn.prototype.interpolateZ = function(t2) {
          if (null === t2)
            throw new m("Supplied point is null.");
          return qn.interpolateZ(t2, this.p0, this.p1, this.p2);
        }, qn.prototype.longestSideLength = function() {
          return qn.longestSideLength(this.p0, this.p1, this.p2);
        }, qn.prototype.isAcute = function() {
          return qn.isAcute(this.p0, this.p1, this.p2);
        }, qn.prototype.circumcentre = function() {
          return qn.circumcentre(this.p0, this.p1, this.p2);
        }, qn.prototype.area3D = function() {
          return qn.area3D(this.p0, this.p1, this.p2);
        }, qn.prototype.centroid = function() {
          return qn.centroid(this.p0, this.p1, this.p2);
        }, qn.prototype.inCentre = function() {
          return qn.inCentre(this.p0, this.p1, this.p2);
        }, qn.prototype.interfaces_ = function() {
          return [];
        }, qn.prototype.getClass = function() {
          return qn;
        }, qn.area = function(t2, e3, n2) {
          return Math.abs(((n2.x - t2.x) * (e3.y - t2.y) - (e3.x - t2.x) * (n2.y - t2.y)) / 2);
        }, qn.signedArea = function(t2, e3, n2) {
          return ((n2.x - t2.x) * (e3.y - t2.y) - (e3.x - t2.x) * (n2.y - t2.y)) / 2;
        }, qn.det = function(t2, e3, n2, i2) {
          return t2 * i2 - e3 * n2;
        }, qn.interpolateZ = function(t2, e3, n2, i2) {
          var r2 = e3.x, o2 = e3.y, s2 = n2.x - r2, a2 = i2.x - r2, u2 = n2.y - o2, l2 = i2.y - o2, c2 = s2 * l2 - a2 * u2, p2 = t2.x - r2, h2 = t2.y - o2, f2 = (l2 * p2 - a2 * h2) / c2, g2 = (-u2 * p2 + s2 * h2) / c2;
          return e3.z + f2 * (n2.z - e3.z) + g2 * (i2.z - e3.z);
        }, qn.longestSideLength = function(t2, e3, n2) {
          var i2 = t2.distance(e3), r2 = e3.distance(n2), o2 = n2.distance(t2), s2 = i2;
          return r2 > s2 && (s2 = r2), o2 > s2 && (s2 = o2), s2;
        }, qn.isAcute = function(t2, e3, n2) {
          return !!Tn.isAcute(t2, e3, n2) && (!!Tn.isAcute(e3, n2, t2) && !!Tn.isAcute(n2, t2, e3));
        }, qn.circumcentre = function(t2, e3, n2) {
          var i2 = n2.x, r2 = n2.y, o2 = t2.x - i2, s2 = t2.y - r2, a2 = e3.x - i2, u2 = e3.y - r2, l2 = 2 * qn.det(o2, s2, a2, u2), c2 = qn.det(s2, o2 * o2 + s2 * s2, u2, a2 * a2 + u2 * u2), p2 = qn.det(o2, o2 * o2 + s2 * s2, a2, a2 * a2 + u2 * u2);
          return new C(i2 - c2 / l2, r2 + p2 / l2);
        }, qn.perpendicularBisector = function(t2, e3) {
          var n2 = e3.x - t2.x, i2 = e3.y - t2.y, r2 = new k(t2.x + n2 / 2, t2.y + i2 / 2, 1), o2 = new k(t2.x - i2 + n2 / 2, t2.y + n2 + i2 / 2, 1);
          return new k(r2, o2);
        }, qn.angleBisector = function(t2, e3, n2) {
          var i2 = e3.distance(t2), r2 = i2 / (i2 + e3.distance(n2)), o2 = n2.x - t2.x, s2 = n2.y - t2.y;
          return new C(t2.x + r2 * o2, t2.y + r2 * s2);
        }, qn.area3D = function(t2, e3, n2) {
          var i2 = e3.x - t2.x, r2 = e3.y - t2.y, o2 = e3.z - t2.z, s2 = n2.x - t2.x, a2 = n2.y - t2.y, u2 = n2.z - t2.z, l2 = r2 * u2 - o2 * a2, c2 = o2 * s2 - i2 * u2, p2 = i2 * a2 - r2 * s2, h2 = l2 * l2 + c2 * c2 + p2 * p2, f2 = Math.sqrt(h2) / 2;
          return f2;
        }, qn.centroid = function(t2, e3, n2) {
          var i2 = (t2.x + e3.x + n2.x) / 3, r2 = (t2.y + e3.y + n2.y) / 3;
          return new C(i2, r2);
        }, qn.inCentre = function(t2, e3, n2) {
          var i2 = e3.distance(n2), r2 = t2.distance(n2), o2 = t2.distance(e3), s2 = i2 + r2 + o2, a2 = (i2 * t2.x + r2 * e3.x + o2 * n2.x) / s2, u2 = (i2 * t2.y + r2 * e3.y + o2 * n2.y) / s2;
          return new C(a2, u2);
        };
        var Bn = function() {
          this._inputGeom = null, this._distance = null, this._curveBuilder = null, this._curveList = new Nt();
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._inputGeom = t2, this._distance = e3, this._curveBuilder = n2;
        };
        Bn.prototype.addPoint = function(t2) {
          if (this._distance <= 0)
            return null;
          var e3 = t2.getCoordinates(), n2 = this._curveBuilder.getLineCurve(e3, this._distance);
          this.addCurve(n2, w.EXTERIOR, w.INTERIOR);
        }, Bn.prototype.addPolygon = function(t2) {
          var e3 = this._distance, n2 = Se.LEFT;
          this._distance < 0 && (e3 = -this._distance, n2 = Se.RIGHT);
          var i2 = t2.getExteriorRing(), r2 = Lt.removeRepeatedPoints(i2.getCoordinates());
          if (this._distance < 0 && this.isErodedCompletely(i2, this._distance))
            return null;
          if (this._distance <= 0 && r2.length < 3)
            return null;
          this.addPolygonRing(r2, e3, n2, w.EXTERIOR, w.INTERIOR);
          for (var o2 = 0; o2 < t2.getNumInteriorRing(); o2++) {
            var s2 = t2.getInteriorRingN(o2), a2 = Lt.removeRepeatedPoints(s2.getCoordinates());
            this._distance > 0 && this.isErodedCompletely(s2, -this._distance) || this.addPolygonRing(a2, e3, Se.opposite(n2), w.INTERIOR, w.EXTERIOR);
          }
        }, Bn.prototype.isTriangleErodedCompletely = function(t2, e3) {
          var n2 = new qn(t2[0], t2[1], t2[2]), i2 = n2.inCentre();
          return at.distancePointLine(i2, n2.p0, n2.p1) < Math.abs(e3);
        }, Bn.prototype.addLineString = function(t2) {
          if (this._distance <= 0 && !this._curveBuilder.getBufferParameters().isSingleSided())
            return null;
          var e3 = Lt.removeRepeatedPoints(t2.getCoordinates()), n2 = this._curveBuilder.getLineCurve(e3, this._distance);
          this.addCurve(n2, w.EXTERIOR, w.INTERIOR);
        }, Bn.prototype.addCurve = function(t2, e3, n2) {
          if (null === t2 || t2.length < 2)
            return null;
          var i2 = new gn(t2, new Pe(0, w.BOUNDARY, e3, n2));
          this._curveList.add(i2);
        }, Bn.prototype.getCurves = function() {
          return this.add(this._inputGeom), this._curveList;
        }, Bn.prototype.addPolygonRing = function(t2, e3, n2, i2, r2) {
          if (0 === e3 && t2.length < ee.MINIMUM_VALID_SIZE)
            return null;
          var o2 = i2, s2 = r2;
          t2.length >= ee.MINIMUM_VALID_SIZE && at.isCCW(t2) && (o2 = r2, s2 = i2, n2 = Se.opposite(n2));
          var a2 = this._curveBuilder.getRingCurve(t2, n2, e3);
          this.addCurve(a2, o2, s2);
        }, Bn.prototype.add = function(t2) {
          if (t2.isEmpty())
            return null;
          t2 instanceof $t ? this.addPolygon(t2) : t2 instanceof Kt ? this.addLineString(t2) : t2 instanceof Qt ? this.addPoint(t2) : t2 instanceof te ? this.addCollection(t2) : t2 instanceof Xt ? this.addCollection(t2) : t2 instanceof ne ? this.addCollection(t2) : t2 instanceof zt && this.addCollection(t2);
        }, Bn.prototype.isErodedCompletely = function(t2, e3) {
          var n2 = t2.getCoordinates();
          if (n2.length < 4)
            return e3 < 0;
          if (4 === n2.length)
            return this.isTriangleErodedCompletely(n2, e3);
          var i2 = t2.getEnvelopeInternal(), r2 = Math.min(i2.getHeight(), i2.getWidth());
          return e3 < 0 && 2 * Math.abs(e3) > r2;
        }, Bn.prototype.addCollection = function(t2) {
          for (var e3 = 0; e3 < t2.getNumGeometries(); e3++) {
            var n2 = t2.getGeometryN(e3);
            this.add(n2);
          }
        }, Bn.prototype.interfaces_ = function() {
          return [];
        }, Bn.prototype.getClass = function() {
          return Bn;
        };
        var Vn = function() {
        };
        Vn.prototype.locate = function(t2) {
        }, Vn.prototype.interfaces_ = function() {
          return [];
        }, Vn.prototype.getClass = function() {
          return Vn;
        };
        var Un = function() {
          this._parent = null, this._atStart = null, this._max = null, this._index = null, this._subcollectionIterator = null;
          var t2 = arguments[0];
          this._parent = t2, this._atStart = true, this._index = 0, this._max = t2.getNumGeometries();
        };
        Un.prototype.next = function() {
          if (this._atStart)
            return this._atStart = false, Un.isAtomic(this._parent) && this._index++, this._parent;
          if (null !== this._subcollectionIterator) {
            if (this._subcollectionIterator.hasNext())
              return this._subcollectionIterator.next();
            this._subcollectionIterator = null;
          }
          if (this._index >= this._max)
            throw new i();
          var t2 = this._parent.getGeometryN(this._index++);
          return t2 instanceof zt ? (this._subcollectionIterator = new Un(t2), this._subcollectionIterator.next()) : t2;
        }, Un.prototype.remove = function() {
          throw new Error(this.getClass().getName());
        }, Un.prototype.hasNext = function() {
          if (this._atStart)
            return true;
          if (null !== this._subcollectionIterator) {
            if (this._subcollectionIterator.hasNext())
              return true;
            this._subcollectionIterator = null;
          }
          return !(this._index >= this._max);
        }, Un.prototype.interfaces_ = function() {
          return [Et];
        }, Un.prototype.getClass = function() {
          return Un;
        }, Un.isAtomic = function(t2) {
          return !(t2 instanceof zt);
        };
        var zn = function() {
          this._geom = null;
          var t2 = arguments[0];
          this._geom = t2;
        };
        zn.prototype.locate = function(t2) {
          return zn.locate(t2, this._geom);
        }, zn.prototype.interfaces_ = function() {
          return [Vn];
        }, zn.prototype.getClass = function() {
          return zn;
        }, zn.isPointInRing = function(t2, e3) {
          return !!e3.getEnvelopeInternal().intersects(t2) && at.isPointInRing(t2, e3.getCoordinates());
        }, zn.containsPointInPolygon = function(t2, e3) {
          if (e3.isEmpty())
            return false;
          var n2 = e3.getExteriorRing();
          if (!zn.isPointInRing(t2, n2))
            return false;
          for (var i2 = 0; i2 < e3.getNumInteriorRing(); i2++) {
            var r2 = e3.getInteriorRingN(i2);
            if (zn.isPointInRing(t2, r2))
              return false;
          }
          return true;
        }, zn.containsPoint = function(t2, e3) {
          if (e3 instanceof $t)
            return zn.containsPointInPolygon(t2, e3);
          if (e3 instanceof zt)
            for (var n2 = new Un(e3); n2.hasNext(); ) {
              var i2 = n2.next();
              if (i2 !== e3 && zn.containsPoint(t2, i2))
                return true;
            }
          return false;
        }, zn.locate = function(t2, e3) {
          return e3.isEmpty() ? w.EXTERIOR : zn.containsPoint(t2, e3) ? w.INTERIOR : w.EXTERIOR;
        };
        var Xn = function() {
          this._edgeMap = new p(), this._edgeList = null, this._ptInAreaLocation = [w.NONE, w.NONE];
        };
        Xn.prototype.getNextCW = function(t2) {
          this.getEdges();
          var e3 = this._edgeList.indexOf(t2), n2 = e3 - 1;
          return 0 === e3 && (n2 = this._edgeList.size() - 1), this._edgeList.get(n2);
        }, Xn.prototype.propagateSideLabels = function(t2) {
          for (var e3 = w.NONE, n2 = this.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().getLabel();
            i2.isArea(t2) && i2.getLocation(t2, Se.LEFT) !== w.NONE && (e3 = i2.getLocation(t2, Se.LEFT));
          }
          if (e3 === w.NONE)
            return null;
          for (var r2 = e3, o2 = this.iterator(); o2.hasNext(); ) {
            var s2 = o2.next(), a2 = s2.getLabel();
            if (a2.getLocation(t2, Se.ON) === w.NONE && a2.setLocation(t2, Se.ON, r2), a2.isArea(t2)) {
              var u2 = a2.getLocation(t2, Se.LEFT), l2 = a2.getLocation(t2, Se.RIGHT);
              if (l2 !== w.NONE) {
                if (l2 !== r2)
                  throw new we("side location conflict", s2.getCoordinate());
                u2 === w.NONE && et.shouldNeverReachHere("found single null side (at " + s2.getCoordinate() + ")"), r2 = u2;
              } else
                et.isTrue(a2.getLocation(t2, Se.LEFT) === w.NONE, "found single null side"), a2.setLocation(t2, Se.RIGHT, r2), a2.setLocation(t2, Se.LEFT, r2);
            }
          }
        }, Xn.prototype.getCoordinate = function() {
          var t2 = this.iterator();
          if (!t2.hasNext())
            return null;
          return t2.next().getCoordinate();
        }, Xn.prototype.print = function(t2) {
          Y.out.println("EdgeEndStar:   " + this.getCoordinate());
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, Xn.prototype.isAreaLabelsConsistent = function(t2) {
          return this.computeEdgeEndLabels(t2.getBoundaryNodeRule()), this.checkAreaLabelsConsistent(0);
        }, Xn.prototype.checkAreaLabelsConsistent = function(t2) {
          var e3 = this.getEdges();
          if (e3.size() <= 0)
            return true;
          var n2 = e3.size() - 1, i2 = e3.get(n2).getLabel().getLocation(t2, Se.LEFT);
          et.isTrue(i2 !== w.NONE, "Found unlabelled area edge");
          for (var r2 = i2, o2 = this.iterator(); o2.hasNext(); ) {
            var s2 = o2.next().getLabel();
            et.isTrue(s2.isArea(t2), "Found non-area edge");
            var a2 = s2.getLocation(t2, Se.LEFT), u2 = s2.getLocation(t2, Se.RIGHT);
            if (a2 === u2)
              return false;
            if (u2 !== r2)
              return false;
            r2 = a2;
          }
          return true;
        }, Xn.prototype.findIndex = function(t2) {
          this.iterator();
          for (var e3 = 0; e3 < this._edgeList.size(); e3++) {
            if (this._edgeList.get(e3) === t2)
              return e3;
          }
          return -1;
        }, Xn.prototype.iterator = function() {
          return this.getEdges().iterator();
        }, Xn.prototype.getEdges = function() {
          return null === this._edgeList && (this._edgeList = new Nt(this._edgeMap.values())), this._edgeList;
        }, Xn.prototype.getLocation = function(t2, e3, n2) {
          return this._ptInAreaLocation[t2] === w.NONE && (this._ptInAreaLocation[t2] = zn.locate(e3, n2[t2].getGeometry())), this._ptInAreaLocation[t2];
        }, Xn.prototype.toString = function() {
          var t2 = new D();
          t2.append("EdgeEndStar:   " + this.getCoordinate()), t2.append("\n");
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            t2.append(n2), t2.append("\n");
          }
          return t2.toString();
        }, Xn.prototype.computeEdgeEndLabels = function(t2) {
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().computeLabel(t2);
          }
        }, Xn.prototype.computeLabelling = function(t2) {
          this.computeEdgeEndLabels(t2[0].getBoundaryNodeRule()), this.propagateSideLabels(0), this.propagateSideLabels(1);
          for (var e3 = [false, false], n2 = this.iterator(); n2.hasNext(); )
            for (var i2 = n2.next().getLabel(), r2 = 0; r2 < 2; r2++)
              i2.isLine(r2) && i2.getLocation(r2) === w.BOUNDARY && (e3[r2] = true);
          for (var o2 = this.iterator(); o2.hasNext(); )
            for (var s2 = o2.next(), a2 = s2.getLabel(), u2 = 0; u2 < 2; u2++)
              if (a2.isAnyNull(u2)) {
                var l2 = w.NONE;
                if (e3[u2])
                  l2 = w.EXTERIOR;
                else {
                  var c2 = s2.getCoordinate();
                  l2 = this.getLocation(u2, c2, t2);
                }
                a2.setAllLocationsIfNull(u2, l2);
              }
        }, Xn.prototype.getDegree = function() {
          return this._edgeMap.size();
        }, Xn.prototype.insertEdgeEnd = function(t2, e3) {
          this._edgeMap.put(t2, e3), this._edgeList = null;
        }, Xn.prototype.interfaces_ = function() {
          return [];
        }, Xn.prototype.getClass = function() {
          return Xn;
        };
        var Yn = function(t2) {
          function e3() {
            t2.call(this), this._resultAreaEdgeList = null, this._label = null, this._SCANNING_FOR_INCOMING = 1, this._LINKING_TO_OUTGOING = 2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.linkResultDirectedEdges = function() {
            this.getResultAreaEdges();
            for (var t3 = null, e4 = null, n2 = this._SCANNING_FOR_INCOMING, i2 = 0; i2 < this._resultAreaEdgeList.size(); i2++) {
              var r2 = this._resultAreaEdgeList.get(i2), o2 = r2.getSym();
              if (r2.getLabel().isArea())
                switch (null === t3 && r2.isInResult() && (t3 = r2), n2) {
                  case this._SCANNING_FOR_INCOMING:
                    if (!o2.isInResult())
                      continue;
                    e4 = o2, n2 = this._LINKING_TO_OUTGOING;
                    break;
                  case this._LINKING_TO_OUTGOING:
                    if (!r2.isInResult())
                      continue;
                    e4.setNext(r2), n2 = this._SCANNING_FOR_INCOMING;
                }
            }
            if (n2 === this._LINKING_TO_OUTGOING) {
              if (null === t3)
                throw new we("no outgoing dirEdge found", this.getCoordinate());
              et.isTrue(t3.isInResult(), "unable to link last incoming dirEdge"), e4.setNext(t3);
            }
          }, e3.prototype.insert = function(t3) {
            var e4 = t3;
            this.insertEdgeEnd(e4, e4);
          }, e3.prototype.getRightmostEdge = function() {
            var t3 = this.getEdges(), e4 = t3.size();
            if (e4 < 1)
              return null;
            var n2 = t3.get(0);
            if (1 === e4)
              return n2;
            var i2 = t3.get(e4 - 1), r2 = n2.getQuadrant(), o2 = i2.getQuadrant();
            return Be.isNorthern(r2) && Be.isNorthern(o2) ? n2 : Be.isNorthern(r2) || Be.isNorthern(o2) ? 0 !== n2.getDy() ? n2 : 0 !== i2.getDy() ? i2 : (et.shouldNeverReachHere("found two horizontal edges incident on node"), null) : i2;
          }, e3.prototype.print = function(t3) {
            Y.out.println("DirectedEdgeStar: " + this.getCoordinate());
            for (var e4 = this.iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              t3.print("out "), n2.print(t3), t3.println(), t3.print("in "), n2.getSym().print(t3), t3.println();
            }
          }, e3.prototype.getResultAreaEdges = function() {
            if (null !== this._resultAreaEdgeList)
              return this._resultAreaEdgeList;
            this._resultAreaEdgeList = new Nt();
            for (var t3 = this.iterator(); t3.hasNext(); ) {
              var e4 = t3.next();
              (e4.isInResult() || e4.getSym().isInResult()) && this._resultAreaEdgeList.add(e4);
            }
            return this._resultAreaEdgeList;
          }, e3.prototype.updateLabelling = function(t3) {
            for (var e4 = this.iterator(); e4.hasNext(); ) {
              var n2 = e4.next().getLabel();
              n2.setAllLocationsIfNull(0, t3.getLocation(0)), n2.setAllLocationsIfNull(1, t3.getLocation(1));
            }
          }, e3.prototype.linkAllDirectedEdges = function() {
            this.getEdges();
            for (var t3 = null, e4 = null, n2 = this._edgeList.size() - 1; n2 >= 0; n2--) {
              var i2 = this._edgeList.get(n2), r2 = i2.getSym();
              null === e4 && (e4 = r2), null !== t3 && r2.setNext(t3), t3 = i2;
            }
            e4.setNext(t3);
          }, e3.prototype.computeDepths = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0], e4 = this.findIndex(t3), n2 = t3.getDepth(Se.LEFT), i2 = t3.getDepth(Se.RIGHT), r2 = this.computeDepths(e4 + 1, this._edgeList.size(), n2);
              if (this.computeDepths(0, e4, r2) !== i2)
                throw new we("depth mismatch at " + t3.getCoordinate());
            } else if (3 === arguments.length) {
              for (var o2 = arguments[0], s2 = arguments[1], a2 = arguments[2], u2 = o2; u2 < s2; u2++) {
                var l2 = this._edgeList.get(u2);
                l2.setEdgeDepths(Se.RIGHT, a2), a2 = l2.getDepth(Se.LEFT);
              }
              return a2;
            }
          }, e3.prototype.mergeSymLabels = function() {
            for (var t3 = this.iterator(); t3.hasNext(); ) {
              var e4 = t3.next();
              e4.getLabel().merge(e4.getSym().getLabel());
            }
          }, e3.prototype.linkMinimalDirectedEdges = function(t3) {
            for (var e4 = null, n2 = null, i2 = this._SCANNING_FOR_INCOMING, r2 = this._resultAreaEdgeList.size() - 1; r2 >= 0; r2--) {
              var o2 = this._resultAreaEdgeList.get(r2), s2 = o2.getSym();
              switch (null === e4 && o2.getEdgeRing() === t3 && (e4 = o2), i2) {
                case this._SCANNING_FOR_INCOMING:
                  if (s2.getEdgeRing() !== t3)
                    continue;
                  n2 = s2, i2 = this._LINKING_TO_OUTGOING;
                  break;
                case this._LINKING_TO_OUTGOING:
                  if (o2.getEdgeRing() !== t3)
                    continue;
                  n2.setNextMin(o2), i2 = this._SCANNING_FOR_INCOMING;
              }
            }
            i2 === this._LINKING_TO_OUTGOING && (et.isTrue(null !== e4, "found null for first outgoing dirEdge"), et.isTrue(e4.getEdgeRing() === t3, "unable to link last incoming dirEdge"), n2.setNextMin(e4));
          }, e3.prototype.getOutgoingDegree = function() {
            if (0 === arguments.length) {
              for (var t3 = 0, e4 = this.iterator(); e4.hasNext(); ) {
                e4.next().isInResult() && t3++;
              }
              return t3;
            }
            if (1 === arguments.length) {
              for (var n2 = arguments[0], i2 = 0, r2 = this.iterator(); r2.hasNext(); ) {
                r2.next().getEdgeRing() === n2 && i2++;
              }
              return i2;
            }
          }, e3.prototype.getLabel = function() {
            return this._label;
          }, e3.prototype.findCoveredLineEdges = function() {
            for (var t3 = w.NONE, e4 = this.iterator(); e4.hasNext(); ) {
              var n2 = e4.next(), i2 = n2.getSym();
              if (!n2.isLineEdge()) {
                if (n2.isInResult()) {
                  t3 = w.INTERIOR;
                  break;
                }
                if (i2.isInResult()) {
                  t3 = w.EXTERIOR;
                  break;
                }
              }
            }
            if (t3 === w.NONE)
              return null;
            for (var r2 = t3, o2 = this.iterator(); o2.hasNext(); ) {
              var s2 = o2.next(), a2 = s2.getSym();
              s2.isLineEdge() ? s2.getEdge().setCovered(r2 === w.INTERIOR) : (s2.isInResult() && (r2 = w.EXTERIOR), a2.isInResult() && (r2 = w.INTERIOR));
            }
          }, e3.prototype.computeLabelling = function(e4) {
            t2.prototype.computeLabelling.call(this, e4), this._label = new Pe(w.NONE);
            for (var n2 = this.iterator(); n2.hasNext(); )
              for (var i2 = n2.next().getEdge().getLabel(), r2 = 0; r2 < 2; r2++) {
                var o2 = i2.getLocation(r2);
                o2 !== w.INTERIOR && o2 !== w.BOUNDARY || this._label.setLocation(r2, w.INTERIOR);
              }
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Xn), kn = function(t2) {
          function e3() {
            t2.apply(this, arguments);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.createNode = function(t3) {
            return new Ge(t3, new Yn());
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Xe), jn = function t2() {
          this._pts = null, this._orientation = null;
          var e3 = arguments[0];
          this._pts = e3, this._orientation = t2.orientation(e3);
        };
        jn.prototype.compareTo = function(t2) {
          var e3 = t2;
          return jn.compareOriented(this._pts, this._orientation, e3._pts, e3._orientation);
        }, jn.prototype.interfaces_ = function() {
          return [E];
        }, jn.prototype.getClass = function() {
          return jn;
        }, jn.orientation = function(t2) {
          return 1 === Lt.increasingDirection(t2);
        }, jn.compareOriented = function(t2, e3, n2, i2) {
          for (var r2 = e3 ? 1 : -1, o2 = i2 ? 1 : -1, s2 = e3 ? t2.length : -1, a2 = i2 ? n2.length : -1, u2 = e3 ? 0 : t2.length - 1, l2 = i2 ? 0 : n2.length - 1; ; ) {
            var c2 = t2[u2].compareTo(n2[l2]);
            if (0 !== c2)
              return c2;
            var p2 = (u2 += r2) === s2, h2 = (l2 += o2) === a2;
            if (p2 && !h2)
              return -1;
            if (!p2 && h2)
              return 1;
            if (p2 && h2)
              return 0;
          }
        };
        var Hn = function() {
          this._edges = new Nt(), this._ocaMap = new p();
        };
        Hn.prototype.print = function(t2) {
          t2.print("MULTILINESTRING ( ");
          for (var e3 = 0; e3 < this._edges.size(); e3++) {
            var n2 = this._edges.get(e3);
            e3 > 0 && t2.print(","), t2.print("(");
            for (var i2 = n2.getCoordinates(), r2 = 0; r2 < i2.length; r2++)
              r2 > 0 && t2.print(","), t2.print(i2[r2].x + " " + i2[r2].y);
            t2.println(")");
          }
          t2.print(")  ");
        }, Hn.prototype.addAll = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); )
            this.add(e3.next());
        }, Hn.prototype.findEdgeIndex = function(t2) {
          for (var e3 = 0; e3 < this._edges.size(); e3++)
            if (this._edges.get(e3).equals(t2))
              return e3;
          return -1;
        }, Hn.prototype.iterator = function() {
          return this._edges.iterator();
        }, Hn.prototype.getEdges = function() {
          return this._edges;
        }, Hn.prototype.get = function(t2) {
          return this._edges.get(t2);
        }, Hn.prototype.findEqualEdge = function(t2) {
          var e3 = new jn(t2.getCoordinates());
          return this._ocaMap.get(e3);
        }, Hn.prototype.add = function(t2) {
          this._edges.add(t2);
          var e3 = new jn(t2.getCoordinates());
          this._ocaMap.put(e3, t2);
        }, Hn.prototype.interfaces_ = function() {
          return [];
        }, Hn.prototype.getClass = function() {
          return Hn;
        };
        var Wn = function() {
        };
        Wn.prototype.processIntersections = function(t2, e3, n2, i2) {
        }, Wn.prototype.isDone = function() {
        }, Wn.prototype.interfaces_ = function() {
          return [];
        }, Wn.prototype.getClass = function() {
          return Wn;
        };
        var Kn = function() {
          this._hasIntersection = false, this._hasProper = false, this._hasProperInterior = false, this._hasInterior = false, this._properIntersectionPoint = null, this._li = null, this._isSelfIntersection = null, this.numIntersections = 0, this.numInteriorIntersections = 0, this.numProperIntersections = 0, this.numTests = 0;
          var t2 = arguments[0];
          this._li = t2;
        };
        Kn.prototype.isTrivialIntersection = function(t2, e3, n2, i2) {
          if (t2 === n2 && 1 === this._li.getIntersectionNum()) {
            if (Kn.isAdjacentSegments(e3, i2))
              return true;
            if (t2.isClosed()) {
              var r2 = t2.size() - 1;
              if (0 === e3 && i2 === r2 || 0 === i2 && e3 === r2)
                return true;
            }
          }
          return false;
        }, Kn.prototype.getProperIntersectionPoint = function() {
          return this._properIntersectionPoint;
        }, Kn.prototype.hasProperInteriorIntersection = function() {
          return this._hasProperInterior;
        }, Kn.prototype.getLineIntersector = function() {
          return this._li;
        }, Kn.prototype.hasProperIntersection = function() {
          return this._hasProper;
        }, Kn.prototype.processIntersections = function(t2, e3, n2, i2) {
          if (t2 === n2 && e3 === i2)
            return null;
          this.numTests++;
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
          this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && (this.numIntersections++, this._li.isInteriorIntersection() && (this.numInteriorIntersections++, this._hasInterior = true), this.isTrivialIntersection(t2, e3, n2, i2) || (this._hasIntersection = true, t2.addIntersections(this._li, e3, 0), n2.addIntersections(this._li, i2, 1), this._li.isProper() && (this.numProperIntersections++, this._hasProper = true, this._hasProperInterior = true)));
        }, Kn.prototype.hasIntersection = function() {
          return this._hasIntersection;
        }, Kn.prototype.isDone = function() {
          return false;
        }, Kn.prototype.hasInteriorIntersection = function() {
          return this._hasInterior;
        }, Kn.prototype.interfaces_ = function() {
          return [Wn];
        }, Kn.prototype.getClass = function() {
          return Kn;
        }, Kn.isAdjacentSegments = function(t2, e3) {
          return 1 === Math.abs(t2 - e3);
        };
        var Jn = function() {
          this.coord = null, this.segmentIndex = null, this.dist = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this.coord = new C(t2), this.segmentIndex = e3, this.dist = n2;
        };
        Jn.prototype.getSegmentIndex = function() {
          return this.segmentIndex;
        }, Jn.prototype.getCoordinate = function() {
          return this.coord;
        }, Jn.prototype.print = function(t2) {
          t2.print(this.coord), t2.print(" seg # = " + this.segmentIndex), t2.println(" dist = " + this.dist);
        }, Jn.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this.compare(e3.segmentIndex, e3.dist);
        }, Jn.prototype.isEndPoint = function(t2) {
          return 0 === this.segmentIndex && 0 === this.dist || this.segmentIndex === t2;
        }, Jn.prototype.toString = function() {
          return this.coord + " seg # = " + this.segmentIndex + " dist = " + this.dist;
        }, Jn.prototype.getDistance = function() {
          return this.dist;
        }, Jn.prototype.compare = function(t2, e3) {
          return this.segmentIndex < t2 ? -1 : this.segmentIndex > t2 ? 1 : this.dist < e3 ? -1 : this.dist > e3 ? 1 : 0;
        }, Jn.prototype.interfaces_ = function() {
          return [E];
        }, Jn.prototype.getClass = function() {
          return Jn;
        };
        var Qn = function() {
          this._nodeMap = new p(), this.edge = null;
          var t2 = arguments[0];
          this.edge = t2;
        };
        Qn.prototype.print = function(t2) {
          t2.println("Intersections:");
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            e3.next().print(t2);
          }
        }, Qn.prototype.iterator = function() {
          return this._nodeMap.values().iterator();
        }, Qn.prototype.addSplitEdges = function(t2) {
          this.addEndpoints();
          for (var e3 = this.iterator(), n2 = e3.next(); e3.hasNext(); ) {
            var i2 = e3.next(), r2 = this.createSplitEdge(n2, i2);
            t2.add(r2), n2 = i2;
          }
        }, Qn.prototype.addEndpoints = function() {
          var t2 = this.edge.pts.length - 1;
          this.add(this.edge.pts[0], 0, 0), this.add(this.edge.pts[t2], t2, 0);
        }, Qn.prototype.createSplitEdge = function(t2, e3) {
          var n2 = e3.segmentIndex - t2.segmentIndex + 2, i2 = this.edge.pts[e3.segmentIndex], r2 = e3.dist > 0 || !e3.coord.equals2D(i2);
          r2 || n2--;
          var o2 = new Array(n2).fill(null), s2 = 0;
          o2[s2++] = new C(t2.coord);
          for (var a2 = t2.segmentIndex + 1; a2 <= e3.segmentIndex; a2++)
            o2[s2++] = this.edge.pts[a2];
          return r2 && (o2[s2] = e3.coord), new ni(o2, new Pe(this.edge._label));
        }, Qn.prototype.add = function(t2, e3, n2) {
          var i2 = new Jn(t2, e3, n2), r2 = this._nodeMap.get(i2);
          return null !== r2 ? r2 : (this._nodeMap.put(i2, i2), i2);
        }, Qn.prototype.isIntersection = function(t2) {
          for (var e3 = this.iterator(); e3.hasNext(); ) {
            if (e3.next().coord.equals(t2))
              return true;
          }
          return false;
        }, Qn.prototype.interfaces_ = function() {
          return [];
        }, Qn.prototype.getClass = function() {
          return Qn;
        };
        var Zn = function() {
        };
        Zn.prototype.getChainStartIndices = function(t2) {
          var e3 = 0, n2 = new Nt();
          n2.add(new M(e3));
          do {
            var i2 = this.findChainEnd(t2, e3);
            n2.add(new M(i2)), e3 = i2;
          } while (e3 < t2.length - 1);
          return Zn.toIntArray(n2);
        }, Zn.prototype.findChainEnd = function(t2, e3) {
          for (var n2 = Be.quadrant(t2[e3], t2[e3 + 1]), i2 = e3 + 1; i2 < t2.length; ) {
            if (Be.quadrant(t2[i2 - 1], t2[i2]) !== n2)
              break;
            i2++;
          }
          return i2 - 1;
        }, Zn.prototype.interfaces_ = function() {
          return [];
        }, Zn.prototype.getClass = function() {
          return Zn;
        }, Zn.toIntArray = function(t2) {
          for (var e3 = new Array(t2.size()).fill(null), n2 = 0; n2 < e3.length; n2++)
            e3[n2] = t2.get(n2).intValue();
          return e3;
        };
        var $n = function() {
          this.e = null, this.pts = null, this.startIndex = null, this.env1 = new j(), this.env2 = new j();
          var t2 = arguments[0];
          this.e = t2, this.pts = t2.getCoordinates();
          var e3 = new Zn();
          this.startIndex = e3.getChainStartIndices(this.pts);
        };
        $n.prototype.getCoordinates = function() {
          return this.pts;
        }, $n.prototype.getMaxX = function(t2) {
          var e3 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
          return e3 > n2 ? e3 : n2;
        }, $n.prototype.getMinX = function(t2) {
          var e3 = this.pts[this.startIndex[t2]].x, n2 = this.pts[this.startIndex[t2 + 1]].x;
          return e3 < n2 ? e3 : n2;
        }, $n.prototype.computeIntersectsForChain = function() {
          if (4 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = arguments[3];
            this.computeIntersectsForChain(this.startIndex[t2], this.startIndex[t2 + 1], e3, e3.startIndex[n2], e3.startIndex[n2 + 1], i2);
          } else if (6 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2], a2 = arguments[3], u2 = arguments[4], l2 = arguments[5], c2 = this.pts[r2], p2 = this.pts[o2], h2 = s2.pts[a2], f2 = s2.pts[u2];
            if (o2 - r2 == 1 && u2 - a2 == 1)
              return l2.addIntersections(this.e, r2, s2.e, a2), null;
            if (this.env1.init(c2, p2), this.env2.init(h2, f2), !this.env1.intersects(this.env2))
              return null;
            var g2 = Math.trunc((r2 + o2) / 2), d2 = Math.trunc((a2 + u2) / 2);
            r2 < g2 && (a2 < d2 && this.computeIntersectsForChain(r2, g2, s2, a2, d2, l2), d2 < u2 && this.computeIntersectsForChain(r2, g2, s2, d2, u2, l2)), g2 < o2 && (a2 < d2 && this.computeIntersectsForChain(g2, o2, s2, a2, d2, l2), d2 < u2 && this.computeIntersectsForChain(g2, o2, s2, d2, u2, l2));
          }
        }, $n.prototype.getStartIndexes = function() {
          return this.startIndex;
        }, $n.prototype.computeIntersects = function(t2, e3) {
          for (var n2 = 0; n2 < this.startIndex.length - 1; n2++)
            for (var i2 = 0; i2 < t2.startIndex.length - 1; i2++)
              this.computeIntersectsForChain(n2, t2, i2, e3);
        }, $n.prototype.interfaces_ = function() {
          return [];
        }, $n.prototype.getClass = function() {
          return $n;
        };
        var ti = function t2() {
          this._depth = Array(2).fill().map(function() {
            return Array(3);
          });
          for (var e3 = 0; e3 < 2; e3++)
            for (var n2 = 0; n2 < 3; n2++)
              this._depth[e3][n2] = t2.NULL_VALUE;
        }, ei = { NULL_VALUE: { configurable: true } };
        ti.prototype.getDepth = function(t2, e3) {
          return this._depth[t2][e3];
        }, ti.prototype.setDepth = function(t2, e3, n2) {
          this._depth[t2][e3] = n2;
        }, ti.prototype.isNull = function() {
          if (0 === arguments.length) {
            for (var t2 = 0; t2 < 2; t2++)
              for (var e3 = 0; e3 < 3; e3++)
                if (this._depth[t2][e3] !== ti.NULL_VALUE)
                  return false;
            return true;
          }
          if (1 === arguments.length) {
            var n2 = arguments[0];
            return this._depth[n2][1] === ti.NULL_VALUE;
          }
          if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            return this._depth[i2][r2] === ti.NULL_VALUE;
          }
        }, ti.prototype.normalize = function() {
          for (var t2 = 0; t2 < 2; t2++)
            if (!this.isNull(t2)) {
              var e3 = this._depth[t2][1];
              this._depth[t2][2] < e3 && (e3 = this._depth[t2][2]), e3 < 0 && (e3 = 0);
              for (var n2 = 1; n2 < 3; n2++) {
                var i2 = 0;
                this._depth[t2][n2] > e3 && (i2 = 1), this._depth[t2][n2] = i2;
              }
            }
        }, ti.prototype.getDelta = function(t2) {
          return this._depth[t2][Se.RIGHT] - this._depth[t2][Se.LEFT];
        }, ti.prototype.getLocation = function(t2, e3) {
          return this._depth[t2][e3] <= 0 ? w.EXTERIOR : w.INTERIOR;
        }, ti.prototype.toString = function() {
          return "A: " + this._depth[0][1] + "," + this._depth[0][2] + " B: " + this._depth[1][1] + "," + this._depth[1][2];
        }, ti.prototype.add = function() {
          if (1 === arguments.length)
            for (var t2 = arguments[0], e3 = 0; e3 < 2; e3++)
              for (var n2 = 1; n2 < 3; n2++) {
                var i2 = t2.getLocation(e3, n2);
                i2 !== w.EXTERIOR && i2 !== w.INTERIOR || (this.isNull(e3, n2) ? this._depth[e3][n2] = ti.depthAtLocation(i2) : this._depth[e3][n2] += ti.depthAtLocation(i2));
              }
          else if (3 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1];
            arguments[2] === w.INTERIOR && this._depth[r2][o2]++;
          }
        }, ti.prototype.interfaces_ = function() {
          return [];
        }, ti.prototype.getClass = function() {
          return ti;
        }, ti.depthAtLocation = function(t2) {
          return t2 === w.EXTERIOR ? 0 : t2 === w.INTERIOR ? 1 : ti.NULL_VALUE;
        }, ei.NULL_VALUE.get = function() {
          return -1;
        }, Object.defineProperties(ti, ei);
        var ni = function(t2) {
          function e3() {
            if (t2.call(this), this.pts = null, this._env = null, this.eiList = new Qn(this), this._name = null, this._mce = null, this._isIsolated = true, this._depth = new ti(), this._depthDelta = 0, 1 === arguments.length) {
              var n2 = arguments[0];
              e3.call(this, n2, null);
            } else if (2 === arguments.length) {
              var i2 = arguments[0], r2 = arguments[1];
              this.pts = i2, this._label = r2;
            }
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.getDepth = function() {
            return this._depth;
          }, e3.prototype.getCollapsedEdge = function() {
            var t3 = new Array(2).fill(null);
            t3[0] = this.pts[0], t3[1] = this.pts[1];
            return new e3(t3, Pe.toLineLabel(this._label));
          }, e3.prototype.isIsolated = function() {
            return this._isIsolated;
          }, e3.prototype.getCoordinates = function() {
            return this.pts;
          }, e3.prototype.setIsolated = function(t3) {
            this._isIsolated = t3;
          }, e3.prototype.setName = function(t3) {
            this._name = t3;
          }, e3.prototype.equals = function(t3) {
            if (!(t3 instanceof e3))
              return false;
            var n2 = t3;
            if (this.pts.length !== n2.pts.length)
              return false;
            for (var i2 = true, r2 = true, o2 = this.pts.length, s2 = 0; s2 < this.pts.length; s2++)
              if (this.pts[s2].equals2D(n2.pts[s2]) || (i2 = false), this.pts[s2].equals2D(n2.pts[--o2]) || (r2 = false), !i2 && !r2)
                return false;
            return true;
          }, e3.prototype.getCoordinate = function() {
            if (0 === arguments.length)
              return this.pts.length > 0 ? this.pts[0] : null;
            if (1 === arguments.length) {
              var t3 = arguments[0];
              return this.pts[t3];
            }
          }, e3.prototype.print = function(t3) {
            t3.print("edge " + this._name + ": "), t3.print("LINESTRING (");
            for (var e4 = 0; e4 < this.pts.length; e4++)
              e4 > 0 && t3.print(","), t3.print(this.pts[e4].x + " " + this.pts[e4].y);
            t3.print(")  " + this._label + " " + this._depthDelta);
          }, e3.prototype.computeIM = function(t3) {
            e3.updateIM(this._label, t3);
          }, e3.prototype.isCollapsed = function() {
            return !!this._label.isArea() && (3 === this.pts.length && !!this.pts[0].equals(this.pts[2]));
          }, e3.prototype.isClosed = function() {
            return this.pts[0].equals(this.pts[this.pts.length - 1]);
          }, e3.prototype.getMaximumSegmentIndex = function() {
            return this.pts.length - 1;
          }, e3.prototype.getDepthDelta = function() {
            return this._depthDelta;
          }, e3.prototype.getNumPoints = function() {
            return this.pts.length;
          }, e3.prototype.printReverse = function(t3) {
            t3.print("edge " + this._name + ": ");
            for (var e4 = this.pts.length - 1; e4 >= 0; e4--)
              t3.print(this.pts[e4] + " ");
            t3.println("");
          }, e3.prototype.getMonotoneChainEdge = function() {
            return null === this._mce && (this._mce = new $n(this)), this._mce;
          }, e3.prototype.getEnvelope = function() {
            if (null === this._env) {
              this._env = new j();
              for (var t3 = 0; t3 < this.pts.length; t3++)
                this._env.expandToInclude(this.pts[t3]);
            }
            return this._env;
          }, e3.prototype.addIntersection = function(t3, e4, n2, i2) {
            var r2 = new C(t3.getIntersection(i2)), o2 = e4, s2 = t3.getEdgeDistance(n2, i2), a2 = o2 + 1;
            if (a2 < this.pts.length) {
              var u2 = this.pts[a2];
              r2.equals2D(u2) && (o2 = a2, s2 = 0);
            }
            this.eiList.add(r2, o2, s2);
          }, e3.prototype.toString = function() {
            var t3 = new D();
            t3.append("edge " + this._name + ": "), t3.append("LINESTRING (");
            for (var e4 = 0; e4 < this.pts.length; e4++)
              e4 > 0 && t3.append(","), t3.append(this.pts[e4].x + " " + this.pts[e4].y);
            return t3.append(")  " + this._label + " " + this._depthDelta), t3.toString();
          }, e3.prototype.isPointwiseEqual = function(t3) {
            if (this.pts.length !== t3.pts.length)
              return false;
            for (var e4 = 0; e4 < this.pts.length; e4++)
              if (!this.pts[e4].equals2D(t3.pts[e4]))
                return false;
            return true;
          }, e3.prototype.setDepthDelta = function(t3) {
            this._depthDelta = t3;
          }, e3.prototype.getEdgeIntersectionList = function() {
            return this.eiList;
          }, e3.prototype.addIntersections = function(t3, e4, n2) {
            for (var i2 = 0; i2 < t3.getIntersectionNum(); i2++)
              this.addIntersection(t3, e4, n2, i2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.updateIM = function() {
            if (2 !== arguments.length)
              return t2.prototype.updateIM.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1];
            n2.setAtLeastIfValid(e4.getLocation(0, Se.ON), e4.getLocation(1, Se.ON), 1), e4.isArea() && (n2.setAtLeastIfValid(e4.getLocation(0, Se.LEFT), e4.getLocation(1, Se.LEFT), 2), n2.setAtLeastIfValid(e4.getLocation(0, Se.RIGHT), e4.getLocation(1, Se.RIGHT), 2));
          }, e3;
        }(Fe), ii = function(t2) {
          this._workingPrecisionModel = null, this._workingNoder = null, this._geomFact = null, this._graph = null, this._edgeList = new Hn(), this._bufParams = t2 || null;
        };
        ii.prototype.setWorkingPrecisionModel = function(t2) {
          this._workingPrecisionModel = t2;
        }, ii.prototype.insertUniqueEdge = function(t2) {
          var e3 = this._edgeList.findEqualEdge(t2);
          if (null !== e3) {
            var n2 = e3.getLabel(), i2 = t2.getLabel();
            e3.isPointwiseEqual(t2) || (i2 = new Pe(t2.getLabel())).flip(), n2.merge(i2);
            var r2 = ii.depthDelta(i2), o2 = e3.getDepthDelta() + r2;
            e3.setDepthDelta(o2);
          } else
            this._edgeList.add(t2), t2.setDepthDelta(ii.depthDelta(t2.getLabel()));
        }, ii.prototype.buildSubgraphs = function(t2, e3) {
          for (var n2 = new Nt(), i2 = t2.iterator(); i2.hasNext(); ) {
            var r2 = i2.next(), o2 = r2.getRightmostCoordinate(), s2 = new An(n2).getDepth(o2);
            r2.computeDepth(s2), r2.findResultEdges(), n2.add(r2), e3.add(r2.getDirectedEdges(), r2.getNodes());
          }
        }, ii.prototype.createSubgraphs = function(t2) {
          for (var e3 = new Nt(), n2 = t2.getNodes().iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            if (!i2.isVisited()) {
              var r2 = new Te();
              r2.create(i2), e3.add(r2);
            }
          }
          return $e.sort(e3, $e.reverseOrder()), e3;
        }, ii.prototype.createEmptyResultGeometry = function() {
          return this._geomFact.createPolygon();
        }, ii.prototype.getNoder = function(t2) {
          if (null !== this._workingNoder)
            return this._workingNoder;
          var e3 = new xn(), n2 = new rt();
          return n2.setPrecisionModel(t2), e3.setSegmentIntersector(new Kn(n2)), e3;
        }, ii.prototype.buffer = function(t2, e3) {
          var n2 = this._workingPrecisionModel;
          null === n2 && (n2 = t2.getPrecisionModel()), this._geomFact = t2.getFactory();
          var i2 = new Mn(n2, this._bufParams), r2 = new Bn(t2, e3, i2).getCurves();
          if (r2.size() <= 0)
            return this.createEmptyResultGeometry();
          this.computeNodedEdges(r2, n2), this._graph = new Ye(new kn()), this._graph.addEdges(this._edgeList.getEdges());
          var o2 = this.createSubgraphs(this._graph), s2 = new ke(this._geomFact);
          this.buildSubgraphs(o2, s2);
          var a2 = s2.getPolygons();
          if (a2.size() <= 0)
            return this.createEmptyResultGeometry();
          return this._geomFact.buildGeometry(a2);
        }, ii.prototype.computeNodedEdges = function(t2, e3) {
          var n2 = this.getNoder(e3);
          n2.computeNodes(t2);
          for (var i2 = n2.getNodedSubstrings().iterator(); i2.hasNext(); ) {
            var r2 = i2.next(), o2 = r2.getCoordinates();
            if (2 !== o2.length || !o2[0].equals2D(o2[1])) {
              var s2 = r2.getData(), a2 = new ni(r2.getCoordinates(), new Pe(s2));
              this.insertUniqueEdge(a2);
            }
          }
        }, ii.prototype.setNoder = function(t2) {
          this._workingNoder = t2;
        }, ii.prototype.interfaces_ = function() {
          return [];
        }, ii.prototype.getClass = function() {
          return ii;
        }, ii.depthDelta = function(t2) {
          var e3 = t2.getLocation(0, Se.LEFT), n2 = t2.getLocation(0, Se.RIGHT);
          return e3 === w.INTERIOR && n2 === w.EXTERIOR ? 1 : e3 === w.EXTERIOR && n2 === w.INTERIOR ? -1 : 0;
        }, ii.convertSegStrings = function(t2) {
          for (var e3 = new _e(), n2 = new Nt(); t2.hasNext(); ) {
            var i2 = t2.next(), r2 = e3.createLineString(i2.getCoordinates());
            n2.add(r2);
          }
          return e3.buildGeometry(n2);
        };
        var ri = function() {
          if (this._noder = null, this._scaleFactor = null, this._offsetX = null, this._offsetY = null, this._isScaled = false, 2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this._noder = t2, this._scaleFactor = e3, this._offsetX = 0, this._offsetY = 0, this._isScaled = !this.isIntegerPrecision();
          } else if (4 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = arguments[3];
            this._noder = n2, this._scaleFactor = i2, this._offsetX = r2, this._offsetY = o2, this._isScaled = !this.isIntegerPrecision();
          }
        };
        ri.prototype.rescale = function() {
          if (T(arguments[0], It))
            for (var t2 = arguments[0].iterator(); t2.hasNext(); ) {
              var e3 = t2.next();
              this.rescale(e3.getCoordinates());
            }
          else if (arguments[0] instanceof Array) {
            for (var n2 = arguments[0], i2 = 0; i2 < n2.length; i2++)
              n2[i2].x = n2[i2].x / this._scaleFactor + this._offsetX, n2[i2].y = n2[i2].y / this._scaleFactor + this._offsetY;
            2 === n2.length && n2[0].equals2D(n2[1]) && Y.out.println(n2);
          }
        }, ri.prototype.scale = function() {
          if (T(arguments[0], It)) {
            for (var t2 = arguments[0], e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
              var i2 = n2.next();
              e3.add(new gn(this.scale(i2.getCoordinates()), i2.getData()));
            }
            return e3;
          }
          if (arguments[0] instanceof Array) {
            for (var r2 = arguments[0], o2 = new Array(r2.length).fill(null), s2 = 0; s2 < r2.length; s2++)
              o2[s2] = new C(Math.round((r2[s2].x - this._offsetX) * this._scaleFactor), Math.round((r2[s2].y - this._offsetY) * this._scaleFactor), r2[s2].z);
            return Lt.removeRepeatedPoints(o2);
          }
        }, ri.prototype.isIntegerPrecision = function() {
          return 1 === this._scaleFactor;
        }, ri.prototype.getNodedSubstrings = function() {
          var t2 = this._noder.getNodedSubstrings();
          return this._isScaled && this.rescale(t2), t2;
        }, ri.prototype.computeNodes = function(t2) {
          var e3 = t2;
          this._isScaled && (e3 = this.scale(t2)), this._noder.computeNodes(e3);
        }, ri.prototype.interfaces_ = function() {
          return [In];
        }, ri.prototype.getClass = function() {
          return ri;
        };
        var oi = function() {
          this._li = new rt(), this._segStrings = null;
          var t2 = arguments[0];
          this._segStrings = t2;
        }, si = { fact: { configurable: true } };
        oi.prototype.checkEndPtVertexIntersections = function() {
          if (0 === arguments.length)
            for (var t2 = this._segStrings.iterator(); t2.hasNext(); ) {
              var e3 = t2.next().getCoordinates();
              this.checkEndPtVertexIntersections(e3[0], this._segStrings), this.checkEndPtVertexIntersections(e3[e3.length - 1], this._segStrings);
            }
          else if (2 === arguments.length) {
            for (var n2 = arguments[0], i2 = arguments[1].iterator(); i2.hasNext(); )
              for (var r2 = i2.next().getCoordinates(), o2 = 1; o2 < r2.length - 1; o2++)
                if (r2[o2].equals(n2))
                  throw new $("found endpt/interior pt intersection at index " + o2 + " :pt " + n2);
          }
        }, oi.prototype.checkInteriorIntersections = function() {
          if (0 === arguments.length)
            for (var t2 = this._segStrings.iterator(); t2.hasNext(); )
              for (var e3 = t2.next(), n2 = this._segStrings.iterator(); n2.hasNext(); ) {
                var i2 = n2.next();
                this.checkInteriorIntersections(e3, i2);
              }
          else if (2 === arguments.length)
            for (var r2 = arguments[0], o2 = arguments[1], s2 = r2.getCoordinates(), a2 = o2.getCoordinates(), u2 = 0; u2 < s2.length - 1; u2++)
              for (var l2 = 0; l2 < a2.length - 1; l2++)
                this.checkInteriorIntersections(r2, u2, o2, l2);
          else if (4 === arguments.length) {
            var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = arguments[3];
            if (c2 === h2 && p2 === f2)
              return null;
            var g2 = c2.getCoordinates()[p2], d2 = c2.getCoordinates()[p2 + 1], y3 = h2.getCoordinates()[f2], _2 = h2.getCoordinates()[f2 + 1];
            if (this._li.computeIntersection(g2, d2, y3, _2), this._li.hasIntersection() && (this._li.isProper() || this.hasInteriorIntersection(this._li, g2, d2) || this.hasInteriorIntersection(this._li, y3, _2)))
              throw new $("found non-noded intersection at " + g2 + "-" + d2 + " and " + y3 + "-" + _2);
          }
        }, oi.prototype.checkValid = function() {
          this.checkEndPtVertexIntersections(), this.checkInteriorIntersections(), this.checkCollapses();
        }, oi.prototype.checkCollapses = function() {
          if (0 === arguments.length)
            for (var t2 = this._segStrings.iterator(); t2.hasNext(); ) {
              var e3 = t2.next();
              this.checkCollapses(e3);
            }
          else if (1 === arguments.length)
            for (var n2 = arguments[0].getCoordinates(), i2 = 0; i2 < n2.length - 2; i2++)
              this.checkCollapse(n2[i2], n2[i2 + 1], n2[i2 + 2]);
        }, oi.prototype.hasInteriorIntersection = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.getIntersectionNum(); i2++) {
            var r2 = t2.getIntersection(i2);
            if (!r2.equals(e3) && !r2.equals(n2))
              return true;
          }
          return false;
        }, oi.prototype.checkCollapse = function(t2, e3, n2) {
          if (t2.equals(n2))
            throw new $("found non-noded collapse at " + oi.fact.createLineString([t2, e3, n2]));
        }, oi.prototype.interfaces_ = function() {
          return [];
        }, oi.prototype.getClass = function() {
          return oi;
        }, si.fact.get = function() {
          return new _e();
        }, Object.defineProperties(oi, si);
        var ai = function() {
          this._li = null, this._pt = null, this._originalPt = null, this._ptScaled = null, this._p0Scaled = null, this._p1Scaled = null, this._scaleFactor = null, this._minx = null, this._maxx = null, this._miny = null, this._maxy = null, this._corner = new Array(4).fill(null), this._safeEnv = null;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          if (this._originalPt = t2, this._pt = t2, this._scaleFactor = e3, this._li = n2, e3 <= 0)
            throw new m("Scale factor must be non-zero");
          1 !== e3 && (this._pt = new C(this.scale(t2.x), this.scale(t2.y)), this._p0Scaled = new C(), this._p1Scaled = new C()), this.initCorners(this._pt);
        }, ui = { SAFE_ENV_EXPANSION_FACTOR: { configurable: true } };
        ai.prototype.intersectsScaled = function(t2, e3) {
          var n2 = Math.min(t2.x, e3.x), i2 = Math.max(t2.x, e3.x), r2 = Math.min(t2.y, e3.y), o2 = Math.max(t2.y, e3.y), s2 = this._maxx < n2 || this._minx > i2 || this._maxy < r2 || this._miny > o2;
          if (s2)
            return false;
          var a2 = this.intersectsToleranceSquare(t2, e3);
          return et.isTrue(!(s2 && a2), "Found bad envelope test"), a2;
        }, ai.prototype.initCorners = function(t2) {
          this._minx = t2.x - 0.5, this._maxx = t2.x + 0.5, this._miny = t2.y - 0.5, this._maxy = t2.y + 0.5, this._corner[0] = new C(this._maxx, this._maxy), this._corner[1] = new C(this._minx, this._maxy), this._corner[2] = new C(this._minx, this._miny), this._corner[3] = new C(this._maxx, this._miny);
        }, ai.prototype.intersects = function(t2, e3) {
          return 1 === this._scaleFactor ? this.intersectsScaled(t2, e3) : (this.copyScaled(t2, this._p0Scaled), this.copyScaled(e3, this._p1Scaled), this.intersectsScaled(this._p0Scaled, this._p1Scaled));
        }, ai.prototype.scale = function(t2) {
          return Math.round(t2 * this._scaleFactor);
        }, ai.prototype.getCoordinate = function() {
          return this._originalPt;
        }, ai.prototype.copyScaled = function(t2, e3) {
          e3.x = this.scale(t2.x), e3.y = this.scale(t2.y);
        }, ai.prototype.getSafeEnvelope = function() {
          if (null === this._safeEnv) {
            var t2 = ai.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
            this._safeEnv = new j(this._originalPt.x - t2, this._originalPt.x + t2, this._originalPt.y - t2, this._originalPt.y + t2);
          }
          return this._safeEnv;
        }, ai.prototype.intersectsPixelClosure = function(t2, e3) {
          return this._li.computeIntersection(t2, e3, this._corner[0], this._corner[1]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e3, this._corner[1], this._corner[2]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e3, this._corner[2], this._corner[3]), !!this._li.hasIntersection() || (this._li.computeIntersection(t2, e3, this._corner[3], this._corner[0]), !!this._li.hasIntersection())));
        }, ai.prototype.intersectsToleranceSquare = function(t2, e3) {
          var n2 = false, i2 = false;
          return this._li.computeIntersection(t2, e3, this._corner[0], this._corner[1]), !!this._li.isProper() || (this._li.computeIntersection(t2, e3, this._corner[1], this._corner[2]), !!this._li.isProper() || (this._li.hasIntersection() && (n2 = true), this._li.computeIntersection(t2, e3, this._corner[2], this._corner[3]), !!this._li.isProper() || (this._li.hasIntersection() && (i2 = true), this._li.computeIntersection(t2, e3, this._corner[3], this._corner[0]), !!this._li.isProper() || (!(!n2 || !i2) || (!!t2.equals(this._pt) || !!e3.equals(this._pt))))));
        }, ai.prototype.addSnappedNode = function(t2, e3) {
          var n2 = t2.getCoordinate(e3), i2 = t2.getCoordinate(e3 + 1);
          return !!this.intersects(n2, i2) && (t2.addIntersection(this.getCoordinate(), e3), true);
        }, ai.prototype.interfaces_ = function() {
          return [];
        }, ai.prototype.getClass = function() {
          return ai;
        }, ui.SAFE_ENV_EXPANSION_FACTOR.get = function() {
          return 0.75;
        }, Object.defineProperties(ai, ui);
        var li = function() {
          this.tempEnv1 = new j(), this.selectedSegment = new dn();
        };
        li.prototype.select = function() {
          if (1 === arguments.length)
            ;
          else if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            t2.getLineSegment(e3, this.selectedSegment), this.select(this.selectedSegment);
          }
        }, li.prototype.interfaces_ = function() {
          return [];
        }, li.prototype.getClass = function() {
          return li;
        };
        var ci = function() {
          this._index = null;
          var t2 = arguments[0];
          this._index = t2;
        }, pi2 = { HotPixelSnapAction: { configurable: true } };
        ci.prototype.snap = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.snap(t2, null, -1);
          }
          if (3 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2], r2 = e3.getSafeEnvelope(), o2 = new hi(e3, n2, i2);
            return this._index.query(r2, { interfaces_: function() {
              return [Ke];
            }, visitItem: function(t3) {
              t3.select(r2, o2);
            } }), o2.isNodeAdded();
          }
        }, ci.prototype.interfaces_ = function() {
          return [];
        }, ci.prototype.getClass = function() {
          return ci;
        }, pi2.HotPixelSnapAction.get = function() {
          return hi;
        }, Object.defineProperties(ci, pi2);
        var hi = function(t2) {
          function e3() {
            t2.call(this), this._hotPixel = null, this._parentEdge = null, this._hotPixelVertexIndex = null, this._isNodeAdded = false;
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            this._hotPixel = e4, this._parentEdge = n2, this._hotPixelVertexIndex = i2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.isNodeAdded = function() {
            return this._isNodeAdded;
          }, e3.prototype.select = function() {
            if (2 !== arguments.length)
              return t2.prototype.select.apply(this, arguments);
            var e4 = arguments[0], n2 = arguments[1], i2 = e4.getContext();
            if (null !== this._parentEdge && i2 === this._parentEdge && n2 === this._hotPixelVertexIndex)
              return null;
            this._isNodeAdded = this._hotPixel.addSnappedNode(i2, n2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(li), fi = function() {
          this._li = null, this._interiorIntersections = null;
          var t2 = arguments[0];
          this._li = t2, this._interiorIntersections = new Nt();
        };
        fi.prototype.processIntersections = function(t2, e3, n2, i2) {
          if (t2 === n2 && e3 === i2)
            return null;
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
          if (this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && this._li.isInteriorIntersection()) {
            for (var u2 = 0; u2 < this._li.getIntersectionNum(); u2++)
              this._interiorIntersections.add(this._li.getIntersection(u2));
            t2.addIntersections(this._li, e3, 0), n2.addIntersections(this._li, i2, 1);
          }
        }, fi.prototype.isDone = function() {
          return false;
        }, fi.prototype.getInteriorIntersections = function() {
          return this._interiorIntersections;
        }, fi.prototype.interfaces_ = function() {
          return [Wn];
        }, fi.prototype.getClass = function() {
          return fi;
        };
        var gi = function() {
          this._pm = null, this._li = null, this._scaleFactor = null, this._noder = null, this._pointSnapper = null, this._nodedSegStrings = null;
          var t2 = arguments[0];
          this._pm = t2, this._li = new rt(), this._li.setPrecisionModel(t2), this._scaleFactor = t2.getScale();
        };
        gi.prototype.checkCorrectness = function(t2) {
          var e3 = gn.getNodedSubstrings(t2), n2 = new oi(e3);
          try {
            n2.checkValid();
          } catch (t3) {
            if (!(t3 instanceof z))
              throw t3;
            t3.printStackTrace();
          }
        }, gi.prototype.getNodedSubstrings = function() {
          return gn.getNodedSubstrings(this._nodedSegStrings);
        }, gi.prototype.snapRound = function(t2, e3) {
          var n2 = this.findInteriorIntersections(t2, e3);
          this.computeIntersectionSnaps(n2), this.computeVertexSnaps(t2);
        }, gi.prototype.findInteriorIntersections = function(t2, e3) {
          var n2 = new fi(e3);
          return this._noder.setSegmentIntersector(n2), this._noder.computeNodes(t2), n2.getInteriorIntersections();
        }, gi.prototype.computeVertexSnaps = function() {
          if (T(arguments[0], It))
            for (var t2 = arguments[0].iterator(); t2.hasNext(); ) {
              var e3 = t2.next();
              this.computeVertexSnaps(e3);
            }
          else if (arguments[0] instanceof gn)
            for (var n2 = arguments[0], i2 = n2.getCoordinates(), r2 = 0; r2 < i2.length; r2++) {
              var o2 = new ai(i2[r2], this._scaleFactor, this._li);
              this._pointSnapper.snap(o2, n2, r2) && n2.addIntersection(i2[r2], r2);
            }
        }, gi.prototype.computeNodes = function(t2) {
          this._nodedSegStrings = t2, this._noder = new xn(), this._pointSnapper = new ci(this._noder.getIndex()), this.snapRound(t2, this._li);
        }, gi.prototype.computeIntersectionSnaps = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = new ai(n2, this._scaleFactor, this._li);
            this._pointSnapper.snap(i2);
          }
        }, gi.prototype.interfaces_ = function() {
          return [In];
        }, gi.prototype.getClass = function() {
          return gi;
        };
        var di = function() {
          if (this._argGeom = null, this._distance = null, this._bufParams = new Cn(), this._resultGeometry = null, this._saveException = null, 1 === arguments.length) {
            var t2 = arguments[0];
            this._argGeom = t2;
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this._argGeom = e3, this._bufParams = n2;
          }
        }, yi = { CAP_ROUND: { configurable: true }, CAP_BUTT: { configurable: true }, CAP_FLAT: { configurable: true }, CAP_SQUARE: { configurable: true }, MAX_PRECISION_DIGITS: { configurable: true } };
        di.prototype.bufferFixedPrecision = function(t2) {
          var e3 = new ri(new gi(new fe(1)), t2.getScale()), n2 = new ii(this._bufParams);
          n2.setWorkingPrecisionModel(t2), n2.setNoder(e3), this._resultGeometry = n2.buffer(this._argGeom, this._distance);
        }, di.prototype.bufferReducedPrecision = function() {
          var t2 = this;
          if (0 === arguments.length) {
            for (var e3 = di.MAX_PRECISION_DIGITS; e3 >= 0; e3--) {
              try {
                t2.bufferReducedPrecision(e3);
              } catch (e4) {
                if (!(e4 instanceof we))
                  throw e4;
                t2._saveException = e4;
              }
              if (null !== t2._resultGeometry)
                return null;
            }
            throw this._saveException;
          }
          if (1 === arguments.length) {
            var n2 = arguments[0], i2 = di.precisionScaleFactor(this._argGeom, this._distance, n2), r2 = new fe(i2);
            this.bufferFixedPrecision(r2);
          }
        }, di.prototype.computeGeometry = function() {
          if (this.bufferOriginalPrecision(), null !== this._resultGeometry)
            return null;
          var t2 = this._argGeom.getFactory().getPrecisionModel();
          t2.getType() === fe.FIXED ? this.bufferFixedPrecision(t2) : this.bufferReducedPrecision();
        }, di.prototype.setQuadrantSegments = function(t2) {
          this._bufParams.setQuadrantSegments(t2);
        }, di.prototype.bufferOriginalPrecision = function() {
          try {
            var t2 = new ii(this._bufParams);
            this._resultGeometry = t2.buffer(this._argGeom, this._distance);
          } catch (t3) {
            if (!(t3 instanceof $))
              throw t3;
            this._saveException = t3;
          }
        }, di.prototype.getResultGeometry = function(t2) {
          return this._distance = t2, this.computeGeometry(), this._resultGeometry;
        }, di.prototype.setEndCapStyle = function(t2) {
          this._bufParams.setEndCapStyle(t2);
        }, di.prototype.interfaces_ = function() {
          return [];
        }, di.prototype.getClass = function() {
          return di;
        }, di.bufferOp = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            return new di(t2).getResultGeometry(e3);
          }
          if (3 === arguments.length) {
            if (Number.isInteger(arguments[2]) && arguments[0] instanceof ct && "number" == typeof arguments[1]) {
              var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new di(n2);
              o2.setQuadrantSegments(r2);
              return o2.getResultGeometry(i2);
            }
            if (arguments[2] instanceof Cn && arguments[0] instanceof ct && "number" == typeof arguments[1]) {
              var s2 = arguments[0], a2 = arguments[1], u2 = arguments[2];
              return new di(s2, u2).getResultGeometry(a2);
            }
          } else if (4 === arguments.length) {
            var l2 = arguments[0], c2 = arguments[1], p2 = arguments[2], h2 = arguments[3], f2 = new di(l2);
            f2.setQuadrantSegments(p2), f2.setEndCapStyle(h2);
            return f2.getResultGeometry(c2);
          }
        }, di.precisionScaleFactor = function(t2, e3, n2) {
          var i2 = t2.getEnvelopeInternal(), r2 = R.max(Math.abs(i2.getMaxX()), Math.abs(i2.getMaxY()), Math.abs(i2.getMinX()), Math.abs(i2.getMinY())) + 2 * (e3 > 0 ? e3 : 0), o2 = n2 - Math.trunc(Math.log(r2) / Math.log(10) + 1);
          return Math.pow(10, o2);
        }, yi.CAP_ROUND.get = function() {
          return Cn.CAP_ROUND;
        }, yi.CAP_BUTT.get = function() {
          return Cn.CAP_FLAT;
        }, yi.CAP_FLAT.get = function() {
          return Cn.CAP_FLAT;
        }, yi.CAP_SQUARE.get = function() {
          return Cn.CAP_SQUARE;
        }, yi.MAX_PRECISION_DIGITS.get = function() {
          return 12;
        }, Object.defineProperties(di, yi);
        var _i = function() {
          this._pt = [new C(), new C()], this._distance = v.NaN, this._isNull = true;
        };
        _i.prototype.getCoordinates = function() {
          return this._pt;
        }, _i.prototype.getCoordinate = function(t2) {
          return this._pt[t2];
        }, _i.prototype.setMinimum = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setMinimum(t2._pt[0], t2._pt[1]);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 < this._distance && this.initialize(e3, n2, i2);
          }
        }, _i.prototype.initialize = function() {
          if (0 === arguments.length)
            this._isNull = true;
          else if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this._pt[0].setCoordinate(t2), this._pt[1].setCoordinate(e3), this._distance = t2.distance(e3), this._isNull = false;
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this._pt[0].setCoordinate(n2), this._pt[1].setCoordinate(i2), this._distance = r2, this._isNull = false;
          }
        }, _i.prototype.getDistance = function() {
          return this._distance;
        }, _i.prototype.setMaximum = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setMaximum(t2._pt[0], t2._pt[1]);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 > this._distance && this.initialize(e3, n2, i2);
          }
        }, _i.prototype.interfaces_ = function() {
          return [];
        }, _i.prototype.getClass = function() {
          return _i;
        };
        var mi = function() {
        };
        mi.prototype.interfaces_ = function() {
          return [];
        }, mi.prototype.getClass = function() {
          return mi;
        }, mi.computeDistance = function() {
          if (arguments[2] instanceof _i && arguments[0] instanceof Kt && arguments[1] instanceof C)
            for (var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = t2.getCoordinates(), r2 = new dn(), o2 = 0; o2 < i2.length - 1; o2++) {
              r2.setCoordinates(i2[o2], i2[o2 + 1]);
              var s2 = r2.closestPoint(e3);
              n2.setMinimum(s2, e3);
            }
          else if (arguments[2] instanceof _i && arguments[0] instanceof $t && arguments[1] instanceof C) {
            var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2];
            mi.computeDistance(a2.getExteriorRing(), u2, l2);
            for (var c2 = 0; c2 < a2.getNumInteriorRing(); c2++)
              mi.computeDistance(a2.getInteriorRingN(c2), u2, l2);
          } else if (arguments[2] instanceof _i && arguments[0] instanceof ct && arguments[1] instanceof C) {
            var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2];
            if (p2 instanceof Kt)
              mi.computeDistance(p2, h2, f2);
            else if (p2 instanceof $t)
              mi.computeDistance(p2, h2, f2);
            else if (p2 instanceof zt)
              for (var g2 = p2, d2 = 0; d2 < g2.getNumGeometries(); d2++) {
                var y3 = g2.getGeometryN(d2);
                mi.computeDistance(y3, h2, f2);
              }
            else
              f2.setMinimum(p2.getCoordinate(), h2);
          } else if (arguments[2] instanceof _i && arguments[0] instanceof dn && arguments[1] instanceof C) {
            var _2 = arguments[0], m2 = arguments[1], v2 = arguments[2], I2 = _2.closestPoint(m2);
            v2.setMinimum(I2, m2);
          }
        };
        var vi = function(t2) {
          this._maxPtDist = new _i(), this._inputGeom = t2 || null;
        }, Ii = { MaxPointDistanceFilter: { configurable: true }, MaxMidpointDistanceFilter: { configurable: true } };
        vi.prototype.computeMaxMidpointDistance = function(t2) {
          var e3 = new xi(this._inputGeom);
          t2.apply(e3), this._maxPtDist.setMaximum(e3.getMaxPointDistance());
        }, vi.prototype.computeMaxVertexDistance = function(t2) {
          var e3 = new Ei(this._inputGeom);
          t2.apply(e3), this._maxPtDist.setMaximum(e3.getMaxPointDistance());
        }, vi.prototype.findDistance = function(t2) {
          return this.computeMaxVertexDistance(t2), this.computeMaxMidpointDistance(t2), this._maxPtDist.getDistance();
        }, vi.prototype.getDistancePoints = function() {
          return this._maxPtDist;
        }, vi.prototype.interfaces_ = function() {
          return [];
        }, vi.prototype.getClass = function() {
          return vi;
        }, Ii.MaxPointDistanceFilter.get = function() {
          return Ei;
        }, Ii.MaxMidpointDistanceFilter.get = function() {
          return xi;
        }, Object.defineProperties(vi, Ii);
        var Ei = function(t2) {
          this._maxPtDist = new _i(), this._minPtDist = new _i(), this._geom = t2 || null;
        };
        Ei.prototype.filter = function(t2) {
          this._minPtDist.initialize(), mi.computeDistance(this._geom, t2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
        }, Ei.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, Ei.prototype.interfaces_ = function() {
          return [ft];
        }, Ei.prototype.getClass = function() {
          return Ei;
        };
        var xi = function(t2) {
          this._maxPtDist = new _i(), this._minPtDist = new _i(), this._geom = t2 || null;
        };
        xi.prototype.filter = function(t2, e3) {
          if (0 === e3)
            return null;
          var n2 = t2.getCoordinate(e3 - 1), i2 = t2.getCoordinate(e3), r2 = new C((n2.x + i2.x) / 2, (n2.y + i2.y) / 2);
          this._minPtDist.initialize(), mi.computeDistance(this._geom, r2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
        }, xi.prototype.isDone = function() {
          return false;
        }, xi.prototype.isGeometryChanged = function() {
          return false;
        }, xi.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, xi.prototype.interfaces_ = function() {
          return [Ut];
        }, xi.prototype.getClass = function() {
          return xi;
        };
        var Ni = function(t2) {
          this._comps = t2 || null;
        };
        Ni.prototype.filter = function(t2) {
          t2 instanceof $t && this._comps.add(t2);
        }, Ni.prototype.interfaces_ = function() {
          return [Vt];
        }, Ni.prototype.getClass = function() {
          return Ni;
        }, Ni.getPolygons = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return Ni.getPolygons(t2, new Nt());
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3 instanceof $t ? n2.add(e3) : e3 instanceof zt && e3.apply(new Ni(n2)), n2;
          }
        };
        var Ci = function() {
          if (this._lines = null, this._isForcedToLineString = false, 1 === arguments.length) {
            var t2 = arguments[0];
            this._lines = t2;
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this._lines = e3, this._isForcedToLineString = n2;
          }
        };
        Ci.prototype.filter = function(t2) {
          if (this._isForcedToLineString && t2 instanceof ee) {
            var e3 = t2.getFactory().createLineString(t2.getCoordinateSequence());
            return this._lines.add(e3), null;
          }
          t2 instanceof Kt && this._lines.add(t2);
        }, Ci.prototype.setForceToLineString = function(t2) {
          this._isForcedToLineString = t2;
        }, Ci.prototype.interfaces_ = function() {
          return [lt];
        }, Ci.prototype.getClass = function() {
          return Ci;
        }, Ci.getGeometry = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return t2.getFactory().buildGeometry(Ci.getLines(t2));
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3.getFactory().buildGeometry(Ci.getLines(e3, n2));
          }
        }, Ci.getLines = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return Ci.getLines(t2, false);
          }
          if (2 === arguments.length) {
            if (T(arguments[0], It) && T(arguments[1], It)) {
              for (var e3 = arguments[0], n2 = arguments[1], i2 = e3.iterator(); i2.hasNext(); ) {
                var r2 = i2.next();
                Ci.getLines(r2, n2);
              }
              return n2;
            }
            if (arguments[0] instanceof ct && "boolean" == typeof arguments[1]) {
              var o2 = arguments[0], s2 = arguments[1], a2 = new Nt();
              return o2.apply(new Ci(a2, s2)), a2;
            }
            if (arguments[0] instanceof ct && T(arguments[1], It)) {
              var u2 = arguments[0], l2 = arguments[1];
              return u2 instanceof Kt ? l2.add(u2) : u2.apply(new Ci(l2)), l2;
            }
          } else if (3 === arguments.length) {
            if ("boolean" == typeof arguments[2] && T(arguments[0], It) && T(arguments[1], It)) {
              for (var c2 = arguments[0], p2 = arguments[1], h2 = arguments[2], f2 = c2.iterator(); f2.hasNext(); ) {
                var g2 = f2.next();
                Ci.getLines(g2, p2, h2);
              }
              return p2;
            }
            if ("boolean" == typeof arguments[2] && arguments[0] instanceof ct && T(arguments[1], It)) {
              var d2 = arguments[0], y3 = arguments[1], _2 = arguments[2];
              return d2.apply(new Ci(y3, _2)), y3;
            }
          }
        };
        var Si = function() {
          if (this._boundaryRule = gt.OGC_SFS_BOUNDARY_RULE, this._isIn = null, this._numBoundaries = null, 0 === arguments.length)
            ;
          else if (1 === arguments.length) {
            var t2 = arguments[0];
            if (null === t2)
              throw new m("Rule must be non-null");
            this._boundaryRule = t2;
          }
        };
        Si.prototype.locateInternal = function() {
          if (arguments[0] instanceof C && arguments[1] instanceof $t) {
            var t2 = arguments[0], e3 = arguments[1];
            if (e3.isEmpty())
              return w.EXTERIOR;
            var n2 = e3.getExteriorRing(), i2 = this.locateInPolygonRing(t2, n2);
            if (i2 === w.EXTERIOR)
              return w.EXTERIOR;
            if (i2 === w.BOUNDARY)
              return w.BOUNDARY;
            for (var r2 = 0; r2 < e3.getNumInteriorRing(); r2++) {
              var o2 = e3.getInteriorRingN(r2), s2 = this.locateInPolygonRing(t2, o2);
              if (s2 === w.INTERIOR)
                return w.EXTERIOR;
              if (s2 === w.BOUNDARY)
                return w.BOUNDARY;
            }
            return w.INTERIOR;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof Kt) {
            var a2 = arguments[0], u2 = arguments[1];
            if (!u2.getEnvelopeInternal().intersects(a2))
              return w.EXTERIOR;
            var l2 = u2.getCoordinates();
            return u2.isClosed() || !a2.equals(l2[0]) && !a2.equals(l2[l2.length - 1]) ? at.isOnLine(a2, l2) ? w.INTERIOR : w.EXTERIOR : w.BOUNDARY;
          }
          if (arguments[0] instanceof C && arguments[1] instanceof Qt) {
            var c2 = arguments[0];
            return arguments[1].getCoordinate().equals2D(c2) ? w.INTERIOR : w.EXTERIOR;
          }
        }, Si.prototype.locateInPolygonRing = function(t2, e3) {
          return e3.getEnvelopeInternal().intersects(t2) ? at.locatePointInRing(t2, e3.getCoordinates()) : w.EXTERIOR;
        }, Si.prototype.intersects = function(t2, e3) {
          return this.locate(t2, e3) !== w.EXTERIOR;
        }, Si.prototype.updateLocationInfo = function(t2) {
          t2 === w.INTERIOR && (this._isIn = true), t2 === w.BOUNDARY && this._numBoundaries++;
        }, Si.prototype.computeLocation = function(t2, e3) {
          if (e3 instanceof Qt && this.updateLocationInfo(this.locateInternal(t2, e3)), e3 instanceof Kt)
            this.updateLocationInfo(this.locateInternal(t2, e3));
          else if (e3 instanceof $t)
            this.updateLocationInfo(this.locateInternal(t2, e3));
          else if (e3 instanceof Xt)
            for (var n2 = e3, i2 = 0; i2 < n2.getNumGeometries(); i2++) {
              var r2 = n2.getGeometryN(i2);
              this.updateLocationInfo(this.locateInternal(t2, r2));
            }
          else if (e3 instanceof ne)
            for (var o2 = e3, s2 = 0; s2 < o2.getNumGeometries(); s2++) {
              var a2 = o2.getGeometryN(s2);
              this.updateLocationInfo(this.locateInternal(t2, a2));
            }
          else if (e3 instanceof zt)
            for (var u2 = new Un(e3); u2.hasNext(); ) {
              var l2 = u2.next();
              l2 !== e3 && this.computeLocation(t2, l2);
            }
        }, Si.prototype.locate = function(t2, e3) {
          return e3.isEmpty() ? w.EXTERIOR : e3 instanceof Kt ? this.locateInternal(t2, e3) : e3 instanceof $t ? this.locateInternal(t2, e3) : (this._isIn = false, this._numBoundaries = 0, this.computeLocation(t2, e3), this._boundaryRule.isInBoundary(this._numBoundaries) ? w.BOUNDARY : this._numBoundaries > 0 || this._isIn ? w.INTERIOR : w.EXTERIOR);
        }, Si.prototype.interfaces_ = function() {
          return [];
        }, Si.prototype.getClass = function() {
          return Si;
        };
        var Li = function t2() {
          if (this._component = null, this._segIndex = null, this._pt = null, 2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            t2.call(this, e3, t2.INSIDE_AREA, n2);
          } else if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            this._component = i2, this._segIndex = r2, this._pt = o2;
          }
        }, bi = { INSIDE_AREA: { configurable: true } };
        Li.prototype.isInsideArea = function() {
          return this._segIndex === Li.INSIDE_AREA;
        }, Li.prototype.getCoordinate = function() {
          return this._pt;
        }, Li.prototype.getGeometryComponent = function() {
          return this._component;
        }, Li.prototype.getSegmentIndex = function() {
          return this._segIndex;
        }, Li.prototype.interfaces_ = function() {
          return [];
        }, Li.prototype.getClass = function() {
          return Li;
        }, bi.INSIDE_AREA.get = function() {
          return -1;
        }, Object.defineProperties(Li, bi);
        var wi = function(t2) {
          this._pts = t2 || null;
        };
        wi.prototype.filter = function(t2) {
          t2 instanceof Qt && this._pts.add(t2);
        }, wi.prototype.interfaces_ = function() {
          return [Vt];
        }, wi.prototype.getClass = function() {
          return wi;
        }, wi.getPoints = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return t2 instanceof Qt ? $e.singletonList(t2) : wi.getPoints(t2, new Nt());
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3 instanceof Qt ? n2.add(e3) : e3 instanceof zt && e3.apply(new wi(n2)), n2;
          }
        };
        var Oi = function() {
          this._locations = null;
          var t2 = arguments[0];
          this._locations = t2;
        };
        Oi.prototype.filter = function(t2) {
          (t2 instanceof Qt || t2 instanceof Kt || t2 instanceof $t) && this._locations.add(new Li(t2, 0, t2.getCoordinate()));
        }, Oi.prototype.interfaces_ = function() {
          return [Vt];
        }, Oi.prototype.getClass = function() {
          return Oi;
        }, Oi.getLocations = function(t2) {
          var e3 = new Nt();
          return t2.apply(new Oi(e3)), e3;
        };
        var Ti = function() {
          if (this._geom = null, this._terminateDistance = 0, this._ptLocator = new Si(), this._minDistanceLocation = null, this._minDistance = v.MAX_VALUE, 2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this._geom = [t2, e3], this._terminateDistance = 0;
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this._geom = new Array(2).fill(null), this._geom[0] = n2, this._geom[1] = i2, this._terminateDistance = r2;
          }
        };
        Ti.prototype.computeContainmentDistance = function() {
          if (0 === arguments.length) {
            var t2 = new Array(2).fill(null);
            if (this.computeContainmentDistance(0, t2), this._minDistance <= this._terminateDistance)
              return null;
            this.computeContainmentDistance(1, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = 1 - e3, r2 = Ni.getPolygons(this._geom[e3]);
            if (r2.size() > 0) {
              var o2 = Oi.getLocations(this._geom[i2]);
              if (this.computeContainmentDistance(o2, r2, n2), this._minDistance <= this._terminateDistance)
                return this._minDistanceLocation[i2] = n2[0], this._minDistanceLocation[e3] = n2[1], null;
            }
          } else if (3 === arguments.length) {
            if (arguments[2] instanceof Array && T(arguments[0], xt) && T(arguments[1], xt)) {
              for (var s2 = arguments[0], a2 = arguments[1], u2 = arguments[2], l2 = 0; l2 < s2.size(); l2++)
                for (var c2 = s2.get(l2), p2 = 0; p2 < a2.size(); p2++)
                  if (this.computeContainmentDistance(c2, a2.get(p2), u2), this._minDistance <= this._terminateDistance)
                    return null;
            } else if (arguments[2] instanceof Array && arguments[0] instanceof Li && arguments[1] instanceof $t) {
              var h2 = arguments[0], f2 = arguments[1], g2 = arguments[2], d2 = h2.getCoordinate();
              if (w.EXTERIOR !== this._ptLocator.locate(d2, f2))
                return this._minDistance = 0, g2[0] = h2, g2[1] = new Li(f2, d2), null;
            }
          }
        }, Ti.prototype.computeMinDistanceLinesPoints = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.size(); i2++)
            for (var r2 = t2.get(i2), o2 = 0; o2 < e3.size(); o2++) {
              var s2 = e3.get(o2);
              if (this.computeMinDistance(r2, s2, n2), this._minDistance <= this._terminateDistance)
                return null;
            }
        }, Ti.prototype.computeFacetDistance = function() {
          var t2 = new Array(2).fill(null), e3 = Ci.getLines(this._geom[0]), n2 = Ci.getLines(this._geom[1]), i2 = wi.getPoints(this._geom[0]), r2 = wi.getPoints(this._geom[1]);
          return this.computeMinDistanceLines(e3, n2, t2), this.updateMinDistance(t2, false), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistanceLinesPoints(e3, r2, t2), this.updateMinDistance(t2, false), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistanceLinesPoints(n2, i2, t2), this.updateMinDistance(t2, true), this._minDistance <= this._terminateDistance ? null : (t2[0] = null, t2[1] = null, this.computeMinDistancePoints(i2, r2, t2), void this.updateMinDistance(t2, false))));
        }, Ti.prototype.nearestLocations = function() {
          return this.computeMinDistance(), this._minDistanceLocation;
        }, Ti.prototype.updateMinDistance = function(t2, e3) {
          if (null === t2[0])
            return null;
          e3 ? (this._minDistanceLocation[0] = t2[1], this._minDistanceLocation[1] = t2[0]) : (this._minDistanceLocation[0] = t2[0], this._minDistanceLocation[1] = t2[1]);
        }, Ti.prototype.nearestPoints = function() {
          this.computeMinDistance();
          return [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];
        }, Ti.prototype.computeMinDistance = function() {
          if (0 === arguments.length) {
            if (null !== this._minDistanceLocation)
              return null;
            if (this._minDistanceLocation = new Array(2).fill(null), this.computeContainmentDistance(), this._minDistance <= this._terminateDistance)
              return null;
            this.computeFacetDistance();
          } else if (3 === arguments.length) {
            if (arguments[2] instanceof Array && arguments[0] instanceof Kt && arguments[1] instanceof Qt) {
              var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
              if (t2.getEnvelopeInternal().distance(e3.getEnvelopeInternal()) > this._minDistance)
                return null;
              for (var i2 = t2.getCoordinates(), r2 = e3.getCoordinate(), o2 = 0; o2 < i2.length - 1; o2++) {
                var s2 = at.distancePointLine(r2, i2[o2], i2[o2 + 1]);
                if (s2 < this._minDistance) {
                  this._minDistance = s2;
                  var a2 = new dn(i2[o2], i2[o2 + 1]).closestPoint(r2);
                  n2[0] = new Li(t2, o2, a2), n2[1] = new Li(e3, 0, r2);
                }
                if (this._minDistance <= this._terminateDistance)
                  return null;
              }
            } else if (arguments[2] instanceof Array && arguments[0] instanceof Kt && arguments[1] instanceof Kt) {
              var u2 = arguments[0], l2 = arguments[1], c2 = arguments[2];
              if (u2.getEnvelopeInternal().distance(l2.getEnvelopeInternal()) > this._minDistance)
                return null;
              for (var p2 = u2.getCoordinates(), h2 = l2.getCoordinates(), f2 = 0; f2 < p2.length - 1; f2++)
                for (var g2 = 0; g2 < h2.length - 1; g2++) {
                  var d2 = at.distanceLineLine(p2[f2], p2[f2 + 1], h2[g2], h2[g2 + 1]);
                  if (d2 < this._minDistance) {
                    this._minDistance = d2;
                    var y3 = new dn(p2[f2], p2[f2 + 1]), _2 = new dn(h2[g2], h2[g2 + 1]), m2 = y3.closestPoints(_2);
                    c2[0] = new Li(u2, f2, m2[0]), c2[1] = new Li(l2, g2, m2[1]);
                  }
                  if (this._minDistance <= this._terminateDistance)
                    return null;
                }
            }
          }
        }, Ti.prototype.computeMinDistancePoints = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.size(); i2++)
            for (var r2 = t2.get(i2), o2 = 0; o2 < e3.size(); o2++) {
              var s2 = e3.get(o2), a2 = r2.getCoordinate().distance(s2.getCoordinate());
              if (a2 < this._minDistance && (this._minDistance = a2, n2[0] = new Li(r2, 0, r2.getCoordinate()), n2[1] = new Li(s2, 0, s2.getCoordinate())), this._minDistance <= this._terminateDistance)
                return null;
            }
        }, Ti.prototype.distance = function() {
          if (null === this._geom[0] || null === this._geom[1])
            throw new m("null geometries are not supported");
          return this._geom[0].isEmpty() || this._geom[1].isEmpty() ? 0 : (this.computeMinDistance(), this._minDistance);
        }, Ti.prototype.computeMinDistanceLines = function(t2, e3, n2) {
          for (var i2 = 0; i2 < t2.size(); i2++)
            for (var r2 = t2.get(i2), o2 = 0; o2 < e3.size(); o2++) {
              var s2 = e3.get(o2);
              if (this.computeMinDistance(r2, s2, n2), this._minDistance <= this._terminateDistance)
                return null;
            }
        }, Ti.prototype.interfaces_ = function() {
          return [];
        }, Ti.prototype.getClass = function() {
          return Ti;
        }, Ti.distance = function(t2, e3) {
          return new Ti(t2, e3).distance();
        }, Ti.isWithinDistance = function(t2, e3, n2) {
          return new Ti(t2, e3, n2).distance() <= n2;
        }, Ti.nearestPoints = function(t2, e3) {
          return new Ti(t2, e3).nearestPoints();
        };
        var Ri = function() {
          this._pt = [new C(), new C()], this._distance = v.NaN, this._isNull = true;
        };
        Ri.prototype.getCoordinates = function() {
          return this._pt;
        }, Ri.prototype.getCoordinate = function(t2) {
          return this._pt[t2];
        }, Ri.prototype.setMinimum = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setMinimum(t2._pt[0], t2._pt[1]);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 < this._distance && this.initialize(e3, n2, i2);
          }
        }, Ri.prototype.initialize = function() {
          if (0 === arguments.length)
            this._isNull = true;
          else if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            this._pt[0].setCoordinate(t2), this._pt[1].setCoordinate(e3), this._distance = t2.distance(e3), this._isNull = false;
          } else if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2];
            this._pt[0].setCoordinate(n2), this._pt[1].setCoordinate(i2), this._distance = r2, this._isNull = false;
          }
        }, Ri.prototype.toString = function() {
          return Z.toLineString(this._pt[0], this._pt[1]);
        }, Ri.prototype.getDistance = function() {
          return this._distance;
        }, Ri.prototype.setMaximum = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            this.setMaximum(t2._pt[0], t2._pt[1]);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            if (this._isNull)
              return this.initialize(e3, n2), null;
            var i2 = e3.distance(n2);
            i2 > this._distance && this.initialize(e3, n2, i2);
          }
        }, Ri.prototype.interfaces_ = function() {
          return [];
        }, Ri.prototype.getClass = function() {
          return Ri;
        };
        var Pi = function() {
        };
        Pi.prototype.interfaces_ = function() {
          return [];
        }, Pi.prototype.getClass = function() {
          return Pi;
        }, Pi.computeDistance = function() {
          if (arguments[2] instanceof Ri && arguments[0] instanceof Kt && arguments[1] instanceof C)
            for (var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2], i2 = new dn(), r2 = t2.getCoordinates(), o2 = 0; o2 < r2.length - 1; o2++) {
              i2.setCoordinates(r2[o2], r2[o2 + 1]);
              var s2 = i2.closestPoint(e3);
              n2.setMinimum(s2, e3);
            }
          else if (arguments[2] instanceof Ri && arguments[0] instanceof $t && arguments[1] instanceof C) {
            var a2 = arguments[0], u2 = arguments[1], l2 = arguments[2];
            Pi.computeDistance(a2.getExteriorRing(), u2, l2);
            for (var c2 = 0; c2 < a2.getNumInteriorRing(); c2++)
              Pi.computeDistance(a2.getInteriorRingN(c2), u2, l2);
          } else if (arguments[2] instanceof Ri && arguments[0] instanceof ct && arguments[1] instanceof C) {
            var p2 = arguments[0], h2 = arguments[1], f2 = arguments[2];
            if (p2 instanceof Kt)
              Pi.computeDistance(p2, h2, f2);
            else if (p2 instanceof $t)
              Pi.computeDistance(p2, h2, f2);
            else if (p2 instanceof zt)
              for (var g2 = p2, d2 = 0; d2 < g2.getNumGeometries(); d2++) {
                var y3 = g2.getGeometryN(d2);
                Pi.computeDistance(y3, h2, f2);
              }
            else
              f2.setMinimum(p2.getCoordinate(), h2);
          } else if (arguments[2] instanceof Ri && arguments[0] instanceof dn && arguments[1] instanceof C) {
            var _2 = arguments[0], m2 = arguments[1], v2 = arguments[2], I2 = _2.closestPoint(m2);
            v2.setMinimum(I2, m2);
          }
        };
        var Di = function() {
          this._g0 = null, this._g1 = null, this._ptDist = new Ri(), this._densifyFrac = 0;
          var t2 = arguments[0], e3 = arguments[1];
          this._g0 = t2, this._g1 = e3;
        }, Mi = { MaxPointDistanceFilter: { configurable: true }, MaxDensifiedByFractionDistanceFilter: { configurable: true } };
        Di.prototype.getCoordinates = function() {
          return this._ptDist.getCoordinates();
        }, Di.prototype.setDensifyFraction = function(t2) {
          if (t2 > 1 || t2 <= 0)
            throw new m("Fraction is not in range (0.0 - 1.0]");
          this._densifyFrac = t2;
        }, Di.prototype.compute = function(t2, e3) {
          this.computeOrientedDistance(t2, e3, this._ptDist), this.computeOrientedDistance(e3, t2, this._ptDist);
        }, Di.prototype.distance = function() {
          return this.compute(this._g0, this._g1), this._ptDist.getDistance();
        }, Di.prototype.computeOrientedDistance = function(t2, e3, n2) {
          var i2 = new Ai(e3);
          if (t2.apply(i2), n2.setMaximum(i2.getMaxPointDistance()), this._densifyFrac > 0) {
            var r2 = new Fi(e3, this._densifyFrac);
            t2.apply(r2), n2.setMaximum(r2.getMaxPointDistance());
          }
        }, Di.prototype.orientedDistance = function() {
          return this.computeOrientedDistance(this._g0, this._g1, this._ptDist), this._ptDist.getDistance();
        }, Di.prototype.interfaces_ = function() {
          return [];
        }, Di.prototype.getClass = function() {
          return Di;
        }, Di.distance = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1];
            return new Di(t2, e3).distance();
          }
          if (3 === arguments.length) {
            var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new Di(n2, i2);
            return o2.setDensifyFraction(r2), o2.distance();
          }
        }, Mi.MaxPointDistanceFilter.get = function() {
          return Ai;
        }, Mi.MaxDensifiedByFractionDistanceFilter.get = function() {
          return Fi;
        }, Object.defineProperties(Di, Mi);
        var Ai = function() {
          this._maxPtDist = new Ri(), this._minPtDist = new Ri(), this._euclideanDist = new Pi(), this._geom = null;
          var t2 = arguments[0];
          this._geom = t2;
        };
        Ai.prototype.filter = function(t2) {
          this._minPtDist.initialize(), Pi.computeDistance(this._geom, t2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
        }, Ai.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, Ai.prototype.interfaces_ = function() {
          return [ft];
        }, Ai.prototype.getClass = function() {
          return Ai;
        };
        var Fi = function() {
          this._maxPtDist = new Ri(), this._minPtDist = new Ri(), this._geom = null, this._numSubSegs = 0;
          var t2 = arguments[0], e3 = arguments[1];
          this._geom = t2, this._numSubSegs = Math.trunc(Math.round(1 / e3));
        };
        Fi.prototype.filter = function(t2, e3) {
          if (0 === e3)
            return null;
          for (var n2 = t2.getCoordinate(e3 - 1), i2 = t2.getCoordinate(e3), r2 = (i2.x - n2.x) / this._numSubSegs, o2 = (i2.y - n2.y) / this._numSubSegs, s2 = 0; s2 < this._numSubSegs; s2++) {
            var a2 = n2.x + s2 * r2, u2 = n2.y + s2 * o2, l2 = new C(a2, u2);
            this._minPtDist.initialize(), Pi.computeDistance(this._geom, l2, this._minPtDist), this._maxPtDist.setMaximum(this._minPtDist);
          }
        }, Fi.prototype.isDone = function() {
          return false;
        }, Fi.prototype.isGeometryChanged = function() {
          return false;
        }, Fi.prototype.getMaxPointDistance = function() {
          return this._maxPtDist;
        }, Fi.prototype.interfaces_ = function() {
          return [Ut];
        }, Fi.prototype.getClass = function() {
          return Fi;
        };
        var Gi = function(t2, e3, n2) {
          this._minValidDistance = null, this._maxValidDistance = null, this._minDistanceFound = null, this._maxDistanceFound = null, this._isValid = true, this._errMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t2 || null, this._bufDistance = e3 || null, this._result = n2 || null;
        }, qi = { VERBOSE: { configurable: true }, MAX_DISTANCE_DIFF_FRAC: { configurable: true } };
        Gi.prototype.checkMaximumDistance = function(t2, e3, n2) {
          var i2 = new Di(e3, t2);
          if (i2.setDensifyFraction(0.25), this._maxDistanceFound = i2.orientedDistance(), this._maxDistanceFound > n2) {
            this._isValid = false;
            var r2 = i2.getCoordinates();
            this._errorLocation = r2[1], this._errorIndicator = t2.getFactory().createLineString(r2), this._errMsg = "Distance between buffer curve and input is too large (" + this._maxDistanceFound + " at " + Z.toLineString(r2[0], r2[1]) + ")";
          }
        }, Gi.prototype.isValid = function() {
          var t2 = Math.abs(this._bufDistance), e3 = Gi.MAX_DISTANCE_DIFF_FRAC * t2;
          return this._minValidDistance = t2 - e3, this._maxValidDistance = t2 + e3, !(!this._input.isEmpty() && !this._result.isEmpty()) || (this._bufDistance > 0 ? this.checkPositiveValid() : this.checkNegativeValid(), Gi.VERBOSE && Y.out.println("Min Dist= " + this._minDistanceFound + "  err= " + (1 - this._minDistanceFound / this._bufDistance) + "  Max Dist= " + this._maxDistanceFound + "  err= " + (this._maxDistanceFound / this._bufDistance - 1)), this._isValid);
        }, Gi.prototype.checkNegativeValid = function() {
          if (!(this._input instanceof $t || this._input instanceof ne || this._input instanceof zt))
            return null;
          var t2 = this.getPolygonLines(this._input);
          if (this.checkMinimumDistance(t2, this._result, this._minValidDistance), !this._isValid)
            return null;
          this.checkMaximumDistance(t2, this._result, this._maxValidDistance);
        }, Gi.prototype.getErrorIndicator = function() {
          return this._errorIndicator;
        }, Gi.prototype.checkMinimumDistance = function(t2, e3, n2) {
          var i2 = new Ti(t2, e3, n2);
          if (this._minDistanceFound = i2.distance(), this._minDistanceFound < n2) {
            this._isValid = false;
            var r2 = i2.nearestPoints();
            this._errorLocation = i2.nearestPoints()[1], this._errorIndicator = t2.getFactory().createLineString(r2), this._errMsg = "Distance between buffer curve and input is too small (" + this._minDistanceFound + " at " + Z.toLineString(r2[0], r2[1]) + " )";
          }
        }, Gi.prototype.checkPositiveValid = function() {
          var t2 = this._result.getBoundary();
          if (this.checkMinimumDistance(this._input, t2, this._minValidDistance), !this._isValid)
            return null;
          this.checkMaximumDistance(this._input, t2, this._maxValidDistance);
        }, Gi.prototype.getErrorLocation = function() {
          return this._errorLocation;
        }, Gi.prototype.getPolygonLines = function(t2) {
          for (var e3 = new Nt(), n2 = new Ci(e3), i2 = Ni.getPolygons(t2).iterator(); i2.hasNext(); ) {
            i2.next().apply(n2);
          }
          return t2.getFactory().buildGeometry(e3);
        }, Gi.prototype.getErrorMessage = function() {
          return this._errMsg;
        }, Gi.prototype.interfaces_ = function() {
          return [];
        }, Gi.prototype.getClass = function() {
          return Gi;
        }, qi.VERBOSE.get = function() {
          return false;
        }, qi.MAX_DISTANCE_DIFF_FRAC.get = function() {
          return 0.012;
        }, Object.defineProperties(Gi, qi);
        var Bi = function(t2, e3, n2) {
          this._isValid = true, this._errorMsg = null, this._errorLocation = null, this._errorIndicator = null, this._input = t2 || null, this._distance = e3 || null, this._result = n2 || null;
        }, Vi = { VERBOSE: { configurable: true }, MAX_ENV_DIFF_FRAC: { configurable: true } };
        Bi.prototype.isValid = function() {
          return this.checkPolygonal(), this._isValid ? (this.checkExpectedEmpty(), this._isValid ? (this.checkEnvelope(), this._isValid ? (this.checkArea(), this._isValid ? (this.checkDistance(), this._isValid) : this._isValid) : this._isValid) : this._isValid) : this._isValid;
        }, Bi.prototype.checkEnvelope = function() {
          if (this._distance < 0)
            return null;
          var t2 = this._distance * Bi.MAX_ENV_DIFF_FRAC;
          0 === t2 && (t2 = 1e-3);
          var e3 = new j(this._input.getEnvelopeInternal());
          e3.expandBy(this._distance);
          var n2 = new j(this._result.getEnvelopeInternal());
          n2.expandBy(t2), n2.contains(e3) || (this._isValid = false, this._errorMsg = "Buffer envelope is incorrect", this._errorIndicator = this._input.getFactory().toGeometry(n2)), this.report("Envelope");
        }, Bi.prototype.checkDistance = function() {
          var t2 = new Gi(this._input, this._distance, this._result);
          t2.isValid() || (this._isValid = false, this._errorMsg = t2.getErrorMessage(), this._errorLocation = t2.getErrorLocation(), this._errorIndicator = t2.getErrorIndicator()), this.report("Distance");
        }, Bi.prototype.checkArea = function() {
          var t2 = this._input.getArea(), e3 = this._result.getArea();
          this._distance > 0 && t2 > e3 && (this._isValid = false, this._errorMsg = "Area of positive buffer is smaller than input", this._errorIndicator = this._result), this._distance < 0 && t2 < e3 && (this._isValid = false, this._errorMsg = "Area of negative buffer is larger than input", this._errorIndicator = this._result), this.report("Area");
        }, Bi.prototype.checkPolygonal = function() {
          this._result instanceof $t || this._result instanceof ne || (this._isValid = false), this._errorMsg = "Result is not polygonal", this._errorIndicator = this._result, this.report("Polygonal");
        }, Bi.prototype.getErrorIndicator = function() {
          return this._errorIndicator;
        }, Bi.prototype.getErrorLocation = function() {
          return this._errorLocation;
        }, Bi.prototype.checkExpectedEmpty = function() {
          return this._input.getDimension() >= 2 ? null : this._distance > 0 ? null : (this._result.isEmpty() || (this._isValid = false, this._errorMsg = "Result is non-empty", this._errorIndicator = this._result), void this.report("ExpectedEmpty"));
        }, Bi.prototype.report = function(t2) {
          if (!Bi.VERBOSE)
            return null;
          Y.out.println("Check " + t2 + ": " + (this._isValid ? "passed" : "FAILED"));
        }, Bi.prototype.getErrorMessage = function() {
          return this._errorMsg;
        }, Bi.prototype.interfaces_ = function() {
          return [];
        }, Bi.prototype.getClass = function() {
          return Bi;
        }, Bi.isValidMsg = function(t2, e3, n2) {
          var i2 = new Bi(t2, e3, n2);
          return i2.isValid() ? null : i2.getErrorMessage();
        }, Bi.isValid = function(t2, e3, n2) {
          return !!new Bi(t2, e3, n2).isValid();
        }, Vi.VERBOSE.get = function() {
          return false;
        }, Vi.MAX_ENV_DIFF_FRAC.get = function() {
          return 0.012;
        }, Object.defineProperties(Bi, Vi);
        var Ui = function() {
          this._pts = null, this._data = null;
          var t2 = arguments[0], e3 = arguments[1];
          this._pts = t2, this._data = e3;
        };
        Ui.prototype.getCoordinates = function() {
          return this._pts;
        }, Ui.prototype.size = function() {
          return this._pts.length;
        }, Ui.prototype.getCoordinate = function(t2) {
          return this._pts[t2];
        }, Ui.prototype.isClosed = function() {
          return this._pts[0].equals(this._pts[this._pts.length - 1]);
        }, Ui.prototype.getSegmentOctant = function(t2) {
          return t2 === this._pts.length - 1 ? -1 : pn.octant(this.getCoordinate(t2), this.getCoordinate(t2 + 1));
        }, Ui.prototype.setData = function(t2) {
          this._data = t2;
        }, Ui.prototype.getData = function() {
          return this._data;
        }, Ui.prototype.toString = function() {
          return Z.toLineString(new ue(this._pts));
        }, Ui.prototype.interfaces_ = function() {
          return [hn];
        }, Ui.prototype.getClass = function() {
          return Ui;
        };
        var zi = function() {
          this._findAllIntersections = false, this._isCheckEndSegmentsOnly = false, this._li = null, this._interiorIntersection = null, this._intSegments = null, this._intersections = new Nt(), this._intersectionCount = 0, this._keepIntersections = true;
          var t2 = arguments[0];
          this._li = t2, this._interiorIntersection = null;
        };
        zi.prototype.getInteriorIntersection = function() {
          return this._interiorIntersection;
        }, zi.prototype.setCheckEndSegmentsOnly = function(t2) {
          this._isCheckEndSegmentsOnly = t2;
        }, zi.prototype.getIntersectionSegments = function() {
          return this._intSegments;
        }, zi.prototype.count = function() {
          return this._intersectionCount;
        }, zi.prototype.getIntersections = function() {
          return this._intersections;
        }, zi.prototype.setFindAllIntersections = function(t2) {
          this._findAllIntersections = t2;
        }, zi.prototype.setKeepIntersections = function(t2) {
          this._keepIntersections = t2;
        }, zi.prototype.processIntersections = function(t2, e3, n2, i2) {
          if (!this._findAllIntersections && this.hasIntersection())
            return null;
          if (t2 === n2 && e3 === i2)
            return null;
          if (this._isCheckEndSegmentsOnly) {
            if (!(this.isEndSegment(t2, e3) || this.isEndSegment(n2, i2)))
              return null;
          }
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
          this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && this._li.isInteriorIntersection() && (this._intSegments = new Array(4).fill(null), this._intSegments[0] = r2, this._intSegments[1] = o2, this._intSegments[2] = s2, this._intSegments[3] = a2, this._interiorIntersection = this._li.getIntersection(0), this._keepIntersections && this._intersections.add(this._interiorIntersection), this._intersectionCount++);
        }, zi.prototype.isEndSegment = function(t2, e3) {
          return 0 === e3 || e3 >= t2.size() - 2;
        }, zi.prototype.hasIntersection = function() {
          return null !== this._interiorIntersection;
        }, zi.prototype.isDone = function() {
          return !this._findAllIntersections && null !== this._interiorIntersection;
        }, zi.prototype.interfaces_ = function() {
          return [Wn];
        }, zi.prototype.getClass = function() {
          return zi;
        }, zi.createAllIntersectionsFinder = function(t2) {
          var e3 = new zi(t2);
          return e3.setFindAllIntersections(true), e3;
        }, zi.createAnyIntersectionFinder = function(t2) {
          return new zi(t2);
        }, zi.createIntersectionCounter = function(t2) {
          var e3 = new zi(t2);
          return e3.setFindAllIntersections(true), e3.setKeepIntersections(false), e3;
        };
        var Xi = function() {
          this._li = new rt(), this._segStrings = null, this._findAllIntersections = false, this._segInt = null, this._isValid = true;
          var t2 = arguments[0];
          this._segStrings = t2;
        };
        Xi.prototype.execute = function() {
          if (null !== this._segInt)
            return null;
          this.checkInteriorIntersections();
        }, Xi.prototype.getIntersections = function() {
          return this._segInt.getIntersections();
        }, Xi.prototype.isValid = function() {
          return this.execute(), this._isValid;
        }, Xi.prototype.setFindAllIntersections = function(t2) {
          this._findAllIntersections = t2;
        }, Xi.prototype.checkInteriorIntersections = function() {
          this._isValid = true, this._segInt = new zi(this._li), this._segInt.setFindAllIntersections(this._findAllIntersections);
          var t2 = new xn();
          if (t2.setSegmentIntersector(this._segInt), t2.computeNodes(this._segStrings), this._segInt.hasIntersection())
            return this._isValid = false, null;
        }, Xi.prototype.checkValid = function() {
          if (this.execute(), !this._isValid)
            throw new we(this.getErrorMessage(), this._segInt.getInteriorIntersection());
        }, Xi.prototype.getErrorMessage = function() {
          if (this._isValid)
            return "no intersections found";
          var t2 = this._segInt.getIntersectionSegments();
          return "found non-noded intersection between " + Z.toLineString(t2[0], t2[1]) + " and " + Z.toLineString(t2[2], t2[3]);
        }, Xi.prototype.interfaces_ = function() {
          return [];
        }, Xi.prototype.getClass = function() {
          return Xi;
        }, Xi.computeIntersections = function(t2) {
          var e3 = new Xi(t2);
          return e3.setFindAllIntersections(true), e3.isValid(), e3.getIntersections();
        };
        var Yi = function t2() {
          this._nv = null;
          var e3 = arguments[0];
          this._nv = new Xi(t2.toSegmentStrings(e3));
        };
        Yi.prototype.checkValid = function() {
          this._nv.checkValid();
        }, Yi.prototype.interfaces_ = function() {
          return [];
        }, Yi.prototype.getClass = function() {
          return Yi;
        }, Yi.toSegmentStrings = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            e3.add(new Ui(i2.getCoordinates(), i2));
          }
          return e3;
        }, Yi.checkValid = function(t2) {
          new Yi(t2).checkValid();
        };
        var ki = function(t2) {
          this._mapOp = t2;
        };
        ki.prototype.map = function(t2) {
          for (var e3 = new Nt(), n2 = 0; n2 < t2.getNumGeometries(); n2++) {
            var i2 = this._mapOp.map(t2.getGeometryN(n2));
            i2.isEmpty() || e3.add(i2);
          }
          return t2.getFactory().createGeometryCollection(_e.toGeometryArray(e3));
        }, ki.prototype.interfaces_ = function() {
          return [];
        }, ki.prototype.getClass = function() {
          return ki;
        }, ki.map = function(t2, e3) {
          return new ki(e3).map(t2);
        };
        var ji = function() {
          this._op = null, this._geometryFactory = null, this._ptLocator = null, this._lineEdgesList = new Nt(), this._resultLineList = new Nt();
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._op = t2, this._geometryFactory = e3, this._ptLocator = n2;
        };
        ji.prototype.collectLines = function(t2) {
          for (var e3 = this._op.getGraph().getEdgeEnds().iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            this.collectLineEdge(n2, t2, this._lineEdgesList), this.collectBoundaryTouchEdge(n2, t2, this._lineEdgesList);
          }
        }, ji.prototype.labelIsolatedLine = function(t2, e3) {
          var n2 = this._ptLocator.locate(t2.getCoordinate(), this._op.getArgGeometry(e3));
          t2.getLabel().setLocation(e3, n2);
        }, ji.prototype.build = function(t2) {
          return this.findCoveredLineEdges(), this.collectLines(t2), this.buildLines(t2), this._resultLineList;
        }, ji.prototype.collectLineEdge = function(t2, e3, n2) {
          var i2 = t2.getLabel(), r2 = t2.getEdge();
          t2.isLineEdge() && (t2.isVisited() || !Lr.isResultOfOp(i2, e3) || r2.isCovered() || (n2.add(r2), t2.setVisitedEdge(true)));
        }, ji.prototype.findCoveredLineEdges = function() {
          for (var t2 = this._op.getGraph().getNodes().iterator(); t2.hasNext(); ) {
            t2.next().getEdges().findCoveredLineEdges();
          }
          for (var e3 = this._op.getGraph().getEdgeEnds().iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = n2.getEdge();
            if (n2.isLineEdge() && !i2.isCoveredSet()) {
              var r2 = this._op.isCoveredByA(n2.getCoordinate());
              i2.setCovered(r2);
            }
          }
        }, ji.prototype.labelIsolatedLines = function(t2) {
          for (var e3 = t2.iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = n2.getLabel();
            n2.isIsolated() && (i2.isNull(0) ? this.labelIsolatedLine(n2, 0) : this.labelIsolatedLine(n2, 1));
          }
        }, ji.prototype.buildLines = function(t2) {
          for (var e3 = this._lineEdgesList.iterator(); e3.hasNext(); ) {
            var n2 = e3.next(), i2 = this._geometryFactory.createLineString(n2.getCoordinates());
            this._resultLineList.add(i2), n2.setInResult(true);
          }
        }, ji.prototype.collectBoundaryTouchEdge = function(t2, e3, n2) {
          var i2 = t2.getLabel();
          return t2.isLineEdge() ? null : t2.isVisited() ? null : t2.isInteriorAreaEdge() ? null : t2.getEdge().isInResult() ? null : (et.isTrue(!(t2.isInResult() || t2.getSym().isInResult()) || !t2.getEdge().isInResult()), void (Lr.isResultOfOp(i2, e3) && e3 === Lr.INTERSECTION && (n2.add(t2.getEdge()), t2.setVisitedEdge(true))));
        }, ji.prototype.interfaces_ = function() {
          return [];
        }, ji.prototype.getClass = function() {
          return ji;
        };
        var Hi = function() {
          this._op = null, this._geometryFactory = null, this._resultPointList = new Nt();
          var t2 = arguments[0], e3 = arguments[1];
          this._op = t2, this._geometryFactory = e3;
        };
        Hi.prototype.filterCoveredNodeToPoint = function(t2) {
          var e3 = t2.getCoordinate();
          if (!this._op.isCoveredByLA(e3)) {
            var n2 = this._geometryFactory.createPoint(e3);
            this._resultPointList.add(n2);
          }
        }, Hi.prototype.extractNonCoveredResultNodes = function(t2) {
          for (var e3 = this._op.getGraph().getNodes().iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            if (!n2.isInResult() && (!n2.isIncidentEdgeInResult() && (0 === n2.getEdges().getDegree() || t2 === Lr.INTERSECTION))) {
              var i2 = n2.getLabel();
              Lr.isResultOfOp(i2, t2) && this.filterCoveredNodeToPoint(n2);
            }
          }
        }, Hi.prototype.build = function(t2) {
          return this.extractNonCoveredResultNodes(t2), this._resultPointList;
        }, Hi.prototype.interfaces_ = function() {
          return [];
        }, Hi.prototype.getClass = function() {
          return Hi;
        };
        var Wi = function() {
          this._inputGeom = null, this._factory = null, this._pruneEmptyGeometry = true, this._preserveGeometryCollectionType = true, this._preserveCollections = false, this._preserveType = false;
        };
        Wi.prototype.transformPoint = function(t2, e3) {
          return this._factory.createPoint(this.transformCoordinates(t2.getCoordinateSequence(), t2));
        }, Wi.prototype.transformPolygon = function(t2, e3) {
          var n2 = true, i2 = this.transformLinearRing(t2.getExteriorRing(), t2);
          null !== i2 && i2 instanceof ee && !i2.isEmpty() || (n2 = false);
          for (var r2 = new Nt(), o2 = 0; o2 < t2.getNumInteriorRing(); o2++) {
            var s2 = this.transformLinearRing(t2.getInteriorRingN(o2), t2);
            null === s2 || s2.isEmpty() || (s2 instanceof ee || (n2 = false), r2.add(s2));
          }
          if (n2)
            return this._factory.createPolygon(i2, r2.toArray([]));
          var a2 = new Nt();
          return null !== i2 && a2.add(i2), a2.addAll(r2), this._factory.buildGeometry(a2);
        }, Wi.prototype.createCoordinateSequence = function(t2) {
          return this._factory.getCoordinateSequenceFactory().create(t2);
        }, Wi.prototype.getInputGeometry = function() {
          return this._inputGeom;
        }, Wi.prototype.transformMultiLineString = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transformLineString(t2.getGeometryN(i2), t2);
            null !== r2 && (r2.isEmpty() || n2.add(r2));
          }
          return this._factory.buildGeometry(n2);
        }, Wi.prototype.transformCoordinates = function(t2, e3) {
          return this.copy(t2);
        }, Wi.prototype.transformLineString = function(t2, e3) {
          return this._factory.createLineString(this.transformCoordinates(t2.getCoordinateSequence(), t2));
        }, Wi.prototype.transformMultiPoint = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transformPoint(t2.getGeometryN(i2), t2);
            null !== r2 && (r2.isEmpty() || n2.add(r2));
          }
          return this._factory.buildGeometry(n2);
        }, Wi.prototype.transformMultiPolygon = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transformPolygon(t2.getGeometryN(i2), t2);
            null !== r2 && (r2.isEmpty() || n2.add(r2));
          }
          return this._factory.buildGeometry(n2);
        }, Wi.prototype.copy = function(t2) {
          return t2.copy();
        }, Wi.prototype.transformGeometryCollection = function(t2, e3) {
          for (var n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
            var r2 = this.transform(t2.getGeometryN(i2));
            null !== r2 && (this._pruneEmptyGeometry && r2.isEmpty() || n2.add(r2));
          }
          return this._preserveGeometryCollectionType ? this._factory.createGeometryCollection(_e.toGeometryArray(n2)) : this._factory.buildGeometry(n2);
        }, Wi.prototype.transform = function(t2) {
          if (this._inputGeom = t2, this._factory = t2.getFactory(), t2 instanceof Qt)
            return this.transformPoint(t2, null);
          if (t2 instanceof te)
            return this.transformMultiPoint(t2, null);
          if (t2 instanceof ee)
            return this.transformLinearRing(t2, null);
          if (t2 instanceof Kt)
            return this.transformLineString(t2, null);
          if (t2 instanceof Xt)
            return this.transformMultiLineString(t2, null);
          if (t2 instanceof $t)
            return this.transformPolygon(t2, null);
          if (t2 instanceof ne)
            return this.transformMultiPolygon(t2, null);
          if (t2 instanceof zt)
            return this.transformGeometryCollection(t2, null);
          throw new m("Unknown Geometry subtype: " + t2.getClass().getName());
        }, Wi.prototype.transformLinearRing = function(t2, e3) {
          var n2 = this.transformCoordinates(t2.getCoordinateSequence(), t2);
          if (null === n2)
            return this._factory.createLinearRing(null);
          var i2 = n2.size();
          return i2 > 0 && i2 < 4 && !this._preserveType ? this._factory.createLineString(n2) : this._factory.createLinearRing(n2);
        }, Wi.prototype.interfaces_ = function() {
          return [];
        }, Wi.prototype.getClass = function() {
          return Wi;
        };
        var Ki = function t2() {
          if (this._snapTolerance = 0, this._srcPts = null, this._seg = new dn(), this._allowSnappingToSourceVertices = false, this._isClosed = false, arguments[0] instanceof Kt && "number" == typeof arguments[1]) {
            var e3 = arguments[0], n2 = arguments[1];
            t2.call(this, e3.getCoordinates(), n2);
          } else if (arguments[0] instanceof Array && "number" == typeof arguments[1]) {
            var i2 = arguments[0], r2 = arguments[1];
            this._srcPts = i2, this._isClosed = t2.isClosed(i2), this._snapTolerance = r2;
          }
        };
        Ki.prototype.snapVertices = function(t2, e3) {
          for (var n2 = this._isClosed ? t2.size() - 1 : t2.size(), i2 = 0; i2 < n2; i2++) {
            var r2 = t2.get(i2), o2 = this.findSnapForVertex(r2, e3);
            null !== o2 && (t2.set(i2, new C(o2)), 0 === i2 && this._isClosed && t2.set(t2.size() - 1, new C(o2)));
          }
        }, Ki.prototype.findSnapForVertex = function(t2, e3) {
          for (var n2 = 0; n2 < e3.length; n2++) {
            if (t2.equals2D(e3[n2]))
              return null;
            if (t2.distance(e3[n2]) < this._snapTolerance)
              return e3[n2];
          }
          return null;
        }, Ki.prototype.snapTo = function(t2) {
          var e3 = new St(this._srcPts);
          this.snapVertices(e3, t2), this.snapSegments(e3, t2);
          return e3.toCoordinateArray();
        }, Ki.prototype.snapSegments = function(t2, e3) {
          if (0 === e3.length)
            return null;
          var n2 = e3.length;
          e3[0].equals2D(e3[e3.length - 1]) && (n2 = e3.length - 1);
          for (var i2 = 0; i2 < n2; i2++) {
            var r2 = e3[i2], o2 = this.findSegmentIndexToSnap(r2, t2);
            o2 >= 0 && t2.add(o2 + 1, new C(r2), false);
          }
        }, Ki.prototype.findSegmentIndexToSnap = function(t2, e3) {
          for (var n2 = v.MAX_VALUE, i2 = -1, r2 = 0; r2 < e3.size() - 1; r2++) {
            if (this._seg.p0 = e3.get(r2), this._seg.p1 = e3.get(r2 + 1), this._seg.p0.equals2D(t2) || this._seg.p1.equals2D(t2)) {
              if (this._allowSnappingToSourceVertices)
                continue;
              return -1;
            }
            var o2 = this._seg.distance(t2);
            o2 < this._snapTolerance && o2 < n2 && (n2 = o2, i2 = r2);
          }
          return i2;
        }, Ki.prototype.setAllowSnappingToSourceVertices = function(t2) {
          this._allowSnappingToSourceVertices = t2;
        }, Ki.prototype.interfaces_ = function() {
          return [];
        }, Ki.prototype.getClass = function() {
          return Ki;
        }, Ki.isClosed = function(t2) {
          return !(t2.length <= 1) && t2[0].equals2D(t2[t2.length - 1]);
        };
        var Ji = function(t2) {
          this._srcGeom = t2 || null;
        }, Qi = { SNAP_PRECISION_FACTOR: { configurable: true } };
        Ji.prototype.snapTo = function(t2, e3) {
          var n2 = this.extractTargetCoordinates(t2);
          return new Zi(e3, n2).transform(this._srcGeom);
        }, Ji.prototype.snapToSelf = function(t2, e3) {
          var n2 = this.extractTargetCoordinates(this._srcGeom), i2 = new Zi(t2, n2, true).transform(this._srcGeom), r2 = i2;
          return e3 && T(r2, Zt) && (r2 = i2.buffer(0)), r2;
        }, Ji.prototype.computeSnapTolerance = function(t2) {
          return this.computeMinimumSegmentLength(t2) / 10;
        }, Ji.prototype.extractTargetCoordinates = function(t2) {
          for (var e3 = new f(), n2 = t2.getCoordinates(), i2 = 0; i2 < n2.length; i2++)
            e3.add(n2[i2]);
          return e3.toArray(new Array(0).fill(null));
        }, Ji.prototype.computeMinimumSegmentLength = function(t2) {
          for (var e3 = v.MAX_VALUE, n2 = 0; n2 < t2.length - 1; n2++) {
            var i2 = t2[n2].distance(t2[n2 + 1]);
            i2 < e3 && (e3 = i2);
          }
          return e3;
        }, Ji.prototype.interfaces_ = function() {
          return [];
        }, Ji.prototype.getClass = function() {
          return Ji;
        }, Ji.snap = function(t2, e3, n2) {
          var i2 = new Array(2).fill(null), r2 = new Ji(t2);
          i2[0] = r2.snapTo(e3, n2);
          var o2 = new Ji(e3);
          return i2[1] = o2.snapTo(i2[0], n2), i2;
        }, Ji.computeOverlaySnapTolerance = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = Ji.computeSizeBasedSnapTolerance(t2), n2 = t2.getPrecisionModel();
            if (n2.getType() === fe.FIXED) {
              var i2 = 1 / n2.getScale() * 2 / 1.415;
              i2 > e3 && (e3 = i2);
            }
            return e3;
          }
          if (2 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1];
            return Math.min(Ji.computeOverlaySnapTolerance(r2), Ji.computeOverlaySnapTolerance(o2));
          }
        }, Ji.computeSizeBasedSnapTolerance = function(t2) {
          var e3 = t2.getEnvelopeInternal();
          return Math.min(e3.getHeight(), e3.getWidth()) * Ji.SNAP_PRECISION_FACTOR;
        }, Ji.snapToSelf = function(t2, e3, n2) {
          return new Ji(t2).snapToSelf(e3, n2);
        }, Qi.SNAP_PRECISION_FACTOR.get = function() {
          return 1e-9;
        }, Object.defineProperties(Ji, Qi);
        var Zi = function(t2) {
          function e3(e4, n2, i2) {
            t2.call(this), this._snapTolerance = e4 || null, this._snapPts = n2 || null, this._isSelfSnap = void 0 !== i2 && i2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.snapLine = function(t3, e4) {
            var n2 = new Ki(t3, this._snapTolerance);
            return n2.setAllowSnappingToSourceVertices(this._isSelfSnap), n2.snapTo(e4);
          }, e3.prototype.transformCoordinates = function(t3, e4) {
            var n2 = t3.toCoordinateArray(), i2 = this.snapLine(n2, this._snapPts);
            return this._factory.getCoordinateSequenceFactory().create(i2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Wi), $i = function() {
          this._isFirst = true, this._commonMantissaBitsCount = 53, this._commonBits = 0, this._commonSignExp = null;
        };
        $i.prototype.getCommon = function() {
          return v.longBitsToDouble(this._commonBits);
        }, $i.prototype.add = function(t2) {
          var e3 = v.doubleToLongBits(t2);
          if (this._isFirst)
            return this._commonBits = e3, this._commonSignExp = $i.signExpBits(this._commonBits), this._isFirst = false, null;
          if ($i.signExpBits(e3) !== this._commonSignExp)
            return this._commonBits = 0, null;
          this._commonMantissaBitsCount = $i.numCommonMostSigMantissaBits(this._commonBits, e3), this._commonBits = $i.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));
        }, $i.prototype.toString = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0], e3 = v.longBitsToDouble(t2), n2 = "0000000000000000000000000000000000000000000000000000000000000000" + v.toBinaryString(t2), i2 = n2.substring(n2.length - 64);
            return i2.substring(0, 1) + "  " + i2.substring(1, 12) + "(exp) " + i2.substring(12) + " [ " + e3 + " ]";
          }
        }, $i.prototype.interfaces_ = function() {
          return [];
        }, $i.prototype.getClass = function() {
          return $i;
        }, $i.getBit = function(t2, e3) {
          return 0 != (t2 & 1 << e3) ? 1 : 0;
        }, $i.signExpBits = function(t2) {
          return t2 >> 52;
        }, $i.zeroLowerBits = function(t2, e3) {
          return t2 & ~((1 << e3) - 1);
        }, $i.numCommonMostSigMantissaBits = function(t2, e3) {
          for (var n2 = 0, i2 = 52; i2 >= 0; i2--) {
            if ($i.getBit(t2, i2) !== $i.getBit(e3, i2))
              return n2;
            n2++;
          }
          return 52;
        };
        var tr = function() {
          this._commonCoord = null, this._ccFilter = new nr();
        }, er = { CommonCoordinateFilter: { configurable: true }, Translater: { configurable: true } };
        tr.prototype.addCommonBits = function(t2) {
          var e3 = new ir(this._commonCoord);
          t2.apply(e3), t2.geometryChanged();
        }, tr.prototype.removeCommonBits = function(t2) {
          if (0 === this._commonCoord.x && 0 === this._commonCoord.y)
            return t2;
          var e3 = new C(this._commonCoord);
          e3.x = -e3.x, e3.y = -e3.y;
          var n2 = new ir(e3);
          return t2.apply(n2), t2.geometryChanged(), t2;
        }, tr.prototype.getCommonCoordinate = function() {
          return this._commonCoord;
        }, tr.prototype.add = function(t2) {
          t2.apply(this._ccFilter), this._commonCoord = this._ccFilter.getCommonCoordinate();
        }, tr.prototype.interfaces_ = function() {
          return [];
        }, tr.prototype.getClass = function() {
          return tr;
        }, er.CommonCoordinateFilter.get = function() {
          return nr;
        }, er.Translater.get = function() {
          return ir;
        }, Object.defineProperties(tr, er);
        var nr = function() {
          this._commonBitsX = new $i(), this._commonBitsY = new $i();
        };
        nr.prototype.filter = function(t2) {
          this._commonBitsX.add(t2.x), this._commonBitsY.add(t2.y);
        }, nr.prototype.getCommonCoordinate = function() {
          return new C(this._commonBitsX.getCommon(), this._commonBitsY.getCommon());
        }, nr.prototype.interfaces_ = function() {
          return [ft];
        }, nr.prototype.getClass = function() {
          return nr;
        };
        var ir = function() {
          this.trans = null;
          var t2 = arguments[0];
          this.trans = t2;
        };
        ir.prototype.filter = function(t2, e3) {
          var n2 = t2.getOrdinate(e3, 0) + this.trans.x, i2 = t2.getOrdinate(e3, 1) + this.trans.y;
          t2.setOrdinate(e3, 0, n2), t2.setOrdinate(e3, 1, i2);
        }, ir.prototype.isDone = function() {
          return false;
        }, ir.prototype.isGeometryChanged = function() {
          return true;
        }, ir.prototype.interfaces_ = function() {
          return [Ut];
        }, ir.prototype.getClass = function() {
          return ir;
        };
        var rr = function(t2, e3) {
          this._geom = new Array(2).fill(null), this._snapTolerance = null, this._cbr = null, this._geom[0] = t2, this._geom[1] = e3, this.computeSnapTolerance();
        };
        rr.prototype.selfSnap = function(t2) {
          return new Ji(t2).snapTo(t2, this._snapTolerance);
        }, rr.prototype.removeCommonBits = function(t2) {
          this._cbr = new tr(), this._cbr.add(t2[0]), this._cbr.add(t2[1]);
          var e3 = new Array(2).fill(null);
          return e3[0] = this._cbr.removeCommonBits(t2[0].copy()), e3[1] = this._cbr.removeCommonBits(t2[1].copy()), e3;
        }, rr.prototype.prepareResult = function(t2) {
          return this._cbr.addCommonBits(t2), t2;
        }, rr.prototype.getResultGeometry = function(t2) {
          var e3 = this.snap(this._geom), n2 = Lr.overlayOp(e3[0], e3[1], t2);
          return this.prepareResult(n2);
        }, rr.prototype.checkValid = function(t2) {
          t2.isValid() || Y.out.println("Snapped geometry is invalid");
        }, rr.prototype.computeSnapTolerance = function() {
          this._snapTolerance = Ji.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);
        }, rr.prototype.snap = function(t2) {
          var e3 = this.removeCommonBits(t2);
          return Ji.snap(e3[0], e3[1], this._snapTolerance);
        }, rr.prototype.interfaces_ = function() {
          return [];
        }, rr.prototype.getClass = function() {
          return rr;
        }, rr.overlayOp = function(t2, e3, n2) {
          return new rr(t2, e3).getResultGeometry(n2);
        }, rr.union = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.UNION);
        }, rr.intersection = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.INTERSECTION);
        }, rr.symDifference = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.SYMDIFFERENCE);
        }, rr.difference = function(t2, e3) {
          return rr.overlayOp(t2, e3, Lr.DIFFERENCE);
        };
        var or = function(t2, e3) {
          this._geom = new Array(2).fill(null), this._geom[0] = t2, this._geom[1] = e3;
        };
        or.prototype.getResultGeometry = function(t2) {
          var e3 = null, n2 = false, i2 = null;
          try {
            e3 = Lr.overlayOp(this._geom[0], this._geom[1], t2);
            n2 = true;
          } catch (t3) {
            if (!(t3 instanceof $))
              throw t3;
            i2 = t3;
          }
          if (!n2)
            try {
              e3 = rr.overlayOp(this._geom[0], this._geom[1], t2);
            } catch (t3) {
              throw t3 instanceof $ ? i2 : t3;
            }
          return e3;
        }, or.prototype.interfaces_ = function() {
          return [];
        }, or.prototype.getClass = function() {
          return or;
        }, or.overlayOp = function(t2, e3, n2) {
          return new or(t2, e3).getResultGeometry(n2);
        }, or.union = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.UNION);
        }, or.intersection = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.INTERSECTION);
        }, or.symDifference = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.SYMDIFFERENCE);
        }, or.difference = function(t2, e3) {
          return or.overlayOp(t2, e3, Lr.DIFFERENCE);
        };
        var sr = function() {
          this.mce = null, this.chainIndex = null;
          var t2 = arguments[0], e3 = arguments[1];
          this.mce = t2, this.chainIndex = e3;
        };
        sr.prototype.computeIntersections = function(t2, e3) {
          this.mce.computeIntersectsForChain(this.chainIndex, t2.mce, t2.chainIndex, e3);
        }, sr.prototype.interfaces_ = function() {
          return [];
        }, sr.prototype.getClass = function() {
          return sr;
        };
        var ar = function t2() {
          if (this._label = null, this._xValue = null, this._eventType = null, this._insertEvent = null, this._deleteEventIndex = null, this._obj = null, 2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            this._eventType = t2.DELETE, this._xValue = e3, this._insertEvent = n2;
          } else if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            this._eventType = t2.INSERT, this._label = i2, this._xValue = r2, this._obj = o2;
          }
        }, ur = { INSERT: { configurable: true }, DELETE: { configurable: true } };
        ar.prototype.isDelete = function() {
          return this._eventType === ar.DELETE;
        }, ar.prototype.setDeleteEventIndex = function(t2) {
          this._deleteEventIndex = t2;
        }, ar.prototype.getObject = function() {
          return this._obj;
        }, ar.prototype.compareTo = function(t2) {
          var e3 = t2;
          return this._xValue < e3._xValue ? -1 : this._xValue > e3._xValue ? 1 : this._eventType < e3._eventType ? -1 : this._eventType > e3._eventType ? 1 : 0;
        }, ar.prototype.getInsertEvent = function() {
          return this._insertEvent;
        }, ar.prototype.isInsert = function() {
          return this._eventType === ar.INSERT;
        }, ar.prototype.isSameLabel = function(t2) {
          return null !== this._label && this._label === t2._label;
        }, ar.prototype.getDeleteEventIndex = function() {
          return this._deleteEventIndex;
        }, ar.prototype.interfaces_ = function() {
          return [E];
        }, ar.prototype.getClass = function() {
          return ar;
        }, ur.INSERT.get = function() {
          return 1;
        }, ur.DELETE.get = function() {
          return 2;
        }, Object.defineProperties(ar, ur);
        var lr = function() {
        };
        lr.prototype.interfaces_ = function() {
          return [];
        }, lr.prototype.getClass = function() {
          return lr;
        };
        var cr = function() {
          this._hasIntersection = false, this._hasProper = false, this._hasProperInterior = false, this._properIntersectionPoint = null, this._li = null, this._includeProper = null, this._recordIsolated = null, this._isSelfIntersection = null, this._numIntersections = 0, this.numTests = 0, this._bdyNodes = null, this._isDone = false, this._isDoneWhenProperInt = false;
          var t2 = arguments[0], e3 = arguments[1], n2 = arguments[2];
          this._li = t2, this._includeProper = e3, this._recordIsolated = n2;
        };
        cr.prototype.isTrivialIntersection = function(t2, e3, n2, i2) {
          if (t2 === n2 && 1 === this._li.getIntersectionNum()) {
            if (cr.isAdjacentSegments(e3, i2))
              return true;
            if (t2.isClosed()) {
              var r2 = t2.getNumPoints() - 1;
              if (0 === e3 && i2 === r2 || 0 === i2 && e3 === r2)
                return true;
            }
          }
          return false;
        }, cr.prototype.getProperIntersectionPoint = function() {
          return this._properIntersectionPoint;
        }, cr.prototype.setIsDoneIfProperInt = function(t2) {
          this._isDoneWhenProperInt = t2;
        }, cr.prototype.hasProperInteriorIntersection = function() {
          return this._hasProperInterior;
        }, cr.prototype.isBoundaryPointInternal = function(t2, e3) {
          for (var n2 = e3.iterator(); n2.hasNext(); ) {
            var i2 = n2.next().getCoordinate();
            if (t2.isIntersection(i2))
              return true;
          }
          return false;
        }, cr.prototype.hasProperIntersection = function() {
          return this._hasProper;
        }, cr.prototype.hasIntersection = function() {
          return this._hasIntersection;
        }, cr.prototype.isDone = function() {
          return this._isDone;
        }, cr.prototype.isBoundaryPoint = function(t2, e3) {
          return null !== e3 && (!!this.isBoundaryPointInternal(t2, e3[0]) || !!this.isBoundaryPointInternal(t2, e3[1]));
        }, cr.prototype.setBoundaryNodes = function(t2, e3) {
          this._bdyNodes = new Array(2).fill(null), this._bdyNodes[0] = t2, this._bdyNodes[1] = e3;
        }, cr.prototype.addIntersections = function(t2, e3, n2, i2) {
          if (t2 === n2 && e3 === i2)
            return null;
          this.numTests++;
          var r2 = t2.getCoordinates()[e3], o2 = t2.getCoordinates()[e3 + 1], s2 = n2.getCoordinates()[i2], a2 = n2.getCoordinates()[i2 + 1];
          this._li.computeIntersection(r2, o2, s2, a2), this._li.hasIntersection() && (this._recordIsolated && (t2.setIsolated(false), n2.setIsolated(false)), this._numIntersections++, this.isTrivialIntersection(t2, e3, n2, i2) || (this._hasIntersection = true, !this._includeProper && this._li.isProper() || (t2.addIntersections(this._li, e3, 0), n2.addIntersections(this._li, i2, 1)), this._li.isProper() && (this._properIntersectionPoint = this._li.getIntersection(0).copy(), this._hasProper = true, this._isDoneWhenProperInt && (this._isDone = true), this.isBoundaryPoint(this._li, this._bdyNodes) || (this._hasProperInterior = true))));
        }, cr.prototype.interfaces_ = function() {
          return [];
        }, cr.prototype.getClass = function() {
          return cr;
        }, cr.isAdjacentSegments = function(t2, e3) {
          return 1 === Math.abs(t2 - e3);
        };
        var pr = function(t2) {
          function e3() {
            t2.call(this), this.events = new Nt(), this.nOverlaps = null;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.prepareEvents = function() {
            $e.sort(this.events);
            for (var t3 = 0; t3 < this.events.size(); t3++) {
              var e4 = this.events.get(t3);
              e4.isDelete() && e4.getInsertEvent().setDeleteEventIndex(t3);
            }
          }, e3.prototype.computeIntersections = function() {
            if (1 === arguments.length) {
              var t3 = arguments[0];
              this.nOverlaps = 0, this.prepareEvents();
              for (var e4 = 0; e4 < this.events.size(); e4++) {
                var n2 = this.events.get(e4);
                if (n2.isInsert() && this.processOverlaps(e4, n2.getDeleteEventIndex(), n2, t3), t3.isDone())
                  break;
              }
            } else if (3 === arguments.length) {
              if (arguments[2] instanceof cr && T(arguments[0], xt) && T(arguments[1], xt)) {
                var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
                this.addEdges(i2, i2), this.addEdges(r2, r2), this.computeIntersections(o2);
              } else if ("boolean" == typeof arguments[2] && T(arguments[0], xt) && arguments[1] instanceof cr) {
                var s2 = arguments[0], a2 = arguments[1];
                arguments[2] ? this.addEdges(s2, null) : this.addEdges(s2), this.computeIntersections(a2);
              }
            }
          }, e3.prototype.addEdge = function(t3, e4) {
            for (var n2 = t3.getMonotoneChainEdge(), i2 = n2.getStartIndexes(), r2 = 0; r2 < i2.length - 1; r2++) {
              var o2 = new sr(n2, r2), s2 = new ar(e4, n2.getMinX(r2), o2);
              this.events.add(s2), this.events.add(new ar(n2.getMaxX(r2), s2));
            }
          }, e3.prototype.processOverlaps = function(t3, e4, n2, i2) {
            for (var r2 = n2.getObject(), o2 = t3; o2 < e4; o2++) {
              var s2 = this.events.get(o2);
              if (s2.isInsert()) {
                var a2 = s2.getObject();
                n2.isSameLabel(s2) || (r2.computeIntersections(a2, i2), this.nOverlaps++);
              }
            }
          }, e3.prototype.addEdges = function() {
            if (1 === arguments.length)
              for (var t3 = arguments[0].iterator(); t3.hasNext(); ) {
                var e4 = t3.next();
                this.addEdge(e4, e4);
              }
            else if (2 === arguments.length)
              for (var n2 = arguments[0], i2 = arguments[1], r2 = n2.iterator(); r2.hasNext(); ) {
                var o2 = r2.next();
                this.addEdge(o2, i2);
              }
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(lr), hr = function() {
          this._min = v.POSITIVE_INFINITY, this._max = v.NEGATIVE_INFINITY;
        }, fr = { NodeComparator: { configurable: true } };
        hr.prototype.getMin = function() {
          return this._min;
        }, hr.prototype.intersects = function(t2, e3) {
          return !(this._min > e3 || this._max < t2);
        }, hr.prototype.getMax = function() {
          return this._max;
        }, hr.prototype.toString = function() {
          return Z.toLineString(new C(this._min, 0), new C(this._max, 0));
        }, hr.prototype.interfaces_ = function() {
          return [];
        }, hr.prototype.getClass = function() {
          return hr;
        }, fr.NodeComparator.get = function() {
          return gr;
        }, Object.defineProperties(hr, fr);
        var gr = function() {
        };
        gr.prototype.compare = function(t2, e3) {
          var n2 = t2, i2 = e3, r2 = (n2._min + n2._max) / 2, o2 = (i2._min + i2._max) / 2;
          return r2 < o2 ? -1 : r2 > o2 ? 1 : 0;
        }, gr.prototype.interfaces_ = function() {
          return [N];
        }, gr.prototype.getClass = function() {
          return gr;
        };
        var dr = function(t2) {
          function e3() {
            t2.call(this), this._item = null;
            var e4 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            this._min = e4, this._max = n2, this._item = i2;
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.query = function(t3, e4, n2) {
            if (!this.intersects(t3, e4))
              return null;
            n2.visitItem(this._item);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(hr), yr = function(t2) {
          function e3() {
            t2.call(this), this._node1 = null, this._node2 = null;
            var e4 = arguments[0], n2 = arguments[1];
            this._node1 = e4, this._node2 = n2, this.buildExtent(this._node1, this._node2);
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.buildExtent = function(t3, e4) {
            this._min = Math.min(t3._min, e4._min), this._max = Math.max(t3._max, e4._max);
          }, e3.prototype.query = function(t3, e4, n2) {
            if (!this.intersects(t3, e4))
              return null;
            null !== this._node1 && this._node1.query(t3, e4, n2), null !== this._node2 && this._node2.query(t3, e4, n2);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(hr), _r = function() {
          this._leaves = new Nt(), this._root = null, this._level = 0;
        };
        _r.prototype.buildTree = function() {
          $e.sort(this._leaves, new hr.NodeComparator());
          for (var t2 = this._leaves, e3 = null, n2 = new Nt(); ; ) {
            if (this.buildLevel(t2, n2), 1 === n2.size())
              return n2.get(0);
            e3 = t2, t2 = n2, n2 = e3;
          }
        }, _r.prototype.insert = function(t2, e3, n2) {
          if (null !== this._root)
            throw new Error("Index cannot be added to once it has been queried");
          this._leaves.add(new dr(t2, e3, n2));
        }, _r.prototype.query = function(t2, e3, n2) {
          this.init(), this._root.query(t2, e3, n2);
        }, _r.prototype.buildRoot = function() {
          if (null !== this._root)
            return null;
          this._root = this.buildTree();
        }, _r.prototype.printNode = function(t2) {
          Y.out.println(Z.toLineString(new C(t2._min, this._level), new C(t2._max, this._level)));
        }, _r.prototype.init = function() {
          if (null !== this._root)
            return null;
          this.buildRoot();
        }, _r.prototype.buildLevel = function(t2, e3) {
          this._level++, e3.clear();
          for (var n2 = 0; n2 < t2.size(); n2 += 2) {
            var i2 = t2.get(n2);
            if (null === (n2 + 1 < t2.size() ? t2.get(n2) : null))
              e3.add(i2);
            else {
              var r2 = new yr(t2.get(n2), t2.get(n2 + 1));
              e3.add(r2);
            }
          }
        }, _r.prototype.interfaces_ = function() {
          return [];
        }, _r.prototype.getClass = function() {
          return _r;
        };
        var mr = function() {
          this._items = new Nt();
        };
        mr.prototype.visitItem = function(t2) {
          this._items.add(t2);
        }, mr.prototype.getItems = function() {
          return this._items;
        }, mr.prototype.interfaces_ = function() {
          return [Ke];
        }, mr.prototype.getClass = function() {
          return mr;
        };
        var vr = function() {
          this._index = null;
          var t2 = arguments[0];
          if (!T(t2, Zt))
            throw new m("Argument must be Polygonal");
          this._index = new xr(t2);
        }, Ir = { SegmentVisitor: { configurable: true }, IntervalIndexedGeometry: { configurable: true } };
        vr.prototype.locate = function(t2) {
          var e3 = new st(t2), n2 = new Er(e3);
          return this._index.query(t2.y, t2.y, n2), e3.getLocation();
        }, vr.prototype.interfaces_ = function() {
          return [Vn];
        }, vr.prototype.getClass = function() {
          return vr;
        }, Ir.SegmentVisitor.get = function() {
          return Er;
        }, Ir.IntervalIndexedGeometry.get = function() {
          return xr;
        }, Object.defineProperties(vr, Ir);
        var Er = function() {
          this._counter = null;
          var t2 = arguments[0];
          this._counter = t2;
        };
        Er.prototype.visitItem = function(t2) {
          var e3 = t2;
          this._counter.countSegment(e3.getCoordinate(0), e3.getCoordinate(1));
        }, Er.prototype.interfaces_ = function() {
          return [Ke];
        }, Er.prototype.getClass = function() {
          return Er;
        };
        var xr = function() {
          this._index = new _r();
          var t2 = arguments[0];
          this.init(t2);
        };
        xr.prototype.init = function(t2) {
          for (var e3 = Ci.getLines(t2).iterator(); e3.hasNext(); ) {
            var n2 = e3.next().getCoordinates();
            this.addLine(n2);
          }
        }, xr.prototype.addLine = function(t2) {
          for (var e3 = 1; e3 < t2.length; e3++) {
            var n2 = new dn(t2[e3 - 1], t2[e3]), i2 = Math.min(n2.p0.y, n2.p1.y), r2 = Math.max(n2.p0.y, n2.p1.y);
            this._index.insert(i2, r2, n2);
          }
        }, xr.prototype.query = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = new mr();
            return this._index.query(t2, e3, n2), n2.getItems();
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            this._index.query(i2, r2, o2);
          }
        }, xr.prototype.interfaces_ = function() {
          return [];
        }, xr.prototype.getClass = function() {
          return xr;
        };
        var Nr = function(t2) {
          function e3() {
            if (t2.call(this), this._parentGeom = null, this._lineEdgeMap = new he(), this._boundaryNodeRule = null, this._useBoundaryDeterminationRule = true, this._argIndex = null, this._boundaryNodes = null, this._hasTooFewPoints = false, this._invalidPoint = null, this._areaPtLocator = null, this._ptLocator = new Si(), 2 === arguments.length) {
              var e4 = arguments[0], n2 = arguments[1], i2 = gt.OGC_SFS_BOUNDARY_RULE;
              this._argIndex = e4, this._parentGeom = n2, this._boundaryNodeRule = i2, null !== n2 && this.add(n2);
            } else if (3 === arguments.length) {
              var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
              this._argIndex = r2, this._parentGeom = o2, this._boundaryNodeRule = s2, null !== o2 && this.add(o2);
            }
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.insertBoundaryPoint = function(t3, n2) {
            var i2 = this._nodes.addNode(n2).getLabel(), r2 = 1;
            w.NONE;
            i2.getLocation(t3, Se.ON) === w.BOUNDARY && r2++;
            var o2 = e3.determineBoundary(this._boundaryNodeRule, r2);
            i2.setLocation(t3, o2);
          }, e3.prototype.computeSelfNodes = function() {
            if (2 === arguments.length) {
              var t3 = arguments[0], e4 = arguments[1];
              return this.computeSelfNodes(t3, e4, false);
            }
            if (3 === arguments.length) {
              var n2 = arguments[0], i2 = arguments[1], r2 = arguments[2], o2 = new cr(n2, true, false);
              o2.setIsDoneIfProperInt(r2);
              var s2 = this.createEdgeSetIntersector(), a2 = this._parentGeom instanceof ee || this._parentGeom instanceof $t || this._parentGeom instanceof ne, u2 = i2 || !a2;
              return s2.computeIntersections(this._edges, o2, u2), this.addSelfIntersectionNodes(this._argIndex), o2;
            }
          }, e3.prototype.computeSplitEdges = function(t3) {
            for (var e4 = this._edges.iterator(); e4.hasNext(); ) {
              e4.next().eiList.addSplitEdges(t3);
            }
          }, e3.prototype.computeEdgeIntersections = function(t3, e4, n2) {
            var i2 = new cr(e4, n2, true);
            i2.setBoundaryNodes(this.getBoundaryNodes(), t3.getBoundaryNodes());
            return this.createEdgeSetIntersector().computeIntersections(this._edges, t3._edges, i2), i2;
          }, e3.prototype.getGeometry = function() {
            return this._parentGeom;
          }, e3.prototype.getBoundaryNodeRule = function() {
            return this._boundaryNodeRule;
          }, e3.prototype.hasTooFewPoints = function() {
            return this._hasTooFewPoints;
          }, e3.prototype.addPoint = function() {
            if (arguments[0] instanceof Qt) {
              var t3 = arguments[0].getCoordinate();
              this.insertPoint(this._argIndex, t3, w.INTERIOR);
            } else if (arguments[0] instanceof C) {
              var e4 = arguments[0];
              this.insertPoint(this._argIndex, e4, w.INTERIOR);
            }
          }, e3.prototype.addPolygon = function(t3) {
            this.addPolygonRing(t3.getExteriorRing(), w.EXTERIOR, w.INTERIOR);
            for (var e4 = 0; e4 < t3.getNumInteriorRing(); e4++) {
              var n2 = t3.getInteriorRingN(e4);
              this.addPolygonRing(n2, w.INTERIOR, w.EXTERIOR);
            }
          }, e3.prototype.addEdge = function(t3) {
            this.insertEdge(t3);
            var e4 = t3.getCoordinates();
            this.insertPoint(this._argIndex, e4[0], w.BOUNDARY), this.insertPoint(this._argIndex, e4[e4.length - 1], w.BOUNDARY);
          }, e3.prototype.addLineString = function(t3) {
            var e4 = Lt.removeRepeatedPoints(t3.getCoordinates());
            if (e4.length < 2)
              return this._hasTooFewPoints = true, this._invalidPoint = e4[0], null;
            var n2 = new ni(e4, new Pe(this._argIndex, w.INTERIOR));
            this._lineEdgeMap.put(t3, n2), this.insertEdge(n2), et.isTrue(e4.length >= 2, "found LineString with single point"), this.insertBoundaryPoint(this._argIndex, e4[0]), this.insertBoundaryPoint(this._argIndex, e4[e4.length - 1]);
          }, e3.prototype.getInvalidPoint = function() {
            return this._invalidPoint;
          }, e3.prototype.getBoundaryPoints = function() {
            for (var t3 = this.getBoundaryNodes(), e4 = new Array(t3.size()).fill(null), n2 = 0, i2 = t3.iterator(); i2.hasNext(); ) {
              var r2 = i2.next();
              e4[n2++] = r2.getCoordinate().copy();
            }
            return e4;
          }, e3.prototype.getBoundaryNodes = function() {
            return null === this._boundaryNodes && (this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex)), this._boundaryNodes;
          }, e3.prototype.addSelfIntersectionNode = function(t3, e4, n2) {
            if (this.isBoundaryNode(t3, e4))
              return null;
            n2 === w.BOUNDARY && this._useBoundaryDeterminationRule ? this.insertBoundaryPoint(t3, e4) : this.insertPoint(t3, e4, n2);
          }, e3.prototype.addPolygonRing = function(t3, e4, n2) {
            if (t3.isEmpty())
              return null;
            var i2 = Lt.removeRepeatedPoints(t3.getCoordinates());
            if (i2.length < 4)
              return this._hasTooFewPoints = true, this._invalidPoint = i2[0], null;
            var r2 = e4, o2 = n2;
            at.isCCW(i2) && (r2 = n2, o2 = e4);
            var s2 = new ni(i2, new Pe(this._argIndex, w.BOUNDARY, r2, o2));
            this._lineEdgeMap.put(t3, s2), this.insertEdge(s2), this.insertPoint(this._argIndex, i2[0], w.BOUNDARY);
          }, e3.prototype.insertPoint = function(t3, e4, n2) {
            var i2 = this._nodes.addNode(e4), r2 = i2.getLabel();
            null === r2 ? i2._label = new Pe(t3, n2) : r2.setLocation(t3, n2);
          }, e3.prototype.createEdgeSetIntersector = function() {
            return new pr();
          }, e3.prototype.addSelfIntersectionNodes = function(t3) {
            for (var e4 = this._edges.iterator(); e4.hasNext(); )
              for (var n2 = e4.next(), i2 = n2.getLabel().getLocation(t3), r2 = n2.eiList.iterator(); r2.hasNext(); ) {
                var o2 = r2.next();
                this.addSelfIntersectionNode(t3, o2.coord, i2);
              }
          }, e3.prototype.add = function() {
            if (1 !== arguments.length)
              return t2.prototype.add.apply(this, arguments);
            var e4 = arguments[0];
            if (e4.isEmpty())
              return null;
            if (e4 instanceof ne && (this._useBoundaryDeterminationRule = false), e4 instanceof $t)
              this.addPolygon(e4);
            else if (e4 instanceof Kt)
              this.addLineString(e4);
            else if (e4 instanceof Qt)
              this.addPoint(e4);
            else if (e4 instanceof te)
              this.addCollection(e4);
            else if (e4 instanceof Xt)
              this.addCollection(e4);
            else if (e4 instanceof ne)
              this.addCollection(e4);
            else {
              if (!(e4 instanceof zt))
                throw new Error(e4.getClass().getName());
              this.addCollection(e4);
            }
          }, e3.prototype.addCollection = function(t3) {
            for (var e4 = 0; e4 < t3.getNumGeometries(); e4++) {
              var n2 = t3.getGeometryN(e4);
              this.add(n2);
            }
          }, e3.prototype.locate = function(t3) {
            return T(this._parentGeom, Zt) && this._parentGeom.getNumGeometries() > 50 ? (null === this._areaPtLocator && (this._areaPtLocator = new vr(this._parentGeom)), this._areaPtLocator.locate(t3)) : this._ptLocator.locate(t3, this._parentGeom);
          }, e3.prototype.findEdge = function() {
            if (1 === arguments.length) {
              var e4 = arguments[0];
              return this._lineEdgeMap.get(e4);
            }
            return t2.prototype.findEdge.apply(this, arguments);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3.determineBoundary = function(t3, e4) {
            return t3.isInBoundary(e4) ? w.BOUNDARY : w.INTERIOR;
          }, e3;
        }(Ye), Cr = function() {
          if (this._li = new rt(), this._resultPrecisionModel = null, this._arg = null, 1 === arguments.length) {
            var t2 = arguments[0];
            this.setComputationPrecision(t2.getPrecisionModel()), this._arg = new Array(1).fill(null), this._arg[0] = new Nr(0, t2);
          } else if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = gt.OGC_SFS_BOUNDARY_RULE;
            e3.getPrecisionModel().compareTo(n2.getPrecisionModel()) >= 0 ? this.setComputationPrecision(e3.getPrecisionModel()) : this.setComputationPrecision(n2.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Nr(0, e3, i2), this._arg[1] = new Nr(1, n2, i2);
          } else if (3 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
            r2.getPrecisionModel().compareTo(o2.getPrecisionModel()) >= 0 ? this.setComputationPrecision(r2.getPrecisionModel()) : this.setComputationPrecision(o2.getPrecisionModel()), this._arg = new Array(2).fill(null), this._arg[0] = new Nr(0, r2, s2), this._arg[1] = new Nr(1, o2, s2);
          }
        };
        Cr.prototype.getArgGeometry = function(t2) {
          return this._arg[t2].getGeometry();
        }, Cr.prototype.setComputationPrecision = function(t2) {
          this._resultPrecisionModel = t2, this._li.setPrecisionModel(this._resultPrecisionModel);
        }, Cr.prototype.interfaces_ = function() {
          return [];
        }, Cr.prototype.getClass = function() {
          return Cr;
        };
        var Sr = function() {
        };
        Sr.prototype.interfaces_ = function() {
          return [];
        }, Sr.prototype.getClass = function() {
          return Sr;
        }, Sr.map = function() {
          if (arguments[0] instanceof ct && T(arguments[1], Sr.MapOp)) {
            for (var t2 = arguments[0], e3 = arguments[1], n2 = new Nt(), i2 = 0; i2 < t2.getNumGeometries(); i2++) {
              var r2 = e3.map(t2.getGeometryN(i2));
              null !== r2 && n2.add(r2);
            }
            return t2.getFactory().buildGeometry(n2);
          }
          if (T(arguments[0], It) && T(arguments[1], Sr.MapOp)) {
            for (var o2 = arguments[0], s2 = arguments[1], a2 = new Nt(), u2 = o2.iterator(); u2.hasNext(); ) {
              var l2 = u2.next(), c2 = s2.map(l2);
              null !== c2 && a2.add(c2);
            }
            return a2;
          }
        }, Sr.MapOp = function() {
        };
        var Lr = function(t2) {
          function e3() {
            var e4 = arguments[0], n2 = arguments[1];
            t2.call(this, e4, n2), this._ptLocator = new Si(), this._geomFact = null, this._resultGeom = null, this._graph = null, this._edgeList = new Hn(), this._resultPolyList = new Nt(), this._resultLineList = new Nt(), this._resultPointList = new Nt(), this._graph = new Ye(new kn()), this._geomFact = e4.getFactory();
          }
          return t2 && (e3.__proto__ = t2), e3.prototype = Object.create(t2 && t2.prototype), e3.prototype.constructor = e3, e3.prototype.insertUniqueEdge = function(t3) {
            var e4 = this._edgeList.findEqualEdge(t3);
            if (null !== e4) {
              var n2 = e4.getLabel(), i2 = t3.getLabel();
              e4.isPointwiseEqual(t3) || (i2 = new Pe(t3.getLabel())).flip();
              var r2 = e4.getDepth();
              r2.isNull() && r2.add(n2), r2.add(i2), n2.merge(i2);
            } else
              this._edgeList.add(t3);
          }, e3.prototype.getGraph = function() {
            return this._graph;
          }, e3.prototype.cancelDuplicateResultEdges = function() {
            for (var t3 = this._graph.getEdgeEnds().iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getSym();
              e4.isInResult() && n2.isInResult() && (e4.setInResult(false), n2.setInResult(false));
            }
          }, e3.prototype.isCoveredByLA = function(t3) {
            return !!this.isCovered(t3, this._resultLineList) || !!this.isCovered(t3, this._resultPolyList);
          }, e3.prototype.computeGeometry = function(t3, n2, i2, r2) {
            var o2 = new Nt();
            return o2.addAll(t3), o2.addAll(n2), o2.addAll(i2), o2.isEmpty() ? e3.createEmptyResult(r2, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) : this._geomFact.buildGeometry(o2);
          }, e3.prototype.mergeSymLabels = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              t3.next().getEdges().mergeSymLabels();
            }
          }, e3.prototype.isCovered = function(t3, e4) {
            for (var n2 = e4.iterator(); n2.hasNext(); ) {
              var i2 = n2.next();
              if (this._ptLocator.locate(t3, i2) !== w.EXTERIOR)
                return true;
            }
            return false;
          }, e3.prototype.replaceCollapsedEdges = function() {
            for (var t3 = new Nt(), e4 = this._edgeList.iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              n2.isCollapsed() && (e4.remove(), t3.add(n2.getCollapsedEdge()));
            }
            this._edgeList.addAll(t3);
          }, e3.prototype.updateNodeLabelling = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getEdges().getLabel();
              e4.getLabel().merge(n2);
            }
          }, e3.prototype.getResultGeometry = function(t3) {
            return this.computeOverlay(t3), this._resultGeom;
          }, e3.prototype.insertUniqueEdges = function(t3) {
            for (var e4 = t3.iterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              this.insertUniqueEdge(n2);
            }
          }, e3.prototype.computeOverlay = function(t3) {
            this.copyPoints(0), this.copyPoints(1), this._arg[0].computeSelfNodes(this._li, false), this._arg[1].computeSelfNodes(this._li, false), this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);
            var e4 = new Nt();
            this._arg[0].computeSplitEdges(e4), this._arg[1].computeSplitEdges(e4), this.insertUniqueEdges(e4), this.computeLabelsFromDepths(), this.replaceCollapsedEdges(), Yi.checkValid(this._edgeList.getEdges()), this._graph.addEdges(this._edgeList.getEdges()), this.computeLabelling(), this.labelIncompleteNodes(), this.findResultAreaEdges(t3), this.cancelDuplicateResultEdges();
            var n2 = new ke(this._geomFact);
            n2.add(this._graph), this._resultPolyList = n2.getPolygons();
            var i2 = new ji(this, this._geomFact, this._ptLocator);
            this._resultLineList = i2.build(t3);
            var r2 = new Hi(this, this._geomFact, this._ptLocator);
            this._resultPointList = r2.build(t3), this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, t3);
          }, e3.prototype.labelIncompleteNode = function(t3, e4) {
            var n2 = this._ptLocator.locate(t3.getCoordinate(), this._arg[e4].getGeometry());
            t3.getLabel().setLocation(e4, n2);
          }, e3.prototype.copyPoints = function(t3) {
            for (var e4 = this._arg[t3].getNodeIterator(); e4.hasNext(); ) {
              var n2 = e4.next();
              this._graph.addNode(n2.getCoordinate()).setLabel(t3, n2.getLabel().getLocation(t3));
            }
          }, e3.prototype.findResultAreaEdges = function(t3) {
            for (var n2 = this._graph.getEdgeEnds().iterator(); n2.hasNext(); ) {
              var i2 = n2.next(), r2 = i2.getLabel();
              r2.isArea() && !i2.isInteriorAreaEdge() && e3.isResultOfOp(r2.getLocation(0, Se.RIGHT), r2.getLocation(1, Se.RIGHT), t3) && i2.setInResult(true);
            }
          }, e3.prototype.computeLabelsFromDepths = function() {
            for (var t3 = this._edgeList.iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getLabel(), i2 = e4.getDepth();
              if (!i2.isNull()) {
                i2.normalize();
                for (var r2 = 0; r2 < 2; r2++)
                  n2.isNull(r2) || !n2.isArea() || i2.isNull(r2) || (0 === i2.getDelta(r2) ? n2.toLine(r2) : (et.isTrue(!i2.isNull(r2, Se.LEFT), "depth of LEFT side has not been initialized"), n2.setLocation(r2, Se.LEFT, i2.getLocation(r2, Se.LEFT)), et.isTrue(!i2.isNull(r2, Se.RIGHT), "depth of RIGHT side has not been initialized"), n2.setLocation(r2, Se.RIGHT, i2.getLocation(r2, Se.RIGHT))));
              }
            }
          }, e3.prototype.computeLabelling = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              t3.next().getEdges().computeLabelling(this._arg);
            }
            this.mergeSymLabels(), this.updateNodeLabelling();
          }, e3.prototype.labelIncompleteNodes = function() {
            for (var t3 = this._graph.getNodes().iterator(); t3.hasNext(); ) {
              var e4 = t3.next(), n2 = e4.getLabel();
              e4.isIsolated() && (n2.isNull(0) ? this.labelIncompleteNode(e4, 0) : this.labelIncompleteNode(e4, 1)), e4.getEdges().updateLabelling(n2);
            }
          }, e3.prototype.isCoveredByA = function(t3) {
            return !!this.isCovered(t3, this._resultPolyList);
          }, e3.prototype.interfaces_ = function() {
            return [];
          }, e3.prototype.getClass = function() {
            return e3;
          }, e3;
        }(Cr);
        Lr.overlayOp = function(t2, e3, n2) {
          return new Lr(t2, e3).getResultGeometry(n2);
        }, Lr.intersection = function(t2, e3) {
          if (t2.isEmpty() || e3.isEmpty())
            return Lr.createEmptyResult(Lr.INTERSECTION, t2, e3, t2.getFactory());
          if (t2.isGeometryCollection()) {
            var n2 = e3;
            return ki.map(t2, { interfaces_: function() {
              return [Sr.MapOp];
            }, map: function(t3) {
              return t3.intersection(n2);
            } });
          }
          return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.INTERSECTION);
        }, Lr.symDifference = function(t2, e3) {
          if (t2.isEmpty() || e3.isEmpty()) {
            if (t2.isEmpty() && e3.isEmpty())
              return Lr.createEmptyResult(Lr.SYMDIFFERENCE, t2, e3, t2.getFactory());
            if (t2.isEmpty())
              return e3.copy();
            if (e3.isEmpty())
              return t2.copy();
          }
          return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.SYMDIFFERENCE);
        }, Lr.resultDimension = function(t2, e3, n2) {
          var i2 = e3.getDimension(), r2 = n2.getDimension(), o2 = -1;
          switch (t2) {
            case Lr.INTERSECTION:
              o2 = Math.min(i2, r2);
              break;
            case Lr.UNION:
              o2 = Math.max(i2, r2);
              break;
            case Lr.DIFFERENCE:
              o2 = i2;
              break;
            case Lr.SYMDIFFERENCE:
              o2 = Math.max(i2, r2);
          }
          return o2;
        }, Lr.createEmptyResult = function(t2, e3, n2, i2) {
          var r2 = null;
          switch (Lr.resultDimension(t2, e3, n2)) {
            case -1:
              r2 = i2.createGeometryCollection(new Array(0).fill(null));
              break;
            case 0:
              r2 = i2.createPoint();
              break;
            case 1:
              r2 = i2.createLineString();
              break;
            case 2:
              r2 = i2.createPolygon();
          }
          return r2;
        }, Lr.difference = function(t2, e3) {
          return t2.isEmpty() ? Lr.createEmptyResult(Lr.DIFFERENCE, t2, e3, t2.getFactory()) : e3.isEmpty() ? t2.copy() : (t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.DIFFERENCE));
        }, Lr.isResultOfOp = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = t2.getLocation(0), i2 = t2.getLocation(1);
            return Lr.isResultOfOp(n2, i2, e3);
          }
          if (3 === arguments.length) {
            var r2 = arguments[0], o2 = arguments[1], s2 = arguments[2];
            switch (r2 === w.BOUNDARY && (r2 = w.INTERIOR), o2 === w.BOUNDARY && (o2 = w.INTERIOR), s2) {
              case Lr.INTERSECTION:
                return r2 === w.INTERIOR && o2 === w.INTERIOR;
              case Lr.UNION:
                return r2 === w.INTERIOR || o2 === w.INTERIOR;
              case Lr.DIFFERENCE:
                return r2 === w.INTERIOR && o2 !== w.INTERIOR;
              case Lr.SYMDIFFERENCE:
                return r2 === w.INTERIOR && o2 !== w.INTERIOR || r2 !== w.INTERIOR && o2 === w.INTERIOR;
            }
            return false;
          }
        }, Lr.INTERSECTION = 1, Lr.UNION = 2, Lr.DIFFERENCE = 3, Lr.SYMDIFFERENCE = 4;
        var br = function() {
          this._g = null, this._boundaryDistanceTolerance = null, this._linework = null, this._ptLocator = new Si(), this._seg = new dn();
          var t2 = arguments[0], e3 = arguments[1];
          this._g = t2, this._boundaryDistanceTolerance = e3, this._linework = this.extractLinework(t2);
        };
        br.prototype.isWithinToleranceOfBoundary = function(t2) {
          for (var e3 = 0; e3 < this._linework.getNumGeometries(); e3++)
            for (var n2 = this._linework.getGeometryN(e3).getCoordinateSequence(), i2 = 0; i2 < n2.size() - 1; i2++) {
              n2.getCoordinate(i2, this._seg.p0), n2.getCoordinate(i2 + 1, this._seg.p1);
              if (this._seg.distance(t2) <= this._boundaryDistanceTolerance)
                return true;
            }
          return false;
        }, br.prototype.getLocation = function(t2) {
          return this.isWithinToleranceOfBoundary(t2) ? w.BOUNDARY : this._ptLocator.locate(t2, this._g);
        }, br.prototype.extractLinework = function(t2) {
          var e3 = new wr();
          t2.apply(e3);
          var n2 = e3.getLinework(), i2 = _e.toLineStringArray(n2);
          return t2.getFactory().createMultiLineString(i2);
        }, br.prototype.interfaces_ = function() {
          return [];
        }, br.prototype.getClass = function() {
          return br;
        };
        var wr = function() {
          this._linework = null, this._linework = new Nt();
        };
        wr.prototype.getLinework = function() {
          return this._linework;
        }, wr.prototype.filter = function(t2) {
          if (t2 instanceof $t) {
            var e3 = t2;
            this._linework.add(e3.getExteriorRing());
            for (var n2 = 0; n2 < e3.getNumInteriorRing(); n2++)
              this._linework.add(e3.getInteriorRingN(n2));
          }
        }, wr.prototype.interfaces_ = function() {
          return [Vt];
        }, wr.prototype.getClass = function() {
          return wr;
        };
        var Or = function() {
          this._g = null, this._doLeft = true, this._doRight = true;
          var t2 = arguments[0];
          this._g = t2;
        };
        Or.prototype.extractPoints = function(t2, e3, n2) {
          for (var i2 = t2.getCoordinates(), r2 = 0; r2 < i2.length - 1; r2++)
            this.computeOffsetPoints(i2[r2], i2[r2 + 1], e3, n2);
        }, Or.prototype.setSidesToGenerate = function(t2, e3) {
          this._doLeft = t2, this._doRight = e3;
        }, Or.prototype.getPoints = function(t2) {
          for (var e3 = new Nt(), n2 = Ci.getLines(this._g).iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            this.extractPoints(i2, t2, e3);
          }
          return e3;
        }, Or.prototype.computeOffsetPoints = function(t2, e3, n2, i2) {
          var r2 = e3.x - t2.x, o2 = e3.y - t2.y, s2 = Math.sqrt(r2 * r2 + o2 * o2), a2 = n2 * r2 / s2, u2 = n2 * o2 / s2, l2 = (e3.x + t2.x) / 2, c2 = (e3.y + t2.y) / 2;
          if (this._doLeft) {
            var p2 = new C(l2 - u2, c2 + a2);
            i2.add(p2);
          }
          if (this._doRight) {
            var h2 = new C(l2 + u2, c2 - a2);
            i2.add(h2);
          }
        }, Or.prototype.interfaces_ = function() {
          return [];
        }, Or.prototype.getClass = function() {
          return Or;
        };
        var Tr = function t2() {
          this._geom = null, this._locFinder = null, this._location = new Array(3).fill(null), this._invalidLocation = null, this._boundaryDistanceTolerance = t2.TOLERANCE, this._testCoords = new Nt();
          var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
          this._boundaryDistanceTolerance = t2.computeBoundaryDistanceTolerance(e3, n2), this._geom = [e3, n2, i2], this._locFinder = [new br(this._geom[0], this._boundaryDistanceTolerance), new br(this._geom[1], this._boundaryDistanceTolerance), new br(this._geom[2], this._boundaryDistanceTolerance)];
        }, Rr = { TOLERANCE: { configurable: true } };
        Tr.prototype.reportResult = function(t2, e3, n2) {
          Y.out.println("Overlay result invalid - A:" + w.toLocationSymbol(e3[0]) + " B:" + w.toLocationSymbol(e3[1]) + " expected:" + (n2 ? "i" : "e") + " actual:" + w.toLocationSymbol(e3[2]));
        }, Tr.prototype.isValid = function(t2) {
          this.addTestPts(this._geom[0]), this.addTestPts(this._geom[1]);
          var e3 = this.checkValid(t2);
          return e3;
        }, Tr.prototype.checkValid = function() {
          if (1 === arguments.length) {
            for (var t2 = arguments[0], e3 = 0; e3 < this._testCoords.size(); e3++) {
              var n2 = this._testCoords.get(e3);
              if (!this.checkValid(t2, n2))
                return this._invalidLocation = n2, false;
            }
            return true;
          }
          if (2 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1];
            return this._location[0] = this._locFinder[0].getLocation(r2), this._location[1] = this._locFinder[1].getLocation(r2), this._location[2] = this._locFinder[2].getLocation(r2), !!Tr.hasLocation(this._location, w.BOUNDARY) || this.isValidResult(i2, this._location);
          }
        }, Tr.prototype.addTestPts = function(t2) {
          var e3 = new Or(t2);
          this._testCoords.addAll(e3.getPoints(5 * this._boundaryDistanceTolerance));
        }, Tr.prototype.isValidResult = function(t2, e3) {
          var n2 = Lr.isResultOfOp(e3[0], e3[1], t2), i2 = !(n2 ^ e3[2] === w.INTERIOR);
          return i2 || this.reportResult(t2, e3, n2), i2;
        }, Tr.prototype.getInvalidLocation = function() {
          return this._invalidLocation;
        }, Tr.prototype.interfaces_ = function() {
          return [];
        }, Tr.prototype.getClass = function() {
          return Tr;
        }, Tr.hasLocation = function(t2, e3) {
          for (var n2 = 0; n2 < 3; n2++)
            if (t2[n2] === e3)
              return true;
          return false;
        }, Tr.computeBoundaryDistanceTolerance = function(t2, e3) {
          return Math.min(Ji.computeSizeBasedSnapTolerance(t2), Ji.computeSizeBasedSnapTolerance(e3));
        }, Tr.isValid = function(t2, e3, n2, i2) {
          return new Tr(t2, e3, i2).isValid(n2);
        }, Rr.TOLERANCE.get = function() {
          return 1e-6;
        }, Object.defineProperties(Tr, Rr);
        var Pr = function t2(e3) {
          this._geomFactory = null, this._skipEmpty = false, this._inputGeoms = null, this._geomFactory = t2.extractFactory(e3), this._inputGeoms = e3;
        };
        Pr.prototype.extractElements = function(t2, e3) {
          if (null === t2)
            return null;
          for (var n2 = 0; n2 < t2.getNumGeometries(); n2++) {
            var i2 = t2.getGeometryN(n2);
            this._skipEmpty && i2.isEmpty() || e3.add(i2);
          }
        }, Pr.prototype.combine = function() {
          for (var t2 = new Nt(), e3 = this._inputGeoms.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            this.extractElements(n2, t2);
          }
          return 0 === t2.size() ? null !== this._geomFactory ? this._geomFactory.createGeometryCollection(null) : null : this._geomFactory.buildGeometry(t2);
        }, Pr.prototype.interfaces_ = function() {
          return [];
        }, Pr.prototype.getClass = function() {
          return Pr;
        }, Pr.combine = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return new Pr(t2).combine();
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return new Pr(Pr.createList(e3, n2)).combine();
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2];
            return new Pr(Pr.createList(i2, r2, o2)).combine();
          }
        }, Pr.extractFactory = function(t2) {
          return t2.isEmpty() ? null : t2.iterator().next().getFactory();
        }, Pr.createList = function() {
          if (2 === arguments.length) {
            var t2 = arguments[0], e3 = arguments[1], n2 = new Nt();
            return n2.add(t2), n2.add(e3), n2;
          }
          if (3 === arguments.length) {
            var i2 = arguments[0], r2 = arguments[1], o2 = arguments[2], s2 = new Nt();
            return s2.add(i2), s2.add(r2), s2.add(o2), s2;
          }
        };
        var Dr = function() {
          this._inputPolys = null, this._geomFactory = null;
          var t2 = arguments[0];
          this._inputPolys = t2, null === this._inputPolys && (this._inputPolys = new Nt());
        }, Mr = { STRTREE_NODE_CAPACITY: { configurable: true } };
        Dr.prototype.reduceToGeometries = function(t2) {
          for (var e3 = new Nt(), n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next(), r2 = null;
            T(i2, xt) ? r2 = this.unionTree(i2) : i2 instanceof ct && (r2 = i2), e3.add(r2);
          }
          return e3;
        }, Dr.prototype.extractByEnvelope = function(t2, e3, n2) {
          for (var i2 = new Nt(), r2 = 0; r2 < e3.getNumGeometries(); r2++) {
            var o2 = e3.getGeometryN(r2);
            o2.getEnvelopeInternal().intersects(t2) ? i2.add(o2) : n2.add(o2);
          }
          return this._geomFactory.buildGeometry(i2);
        }, Dr.prototype.unionOptimized = function(t2, e3) {
          var n2 = t2.getEnvelopeInternal(), i2 = e3.getEnvelopeInternal();
          if (!n2.intersects(i2)) {
            return Pr.combine(t2, e3);
          }
          if (t2.getNumGeometries() <= 1 && e3.getNumGeometries() <= 1)
            return this.unionActual(t2, e3);
          var r2 = n2.intersection(i2);
          return this.unionUsingEnvelopeIntersection(t2, e3, r2);
        }, Dr.prototype.union = function() {
          if (null === this._inputPolys)
            throw new Error("union() method cannot be called twice");
          if (this._inputPolys.isEmpty())
            return null;
          this._geomFactory = this._inputPolys.iterator().next().getFactory();
          for (var t2 = new sn(Dr.STRTREE_NODE_CAPACITY), e3 = this._inputPolys.iterator(); e3.hasNext(); ) {
            var n2 = e3.next();
            t2.insert(n2.getEnvelopeInternal(), n2);
          }
          this._inputPolys = null;
          var i2 = t2.itemsTree();
          return this.unionTree(i2);
        }, Dr.prototype.binaryUnion = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return this.binaryUnion(t2, 0, t2.size());
          }
          if (3 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1], i2 = arguments[2];
            if (i2 - n2 <= 1) {
              var r2 = Dr.getGeometry(e3, n2);
              return this.unionSafe(r2, null);
            }
            if (i2 - n2 == 2)
              return this.unionSafe(Dr.getGeometry(e3, n2), Dr.getGeometry(e3, n2 + 1));
            var o2 = Math.trunc((i2 + n2) / 2), s2 = this.binaryUnion(e3, n2, o2), a2 = this.binaryUnion(e3, o2, i2);
            return this.unionSafe(s2, a2);
          }
        }, Dr.prototype.repeatedUnion = function(t2) {
          for (var e3 = null, n2 = t2.iterator(); n2.hasNext(); ) {
            var i2 = n2.next();
            e3 = null === e3 ? i2.copy() : e3.union(i2);
          }
          return e3;
        }, Dr.prototype.unionSafe = function(t2, e3) {
          return null === t2 && null === e3 ? null : null === t2 ? e3.copy() : null === e3 ? t2.copy() : this.unionOptimized(t2, e3);
        }, Dr.prototype.unionActual = function(t2, e3) {
          return Dr.restrictToPolygons(t2.union(e3));
        }, Dr.prototype.unionTree = function(t2) {
          var e3 = this.reduceToGeometries(t2);
          return this.binaryUnion(e3);
        }, Dr.prototype.unionUsingEnvelopeIntersection = function(t2, e3, n2) {
          var i2 = new Nt(), r2 = this.extractByEnvelope(n2, t2, i2), o2 = this.extractByEnvelope(n2, e3, i2), s2 = this.unionActual(r2, o2);
          i2.add(s2);
          return Pr.combine(i2);
        }, Dr.prototype.bufferUnion = function() {
          if (1 === arguments.length) {
            var t2 = arguments[0];
            return t2.get(0).getFactory().buildGeometry(t2).buffer(0);
          }
          if (2 === arguments.length) {
            var e3 = arguments[0], n2 = arguments[1];
            return e3.getFactory().createGeometryCollection([e3, n2]).buffer(0);
          }
        }, Dr.prototype.interfaces_ = function() {
          return [];
        }, Dr.prototype.getClass = function() {
          return Dr;
        }, Dr.restrictToPolygons = function(t2) {
          if (T(t2, Zt))
            return t2;
          var e3 = Ni.getPolygons(t2);
          return 1 === e3.size() ? e3.get(0) : t2.getFactory().createMultiPolygon(_e.toPolygonArray(e3));
        }, Dr.getGeometry = function(t2, e3) {
          return e3 >= t2.size() ? null : t2.get(e3);
        }, Dr.union = function(t2) {
          return new Dr(t2).union();
        }, Mr.STRTREE_NODE_CAPACITY.get = function() {
          return 4;
        }, Object.defineProperties(Dr, Mr);
        var Ar = function() {
        };
        Ar.prototype.interfaces_ = function() {
          return [];
        }, Ar.prototype.getClass = function() {
          return Ar;
        }, Ar.union = function(t2, e3) {
          if (t2.isEmpty() || e3.isEmpty()) {
            if (t2.isEmpty() && e3.isEmpty())
              return Lr.createEmptyResult(Lr.UNION, t2, e3, t2.getFactory());
            if (t2.isEmpty())
              return e3.copy();
            if (e3.isEmpty())
              return t2.copy();
          }
          return t2.checkNotGeometryCollection(t2), t2.checkNotGeometryCollection(e3), or.overlayOp(t2, e3, Lr.UNION);
        }, t.GeoJSONReader = Ne, t.GeoJSONWriter = Ce, t.OverlayOp = Lr, t.UnionOp = Ar, t.BufferOp = di, Object.defineProperty(t, "__esModule", { value: true });
      });
    }
  });

  // <stdin>
  var maplibreGl = __toESM(require_maplibre_gl());

  // node_modules/@turf/helpers/dist/es/index.js
  var earthRadius = 63710088e-1;
  var factors = {
    centimeters: earthRadius * 100,
    centimetres: earthRadius * 100,
    degrees: earthRadius / 111325,
    feet: earthRadius * 3.28084,
    inches: earthRadius * 39.37,
    kilometers: earthRadius / 1e3,
    kilometres: earthRadius / 1e3,
    meters: earthRadius,
    metres: earthRadius,
    miles: earthRadius / 1609.344,
    millimeters: earthRadius * 1e3,
    millimetres: earthRadius * 1e3,
    nauticalmiles: earthRadius / 1852,
    radians: 1,
    yards: earthRadius * 1.0936
  };
  var unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.37,
    kilometers: 1 / 1e3,
    kilometres: 1 / 1e3,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1e3,
    millimetres: 1e3,
    nauticalmiles: 1 / 1852,
    radians: 1 / earthRadius,
    yards: 1.0936133
  };
  function feature(geom, properties, options) {
    if (options === void 0) {
      options = {};
    }
    var feat = { type: "Feature" };
    if (options.id === 0 || options.id) {
      feat.id = options.id;
    }
    if (options.bbox) {
      feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
  }
  function point(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    if (!coordinates) {
      throw new Error("coordinates is required");
    }
    if (!Array.isArray(coordinates)) {
      throw new Error("coordinates must be an Array");
    }
    if (coordinates.length < 2) {
      throw new Error("coordinates must be at least 2 numbers long");
    }
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
      throw new Error("coordinates must contain numbers");
    }
    var geom = {
      type: "Point",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function polygon(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
      var ring = coordinates_1[_i];
      if (ring.length < 4) {
        throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
      }
      for (var j = 0; j < ring[ring.length - 1].length; j++) {
        if (ring[ring.length - 1][j] !== ring[0][j]) {
          throw new Error("First and last Position are not equivalent.");
        }
      }
    }
    var geom = {
      type: "Polygon",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function lineString(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    if (coordinates.length < 2) {
      throw new Error("coordinates must be an array of two or more positions");
    }
    var geom = {
      type: "LineString",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function featureCollection(features2, options) {
    if (options === void 0) {
      options = {};
    }
    var fc = { type: "FeatureCollection" };
    if (options.id) {
      fc.id = options.id;
    }
    if (options.bbox) {
      fc.bbox = options.bbox;
    }
    fc.features = features2;
    return fc;
  }
  function multiPoint(coordinates, properties, options) {
    if (options === void 0) {
      options = {};
    }
    var geom = {
      type: "MultiPoint",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function radiansToLength(radians2, units) {
    if (units === void 0) {
      units = "kilometers";
    }
    var factor = factors[units];
    if (!factor) {
      throw new Error(units + " units is invalid");
    }
    return radians2 * factor;
  }
  function lengthToRadians(distance2, units) {
    if (units === void 0) {
      units = "kilometers";
    }
    var factor = factors[units];
    if (!factor) {
      throw new Error(units + " units is invalid");
    }
    return distance2 / factor;
  }
  function radiansToDegrees(radians2) {
    var degrees2 = radians2 % (2 * Math.PI);
    return degrees2 * 180 / Math.PI;
  }
  function degreesToRadians(degrees2) {
    var radians2 = degrees2 % 360;
    return radians2 * Math.PI / 180;
  }
  function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
  }

  // node_modules/@turf/meta/dist/es/index.js
  function coordEach(geojson, callback, excludeWrapCoord) {
    if (geojson === null)
      return;
    var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
        var multiFeatureIndex = 0;
        var geometryIndex = 0;
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
        if (geometry === null)
          continue;
        coords = geometry.coordinates;
        var geomType = geometry.type;
        wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
        switch (geomType) {
          case null:
            break;
          case "Point":
            if (callback(
              coords,
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            multiFeatureIndex++;
            break;
          case "LineString":
          case "MultiPoint":
            for (j = 0; j < coords.length; j++) {
              if (callback(
                coords[j],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
              if (geomType === "MultiPoint")
                multiFeatureIndex++;
            }
            if (geomType === "LineString")
              multiFeatureIndex++;
            break;
          case "Polygon":
          case "MultiLineString":
            for (j = 0; j < coords.length; j++) {
              for (k = 0; k < coords[j].length - wrapShrink; k++) {
                if (callback(
                  coords[j][k],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              if (geomType === "MultiLineString")
                multiFeatureIndex++;
              if (geomType === "Polygon")
                geometryIndex++;
            }
            if (geomType === "Polygon")
              multiFeatureIndex++;
            break;
          case "MultiPolygon":
            for (j = 0; j < coords.length; j++) {
              geometryIndex = 0;
              for (k = 0; k < coords[j].length; k++) {
                for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                  if (callback(
                    coords[j][k][l],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false)
                    return false;
                  coordIndex++;
                }
                geometryIndex++;
              }
              multiFeatureIndex++;
            }
            break;
          case "GeometryCollection":
            for (j = 0; j < geometry.geometries.length; j++)
              if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)
                return false;
            break;
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
    }
  }
  function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(
      geojson,
      function(currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (coordIndex === 0 && initialValue === void 0)
          previousValue = currentCoord;
        else
          previousValue = callback(
            previousValue,
            currentCoord,
            coordIndex,
            featureIndex,
            multiFeatureIndex,
            geometryIndex
          );
      },
      excludeWrapCoord
    );
    return previousValue;
  }
  function featureEach(geojson, callback) {
    if (geojson.type === "Feature") {
      callback(geojson, 0);
    } else if (geojson.type === "FeatureCollection") {
      for (var i = 0; i < geojson.features.length; i++) {
        if (callback(geojson.features[i], i) === false)
          break;
      }
    }
  }
  function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (i = 0; i < stop; i++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
      featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
      featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
      featureId = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (g = 0; g < stopG; g++) {
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
        if (geometry === null) {
          if (callback(
            null,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId
          ) === false)
            return false;
          continue;
        }
        switch (geometry.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon": {
            if (callback(
              geometry,
              featureIndex,
              featureProperties,
              featureBBox,
              featureId
            ) === false)
              return false;
            break;
          }
          case "GeometryCollection": {
            for (j = 0; j < geometry.geometries.length; j++) {
              if (callback(
                geometry.geometries[j],
                featureIndex,
                featureProperties,
                featureBBox,
                featureId
              ) === false)
                return false;
            }
            break;
          }
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
      featureIndex++;
    }
  }
  function flattenEach(geojson, callback) {
    geomEach(geojson, function(geometry, featureIndex, properties, bbox3, id) {
      var type = geometry === null ? null : geometry.type;
      switch (type) {
        case null:
        case "Point":
        case "LineString":
        case "Polygon":
          if (callback(
            feature(geometry, properties, { bbox: bbox3, id }),
            featureIndex,
            0
          ) === false)
            return false;
          return;
      }
      var geomType;
      switch (type) {
        case "MultiPoint":
          geomType = "Point";
          break;
        case "MultiLineString":
          geomType = "LineString";
          break;
        case "MultiPolygon":
          geomType = "Polygon";
          break;
      }
      for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
        var coordinate = geometry.coordinates[multiFeatureIndex];
        var geom = {
          type: geomType,
          coordinates: coordinate
        };
        if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)
          return false;
      }
    });
  }
  function segmentEach(geojson, callback) {
    flattenEach(geojson, function(feature2, featureIndex, multiFeatureIndex) {
      var segmentIndex = 0;
      if (!feature2.geometry)
        return;
      var type = feature2.geometry.type;
      if (type === "Point" || type === "MultiPoint")
        return;
      var previousCoords;
      var previousFeatureIndex = 0;
      var previousMultiIndex = 0;
      var prevGeomIndex = 0;
      if (coordEach(
        feature2,
        function(currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
          if (previousCoords === void 0 || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
            previousCoords = currentCoord;
            previousFeatureIndex = featureIndex;
            previousMultiIndex = multiPartIndexCoord;
            prevGeomIndex = geometryIndex;
            segmentIndex = 0;
            return;
          }
          var currentSegment = lineString(
            [previousCoords, currentCoord],
            feature2.properties
          );
          if (callback(
            currentSegment,
            featureIndex,
            multiFeatureIndex,
            geometryIndex,
            segmentIndex
          ) === false)
            return false;
          segmentIndex++;
          previousCoords = currentCoord;
        }
      ) === false)
        return false;
    });
  }
  function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(
      geojson,
      function(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
        if (started === false && initialValue === void 0)
          previousValue = currentSegment;
        else
          previousValue = callback(
            previousValue,
            currentSegment,
            featureIndex,
            multiFeatureIndex,
            geometryIndex,
            segmentIndex
          );
        started = true;
      }
    );
    return previousValue;
  }

  // node_modules/@turf/bbox/dist/es/index.js
  function bbox(geojson) {
    var result = [Infinity, Infinity, -Infinity, -Infinity];
    coordEach(geojson, function(coord) {
      if (result[0] > coord[0]) {
        result[0] = coord[0];
      }
      if (result[1] > coord[1]) {
        result[1] = coord[1];
      }
      if (result[2] < coord[0]) {
        result[2] = coord[0];
      }
      if (result[3] < coord[1]) {
        result[3] = coord[1];
      }
    });
    return result;
  }
  bbox["default"] = bbox;
  var es_default = bbox;

  // node_modules/@turf/invariant/dist/es/index.js
  function getCoord(coord) {
    if (!coord) {
      throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
      if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
        return coord.geometry.coordinates;
      }
      if (coord.type === "Point") {
        return coord.coordinates;
      }
    }
    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
      return coord;
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
  }
  function getCoords(coords) {
    if (Array.isArray(coords)) {
      return coords;
    }
    if (coords.type === "Feature") {
      if (coords.geometry !== null) {
        return coords.geometry.coordinates;
      }
    } else {
      if (coords.coordinates) {
        return coords.coordinates;
      }
    }
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
  }
  function featureOf(feature2, type, name) {
    if (!feature2) {
      throw new Error("No feature passed");
    }
    if (!name) {
      throw new Error(".featureOf() requires a name");
    }
    if (!feature2 || feature2.type !== "Feature" || !feature2.geometry) {
      throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature2.geometry || feature2.geometry.type !== type) {
      throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature2.geometry.type);
    }
  }
  function getGeom(geojson) {
    if (geojson.type === "Feature") {
      return geojson.geometry;
    }
    return geojson;
  }
  function getType(geojson, _name) {
    if (geojson.type === "FeatureCollection") {
      return "FeatureCollection";
    }
    if (geojson.type === "GeometryCollection") {
      return "GeometryCollection";
    }
    if (geojson.type === "Feature" && geojson.geometry !== null) {
      return geojson.geometry.type;
    }
    return geojson.type;
  }

  // node_modules/@turf/isolines/dist/es/index.js
  var import_object_assign = __toESM(require_object_assign(), 1);

  // node_modules/@turf/convex/dist/es/index.js
  var import_concaveman = __toESM(require_concaveman(), 1);

  // node_modules/@turf/boolean-point-in-polygon/dist/es/index.js
  function booleanPointInPolygon(point2, polygon2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!point2) {
      throw new Error("point is required");
    }
    if (!polygon2) {
      throw new Error("polygon is required");
    }
    var pt = getCoord(point2);
    var geom = getGeom(polygon2);
    var type = geom.type;
    var bbox3 = polygon2.bbox;
    var polys = geom.coordinates;
    if (bbox3 && inBBox(pt, bbox3) === false) {
      return false;
    }
    if (type === "Polygon") {
      polys = [polys];
    }
    var insidePoly = false;
    for (var i = 0; i < polys.length && !insidePoly; i++) {
      if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
        var inHole = false;
        var k = 1;
        while (k < polys[i].length && !inHole) {
          if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
            inHole = true;
          }
          k++;
        }
        if (!inHole) {
          insidePoly = true;
        }
      }
    }
    return insidePoly;
  }
  function inRing(pt, ring, ignoreBoundary) {
    var isInside = false;
    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {
      ring = ring.slice(0, ring.length - 1);
    }
    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
      var xi = ring[i][0];
      var yi = ring[i][1];
      var xj = ring[j][0];
      var yj = ring[j][1];
      var onBoundary = pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0 && (xi - pt[0]) * (xj - pt[0]) <= 0 && (yi - pt[1]) * (yj - pt[1]) <= 0;
      if (onBoundary) {
        return !ignoreBoundary;
      }
      var intersect2 = yi > pt[1] !== yj > pt[1] && pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi;
      if (intersect2) {
        isInside = !isInside;
      }
    }
    return isInside;
  }
  function inBBox(pt, bbox3) {
    return bbox3[0] <= pt[0] && bbox3[1] <= pt[1] && bbox3[2] >= pt[0] && bbox3[3] >= pt[1];
  }

  // node_modules/@turf/distance/dist/es/index.js
  function distance(from, to, options) {
    if (options === void 0) {
      options = {};
    }
    var coordinates1 = getCoord(from);
    var coordinates2 = getCoord(to);
    var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);
    var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);
    var lat1 = degreesToRadians(coordinates1[1]);
    var lat2 = degreesToRadians(coordinates2[1]);
    var a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
  }
  var es_default2 = distance;

  // node_modules/@turf/tin/dist/es/index.js
  var Triangle = (
    /** @class */
    function() {
      function Triangle2(a, b, c) {
        this.a = a;
        this.b = b;
        this.c = c;
        var A = b.x - a.x;
        var B2 = b.y - a.y;
        var C = c.x - a.x;
        var D = c.y - a.y;
        var E = A * (a.x + b.x) + B2 * (a.y + b.y);
        var F = C * (a.x + c.x) + D * (a.y + c.y);
        var G = 2 * (A * (c.y - b.y) - B2 * (c.x - b.x));
        var dx;
        var dy;
        this.x = (D * E - B2 * F) / G;
        this.y = (A * F - C * E) / G;
        dx = this.x - a.x;
        dy = this.y - a.y;
        this.r = dx * dx + dy * dy;
      }
      return Triangle2;
    }()
  );

  // node_modules/topojson-server/src/hash/point-hash.js
  var buffer = new ArrayBuffer(16);
  var floats = new Float64Array(buffer);
  var uints = new Uint32Array(buffer);

  // node_modules/@turf/collect/dist/es/index.js
  var import_rbush = __toESM(require_rbush(), 1);

  // node_modules/@turf/bezier-spline/dist/es/lib/spline.js
  var Spline = (
    /** @class */
    function() {
      function Spline2(options) {
        this.points = options.points || [];
        this.duration = options.duration || 1e4;
        this.sharpness = options.sharpness || 0.85;
        this.centers = [];
        this.controls = [];
        this.stepLength = options.stepLength || 60;
        this.length = this.points.length;
        this.delay = 0;
        for (var i = 0; i < this.length; i++) {
          this.points[i].z = this.points[i].z || 0;
        }
        for (var i = 0; i < this.length - 1; i++) {
          var p1 = this.points[i];
          var p2 = this.points[i + 1];
          this.centers.push({
            x: (p1.x + p2.x) / 2,
            y: (p1.y + p2.y) / 2,
            z: (p1.z + p2.z) / 2
          });
        }
        this.controls.push([this.points[0], this.points[0]]);
        for (var i = 0; i < this.centers.length - 1; i++) {
          var dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;
          var dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;
          var dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;
          this.controls.push([
            {
              x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),
              y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),
              z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)
            },
            {
              x: (1 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),
              y: (1 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),
              z: (1 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)
            }
          ]);
        }
        this.controls.push([
          this.points[this.length - 1],
          this.points[this.length - 1]
        ]);
        this.steps = this.cacheSteps(this.stepLength);
        return this;
      }
      Spline2.prototype.cacheSteps = function(mindist) {
        var steps2 = [];
        var laststep = this.pos(0);
        steps2.push(0);
        for (var t = 0; t < this.duration; t += 10) {
          var step = this.pos(t);
          var dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z));
          if (dist > mindist) {
            steps2.push(t);
            laststep = step;
          }
        }
        return steps2;
      };
      Spline2.prototype.vector = function(t) {
        var p1 = this.pos(t + 10);
        var p2 = this.pos(t - 10);
        return {
          angle: 180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,
          speed: Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z))
        };
      };
      Spline2.prototype.pos = function(time) {
        var t = time - this.delay;
        if (t < 0) {
          t = 0;
        }
        if (t > this.duration) {
          t = this.duration - 1;
        }
        var t2 = t / this.duration;
        if (t2 >= 1) {
          return this.points[this.length - 1];
        }
        var n = Math.floor((this.points.length - 1) * t2);
        var t1 = (this.length - 1) * t2 - n;
        return bezier(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);
      };
      return Spline2;
    }()
  );
  function bezier(t, p1, c1, c2, p2) {
    var b = B(t);
    var pos = {
      x: p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
      y: p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
      z: p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]
    };
    return pos;
  }
  function B(t) {
    var t2 = t * t;
    var t3 = t2 * t;
    return [
      t3,
      3 * t2 * (1 - t),
      3 * t * (1 - t) * (1 - t),
      (1 - t) * (1 - t) * (1 - t)
    ];
  }

  // node_modules/@turf/bbox-polygon/dist/es/index.js
  function bboxPolygon(bbox3, options) {
    if (options === void 0) {
      options = {};
    }
    var west = Number(bbox3[0]);
    var south = Number(bbox3[1]);
    var east = Number(bbox3[2]);
    var north = Number(bbox3[3]);
    if (bbox3.length === 6) {
      throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
    }
    var lowLeft = [west, south];
    var topLeft = [west, north];
    var topRight = [east, north];
    var lowRight = [east, south];
    return polygon([[lowLeft, lowRight, topRight, topLeft, lowLeft]], options.properties, { bbox: bbox3, id: options.id });
  }

  // node_modules/@turf/envelope/dist/es/index.js
  function envelope(geojson) {
    return bboxPolygon(es_default(geojson));
  }
  var es_default5 = envelope;

  // node_modules/@turf/destination/dist/es/index.js
  function destination(origin, distance2, bearing2, options) {
    if (options === void 0) {
      options = {};
    }
    var coordinates1 = getCoord(origin);
    var longitude1 = degreesToRadians(coordinates1[0]);
    var latitude1 = degreesToRadians(coordinates1[1]);
    var bearingRad = degreesToRadians(bearing2);
    var radians2 = lengthToRadians(distance2, options.units);
    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians2) + Math.cos(latitude1) * Math.sin(radians2) * Math.cos(bearingRad));
    var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians2) * Math.cos(latitude1), Math.cos(radians2) - Math.sin(latitude1) * Math.sin(latitude2));
    var lng = radiansToDegrees(longitude2);
    var lat = radiansToDegrees(latitude2);
    return point([lng, lat], options.properties);
  }

  // node_modules/@turf/bearing/dist/es/index.js
  function bearing(start, end, options) {
    if (options === void 0) {
      options = {};
    }
    if (options.final === true) {
      return calculateFinalBearing(start, end);
    }
    var coordinates1 = getCoord(start);
    var coordinates2 = getCoord(end);
    var lon1 = degreesToRadians(coordinates1[0]);
    var lon2 = degreesToRadians(coordinates2[0]);
    var lat1 = degreesToRadians(coordinates1[1]);
    var lat2 = degreesToRadians(coordinates2[1]);
    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
    var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
    return radiansToDegrees(Math.atan2(a, b));
  }
  function calculateFinalBearing(start, end) {
    var bear = bearing(end, start);
    bear = (bear + 180) % 360;
    return bear;
  }

  // node_modules/@turf/tesselate/dist/es/index.js
  var import_earcut = __toESM(require_earcut(), 1);

  // node_modules/@turf/line-segment/dist/es/index.js
  function lineSegment(geojson) {
    if (!geojson) {
      throw new Error("geojson is required");
    }
    var results = [];
    flattenEach(geojson, function(feature2) {
      lineSegmentFeature(feature2, results);
    });
    return featureCollection(results);
  }
  function lineSegmentFeature(geojson, results) {
    var coords = [];
    var geometry = geojson.geometry;
    if (geometry !== null) {
      switch (geometry.type) {
        case "Polygon":
          coords = getCoords(geometry);
          break;
        case "LineString":
          coords = [getCoords(geometry)];
      }
      coords.forEach(function(coord) {
        var segments = createSegments(coord, geojson.properties);
        segments.forEach(function(segment) {
          segment.id = results.length;
          results.push(segment);
        });
      });
    }
  }
  function createSegments(coords, properties) {
    var segments = [];
    coords.reduce(function(previousCoords, currentCoords) {
      var segment = lineString([previousCoords, currentCoords], properties);
      segment.bbox = bbox2(previousCoords, currentCoords);
      segments.push(segment);
      return currentCoords;
    });
    return segments;
  }
  function bbox2(coords1, coords2) {
    var x12 = coords1[0];
    var y1 = coords1[1];
    var x2 = coords2[0];
    var y2 = coords2[1];
    var west = x12 < x2 ? x12 : x2;
    var south = y1 < y2 ? y1 : y2;
    var east = x12 > x2 ? x12 : x2;
    var north = y1 > y2 ? y1 : y2;
    return [west, south, east, north];
  }
  var es_default7 = lineSegment;

  // node_modules/@turf/line-intersect/dist/es/index.js
  var import_geojson_rbush = __toESM(require_geojson_rbush(), 1);
  function lineIntersect(line1, line2) {
    var unique = {};
    var results = [];
    if (line1.type === "LineString") {
      line1 = feature(line1);
    }
    if (line2.type === "LineString") {
      line2 = feature(line2);
    }
    if (line1.type === "Feature" && line2.type === "Feature" && line1.geometry !== null && line2.geometry !== null && line1.geometry.type === "LineString" && line2.geometry.type === "LineString" && line1.geometry.coordinates.length === 2 && line2.geometry.coordinates.length === 2) {
      var intersect2 = intersects(line1, line2);
      if (intersect2) {
        results.push(intersect2);
      }
      return featureCollection(results);
    }
    var tree = (0, import_geojson_rbush.default)();
    tree.load(es_default7(line2));
    featureEach(es_default7(line1), function(segment) {
      featureEach(tree.search(segment), function(match) {
        var intersect3 = intersects(segment, match);
        if (intersect3) {
          var key = getCoords(intersect3).join(",");
          if (!unique[key]) {
            unique[key] = true;
            results.push(intersect3);
          }
        }
      });
    });
    return featureCollection(results);
  }
  function intersects(line1, line2) {
    var coords1 = getCoords(line1);
    var coords2 = getCoords(line2);
    if (coords1.length !== 2) {
      throw new Error("<intersects> line1 must only contain 2 coordinates");
    }
    if (coords2.length !== 2) {
      throw new Error("<intersects> line2 must only contain 2 coordinates");
    }
    var x12 = coords1[0][0];
    var y1 = coords1[0][1];
    var x2 = coords1[1][0];
    var y2 = coords1[1][1];
    var x3 = coords2[0][0];
    var y3 = coords2[0][1];
    var x4 = coords2[1][0];
    var y4 = coords2[1][1];
    var denom = (y4 - y3) * (x2 - x12) - (x4 - x3) * (y2 - y1);
    var numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x12 - x3);
    var numeB = (x2 - x12) * (y1 - y3) - (y2 - y1) * (x12 - x3);
    if (denom === 0) {
      if (numeA === 0 && numeB === 0) {
        return null;
      }
      return null;
    }
    var uA = numeA / denom;
    var uB = numeB / denom;
    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
      var x5 = x12 + uA * (x2 - x12);
      var y5 = y1 + uA * (y2 - y1);
      return point([x5, y5]);
    }
    return null;
  }
  var es_default8 = lineIntersect;

  // node_modules/@turf/nearest-point-on-line/dist/es/index.js
  function nearestPointOnLine(lines, pt, options) {
    if (options === void 0) {
      options = {};
    }
    var closestPt = point([Infinity, Infinity], {
      dist: Infinity
    });
    var length2 = 0;
    flattenEach(lines, function(line) {
      var coords = getCoords(line);
      for (var i = 0; i < coords.length - 1; i++) {
        var start = point(coords[i]);
        start.properties.dist = es_default2(pt, start, options);
        var stop_1 = point(coords[i + 1]);
        stop_1.properties.dist = es_default2(pt, stop_1, options);
        var sectionLength = es_default2(start, stop_1, options);
        var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);
        var direction = bearing(start, stop_1);
        var perpendicularPt1 = destination(pt, heightDistance, direction + 90, options);
        var perpendicularPt2 = destination(pt, heightDistance, direction - 90, options);
        var intersect2 = es_default8(lineString([
          perpendicularPt1.geometry.coordinates,
          perpendicularPt2.geometry.coordinates
        ]), lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));
        var intersectPt = null;
        if (intersect2.features.length > 0) {
          intersectPt = intersect2.features[0];
          intersectPt.properties.dist = es_default2(pt, intersectPt, options);
          intersectPt.properties.location = length2 + es_default2(start, intersectPt, options);
        }
        if (start.properties.dist < closestPt.properties.dist) {
          closestPt = start;
          closestPt.properties.index = i;
          closestPt.properties.location = length2;
        }
        if (stop_1.properties.dist < closestPt.properties.dist) {
          closestPt = stop_1;
          closestPt.properties.index = i + 1;
          closestPt.properties.location = length2 + sectionLength;
        }
        if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
          closestPt = intersectPt;
          closestPt.properties.index = i;
        }
        length2 += sectionLength;
      }
    });
    return closestPt;
  }
  var es_default9 = nearestPointOnLine;

  // node_modules/@turf/nearest-point-to-line/dist/es/index.js
  var import_object_assign2 = __toESM(require_object_assign(), 1);

  // node_modules/@turf/along/dist/es/index.js
  function along(line, distance2, options) {
    if (options === void 0) {
      options = {};
    }
    var geom = getGeom(line);
    var coords = geom.coordinates;
    var travelled = 0;
    for (var i = 0; i < coords.length; i++) {
      if (distance2 >= travelled && i === coords.length - 1) {
        break;
      } else if (travelled >= distance2) {
        var overshot = distance2 - travelled;
        if (!overshot) {
          return point(coords[i]);
        } else {
          var direction = bearing(coords[i], coords[i - 1]) - 180;
          var interpolated = destination(coords[i], overshot, direction, options);
          return interpolated;
        }
      } else {
        travelled += es_default2(coords[i], coords[i + 1], options);
      }
    }
    return point(coords[coords.length - 1]);
  }

  // node_modules/@turf/length/dist/es/index.js
  function length(geojson, options) {
    if (options === void 0) {
      options = {};
    }
    return segmentReduce(geojson, function(previousValue, segment) {
      var coords = segment.geometry.coordinates;
      return previousValue + es_default2(coords[0], coords[1], options);
    }, 0);
  }

  // node_modules/@turf/line-slice/dist/es/index.js
  function lineSlice(startPt, stopPt, line) {
    var coords = getCoords(line);
    if (getType(line) !== "LineString")
      throw new Error("line must be a LineString");
    var startVertex = es_default9(line, startPt);
    var stopVertex = es_default9(line, stopPt);
    var ends;
    if (startVertex.properties.index <= stopVertex.properties.index) {
      ends = [startVertex, stopVertex];
    } else {
      ends = [stopVertex, startVertex];
    }
    var clipCoords = [ends[0].geometry.coordinates];
    for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {
      clipCoords.push(coords[i]);
    }
    clipCoords.push(ends[1].geometry.coordinates);
    return lineString(clipCoords, line.properties);
  }
  var es_default15 = lineSlice;

  // node_modules/@turf/unkink-polygon/dist/es/index.js
  var import_rbush2 = __toESM(require_rbush(), 1);

  // node_modules/@turf/great-circle/dist/es/index.js
  var D2R = Math.PI / 180;
  var R2D = 180 / Math.PI;
  var Coord = function(lon, lat) {
    this.lon = lon;
    this.lat = lat;
    this.x = D2R * lon;
    this.y = D2R * lat;
  };
  Coord.prototype.view = function() {
    return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4);
  };
  Coord.prototype.antipode = function() {
    var anti_lat = -1 * this.lat;
    var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;
    return new Coord(anti_lon, anti_lat);
  };
  var LineString = function() {
    this.coords = [];
    this.length = 0;
  };
  LineString.prototype.move_to = function(coord) {
    this.length++;
    this.coords.push(coord);
  };
  var Arc = function(properties) {
    this.properties = properties || {};
    this.geometries = [];
  };
  Arc.prototype.json = function() {
    if (this.geometries.length <= 0) {
      return {
        geometry: { type: "LineString", coordinates: null },
        type: "Feature",
        properties: this.properties
      };
    } else if (this.geometries.length === 1) {
      return {
        geometry: { type: "LineString", coordinates: this.geometries[0].coords },
        type: "Feature",
        properties: this.properties
      };
    } else {
      var multiline = [];
      for (var i = 0; i < this.geometries.length; i++) {
        multiline.push(this.geometries[i].coords);
      }
      return {
        geometry: { type: "MultiLineString", coordinates: multiline },
        type: "Feature",
        properties: this.properties
      };
    }
  };
  Arc.prototype.wkt = function() {
    var wkt_string = "";
    var wkt = "LINESTRING(";
    var collect = function(c) {
      wkt += c[0] + " " + c[1] + ",";
    };
    for (var i = 0; i < this.geometries.length; i++) {
      if (this.geometries[i].coords.length === 0) {
        return "LINESTRING(empty)";
      } else {
        var coords = this.geometries[i].coords;
        coords.forEach(collect);
        wkt_string += wkt.substring(0, wkt.length - 1) + ")";
      }
    }
    return wkt_string;
  };
  var GreatCircle = function(start, end, properties) {
    if (!start || start.x === void 0 || start.y === void 0) {
      throw new Error(
        "GreatCircle constructor expects two args: start and end objects with x and y properties"
      );
    }
    if (!end || end.x === void 0 || end.y === void 0) {
      throw new Error(
        "GreatCircle constructor expects two args: start and end objects with x and y properties"
      );
    }
    this.start = new Coord(start.x, start.y);
    this.end = new Coord(end.x, end.y);
    this.properties = properties || {};
    var w = this.start.x - this.end.x;
    var h = this.start.y - this.end.y;
    var z = Math.pow(Math.sin(h / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(w / 2), 2);
    this.g = 2 * Math.asin(Math.sqrt(z));
    if (this.g === Math.PI) {
      throw new Error(
        "it appears " + start.view() + " and " + end.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite"
      );
    } else if (isNaN(this.g)) {
      throw new Error(
        "could not calculate great circle between " + start + " and " + end
      );
    }
  };
  GreatCircle.prototype.interpolate = function(f) {
    var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);
    var B2 = Math.sin(f * this.g) / Math.sin(this.g);
    var x2 = A * Math.cos(this.start.y) * Math.cos(this.start.x) + B2 * Math.cos(this.end.y) * Math.cos(this.end.x);
    var y2 = A * Math.cos(this.start.y) * Math.sin(this.start.x) + B2 * Math.cos(this.end.y) * Math.sin(this.end.x);
    var z = A * Math.sin(this.start.y) + B2 * Math.sin(this.end.y);
    var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2)));
    var lon = R2D * Math.atan2(y2, x2);
    return [lon, lat];
  };
  GreatCircle.prototype.Arc = function(npoints, options) {
    var first_pass = [];
    if (!npoints || npoints <= 2) {
      first_pass.push([this.start.lon, this.start.lat]);
      first_pass.push([this.end.lon, this.end.lat]);
    } else {
      var delta = 1 / (npoints - 1);
      for (var i = 0; i < npoints; ++i) {
        var step = delta * i;
        var pair2 = this.interpolate(step);
        first_pass.push(pair2);
      }
    }
    var bHasBigDiff = false;
    var dfMaxSmallDiffLong = 0;
    var dfDateLineOffset = options && options.offset ? options.offset : 10;
    var dfLeftBorderX = 180 - dfDateLineOffset;
    var dfRightBorderX = -180 + dfDateLineOffset;
    var dfDiffSpace = 360 - dfDateLineOffset;
    for (var j = 1; j < first_pass.length; ++j) {
      var dfPrevX = first_pass[j - 1][0];
      var dfX = first_pass[j][0];
      var dfDiffLong = Math.abs(dfX - dfPrevX);
      if (dfDiffLong > dfDiffSpace && (dfX > dfLeftBorderX && dfPrevX < dfRightBorderX || dfPrevX > dfLeftBorderX && dfX < dfRightBorderX)) {
        bHasBigDiff = true;
      } else if (dfDiffLong > dfMaxSmallDiffLong) {
        dfMaxSmallDiffLong = dfDiffLong;
      }
    }
    var poMulti = [];
    if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {
      var poNewLS = [];
      poMulti.push(poNewLS);
      for (var k = 0; k < first_pass.length; ++k) {
        var dfX0 = parseFloat(first_pass[k][0]);
        if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {
          var dfX1 = parseFloat(first_pass[k - 1][0]);
          var dfY1 = parseFloat(first_pass[k - 1][1]);
          var dfX2 = parseFloat(first_pass[k][0]);
          var dfY2 = parseFloat(first_pass[k][1]);
          if (dfX1 > -180 && dfX1 < dfRightBorderX && dfX2 === 180 && k + 1 < first_pass.length && first_pass[k - 1][0] > -180 && first_pass[k - 1][0] < dfRightBorderX) {
            poNewLS.push([-180, first_pass[k][1]]);
            k++;
            poNewLS.push([first_pass[k][0], first_pass[k][1]]);
            continue;
          } else if (dfX1 > dfLeftBorderX && dfX1 < 180 && dfX2 === -180 && k + 1 < first_pass.length && first_pass[k - 1][0] > dfLeftBorderX && first_pass[k - 1][0] < 180) {
            poNewLS.push([180, first_pass[k][1]]);
            k++;
            poNewLS.push([first_pass[k][0], first_pass[k][1]]);
            continue;
          }
          if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {
            var tmpX = dfX1;
            dfX1 = dfX2;
            dfX2 = tmpX;
            var tmpY = dfY1;
            dfY1 = dfY2;
            dfY2 = tmpY;
          }
          if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {
            dfX2 += 360;
          }
          if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {
            var dfRatio = (180 - dfX1) / (dfX2 - dfX1);
            var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;
            poNewLS.push([
              first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180,
              dfY
            ]);
            poNewLS = [];
            poNewLS.push([
              first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180,
              dfY
            ]);
            poMulti.push(poNewLS);
          } else {
            poNewLS = [];
            poMulti.push(poNewLS);
          }
          poNewLS.push([dfX0, first_pass[k][1]]);
        } else {
          poNewLS.push([first_pass[k][0], first_pass[k][1]]);
        }
      }
    } else {
      var poNewLS0 = [];
      poMulti.push(poNewLS0);
      for (var l = 0; l < first_pass.length; ++l) {
        poNewLS0.push([first_pass[l][0], first_pass[l][1]]);
      }
    }
    var arc = new Arc(this.properties);
    for (var m = 0; m < poMulti.length; ++m) {
      var line = new LineString();
      arc.geometries.push(line);
      var points = poMulti[m];
      for (var j0 = 0; j0 < points.length; ++j0) {
        line.move_to(points[j0]);
      }
    }
    return arc;
  };

  // node_modules/@turf/line-split/dist/es/index.js
  var import_geojson_rbush2 = __toESM(require_geojson_rbush(), 1);

  // node_modules/@turf/line-overlap/dist/es/index.js
  var import_geojson_rbush3 = __toESM(require_geojson_rbush(), 1);
  var import_deep_equal = __toESM(require_deep_equal(), 1);

  // node_modules/@turf/isobands/dist/es/index.js
  var import_object_assign3 = __toESM(require_object_assign(), 1);
  var isoBandNextXTL = [];
  var isoBandNextYTL = [];
  var isoBandNextOTL = [];
  var isoBandNextXTR = [];
  var isoBandNextYTR = [];
  var isoBandNextOTR = [];
  var isoBandNextXRT = [];
  var isoBandNextYRT = [];
  var isoBandNextORT = [];
  var isoBandNextXRB = [];
  var isoBandNextYRB = [];
  var isoBandNextORB = [];
  var isoBandNextXBL = [];
  var isoBandNextYBL = [];
  var isoBandNextOBL = [];
  var isoBandNextXBR = [];
  var isoBandNextYBR = [];
  var isoBandNextOBR = [];
  var isoBandNextXLT = [];
  var isoBandNextYLT = [];
  var isoBandNextOLT = [];
  var isoBandNextXLB = [];
  var isoBandNextYLB = [];
  var isoBandNextOLB = [];
  isoBandNextXRT[85] = isoBandNextXRB[85] = -1;
  isoBandNextYRT[85] = isoBandNextYRB[85] = 0;
  isoBandNextORT[85] = isoBandNextORB[85] = 1;
  isoBandNextXLT[85] = isoBandNextXLB[85] = 1;
  isoBandNextYLT[85] = isoBandNextYLB[85] = 0;
  isoBandNextOLT[85] = isoBandNextOLB[85] = 1;
  isoBandNextXTL[85] = isoBandNextXTR[85] = 0;
  isoBandNextYTL[85] = isoBandNextYTR[85] = -1;
  isoBandNextOTL[85] = isoBandNextOBL[85] = 0;
  isoBandNextXBR[85] = isoBandNextXBL[85] = 0;
  isoBandNextYBR[85] = isoBandNextYBL[85] = 1;
  isoBandNextOTR[85] = isoBandNextOBR[85] = 1;
  isoBandNextXLB[1] = isoBandNextXLB[169] = 0;
  isoBandNextYLB[1] = isoBandNextYLB[169] = -1;
  isoBandNextOLB[1] = isoBandNextOLB[169] = 0;
  isoBandNextXBL[1] = isoBandNextXBL[169] = -1;
  isoBandNextYBL[1] = isoBandNextYBL[169] = 0;
  isoBandNextOBL[1] = isoBandNextOBL[169] = 0;
  isoBandNextXRB[4] = isoBandNextXRB[166] = 0;
  isoBandNextYRB[4] = isoBandNextYRB[166] = -1;
  isoBandNextORB[4] = isoBandNextORB[166] = 1;
  isoBandNextXBR[4] = isoBandNextXBR[166] = 1;
  isoBandNextYBR[4] = isoBandNextYBR[166] = 0;
  isoBandNextOBR[4] = isoBandNextOBR[166] = 0;
  isoBandNextXRT[16] = isoBandNextXRT[154] = 0;
  isoBandNextYRT[16] = isoBandNextYRT[154] = 1;
  isoBandNextORT[16] = isoBandNextORT[154] = 1;
  isoBandNextXTR[16] = isoBandNextXTR[154] = 1;
  isoBandNextYTR[16] = isoBandNextYTR[154] = 0;
  isoBandNextOTR[16] = isoBandNextOTR[154] = 1;
  isoBandNextXLT[64] = isoBandNextXLT[106] = 0;
  isoBandNextYLT[64] = isoBandNextYLT[106] = 1;
  isoBandNextOLT[64] = isoBandNextOLT[106] = 0;
  isoBandNextXTL[64] = isoBandNextXTL[106] = -1;
  isoBandNextYTL[64] = isoBandNextYTL[106] = 0;
  isoBandNextOTL[64] = isoBandNextOTL[106] = 1;
  isoBandNextXLT[2] = isoBandNextXLT[168] = 0;
  isoBandNextYLT[2] = isoBandNextYLT[168] = -1;
  isoBandNextOLT[2] = isoBandNextOLT[168] = 1;
  isoBandNextXLB[2] = isoBandNextXLB[168] = 0;
  isoBandNextYLB[2] = isoBandNextYLB[168] = -1;
  isoBandNextOLB[2] = isoBandNextOLB[168] = 0;
  isoBandNextXBL[2] = isoBandNextXBL[168] = -1;
  isoBandNextYBL[2] = isoBandNextYBL[168] = 0;
  isoBandNextOBL[2] = isoBandNextOBL[168] = 0;
  isoBandNextXBR[2] = isoBandNextXBR[168] = -1;
  isoBandNextYBR[2] = isoBandNextYBR[168] = 0;
  isoBandNextOBR[2] = isoBandNextOBR[168] = 1;
  isoBandNextXRT[8] = isoBandNextXRT[162] = 0;
  isoBandNextYRT[8] = isoBandNextYRT[162] = -1;
  isoBandNextORT[8] = isoBandNextORT[162] = 0;
  isoBandNextXRB[8] = isoBandNextXRB[162] = 0;
  isoBandNextYRB[8] = isoBandNextYRB[162] = -1;
  isoBandNextORB[8] = isoBandNextORB[162] = 1;
  isoBandNextXBL[8] = isoBandNextXBL[162] = 1;
  isoBandNextYBL[8] = isoBandNextYBL[162] = 0;
  isoBandNextOBL[8] = isoBandNextOBL[162] = 1;
  isoBandNextXBR[8] = isoBandNextXBR[162] = 1;
  isoBandNextYBR[8] = isoBandNextYBR[162] = 0;
  isoBandNextOBR[8] = isoBandNextOBR[162] = 0;
  isoBandNextXRT[32] = isoBandNextXRT[138] = 0;
  isoBandNextYRT[32] = isoBandNextYRT[138] = 1;
  isoBandNextORT[32] = isoBandNextORT[138] = 1;
  isoBandNextXRB[32] = isoBandNextXRB[138] = 0;
  isoBandNextYRB[32] = isoBandNextYRB[138] = 1;
  isoBandNextORB[32] = isoBandNextORB[138] = 0;
  isoBandNextXTL[32] = isoBandNextXTL[138] = 1;
  isoBandNextYTL[32] = isoBandNextYTL[138] = 0;
  isoBandNextOTL[32] = isoBandNextOTL[138] = 0;
  isoBandNextXTR[32] = isoBandNextXTR[138] = 1;
  isoBandNextYTR[32] = isoBandNextYTR[138] = 0;
  isoBandNextOTR[32] = isoBandNextOTR[138] = 1;
  isoBandNextXLB[128] = isoBandNextXLB[42] = 0;
  isoBandNextYLB[128] = isoBandNextYLB[42] = 1;
  isoBandNextOLB[128] = isoBandNextOLB[42] = 1;
  isoBandNextXLT[128] = isoBandNextXLT[42] = 0;
  isoBandNextYLT[128] = isoBandNextYLT[42] = 1;
  isoBandNextOLT[128] = isoBandNextOLT[42] = 0;
  isoBandNextXTL[128] = isoBandNextXTL[42] = -1;
  isoBandNextYTL[128] = isoBandNextYTL[42] = 0;
  isoBandNextOTL[128] = isoBandNextOTL[42] = 1;
  isoBandNextXTR[128] = isoBandNextXTR[42] = -1;
  isoBandNextYTR[128] = isoBandNextYTR[42] = 0;
  isoBandNextOTR[128] = isoBandNextOTR[42] = 0;
  isoBandNextXRB[5] = isoBandNextXRB[165] = -1;
  isoBandNextYRB[5] = isoBandNextYRB[165] = 0;
  isoBandNextORB[5] = isoBandNextORB[165] = 0;
  isoBandNextXLB[5] = isoBandNextXLB[165] = 1;
  isoBandNextYLB[5] = isoBandNextYLB[165] = 0;
  isoBandNextOLB[5] = isoBandNextOLB[165] = 0;
  isoBandNextXBR[20] = isoBandNextXBR[150] = 0;
  isoBandNextYBR[20] = isoBandNextYBR[150] = 1;
  isoBandNextOBR[20] = isoBandNextOBR[150] = 1;
  isoBandNextXTR[20] = isoBandNextXTR[150] = 0;
  isoBandNextYTR[20] = isoBandNextYTR[150] = -1;
  isoBandNextOTR[20] = isoBandNextOTR[150] = 1;
  isoBandNextXRT[80] = isoBandNextXRT[90] = -1;
  isoBandNextYRT[80] = isoBandNextYRT[90] = 0;
  isoBandNextORT[80] = isoBandNextORT[90] = 1;
  isoBandNextXLT[80] = isoBandNextXLT[90] = 1;
  isoBandNextYLT[80] = isoBandNextYLT[90] = 0;
  isoBandNextOLT[80] = isoBandNextOLT[90] = 1;
  isoBandNextXBL[65] = isoBandNextXBL[105] = 0;
  isoBandNextYBL[65] = isoBandNextYBL[105] = 1;
  isoBandNextOBL[65] = isoBandNextOBL[105] = 0;
  isoBandNextXTL[65] = isoBandNextXTL[105] = 0;
  isoBandNextYTL[65] = isoBandNextYTL[105] = -1;
  isoBandNextOTL[65] = isoBandNextOTL[105] = 0;
  isoBandNextXRT[160] = isoBandNextXRT[10] = -1;
  isoBandNextYRT[160] = isoBandNextYRT[10] = 0;
  isoBandNextORT[160] = isoBandNextORT[10] = 1;
  isoBandNextXRB[160] = isoBandNextXRB[10] = -1;
  isoBandNextYRB[160] = isoBandNextYRB[10] = 0;
  isoBandNextORB[160] = isoBandNextORB[10] = 0;
  isoBandNextXLB[160] = isoBandNextXLB[10] = 1;
  isoBandNextYLB[160] = isoBandNextYLB[10] = 0;
  isoBandNextOLB[160] = isoBandNextOLB[10] = 0;
  isoBandNextXLT[160] = isoBandNextXLT[10] = 1;
  isoBandNextYLT[160] = isoBandNextYLT[10] = 0;
  isoBandNextOLT[160] = isoBandNextOLT[10] = 1;
  isoBandNextXBR[130] = isoBandNextXBR[40] = 0;
  isoBandNextYBR[130] = isoBandNextYBR[40] = 1;
  isoBandNextOBR[130] = isoBandNextOBR[40] = 1;
  isoBandNextXBL[130] = isoBandNextXBL[40] = 0;
  isoBandNextYBL[130] = isoBandNextYBL[40] = 1;
  isoBandNextOBL[130] = isoBandNextOBL[40] = 0;
  isoBandNextXTL[130] = isoBandNextXTL[40] = 0;
  isoBandNextYTL[130] = isoBandNextYTL[40] = -1;
  isoBandNextOTL[130] = isoBandNextOTL[40] = 0;
  isoBandNextXTR[130] = isoBandNextXTR[40] = 0;
  isoBandNextYTR[130] = isoBandNextYTR[40] = -1;
  isoBandNextOTR[130] = isoBandNextOTR[40] = 1;
  isoBandNextXRB[37] = isoBandNextXRB[133] = 0;
  isoBandNextYRB[37] = isoBandNextYRB[133] = 1;
  isoBandNextORB[37] = isoBandNextORB[133] = 1;
  isoBandNextXLB[37] = isoBandNextXLB[133] = 0;
  isoBandNextYLB[37] = isoBandNextYLB[133] = 1;
  isoBandNextOLB[37] = isoBandNextOLB[133] = 0;
  isoBandNextXTL[37] = isoBandNextXTL[133] = -1;
  isoBandNextYTL[37] = isoBandNextYTL[133] = 0;
  isoBandNextOTL[37] = isoBandNextOTL[133] = 0;
  isoBandNextXTR[37] = isoBandNextXTR[133] = 1;
  isoBandNextYTR[37] = isoBandNextYTR[133] = 0;
  isoBandNextOTR[37] = isoBandNextOTR[133] = 0;
  isoBandNextXBR[148] = isoBandNextXBR[22] = -1;
  isoBandNextYBR[148] = isoBandNextYBR[22] = 0;
  isoBandNextOBR[148] = isoBandNextOBR[22] = 0;
  isoBandNextXLB[148] = isoBandNextXLB[22] = 0;
  isoBandNextYLB[148] = isoBandNextYLB[22] = -1;
  isoBandNextOLB[148] = isoBandNextOLB[22] = 1;
  isoBandNextXLT[148] = isoBandNextXLT[22] = 0;
  isoBandNextYLT[148] = isoBandNextYLT[22] = 1;
  isoBandNextOLT[148] = isoBandNextOLT[22] = 1;
  isoBandNextXTR[148] = isoBandNextXTR[22] = -1;
  isoBandNextYTR[148] = isoBandNextYTR[22] = 0;
  isoBandNextOTR[148] = isoBandNextOTR[22] = 1;
  isoBandNextXRT[82] = isoBandNextXRT[88] = 0;
  isoBandNextYRT[82] = isoBandNextYRT[88] = -1;
  isoBandNextORT[82] = isoBandNextORT[88] = 1;
  isoBandNextXBR[82] = isoBandNextXBR[88] = 1;
  isoBandNextYBR[82] = isoBandNextYBR[88] = 0;
  isoBandNextOBR[82] = isoBandNextOBR[88] = 1;
  isoBandNextXBL[82] = isoBandNextXBL[88] = -1;
  isoBandNextYBL[82] = isoBandNextYBL[88] = 0;
  isoBandNextOBL[82] = isoBandNextOBL[88] = 1;
  isoBandNextXLT[82] = isoBandNextXLT[88] = 0;
  isoBandNextYLT[82] = isoBandNextYLT[88] = -1;
  isoBandNextOLT[82] = isoBandNextOLT[88] = 0;
  isoBandNextXRT[73] = isoBandNextXRT[97] = 0;
  isoBandNextYRT[73] = isoBandNextYRT[97] = 1;
  isoBandNextORT[73] = isoBandNextORT[97] = 0;
  isoBandNextXRB[73] = isoBandNextXRB[97] = 0;
  isoBandNextYRB[73] = isoBandNextYRB[97] = -1;
  isoBandNextORB[73] = isoBandNextORB[97] = 0;
  isoBandNextXBL[73] = isoBandNextXBL[97] = 1;
  isoBandNextYBL[73] = isoBandNextYBL[97] = 0;
  isoBandNextOBL[73] = isoBandNextOBL[97] = 0;
  isoBandNextXTL[73] = isoBandNextXTL[97] = 1;
  isoBandNextYTL[73] = isoBandNextYTL[97] = 0;
  isoBandNextOTL[73] = isoBandNextOTL[97] = 1;
  isoBandNextXRT[145] = isoBandNextXRT[25] = 0;
  isoBandNextYRT[145] = isoBandNextYRT[25] = -1;
  isoBandNextORT[145] = isoBandNextORT[25] = 0;
  isoBandNextXBL[145] = isoBandNextXBL[25] = 1;
  isoBandNextYBL[145] = isoBandNextYBL[25] = 0;
  isoBandNextOBL[145] = isoBandNextOBL[25] = 1;
  isoBandNextXLB[145] = isoBandNextXLB[25] = 0;
  isoBandNextYLB[145] = isoBandNextYLB[25] = 1;
  isoBandNextOLB[145] = isoBandNextOLB[25] = 1;
  isoBandNextXTR[145] = isoBandNextXTR[25] = -1;
  isoBandNextYTR[145] = isoBandNextYTR[25] = 0;
  isoBandNextOTR[145] = isoBandNextOTR[25] = 0;
  isoBandNextXRB[70] = isoBandNextXRB[100] = 0;
  isoBandNextYRB[70] = isoBandNextYRB[100] = 1;
  isoBandNextORB[70] = isoBandNextORB[100] = 0;
  isoBandNextXBR[70] = isoBandNextXBR[100] = -1;
  isoBandNextYBR[70] = isoBandNextYBR[100] = 0;
  isoBandNextOBR[70] = isoBandNextOBR[100] = 1;
  isoBandNextXLT[70] = isoBandNextXLT[100] = 0;
  isoBandNextYLT[70] = isoBandNextYLT[100] = -1;
  isoBandNextOLT[70] = isoBandNextOLT[100] = 1;
  isoBandNextXTL[70] = isoBandNextXTL[100] = 1;
  isoBandNextYTL[70] = isoBandNextYTL[100] = 0;
  isoBandNextOTL[70] = isoBandNextOTL[100] = 0;
  isoBandNextXRB[101] = isoBandNextXRB[69] = 0;
  isoBandNextYRB[101] = isoBandNextYRB[69] = 1;
  isoBandNextORB[101] = isoBandNextORB[69] = 0;
  isoBandNextXTL[101] = isoBandNextXTL[69] = 1;
  isoBandNextYTL[101] = isoBandNextYTL[69] = 0;
  isoBandNextOTL[101] = isoBandNextOTL[69] = 0;
  isoBandNextXLB[149] = isoBandNextXLB[21] = 0;
  isoBandNextYLB[149] = isoBandNextYLB[21] = 1;
  isoBandNextOLB[149] = isoBandNextOLB[21] = 1;
  isoBandNextXTR[149] = isoBandNextXTR[21] = -1;
  isoBandNextYTR[149] = isoBandNextYTR[21] = 0;
  isoBandNextOTR[149] = isoBandNextOTR[21] = 0;
  isoBandNextXBR[86] = isoBandNextXBR[84] = -1;
  isoBandNextYBR[86] = isoBandNextYBR[84] = 0;
  isoBandNextOBR[86] = isoBandNextOBR[84] = 1;
  isoBandNextXLT[86] = isoBandNextXLT[84] = 0;
  isoBandNextYLT[86] = isoBandNextYLT[84] = -1;
  isoBandNextOLT[86] = isoBandNextOLT[84] = 1;
  isoBandNextXRT[89] = isoBandNextXRT[81] = 0;
  isoBandNextYRT[89] = isoBandNextYRT[81] = -1;
  isoBandNextORT[89] = isoBandNextORT[81] = 0;
  isoBandNextXBL[89] = isoBandNextXBL[81] = 1;
  isoBandNextYBL[89] = isoBandNextYBL[81] = 0;
  isoBandNextOBL[89] = isoBandNextOBL[81] = 1;
  isoBandNextXRT[96] = isoBandNextXRT[74] = 0;
  isoBandNextYRT[96] = isoBandNextYRT[74] = 1;
  isoBandNextORT[96] = isoBandNextORT[74] = 0;
  isoBandNextXRB[96] = isoBandNextXRB[74] = -1;
  isoBandNextYRB[96] = isoBandNextYRB[74] = 0;
  isoBandNextORB[96] = isoBandNextORB[74] = 1;
  isoBandNextXLT[96] = isoBandNextXLT[74] = 1;
  isoBandNextYLT[96] = isoBandNextYLT[74] = 0;
  isoBandNextOLT[96] = isoBandNextOLT[74] = 0;
  isoBandNextXTL[96] = isoBandNextXTL[74] = 1;
  isoBandNextYTL[96] = isoBandNextYTL[74] = 0;
  isoBandNextOTL[96] = isoBandNextOTL[74] = 1;
  isoBandNextXRT[24] = isoBandNextXRT[146] = 0;
  isoBandNextYRT[24] = isoBandNextYRT[146] = -1;
  isoBandNextORT[24] = isoBandNextORT[146] = 1;
  isoBandNextXBR[24] = isoBandNextXBR[146] = 1;
  isoBandNextYBR[24] = isoBandNextYBR[146] = 0;
  isoBandNextOBR[24] = isoBandNextOBR[146] = 1;
  isoBandNextXBL[24] = isoBandNextXBL[146] = 0;
  isoBandNextYBL[24] = isoBandNextYBL[146] = 1;
  isoBandNextOBL[24] = isoBandNextOBL[146] = 1;
  isoBandNextXTR[24] = isoBandNextXTR[146] = 0;
  isoBandNextYTR[24] = isoBandNextYTR[146] = -1;
  isoBandNextOTR[24] = isoBandNextOTR[146] = 0;
  isoBandNextXRB[6] = isoBandNextXRB[164] = -1;
  isoBandNextYRB[6] = isoBandNextYRB[164] = 0;
  isoBandNextORB[6] = isoBandNextORB[164] = 1;
  isoBandNextXBR[6] = isoBandNextXBR[164] = -1;
  isoBandNextYBR[6] = isoBandNextYBR[164] = 0;
  isoBandNextOBR[6] = isoBandNextOBR[164] = 0;
  isoBandNextXLB[6] = isoBandNextXLB[164] = 0;
  isoBandNextYLB[6] = isoBandNextYLB[164] = -1;
  isoBandNextOLB[6] = isoBandNextOLB[164] = 1;
  isoBandNextXLT[6] = isoBandNextXLT[164] = 1;
  isoBandNextYLT[6] = isoBandNextYLT[164] = 0;
  isoBandNextOLT[6] = isoBandNextOLT[164] = 0;
  isoBandNextXBL[129] = isoBandNextXBL[41] = 0;
  isoBandNextYBL[129] = isoBandNextYBL[41] = 1;
  isoBandNextOBL[129] = isoBandNextOBL[41] = 1;
  isoBandNextXLB[129] = isoBandNextXLB[41] = 0;
  isoBandNextYLB[129] = isoBandNextYLB[41] = 1;
  isoBandNextOLB[129] = isoBandNextOLB[41] = 0;
  isoBandNextXTL[129] = isoBandNextXTL[41] = -1;
  isoBandNextYTL[129] = isoBandNextYTL[41] = 0;
  isoBandNextOTL[129] = isoBandNextOTL[41] = 0;
  isoBandNextXTR[129] = isoBandNextXTR[41] = 0;
  isoBandNextYTR[129] = isoBandNextYTR[41] = -1;
  isoBandNextOTR[129] = isoBandNextOTR[41] = 0;
  isoBandNextXBR[66] = isoBandNextXBR[104] = 0;
  isoBandNextYBR[66] = isoBandNextYBR[104] = 1;
  isoBandNextOBR[66] = isoBandNextOBR[104] = 0;
  isoBandNextXBL[66] = isoBandNextXBL[104] = -1;
  isoBandNextYBL[66] = isoBandNextYBL[104] = 0;
  isoBandNextOBL[66] = isoBandNextOBL[104] = 1;
  isoBandNextXLT[66] = isoBandNextXLT[104] = 0;
  isoBandNextYLT[66] = isoBandNextYLT[104] = -1;
  isoBandNextOLT[66] = isoBandNextOLT[104] = 0;
  isoBandNextXTL[66] = isoBandNextXTL[104] = 0;
  isoBandNextYTL[66] = isoBandNextYTL[104] = -1;
  isoBandNextOTL[66] = isoBandNextOTL[104] = 1;
  isoBandNextXRT[144] = isoBandNextXRT[26] = -1;
  isoBandNextYRT[144] = isoBandNextYRT[26] = 0;
  isoBandNextORT[144] = isoBandNextORT[26] = 0;
  isoBandNextXLB[144] = isoBandNextXLB[26] = 1;
  isoBandNextYLB[144] = isoBandNextYLB[26] = 0;
  isoBandNextOLB[144] = isoBandNextOLB[26] = 1;
  isoBandNextXLT[144] = isoBandNextXLT[26] = 0;
  isoBandNextYLT[144] = isoBandNextYLT[26] = 1;
  isoBandNextOLT[144] = isoBandNextOLT[26] = 1;
  isoBandNextXTR[144] = isoBandNextXTR[26] = -1;
  isoBandNextYTR[144] = isoBandNextYTR[26] = 0;
  isoBandNextOTR[144] = isoBandNextOTR[26] = 1;
  isoBandNextXRB[36] = isoBandNextXRB[134] = 0;
  isoBandNextYRB[36] = isoBandNextYRB[134] = 1;
  isoBandNextORB[36] = isoBandNextORB[134] = 1;
  isoBandNextXBR[36] = isoBandNextXBR[134] = 0;
  isoBandNextYBR[36] = isoBandNextYBR[134] = 1;
  isoBandNextOBR[36] = isoBandNextOBR[134] = 0;
  isoBandNextXTL[36] = isoBandNextXTL[134] = 0;
  isoBandNextYTL[36] = isoBandNextYTL[134] = -1;
  isoBandNextOTL[36] = isoBandNextOTL[134] = 1;
  isoBandNextXTR[36] = isoBandNextXTR[134] = 1;
  isoBandNextYTR[36] = isoBandNextYTR[134] = 0;
  isoBandNextOTR[36] = isoBandNextOTR[134] = 0;
  isoBandNextXRT[9] = isoBandNextXRT[161] = -1;
  isoBandNextYRT[9] = isoBandNextYRT[161] = 0;
  isoBandNextORT[9] = isoBandNextORT[161] = 0;
  isoBandNextXRB[9] = isoBandNextXRB[161] = 0;
  isoBandNextYRB[9] = isoBandNextYRB[161] = -1;
  isoBandNextORB[9] = isoBandNextORB[161] = 0;
  isoBandNextXBL[9] = isoBandNextXBL[161] = 1;
  isoBandNextYBL[9] = isoBandNextYBL[161] = 0;
  isoBandNextOBL[9] = isoBandNextOBL[161] = 0;
  isoBandNextXLB[9] = isoBandNextXLB[161] = 1;
  isoBandNextYLB[9] = isoBandNextYLB[161] = 0;
  isoBandNextOLB[9] = isoBandNextOLB[161] = 1;
  isoBandNextXRT[136] = 0;
  isoBandNextYRT[136] = 1;
  isoBandNextORT[136] = 1;
  isoBandNextXRB[136] = 0;
  isoBandNextYRB[136] = 1;
  isoBandNextORB[136] = 0;
  isoBandNextXBR[136] = -1;
  isoBandNextYBR[136] = 0;
  isoBandNextOBR[136] = 1;
  isoBandNextXBL[136] = -1;
  isoBandNextYBL[136] = 0;
  isoBandNextOBL[136] = 0;
  isoBandNextXLB[136] = 0;
  isoBandNextYLB[136] = -1;
  isoBandNextOLB[136] = 0;
  isoBandNextXLT[136] = 0;
  isoBandNextYLT[136] = -1;
  isoBandNextOLT[136] = 1;
  isoBandNextXTL[136] = 1;
  isoBandNextYTL[136] = 0;
  isoBandNextOTL[136] = 0;
  isoBandNextXTR[136] = 1;
  isoBandNextYTR[136] = 0;
  isoBandNextOTR[136] = 1;
  isoBandNextXRT[34] = 0;
  isoBandNextYRT[34] = -1;
  isoBandNextORT[34] = 0;
  isoBandNextXRB[34] = 0;
  isoBandNextYRB[34] = -1;
  isoBandNextORB[34] = 1;
  isoBandNextXBR[34] = 1;
  isoBandNextYBR[34] = 0;
  isoBandNextOBR[34] = 0;
  isoBandNextXBL[34] = 1;
  isoBandNextYBL[34] = 0;
  isoBandNextOBL[34] = 1;
  isoBandNextXLB[34] = 0;
  isoBandNextYLB[34] = 1;
  isoBandNextOLB[34] = 1;
  isoBandNextXLT[34] = 0;
  isoBandNextYLT[34] = 1;
  isoBandNextOLT[34] = 0;
  isoBandNextXTL[34] = -1;
  isoBandNextYTL[34] = 0;
  isoBandNextOTL[34] = 1;
  isoBandNextXTR[34] = -1;
  isoBandNextYTR[34] = 0;
  isoBandNextOTR[34] = 0;
  isoBandNextXRT[35] = 0;
  isoBandNextYRT[35] = 1;
  isoBandNextORT[35] = 1;
  isoBandNextXRB[35] = 0;
  isoBandNextYRB[35] = -1;
  isoBandNextORB[35] = 1;
  isoBandNextXBR[35] = 1;
  isoBandNextYBR[35] = 0;
  isoBandNextOBR[35] = 0;
  isoBandNextXBL[35] = -1;
  isoBandNextYBL[35] = 0;
  isoBandNextOBL[35] = 0;
  isoBandNextXLB[35] = 0;
  isoBandNextYLB[35] = -1;
  isoBandNextOLB[35] = 0;
  isoBandNextXLT[35] = 0;
  isoBandNextYLT[35] = 1;
  isoBandNextOLT[35] = 0;
  isoBandNextXTL[35] = -1;
  isoBandNextYTL[35] = 0;
  isoBandNextOTL[35] = 1;
  isoBandNextXTR[35] = 1;
  isoBandNextYTR[35] = 0;
  isoBandNextOTR[35] = 1;
  isoBandNextXRT[153] = 0;
  isoBandNextYRT[153] = 1;
  isoBandNextORT[153] = 1;
  isoBandNextXBL[153] = -1;
  isoBandNextYBL[153] = 0;
  isoBandNextOBL[153] = 0;
  isoBandNextXLB[153] = 0;
  isoBandNextYLB[153] = -1;
  isoBandNextOLB[153] = 0;
  isoBandNextXTR[153] = 1;
  isoBandNextYTR[153] = 0;
  isoBandNextOTR[153] = 1;
  isoBandNextXRB[102] = 0;
  isoBandNextYRB[102] = -1;
  isoBandNextORB[102] = 1;
  isoBandNextXBR[102] = 1;
  isoBandNextYBR[102] = 0;
  isoBandNextOBR[102] = 0;
  isoBandNextXLT[102] = 0;
  isoBandNextYLT[102] = 1;
  isoBandNextOLT[102] = 0;
  isoBandNextXTL[102] = -1;
  isoBandNextYTL[102] = 0;
  isoBandNextOTL[102] = 1;
  isoBandNextXRT[155] = 0;
  isoBandNextYRT[155] = -1;
  isoBandNextORT[155] = 0;
  isoBandNextXBL[155] = 1;
  isoBandNextYBL[155] = 0;
  isoBandNextOBL[155] = 1;
  isoBandNextXLB[155] = 0;
  isoBandNextYLB[155] = 1;
  isoBandNextOLB[155] = 1;
  isoBandNextXTR[155] = -1;
  isoBandNextYTR[155] = 0;
  isoBandNextOTR[155] = 0;
  isoBandNextXRB[103] = 0;
  isoBandNextYRB[103] = 1;
  isoBandNextORB[103] = 0;
  isoBandNextXBR[103] = -1;
  isoBandNextYBR[103] = 0;
  isoBandNextOBR[103] = 1;
  isoBandNextXLT[103] = 0;
  isoBandNextYLT[103] = -1;
  isoBandNextOLT[103] = 1;
  isoBandNextXTL[103] = 1;
  isoBandNextYTL[103] = 0;
  isoBandNextOTL[103] = 0;
  isoBandNextXRT[152] = 0;
  isoBandNextYRT[152] = 1;
  isoBandNextORT[152] = 1;
  isoBandNextXBR[152] = -1;
  isoBandNextYBR[152] = 0;
  isoBandNextOBR[152] = 1;
  isoBandNextXBL[152] = -1;
  isoBandNextYBL[152] = 0;
  isoBandNextOBL[152] = 0;
  isoBandNextXLB[152] = 0;
  isoBandNextYLB[152] = -1;
  isoBandNextOLB[152] = 0;
  isoBandNextXLT[152] = 0;
  isoBandNextYLT[152] = -1;
  isoBandNextOLT[152] = 1;
  isoBandNextXTR[152] = 1;
  isoBandNextYTR[152] = 0;
  isoBandNextOTR[152] = 1;
  isoBandNextXRT[156] = 0;
  isoBandNextYRT[156] = -1;
  isoBandNextORT[156] = 1;
  isoBandNextXBR[156] = 1;
  isoBandNextYBR[156] = 0;
  isoBandNextOBR[156] = 1;
  isoBandNextXBL[156] = -1;
  isoBandNextYBL[156] = 0;
  isoBandNextOBL[156] = 0;
  isoBandNextXLB[156] = 0;
  isoBandNextYLB[156] = -1;
  isoBandNextOLB[156] = 0;
  isoBandNextXLT[156] = 0;
  isoBandNextYLT[156] = 1;
  isoBandNextOLT[156] = 1;
  isoBandNextXTR[156] = -1;
  isoBandNextYTR[156] = 0;
  isoBandNextOTR[156] = 1;
  isoBandNextXRT[137] = 0;
  isoBandNextYRT[137] = 1;
  isoBandNextORT[137] = 1;
  isoBandNextXRB[137] = 0;
  isoBandNextYRB[137] = 1;
  isoBandNextORB[137] = 0;
  isoBandNextXBL[137] = -1;
  isoBandNextYBL[137] = 0;
  isoBandNextOBL[137] = 0;
  isoBandNextXLB[137] = 0;
  isoBandNextYLB[137] = -1;
  isoBandNextOLB[137] = 0;
  isoBandNextXTL[137] = 1;
  isoBandNextYTL[137] = 0;
  isoBandNextOTL[137] = 0;
  isoBandNextXTR[137] = 1;
  isoBandNextYTR[137] = 0;
  isoBandNextOTR[137] = 1;
  isoBandNextXRT[139] = 0;
  isoBandNextYRT[139] = 1;
  isoBandNextORT[139] = 1;
  isoBandNextXRB[139] = 0;
  isoBandNextYRB[139] = -1;
  isoBandNextORB[139] = 0;
  isoBandNextXBL[139] = 1;
  isoBandNextYBL[139] = 0;
  isoBandNextOBL[139] = 0;
  isoBandNextXLB[139] = 0;
  isoBandNextYLB[139] = 1;
  isoBandNextOLB[139] = 0;
  isoBandNextXTL[139] = -1;
  isoBandNextYTL[139] = 0;
  isoBandNextOTL[139] = 0;
  isoBandNextXTR[139] = 1;
  isoBandNextYTR[139] = 0;
  isoBandNextOTR[139] = 1;
  isoBandNextXRT[98] = 0;
  isoBandNextYRT[98] = -1;
  isoBandNextORT[98] = 0;
  isoBandNextXRB[98] = 0;
  isoBandNextYRB[98] = -1;
  isoBandNextORB[98] = 1;
  isoBandNextXBR[98] = 1;
  isoBandNextYBR[98] = 0;
  isoBandNextOBR[98] = 0;
  isoBandNextXBL[98] = 1;
  isoBandNextYBL[98] = 0;
  isoBandNextOBL[98] = 1;
  isoBandNextXLT[98] = 0;
  isoBandNextYLT[98] = 1;
  isoBandNextOLT[98] = 0;
  isoBandNextXTL[98] = -1;
  isoBandNextYTL[98] = 0;
  isoBandNextOTL[98] = 1;
  isoBandNextXRT[99] = 0;
  isoBandNextYRT[99] = 1;
  isoBandNextORT[99] = 0;
  isoBandNextXRB[99] = 0;
  isoBandNextYRB[99] = -1;
  isoBandNextORB[99] = 1;
  isoBandNextXBR[99] = 1;
  isoBandNextYBR[99] = 0;
  isoBandNextOBR[99] = 0;
  isoBandNextXBL[99] = -1;
  isoBandNextYBL[99] = 0;
  isoBandNextOBL[99] = 1;
  isoBandNextXLT[99] = 0;
  isoBandNextYLT[99] = -1;
  isoBandNextOLT[99] = 0;
  isoBandNextXTL[99] = 1;
  isoBandNextYTL[99] = 0;
  isoBandNextOTL[99] = 1;
  isoBandNextXRB[38] = 0;
  isoBandNextYRB[38] = -1;
  isoBandNextORB[38] = 1;
  isoBandNextXBR[38] = 1;
  isoBandNextYBR[38] = 0;
  isoBandNextOBR[38] = 0;
  isoBandNextXLB[38] = 0;
  isoBandNextYLB[38] = 1;
  isoBandNextOLB[38] = 1;
  isoBandNextXLT[38] = 0;
  isoBandNextYLT[38] = 1;
  isoBandNextOLT[38] = 0;
  isoBandNextXTL[38] = -1;
  isoBandNextYTL[38] = 0;
  isoBandNextOTL[38] = 1;
  isoBandNextXTR[38] = -1;
  isoBandNextYTR[38] = 0;
  isoBandNextOTR[38] = 0;
  isoBandNextXRB[39] = 0;
  isoBandNextYRB[39] = 1;
  isoBandNextORB[39] = 1;
  isoBandNextXBR[39] = -1;
  isoBandNextYBR[39] = 0;
  isoBandNextOBR[39] = 0;
  isoBandNextXLB[39] = 0;
  isoBandNextYLB[39] = -1;
  isoBandNextOLB[39] = 1;
  isoBandNextXLT[39] = 0;
  isoBandNextYLT[39] = 1;
  isoBandNextOLT[39] = 0;
  isoBandNextXTL[39] = -1;
  isoBandNextYTL[39] = 0;
  isoBandNextOTL[39] = 1;
  isoBandNextXTR[39] = 1;
  isoBandNextYTR[39] = 0;
  isoBandNextOTR[39] = 0;
  var p00 = function(cell) {
    return [
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom]
    ];
  };
  var p01 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0]
    ];
  };
  var p02 = function(cell) {
    return [
      [cell.topright, 1],
      [1, 1],
      [1, cell.righttop]
    ];
  };
  var p03 = function(cell) {
    return [
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p04 = function(cell) {
    return [
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop]
    ];
  };
  var p05 = function(cell) {
    return [
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [1, cell.righttop],
      [1, cell.rightbottom]
    ];
  };
  var p06 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p07 = function(cell) {
    return [
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p08 = function(cell) {
    return [
      [0, 0],
      [0, cell.leftbottom],
      [1, cell.rightbottom],
      [1, 0]
    ];
  };
  var p09 = function(cell) {
    return [
      [1, 0],
      [cell.bottomright, 0],
      [cell.topright, 1],
      [1, 1]
    ];
  };
  var p10 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [0, cell.lefttop],
      [0, 1]
    ];
  };
  var p11 = function(cell) {
    return [
      [cell.bottomleft, 0],
      [0, 0],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p12 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [0, cell.leftbottom],
      [0, cell.lefttop]
    ];
  };
  var p13 = function(cell) {
    return [
      [cell.topleft, 1],
      [cell.topright, 1],
      [cell.bottomright, 0],
      [cell.bottomleft, 0]
    ];
  };
  var p14 = function() {
    return [
      [0, 0],
      [0, 1],
      [1, 1],
      [1, 0]
    ];
  };
  var p15 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [0, 0],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p16 = function(cell) {
    return [
      [cell.topright, 1],
      [1, 1],
      [1, 0],
      [0, 0],
      [0, cell.leftbottom]
    ];
  };
  var p17 = function(cell) {
    return [
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.lefttop],
      [0, 1],
      [1, 1]
    ];
  };
  var p18 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomleft, 0],
      [0, 0],
      [0, 1]
    ];
  };
  var p19 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p20 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [cell.topright, 1]
    ];
  };
  var p21 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop]
    ];
  };
  var p22 = function(cell) {
    return [
      [cell.topright, 1],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topleft, 1]
    ];
  };
  var p23 = function(cell) {
    return [
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p24 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topright, 1]
    ];
  };
  var p25 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p26 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom]
    ];
  };
  var p27 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p28 = function(cell) {
    return [
      [1, 1],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topright, 1]
    ];
  };
  var p29 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.lefttop],
      [0, 1]
    ];
  };
  var p30 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomleft, 0],
      [0, 0],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p31 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topright, 1]
    ];
  };
  var p32 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p33 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p34 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topright, 1]
    ];
  };
  var p35 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p36 = function(cell) {
    return [
      [1, 1],
      [1, cell.righttop],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topright, 1]
    ];
  };
  var p37 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomleft, 0],
      [0, 0],
      [0, cell.leftbottom],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var p38 = function(cell) {
    return [
      [1, cell.righttop],
      [1, cell.rightbottom],
      [cell.bottomright, 0],
      [cell.bottomleft, 0],
      [0, cell.lefttop],
      [0, 1],
      [cell.topleft, 1]
    ];
  };
  var p39 = function(cell) {
    return [
      [1, cell.rightbottom],
      [1, 0],
      [cell.bottomright, 0],
      [0, cell.leftbottom],
      [0, cell.lefttop],
      [cell.topleft, 1],
      [cell.topright, 1]
    ];
  };
  var isoBandEdgeRT = [];
  var isoBandEdgeRB = [];
  var isoBandEdgeBR = [];
  var isoBandEdgeBL = [];
  var isoBandEdgeLB = [];
  var isoBandEdgeLT = [];
  var isoBandEdgeTL = [];
  var isoBandEdgeTR = [];
  isoBandEdgeBL[1] = isoBandEdgeLB[1] = 18;
  isoBandEdgeBL[169] = isoBandEdgeLB[169] = 18;
  isoBandEdgeBR[4] = isoBandEdgeRB[4] = 12;
  isoBandEdgeBR[166] = isoBandEdgeRB[166] = 12;
  isoBandEdgeRT[16] = isoBandEdgeTR[16] = 4;
  isoBandEdgeRT[154] = isoBandEdgeTR[154] = 4;
  isoBandEdgeLT[64] = isoBandEdgeTL[64] = 22;
  isoBandEdgeLT[106] = isoBandEdgeTL[106] = 22;
  isoBandEdgeBR[2] = isoBandEdgeLT[2] = 17;
  isoBandEdgeBL[2] = isoBandEdgeLB[2] = 18;
  isoBandEdgeBR[168] = isoBandEdgeLT[168] = 17;
  isoBandEdgeBL[168] = isoBandEdgeLB[168] = 18;
  isoBandEdgeRT[8] = isoBandEdgeBL[8] = 9;
  isoBandEdgeRB[8] = isoBandEdgeBR[8] = 12;
  isoBandEdgeRT[162] = isoBandEdgeBL[162] = 9;
  isoBandEdgeRB[162] = isoBandEdgeBR[162] = 12;
  isoBandEdgeRT[32] = isoBandEdgeTR[32] = 4;
  isoBandEdgeRB[32] = isoBandEdgeTL[32] = 1;
  isoBandEdgeRT[138] = isoBandEdgeTR[138] = 4;
  isoBandEdgeRB[138] = isoBandEdgeTL[138] = 1;
  isoBandEdgeLB[128] = isoBandEdgeTR[128] = 21;
  isoBandEdgeLT[128] = isoBandEdgeTL[128] = 22;
  isoBandEdgeLB[42] = isoBandEdgeTR[42] = 21;
  isoBandEdgeLT[42] = isoBandEdgeTL[42] = 22;
  isoBandEdgeRB[5] = isoBandEdgeLB[5] = 14;
  isoBandEdgeRB[165] = isoBandEdgeLB[165] = 14;
  isoBandEdgeBR[20] = isoBandEdgeTR[20] = 6;
  isoBandEdgeBR[150] = isoBandEdgeTR[150] = 6;
  isoBandEdgeRT[80] = isoBandEdgeLT[80] = 11;
  isoBandEdgeRT[90] = isoBandEdgeLT[90] = 11;
  isoBandEdgeBL[65] = isoBandEdgeTL[65] = 3;
  isoBandEdgeBL[105] = isoBandEdgeTL[105] = 3;
  isoBandEdgeRT[160] = isoBandEdgeLT[160] = 11;
  isoBandEdgeRB[160] = isoBandEdgeLB[160] = 14;
  isoBandEdgeRT[10] = isoBandEdgeLT[10] = 11;
  isoBandEdgeRB[10] = isoBandEdgeLB[10] = 14;
  isoBandEdgeBR[130] = isoBandEdgeTR[130] = 6;
  isoBandEdgeBL[130] = isoBandEdgeTL[130] = 3;
  isoBandEdgeBR[40] = isoBandEdgeTR[40] = 6;
  isoBandEdgeBL[40] = isoBandEdgeTL[40] = 3;
  isoBandEdgeRB[101] = isoBandEdgeTL[101] = 1;
  isoBandEdgeRB[69] = isoBandEdgeTL[69] = 1;
  isoBandEdgeLB[149] = isoBandEdgeTR[149] = 21;
  isoBandEdgeLB[21] = isoBandEdgeTR[21] = 21;
  isoBandEdgeBR[86] = isoBandEdgeLT[86] = 17;
  isoBandEdgeBR[84] = isoBandEdgeLT[84] = 17;
  isoBandEdgeRT[89] = isoBandEdgeBL[89] = 9;
  isoBandEdgeRT[81] = isoBandEdgeBL[81] = 9;
  isoBandEdgeRT[96] = isoBandEdgeTL[96] = 0;
  isoBandEdgeRB[96] = isoBandEdgeLT[96] = 15;
  isoBandEdgeRT[74] = isoBandEdgeTL[74] = 0;
  isoBandEdgeRB[74] = isoBandEdgeLT[74] = 15;
  isoBandEdgeRT[24] = isoBandEdgeBR[24] = 8;
  isoBandEdgeBL[24] = isoBandEdgeTR[24] = 7;
  isoBandEdgeRT[146] = isoBandEdgeBR[146] = 8;
  isoBandEdgeBL[146] = isoBandEdgeTR[146] = 7;
  isoBandEdgeRB[6] = isoBandEdgeLT[6] = 15;
  isoBandEdgeBR[6] = isoBandEdgeLB[6] = 16;
  isoBandEdgeRB[164] = isoBandEdgeLT[164] = 15;
  isoBandEdgeBR[164] = isoBandEdgeLB[164] = 16;
  isoBandEdgeBL[129] = isoBandEdgeTR[129] = 7;
  isoBandEdgeLB[129] = isoBandEdgeTL[129] = 20;
  isoBandEdgeBL[41] = isoBandEdgeTR[41] = 7;
  isoBandEdgeLB[41] = isoBandEdgeTL[41] = 20;
  isoBandEdgeBR[66] = isoBandEdgeTL[66] = 2;
  isoBandEdgeBL[66] = isoBandEdgeLT[66] = 19;
  isoBandEdgeBR[104] = isoBandEdgeTL[104] = 2;
  isoBandEdgeBL[104] = isoBandEdgeLT[104] = 19;
  isoBandEdgeRT[144] = isoBandEdgeLB[144] = 10;
  isoBandEdgeLT[144] = isoBandEdgeTR[144] = 23;
  isoBandEdgeRT[26] = isoBandEdgeLB[26] = 10;
  isoBandEdgeLT[26] = isoBandEdgeTR[26] = 23;
  isoBandEdgeRB[36] = isoBandEdgeTR[36] = 5;
  isoBandEdgeBR[36] = isoBandEdgeTL[36] = 2;
  isoBandEdgeRB[134] = isoBandEdgeTR[134] = 5;
  isoBandEdgeBR[134] = isoBandEdgeTL[134] = 2;
  isoBandEdgeRT[9] = isoBandEdgeLB[9] = 10;
  isoBandEdgeRB[9] = isoBandEdgeBL[9] = 13;
  isoBandEdgeRT[161] = isoBandEdgeLB[161] = 10;
  isoBandEdgeRB[161] = isoBandEdgeBL[161] = 13;
  isoBandEdgeRB[37] = isoBandEdgeTR[37] = 5;
  isoBandEdgeLB[37] = isoBandEdgeTL[37] = 20;
  isoBandEdgeRB[133] = isoBandEdgeTR[133] = 5;
  isoBandEdgeLB[133] = isoBandEdgeTL[133] = 20;
  isoBandEdgeBR[148] = isoBandEdgeLB[148] = 16;
  isoBandEdgeLT[148] = isoBandEdgeTR[148] = 23;
  isoBandEdgeBR[22] = isoBandEdgeLB[22] = 16;
  isoBandEdgeLT[22] = isoBandEdgeTR[22] = 23;
  isoBandEdgeRT[82] = isoBandEdgeBR[82] = 8;
  isoBandEdgeBL[82] = isoBandEdgeLT[82] = 19;
  isoBandEdgeRT[88] = isoBandEdgeBR[88] = 8;
  isoBandEdgeBL[88] = isoBandEdgeLT[88] = 19;
  isoBandEdgeRT[73] = isoBandEdgeTL[73] = 0;
  isoBandEdgeRB[73] = isoBandEdgeBL[73] = 13;
  isoBandEdgeRT[97] = isoBandEdgeTL[97] = 0;
  isoBandEdgeRB[97] = isoBandEdgeBL[97] = 13;
  isoBandEdgeRT[145] = isoBandEdgeBL[145] = 9;
  isoBandEdgeLB[145] = isoBandEdgeTR[145] = 21;
  isoBandEdgeRT[25] = isoBandEdgeBL[25] = 9;
  isoBandEdgeLB[25] = isoBandEdgeTR[25] = 21;
  isoBandEdgeRB[70] = isoBandEdgeTL[70] = 1;
  isoBandEdgeBR[70] = isoBandEdgeLT[70] = 17;
  isoBandEdgeRB[100] = isoBandEdgeTL[100] = 1;
  isoBandEdgeBR[100] = isoBandEdgeLT[100] = 17;
  isoBandEdgeRT[34] = isoBandEdgeBL[34] = 9;
  isoBandEdgeRB[34] = isoBandEdgeBR[34] = 12;
  isoBandEdgeLB[34] = isoBandEdgeTR[34] = 21;
  isoBandEdgeLT[34] = isoBandEdgeTL[34] = 22;
  isoBandEdgeRT[136] = isoBandEdgeTR[136] = 4;
  isoBandEdgeRB[136] = isoBandEdgeTL[136] = 1;
  isoBandEdgeBR[136] = isoBandEdgeLT[136] = 17;
  isoBandEdgeBL[136] = isoBandEdgeLB[136] = 18;
  isoBandEdgeRT[35] = isoBandEdgeTR[35] = 4;
  isoBandEdgeRB[35] = isoBandEdgeBR[35] = 12;
  isoBandEdgeBL[35] = isoBandEdgeLB[35] = 18;
  isoBandEdgeLT[35] = isoBandEdgeTL[35] = 22;
  isoBandEdgeRT[153] = isoBandEdgeTR[153] = 4;
  isoBandEdgeBL[153] = isoBandEdgeLB[153] = 18;
  isoBandEdgeRB[102] = isoBandEdgeBR[102] = 12;
  isoBandEdgeLT[102] = isoBandEdgeTL[102] = 22;
  isoBandEdgeRT[155] = isoBandEdgeBL[155] = 9;
  isoBandEdgeLB[155] = isoBandEdgeTR[155] = 23;
  isoBandEdgeRB[103] = isoBandEdgeTL[103] = 1;
  isoBandEdgeBR[103] = isoBandEdgeLT[103] = 17;
  isoBandEdgeRT[152] = isoBandEdgeTR[152] = 4;
  isoBandEdgeBR[152] = isoBandEdgeLT[152] = 17;
  isoBandEdgeBL[152] = isoBandEdgeLB[152] = 18;
  isoBandEdgeRT[156] = isoBandEdgeBR[156] = 8;
  isoBandEdgeBL[156] = isoBandEdgeLB[156] = 18;
  isoBandEdgeLT[156] = isoBandEdgeTR[156] = 23;
  isoBandEdgeRT[137] = isoBandEdgeTR[137] = 4;
  isoBandEdgeRB[137] = isoBandEdgeTL[137] = 1;
  isoBandEdgeBL[137] = isoBandEdgeLB[137] = 18;
  isoBandEdgeRT[139] = isoBandEdgeTR[139] = 4;
  isoBandEdgeRB[139] = isoBandEdgeBL[139] = 13;
  isoBandEdgeLB[139] = isoBandEdgeTL[139] = 20;
  isoBandEdgeRT[98] = isoBandEdgeBL[98] = 9;
  isoBandEdgeRB[98] = isoBandEdgeBR[98] = 12;
  isoBandEdgeLT[98] = isoBandEdgeTL[98] = 22;
  isoBandEdgeRT[99] = isoBandEdgeTL[99] = 0;
  isoBandEdgeRB[99] = isoBandEdgeBR[99] = 12;
  isoBandEdgeBL[99] = isoBandEdgeLT[99] = 19;
  isoBandEdgeRB[38] = isoBandEdgeBR[38] = 12;
  isoBandEdgeLB[38] = isoBandEdgeTR[38] = 21;
  isoBandEdgeLT[38] = isoBandEdgeTL[38] = 22;
  isoBandEdgeRB[39] = isoBandEdgeTR[39] = 5;
  isoBandEdgeBR[39] = isoBandEdgeLB[39] = 16;
  isoBandEdgeLT[39] = isoBandEdgeTL[39] = 22;
  var polygon_table = [];
  polygon_table[1] = polygon_table[169] = p00;
  polygon_table[4] = polygon_table[166] = p01;
  polygon_table[16] = polygon_table[154] = p02;
  polygon_table[64] = polygon_table[106] = p03;
  polygon_table[168] = polygon_table[2] = p04;
  polygon_table[162] = polygon_table[8] = p05;
  polygon_table[138] = polygon_table[32] = p06;
  polygon_table[42] = polygon_table[128] = p07;
  polygon_table[5] = polygon_table[165] = p08;
  polygon_table[20] = polygon_table[150] = p09;
  polygon_table[80] = polygon_table[90] = p10;
  polygon_table[65] = polygon_table[105] = p11;
  polygon_table[160] = polygon_table[10] = p12;
  polygon_table[130] = polygon_table[40] = p13;
  polygon_table[85] = p14;
  polygon_table[101] = polygon_table[69] = p15;
  polygon_table[149] = polygon_table[21] = p16;
  polygon_table[86] = polygon_table[84] = p17;
  polygon_table[89] = polygon_table[81] = p18;
  polygon_table[96] = polygon_table[74] = p19;
  polygon_table[24] = polygon_table[146] = p20;
  polygon_table[6] = polygon_table[164] = p21;
  polygon_table[129] = polygon_table[41] = p22;
  polygon_table[66] = polygon_table[104] = p23;
  polygon_table[144] = polygon_table[26] = p24;
  polygon_table[36] = polygon_table[134] = p25;
  polygon_table[9] = polygon_table[161] = p26;
  polygon_table[37] = polygon_table[133] = p27;
  polygon_table[148] = polygon_table[22] = p28;
  polygon_table[82] = polygon_table[88] = p29;
  polygon_table[73] = polygon_table[97] = p30;
  polygon_table[145] = polygon_table[25] = p31;
  polygon_table[70] = polygon_table[100] = p32;
  polygon_table[34] = function(c) {
    return [p07(c), p05(c)];
  };
  polygon_table[35] = p33;
  polygon_table[136] = function(c) {
    return [p06(c), p04(c)];
  };
  polygon_table[153] = function(c) {
    return [p02(c), p00(c)];
  };
  polygon_table[102] = function(c) {
    return [p01(c), p03(c)];
  };
  polygon_table[155] = p34;
  polygon_table[103] = p35;
  polygon_table[152] = function(c) {
    return [p02(c), p04(c)];
  };
  polygon_table[156] = p36;
  polygon_table[137] = function(c) {
    return [p06(c), p00(c)];
  };
  polygon_table[139] = p37;
  polygon_table[98] = function(c) {
    return [p05(c), p03(c)];
  };
  polygon_table[99] = p38;
  polygon_table[38] = function(c) {
    return [p01(c), p07(c)];
  };
  polygon_table[39] = p39;

  // node_modules/@turf/polygonize/dist/es/lib/util.js
  function mathSign(x2) {
    return (x2 > 0) - (x2 < 0) || +x2;
  }
  function orientationIndex(p1, p2, q) {
    var dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1], dx2 = q[0] - p2[0], dy2 = q[1] - p2[1];
    return mathSign(dx1 * dy2 - dx2 * dy1);
  }
  function envelopeIsEqual(env1, env2) {
    var envX1 = env1.geometry.coordinates[0].map(function(c) {
      return c[0];
    }), envY1 = env1.geometry.coordinates[0].map(function(c) {
      return c[1];
    }), envX2 = env2.geometry.coordinates[0].map(function(c) {
      return c[0];
    }), envY2 = env2.geometry.coordinates[0].map(function(c) {
      return c[1];
    });
    return Math.max.apply(null, envX1) === Math.max.apply(null, envX2) && Math.max.apply(null, envY1) === Math.max.apply(null, envY2) && Math.min.apply(null, envX1) === Math.min.apply(null, envX2) && Math.min.apply(null, envY1) === Math.min.apply(null, envY2);
  }
  function envelopeContains(self2, env) {
    return env.geometry.coordinates[0].every(function(c) {
      return booleanPointInPolygon(point(c), self2);
    });
  }
  function coordinatesEqual(coord1, coord2) {
    return coord1[0] === coord2[0] && coord1[1] === coord2[1];
  }

  // node_modules/@turf/polygonize/dist/es/lib/Node.js
  var Node = (
    /** @class */
    function() {
      function Node2(coordinates) {
        this.id = Node2.buildId(coordinates);
        this.coordinates = coordinates;
        this.innerEdges = [];
        this.outerEdges = [];
        this.outerEdgesSorted = false;
      }
      Node2.buildId = function(coordinates) {
        return coordinates.join(",");
      };
      Node2.prototype.removeInnerEdge = function(edge) {
        this.innerEdges = this.innerEdges.filter(function(e) {
          return e.from.id !== edge.from.id;
        });
      };
      Node2.prototype.removeOuterEdge = function(edge) {
        this.outerEdges = this.outerEdges.filter(function(e) {
          return e.to.id !== edge.to.id;
        });
      };
      Node2.prototype.addOuterEdge = function(edge) {
        this.outerEdges.push(edge);
        this.outerEdgesSorted = false;
      };
      Node2.prototype.sortOuterEdges = function() {
        var _this = this;
        if (!this.outerEdgesSorted) {
          this.outerEdges.sort(function(a, b) {
            var aNode = a.to, bNode = b.to;
            if (aNode.coordinates[0] - _this.coordinates[0] >= 0 && bNode.coordinates[0] - _this.coordinates[0] < 0)
              return 1;
            if (aNode.coordinates[0] - _this.coordinates[0] < 0 && bNode.coordinates[0] - _this.coordinates[0] >= 0)
              return -1;
            if (aNode.coordinates[0] - _this.coordinates[0] === 0 && bNode.coordinates[0] - _this.coordinates[0] === 0) {
              if (aNode.coordinates[1] - _this.coordinates[1] >= 0 || bNode.coordinates[1] - _this.coordinates[1] >= 0)
                return aNode.coordinates[1] - bNode.coordinates[1];
              return bNode.coordinates[1] - aNode.coordinates[1];
            }
            var det = orientationIndex(_this.coordinates, aNode.coordinates, bNode.coordinates);
            if (det < 0)
              return 1;
            if (det > 0)
              return -1;
            var d1 = Math.pow(aNode.coordinates[0] - _this.coordinates[0], 2) + Math.pow(aNode.coordinates[1] - _this.coordinates[1], 2), d2 = Math.pow(bNode.coordinates[0] - _this.coordinates[0], 2) + Math.pow(bNode.coordinates[1] - _this.coordinates[1], 2);
            return d1 - d2;
          });
          this.outerEdgesSorted = true;
        }
      };
      Node2.prototype.getOuterEdges = function() {
        this.sortOuterEdges();
        return this.outerEdges;
      };
      Node2.prototype.getOuterEdge = function(i) {
        this.sortOuterEdges();
        return this.outerEdges[i];
      };
      Node2.prototype.addInnerEdge = function(edge) {
        this.innerEdges.push(edge);
      };
      return Node2;
    }()
  );
  var Node_default = Node;

  // node_modules/@turf/polygonize/dist/es/lib/Edge.js
  var Edge = (
    /** @class */
    function() {
      function Edge2(from, to) {
        this.from = from;
        this.to = to;
        this.next = void 0;
        this.label = void 0;
        this.symetric = void 0;
        this.ring = void 0;
        this.from.addOuterEdge(this);
        this.to.addInnerEdge(this);
      }
      Edge2.prototype.getSymetric = function() {
        if (!this.symetric) {
          this.symetric = new Edge2(this.to, this.from);
          this.symetric.symetric = this;
        }
        return this.symetric;
      };
      Edge2.prototype.deleteEdge = function() {
        this.from.removeOuterEdge(this);
        this.to.removeInnerEdge(this);
      };
      Edge2.prototype.isEqual = function(edge) {
        return this.from.id === edge.from.id && this.to.id === edge.to.id;
      };
      Edge2.prototype.toString = function() {
        return "Edge { " + this.from.id + " -> " + this.to.id + " }";
      };
      Edge2.prototype.toLineString = function() {
        return lineString([this.from.coordinates, this.to.coordinates]);
      };
      Edge2.prototype.compareTo = function(edge) {
        return orientationIndex(edge.from.coordinates, edge.to.coordinates, this.to.coordinates);
      };
      return Edge2;
    }()
  );
  var Edge_default = Edge;

  // node_modules/@turf/polygonize/dist/es/lib/EdgeRing.js
  var EdgeRing = (
    /** @class */
    function() {
      function EdgeRing2() {
        this.edges = [];
        this.polygon = void 0;
        this.envelope = void 0;
      }
      EdgeRing2.prototype.push = function(edge) {
        this.edges.push(edge);
        this.polygon = this.envelope = void 0;
      };
      EdgeRing2.prototype.get = function(i) {
        return this.edges[i];
      };
      Object.defineProperty(EdgeRing2.prototype, "length", {
        /**
         * Getter of length property.
         *
         * @memberof EdgeRing
         * @returns {number} - Length of the edge ring.
         */
        get: function() {
          return this.edges.length;
        },
        enumerable: true,
        configurable: true
      });
      EdgeRing2.prototype.forEach = function(f) {
        this.edges.forEach(f);
      };
      EdgeRing2.prototype.map = function(f) {
        return this.edges.map(f);
      };
      EdgeRing2.prototype.some = function(f) {
        return this.edges.some(f);
      };
      EdgeRing2.prototype.isValid = function() {
        return true;
      };
      EdgeRing2.prototype.isHole = function() {
        var _this = this;
        var hiIndex = this.edges.reduce(function(high, edge, i) {
          if (edge.from.coordinates[1] > _this.edges[high].from.coordinates[1])
            high = i;
          return high;
        }, 0), iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1, iNext = (hiIndex + 1) % this.length, disc = orientationIndex(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);
        if (disc === 0)
          return this.edges[iPrev].from.coordinates[0] > this.edges[iNext].from.coordinates[0];
        return disc > 0;
      };
      EdgeRing2.prototype.toMultiPoint = function() {
        return multiPoint(this.edges.map(function(edge) {
          return edge.from.coordinates;
        }));
      };
      EdgeRing2.prototype.toPolygon = function() {
        if (this.polygon)
          return this.polygon;
        var coordinates = this.edges.map(function(edge) {
          return edge.from.coordinates;
        });
        coordinates.push(this.edges[0].from.coordinates);
        return this.polygon = polygon([coordinates]);
      };
      EdgeRing2.prototype.getEnvelope = function() {
        if (this.envelope)
          return this.envelope;
        return this.envelope = es_default5(this.toPolygon());
      };
      EdgeRing2.findEdgeRingContaining = function(testEdgeRing, shellList) {
        var testEnvelope = testEdgeRing.getEnvelope();
        var minEnvelope, minShell;
        shellList.forEach(function(shell) {
          var tryEnvelope = shell.getEnvelope();
          if (minShell)
            minEnvelope = minShell.getEnvelope();
          if (envelopeIsEqual(tryEnvelope, testEnvelope))
            return;
          if (envelopeContains(tryEnvelope, testEnvelope)) {
            var testEdgeRingCoordinates = testEdgeRing.map(function(edge) {
              return edge.from.coordinates;
            });
            var testPoint = void 0;
            var _loop_1 = function(pt2) {
              if (!shell.some(function(edge) {
                return coordinatesEqual(pt2, edge.from.coordinates);
              })) {
                testPoint = pt2;
              }
            };
            for (var _i = 0, testEdgeRingCoordinates_1 = testEdgeRingCoordinates; _i < testEdgeRingCoordinates_1.length; _i++) {
              var pt = testEdgeRingCoordinates_1[_i];
              _loop_1(pt);
            }
            if (testPoint && shell.inside(point(testPoint))) {
              if (!minShell || envelopeContains(minEnvelope, tryEnvelope))
                minShell = shell;
            }
          }
        });
        return minShell;
      };
      EdgeRing2.prototype.inside = function(pt) {
        return booleanPointInPolygon(pt, this.toPolygon());
      };
      return EdgeRing2;
    }()
  );
  var EdgeRing_default = EdgeRing;

  // node_modules/@turf/polygonize/dist/es/lib/Graph.js
  function validateGeoJson(geoJson) {
    if (!geoJson)
      throw new Error("No geojson passed");
    if (geoJson.type !== "FeatureCollection" && geoJson.type !== "GeometryCollection" && geoJson.type !== "MultiLineString" && geoJson.type !== "LineString" && geoJson.type !== "Feature")
      throw new Error("Invalid input type '" + geoJson.type + "'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature");
  }
  var Graph = (
    /** @class */
    function() {
      function Graph3() {
        this.edges = [];
        this.nodes = {};
      }
      Graph3.fromGeoJson = function(geoJson) {
        validateGeoJson(geoJson);
        var graph = new Graph3();
        flattenEach(geoJson, function(feature2) {
          featureOf(feature2, "LineString", "Graph::fromGeoJson");
          coordReduce(feature2, function(prev, cur) {
            if (prev) {
              var start = graph.getNode(prev), end = graph.getNode(cur);
              graph.addEdge(start, end);
            }
            return cur;
          });
        });
        return graph;
      };
      Graph3.prototype.getNode = function(coordinates) {
        var id = Node_default.buildId(coordinates);
        var node = this.nodes[id];
        if (!node)
          node = this.nodes[id] = new Node_default(coordinates);
        return node;
      };
      Graph3.prototype.addEdge = function(from, to) {
        var edge = new Edge_default(from, to), symetricEdge = edge.getSymetric();
        this.edges.push(edge);
        this.edges.push(symetricEdge);
      };
      Graph3.prototype.deleteDangles = function() {
        var _this = this;
        Object.keys(this.nodes).map(function(id) {
          return _this.nodes[id];
        }).forEach(function(node) {
          return _this._removeIfDangle(node);
        });
      };
      Graph3.prototype._removeIfDangle = function(node) {
        var _this = this;
        if (node.innerEdges.length <= 1) {
          var outerNodes = node.getOuterEdges().map(function(e) {
            return e.to;
          });
          this.removeNode(node);
          outerNodes.forEach(function(n) {
            return _this._removeIfDangle(n);
          });
        }
      };
      Graph3.prototype.deleteCutEdges = function() {
        var _this = this;
        this._computeNextCWEdges();
        this._findLabeledEdgeRings();
        this.edges.forEach(function(edge) {
          if (edge.label === edge.symetric.label) {
            _this.removeEdge(edge.symetric);
            _this.removeEdge(edge);
          }
        });
      };
      Graph3.prototype._computeNextCWEdges = function(node) {
        var _this = this;
        if (typeof node === "undefined") {
          Object.keys(this.nodes).forEach(function(id) {
            return _this._computeNextCWEdges(_this.nodes[id]);
          });
        } else {
          node.getOuterEdges().forEach(function(edge, i) {
            node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;
          });
        }
      };
      Graph3.prototype._computeNextCCWEdges = function(node, label) {
        var edges2 = node.getOuterEdges();
        var firstOutDE, prevInDE;
        for (var i = edges2.length - 1; i >= 0; --i) {
          var de = edges2[i], sym = de.symetric, outDE = void 0, inDE = void 0;
          if (de.label === label)
            outDE = de;
          if (sym.label === label)
            inDE = sym;
          if (!outDE || !inDE)
            continue;
          if (inDE)
            prevInDE = inDE;
          if (outDE) {
            if (prevInDE) {
              prevInDE.next = outDE;
              prevInDE = void 0;
            }
            if (!firstOutDE)
              firstOutDE = outDE;
          }
        }
        if (prevInDE)
          prevInDE.next = firstOutDE;
      };
      Graph3.prototype._findLabeledEdgeRings = function() {
        var edgeRingStarts = [];
        var label = 0;
        this.edges.forEach(function(edge) {
          if (edge.label >= 0)
            return;
          edgeRingStarts.push(edge);
          var e = edge;
          do {
            e.label = label;
            e = e.next;
          } while (!edge.isEqual(e));
          label++;
        });
        return edgeRingStarts;
      };
      Graph3.prototype.getEdgeRings = function() {
        var _this = this;
        this._computeNextCWEdges();
        this.edges.forEach(function(edge) {
          edge.label = void 0;
        });
        this._findLabeledEdgeRings().forEach(function(edge) {
          _this._findIntersectionNodes(edge).forEach(function(node) {
            _this._computeNextCCWEdges(node, edge.label);
          });
        });
        var edgeRingList = [];
        this.edges.forEach(function(edge) {
          if (edge.ring)
            return;
          edgeRingList.push(_this._findEdgeRing(edge));
        });
        return edgeRingList;
      };
      Graph3.prototype._findIntersectionNodes = function(startEdge) {
        var intersectionNodes = [];
        var edge = startEdge;
        var _loop_1 = function() {
          var degree = 0;
          edge.from.getOuterEdges().forEach(function(e) {
            if (e.label === startEdge.label)
              ++degree;
          });
          if (degree > 1)
            intersectionNodes.push(edge.from);
          edge = edge.next;
        };
        do {
          _loop_1();
        } while (!startEdge.isEqual(edge));
        return intersectionNodes;
      };
      Graph3.prototype._findEdgeRing = function(startEdge) {
        var edge = startEdge;
        var edgeRing = new EdgeRing_default();
        do {
          edgeRing.push(edge);
          edge.ring = edgeRing;
          edge = edge.next;
        } while (!startEdge.isEqual(edge));
        return edgeRing;
      };
      Graph3.prototype.removeNode = function(node) {
        var _this = this;
        node.getOuterEdges().forEach(function(edge) {
          return _this.removeEdge(edge);
        });
        node.innerEdges.forEach(function(edge) {
          return _this.removeEdge(edge);
        });
        delete this.nodes[node.id];
      };
      Graph3.prototype.removeEdge = function(edge) {
        this.edges = this.edges.filter(function(e) {
          return !e.isEqual(edge);
        });
        edge.deleteEdge();
      };
      return Graph3;
    }()
  );

  // node_modules/@turf/boolean-overlap/dist/es/index.js
  var import_geojson_equality = __toESM(require_geojson_equality(), 1);

  // node_modules/@turf/boolean-equal/dist/es/index.js
  var import_geojson_equality2 = __toESM(require_geojson_equality(), 1);

  // node_modules/@turf/clusters-dbscan/dist/es/index.js
  var import_density_clustering = __toESM(require_lib(), 1);

  // node_modules/@turf/clusters-kmeans/dist/es/index.js
  var import_skmeans = __toESM(require_main(), 1);

  // node_modules/@turf/shortest-path/dist/es/index.js
  function pathTo(node) {
    var curr = node, path = [];
    while (curr.parent) {
      path.unshift(curr);
      curr = curr.parent;
    }
    return path;
  }
  function getHeap() {
    return new BinaryHeap(function(node) {
      return node.f;
    });
  }
  var astar = {
    /**
     * Perform an A* Search on a graph given a start and end node.
     *
     * @private
     * @memberof astar
     * @param {Graph} graph Graph
     * @param {GridNode} start Start
     * @param {GridNode} end End
     * @param {Object} [options] Options
     * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.
     * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).
     * @returns {Object} Search
     */
    search: function(graph, start, end, options) {
      graph.cleanDirty();
      options = options || {};
      var heuristic = options.heuristic || astar.heuristics.manhattan, closest = options.closest || false;
      var openHeap = getHeap(), closestNode = start;
      start.h = heuristic(start, end);
      openHeap.push(start);
      while (openHeap.size() > 0) {
        var currentNode = openHeap.pop();
        if (currentNode === end) {
          return pathTo(currentNode);
        }
        currentNode.closed = true;
        var neighbors = graph.neighbors(currentNode);
        for (var i = 0, il = neighbors.length; i < il; ++i) {
          var neighbor = neighbors[i];
          if (neighbor.closed || neighbor.isWall()) {
            continue;
          }
          var gScore = currentNode.g + neighbor.getCost(currentNode), beenVisited = neighbor.visited;
          if (!beenVisited || gScore < neighbor.g) {
            neighbor.visited = true;
            neighbor.parent = currentNode;
            neighbor.h = neighbor.h || heuristic(neighbor, end);
            neighbor.g = gScore;
            neighbor.f = neighbor.g + neighbor.h;
            graph.markDirty(neighbor);
            if (closest) {
              if (neighbor.h < closestNode.h || neighbor.h === closestNode.h && neighbor.g < closestNode.g) {
                closestNode = neighbor;
              }
            }
            if (!beenVisited) {
              openHeap.push(neighbor);
            } else {
              openHeap.rescoreElement(neighbor);
            }
          }
        }
      }
      if (closest) {
        return pathTo(closestNode);
      }
      return [];
    },
    // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html
    heuristics: {
      manhattan: function(pos0, pos1) {
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return d1 + d2;
      },
      diagonal: function(pos0, pos1) {
        var D = 1;
        var D2 = Math.sqrt(2);
        var d1 = Math.abs(pos1.x - pos0.x);
        var d2 = Math.abs(pos1.y - pos0.y);
        return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);
      }
    },
    cleanNode: function(node) {
      node.f = 0;
      node.g = 0;
      node.h = 0;
      node.visited = false;
      node.closed = false;
      node.parent = null;
    }
  };
  function Graph2(gridIn, options) {
    options = options || {};
    this.nodes = [];
    this.diagonal = !!options.diagonal;
    this.grid = [];
    for (var x2 = 0; x2 < gridIn.length; x2++) {
      this.grid[x2] = [];
      for (var y2 = 0, row = gridIn[x2]; y2 < row.length; y2++) {
        var node = new GridNode(x2, y2, row[y2]);
        this.grid[x2][y2] = node;
        this.nodes.push(node);
      }
    }
    this.init();
  }
  Graph2.prototype.init = function() {
    this.dirtyNodes = [];
    for (var i = 0; i < this.nodes.length; i++) {
      astar.cleanNode(this.nodes[i]);
    }
  };
  Graph2.prototype.cleanDirty = function() {
    for (var i = 0; i < this.dirtyNodes.length; i++) {
      astar.cleanNode(this.dirtyNodes[i]);
    }
    this.dirtyNodes = [];
  };
  Graph2.prototype.markDirty = function(node) {
    this.dirtyNodes.push(node);
  };
  Graph2.prototype.neighbors = function(node) {
    var ret = [], x2 = node.x, y2 = node.y, grid = this.grid;
    if (grid[x2 - 1] && grid[x2 - 1][y2]) {
      ret.push(grid[x2 - 1][y2]);
    }
    if (grid[x2 + 1] && grid[x2 + 1][y2]) {
      ret.push(grid[x2 + 1][y2]);
    }
    if (grid[x2] && grid[x2][y2 - 1]) {
      ret.push(grid[x2][y2 - 1]);
    }
    if (grid[x2] && grid[x2][y2 + 1]) {
      ret.push(grid[x2][y2 + 1]);
    }
    if (this.diagonal) {
      if (grid[x2 - 1] && grid[x2 - 1][y2 - 1]) {
        ret.push(grid[x2 - 1][y2 - 1]);
      }
      if (grid[x2 + 1] && grid[x2 + 1][y2 - 1]) {
        ret.push(grid[x2 + 1][y2 - 1]);
      }
      if (grid[x2 - 1] && grid[x2 - 1][y2 + 1]) {
        ret.push(grid[x2 - 1][y2 + 1]);
      }
      if (grid[x2 + 1] && grid[x2 + 1][y2 + 1]) {
        ret.push(grid[x2 + 1][y2 + 1]);
      }
    }
    return ret;
  };
  Graph2.prototype.toString = function() {
    var graphString = [], nodes = this.grid, rowDebug, row, y2, l;
    for (var x2 = 0, len = nodes.length; x2 < len; x2++) {
      rowDebug = [];
      row = nodes[x2];
      for (y2 = 0, l = row.length; y2 < l; y2++) {
        rowDebug.push(row[y2].weight);
      }
      graphString.push(rowDebug.join(" "));
    }
    return graphString.join("\n");
  };
  function GridNode(x2, y2, weight) {
    this.x = x2;
    this.y = y2;
    this.weight = weight;
  }
  GridNode.prototype.toString = function() {
    return "[" + this.x + " " + this.y + "]";
  };
  GridNode.prototype.getCost = function(fromNeighbor) {
    if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {
      return this.weight * 1.41421;
    }
    return this.weight;
  };
  GridNode.prototype.isWall = function() {
    return this.weight === 0;
  };
  function BinaryHeap(scoreFunction) {
    this.content = [];
    this.scoreFunction = scoreFunction;
  }
  BinaryHeap.prototype = {
    push: function(element) {
      this.content.push(element);
      this.sinkDown(this.content.length - 1);
    },
    pop: function() {
      var result = this.content[0];
      var end = this.content.pop();
      if (this.content.length > 0) {
        this.content[0] = end;
        this.bubbleUp(0);
      }
      return result;
    },
    remove: function(node) {
      var i = this.content.indexOf(node);
      var end = this.content.pop();
      if (i !== this.content.length - 1) {
        this.content[i] = end;
        if (this.scoreFunction(end) < this.scoreFunction(node)) {
          this.sinkDown(i);
        } else {
          this.bubbleUp(i);
        }
      }
    },
    size: function() {
      return this.content.length;
    },
    rescoreElement: function(node) {
      this.sinkDown(this.content.indexOf(node));
    },
    sinkDown: function(n) {
      var element = this.content[n];
      while (n > 0) {
        var parentN = (n + 1 >> 1) - 1, parent = this.content[parentN];
        if (this.scoreFunction(element) < this.scoreFunction(parent)) {
          this.content[parentN] = element;
          this.content[n] = parent;
          n = parentN;
        } else {
          break;
        }
      }
    },
    bubbleUp: function(n) {
      var length2 = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);
      while (true) {
        var child2N = n + 1 << 1, child1N = child2N - 1;
        var swap = null, child1Score;
        if (child1N < length2) {
          var child1 = this.content[child1N];
          child1Score = this.scoreFunction(child1);
          if (child1Score < elemScore) {
            swap = child1N;
          }
        }
        if (child2N < length2) {
          var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);
          if (child2Score < (swap === null ? elemScore : child1Score)) {
            swap = child2N;
          }
        }
        if (swap !== null) {
          this.content[n] = this.content[swap];
          this.content[swap] = element;
          n = swap;
        } else {
          break;
        }
      }
    }
  };

  // node_modules/d3-voronoi/src/RedBlackTree.js
  function RedBlackTree() {
    this._ = null;
  }
  function RedBlackNode(node) {
    node.U = // parent node
    node.C = // color - true for red, false for black
    node.L = // left node
    node.R = // right node
    node.P = // previous node
    node.N = null;
  }
  RedBlackTree.prototype = {
    constructor: RedBlackTree,
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N)
          after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L)
            after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = RedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              RedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            RedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              RedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            RedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N)
        node.N.P = node.P;
      if (node.P)
        node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left)
        next = right;
      else if (!right)
        next = left;
      else
        next = RedBlackFirst(right);
      if (parent) {
        if (parent.L === node)
          parent.L = next;
        else
          parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node)
        node.U = parent;
      if (red)
        return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._)
          break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            RedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              RedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            RedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            RedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              RedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            RedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node)
        node.C = false;
    }
  };
  function RedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p)
        parent.L = q;
      else
        parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R)
      p.R.U = p;
    q.L = p;
  }
  function RedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p)
        parent.L = q;
      else
        parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L)
      p.L.U = p;
    q.R = p;
  }
  function RedBlackFirst(node) {
    while (node.L)
      node = node.L;
    return node;
  }
  var RedBlackTree_default = RedBlackTree;

  // node_modules/d3-voronoi/src/Edge.js
  function createEdge(left, right, v0, v1) {
    var edge = [null, null], index = edges.push(edge) - 1;
    edge.left = left;
    edge.right = right;
    if (v0)
      setEdgeEnd(edge, left, right, v0);
    if (v1)
      setEdgeEnd(edge, right, left, v1);
    cells[left.index].halfedges.push(index);
    cells[right.index].halfedges.push(index);
    return edge;
  }
  function createBorderEdge(left, v0, v1) {
    var edge = [v0, v1];
    edge.left = left;
    return edge;
  }
  function setEdgeEnd(edge, left, right, vertex) {
    if (!edge[0] && !edge[1]) {
      edge[0] = vertex;
      edge.left = left;
      edge.right = right;
    } else if (edge.left === right) {
      edge[1] = vertex;
    } else {
      edge[0] = vertex;
    }
  }
  function clipEdge(edge, x02, y0, x12, y1) {
    var a = edge[0], b = edge[1], ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
    r = x02 - ax;
    if (!dx && r > 0)
      return;
    r /= dx;
    if (dx < 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    } else if (dx > 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    }
    r = x12 - ax;
    if (!dx && r < 0)
      return;
    r /= dx;
    if (dx < 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    } else if (dx > 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    }
    r = y0 - ay;
    if (!dy && r > 0)
      return;
    r /= dy;
    if (dy < 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    } else if (dy > 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    }
    r = y1 - ay;
    if (!dy && r < 0)
      return;
    r /= dy;
    if (dy < 0) {
      if (r > t1)
        return;
      if (r > t0)
        t0 = r;
    } else if (dy > 0) {
      if (r < t0)
        return;
      if (r < t1)
        t1 = r;
    }
    if (!(t0 > 0) && !(t1 < 1))
      return true;
    if (t0 > 0)
      edge[0] = [ax + t0 * dx, ay + t0 * dy];
    if (t1 < 1)
      edge[1] = [ax + t1 * dx, ay + t1 * dy];
    return true;
  }
  function connectEdge(edge, x02, y0, x12, y1) {
    var v1 = edge[1];
    if (v1)
      return true;
    var v0 = edge[0], left = edge.left, right = edge.right, lx = left[0], ly = left[1], rx = right[0], ry = right[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x02 || fx >= x12)
        return;
      if (lx > rx) {
        if (!v0)
          v0 = [fx, y0];
        else if (v0[1] >= y1)
          return;
        v1 = [fx, y1];
      } else {
        if (!v0)
          v0 = [fx, y1];
        else if (v0[1] < y0)
          return;
        v1 = [fx, y0];
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!v0)
            v0 = [(y0 - fb) / fm, y0];
          else if (v0[1] >= y1)
            return;
          v1 = [(y1 - fb) / fm, y1];
        } else {
          if (!v0)
            v0 = [(y1 - fb) / fm, y1];
          else if (v0[1] < y0)
            return;
          v1 = [(y0 - fb) / fm, y0];
        }
      } else {
        if (ly < ry) {
          if (!v0)
            v0 = [x02, fm * x02 + fb];
          else if (v0[0] >= x12)
            return;
          v1 = [x12, fm * x12 + fb];
        } else {
          if (!v0)
            v0 = [x12, fm * x12 + fb];
          else if (v0[0] < x02)
            return;
          v1 = [x02, fm * x02 + fb];
        }
      }
    }
    edge[0] = v0;
    edge[1] = v1;
    return true;
  }
  function clipEdges(x02, y0, x12, y1) {
    var i = edges.length, edge;
    while (i--) {
      if (!connectEdge(edge = edges[i], x02, y0, x12, y1) || !clipEdge(edge, x02, y0, x12, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
        delete edges[i];
      }
    }
  }

  // node_modules/d3-voronoi/src/Cell.js
  function createCell(site) {
    return cells[site.index] = {
      site,
      halfedges: []
    };
  }
  function cellHalfedgeAngle(cell, edge) {
    var site = cell.site, va = edge.left, vb = edge.right;
    if (site === vb)
      vb = va, va = site;
    if (vb)
      return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
    if (site === va)
      va = edge[1], vb = edge[0];
    else
      va = edge[0], vb = edge[1];
    return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
  }
  function cellHalfedgeStart(cell, edge) {
    return edge[+(edge.left !== cell.site)];
  }
  function cellHalfedgeEnd(cell, edge) {
    return edge[+(edge.left === cell.site)];
  }
  function sortCellHalfedges() {
    for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
      if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
        var index = new Array(m), array2 = new Array(m);
        for (j = 0; j < m; ++j)
          index[j] = j, array2[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
        index.sort(function(i2, j2) {
          return array2[j2] - array2[i2];
        });
        for (j = 0; j < m; ++j)
          array2[j] = halfedges[index[j]];
        for (j = 0; j < m; ++j)
          halfedges[j] = array2[j];
      }
    }
  }
  function clipCells(x02, y0, x12, y1) {
    var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start, startX, startY, end, endX, endY, cover = true;
    for (iCell = 0; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        halfedges = cell.halfedges;
        iHalfedge = halfedges.length;
        while (iHalfedge--) {
          if (!edges[halfedges[iHalfedge]]) {
            halfedges.splice(iHalfedge, 1);
          }
        }
        iHalfedge = 0, nHalfedges = halfedges.length;
        while (iHalfedge < nHalfedges) {
          end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
          start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
          if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
            halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(
              site,
              end,
              Math.abs(endX - x02) < epsilon && y1 - endY > epsilon ? [x02, Math.abs(startX - x02) < epsilon ? startY : y1] : Math.abs(endY - y1) < epsilon && x12 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x12, y1] : Math.abs(endX - x12) < epsilon && endY - y0 > epsilon ? [x12, Math.abs(startX - x12) < epsilon ? startY : y0] : Math.abs(endY - y0) < epsilon && endX - x02 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x02, y0] : null
            )) - 1);
            ++nHalfedges;
          }
        }
        if (nHalfedges)
          cover = false;
      }
    }
    if (cover) {
      var dx, dy, d2, dc = Infinity;
      for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
        if (cell = cells[iCell]) {
          site = cell.site;
          dx = site[0] - x02;
          dy = site[1] - y0;
          d2 = dx * dx + dy * dy;
          if (d2 < dc)
            dc = d2, cover = cell;
        }
      }
      if (cover) {
        var v00 = [x02, y0], v01 = [x02, y1], v11 = [x12, y1], v10 = [x12, y0];
        cover.halfedges.push(
          edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
          edges.push(createBorderEdge(site, v01, v11)) - 1,
          edges.push(createBorderEdge(site, v11, v10)) - 1,
          edges.push(createBorderEdge(site, v10, v00)) - 1
        );
      }
    }
    for (iCell = 0; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        if (!cell.halfedges.length) {
          delete cells[iCell];
        }
      }
    }
  }

  // node_modules/d3-voronoi/src/Circle.js
  var circlePool = [];
  var firstCircle;
  function Circle() {
    RedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function attachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc)
      return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite)
      return;
    var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -epsilon2)
      return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x2 = (cy * ha - ay * hc) / d, y2 = (ax * hc - cx * ha) / d;
    var circle2 = circlePool.pop() || new Circle();
    circle2.arc = arc;
    circle2.site = cSite;
    circle2.x = x2 + bx;
    circle2.y = (circle2.cy = y2 + by) + Math.sqrt(x2 * x2 + y2 * y2);
    arc.circle = circle2;
    var before = null, node = circles._;
    while (node) {
      if (circle2.y < node.y || circle2.y === node.y && circle2.x <= node.x) {
        if (node.L)
          node = node.L;
        else {
          before = node.P;
          break;
        }
      } else {
        if (node.R)
          node = node.R;
        else {
          before = node;
          break;
        }
      }
    }
    circles.insert(before, circle2);
    if (!before)
      firstCircle = circle2;
  }
  function detachCircle(arc) {
    var circle2 = arc.circle;
    if (circle2) {
      if (!circle2.P)
        firstCircle = circle2.N;
      circles.remove(circle2);
      circlePool.push(circle2);
      RedBlackNode(circle2);
      arc.circle = null;
    }
  }

  // node_modules/d3-voronoi/src/Beach.js
  var beachPool = [];
  function Beach() {
    RedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function createBeach(site) {
    var beach = beachPool.pop() || new Beach();
    beach.site = site;
    return beach;
  }
  function detachBeach(beach) {
    detachCircle(beach);
    beaches.remove(beach);
    beachPool.push(beach);
    RedBlackNode(beach);
  }
  function removeBeach(beach) {
    var circle2 = beach.circle, x2 = circle2.x, y2 = circle2.cy, vertex = [x2, y2], previous = beach.P, next = beach.N, disappearing = [beach];
    detachBeach(beach);
    var lArc = previous;
    while (lArc.circle && Math.abs(x2 - lArc.circle.x) < epsilon && Math.abs(y2 - lArc.circle.cy) < epsilon) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      detachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    detachCircle(lArc);
    var rArc = next;
    while (rArc.circle && Math.abs(x2 - rArc.circle.x) < epsilon && Math.abs(y2 - rArc.circle.cy) < epsilon) {
      next = rArc.N;
      disappearing.push(rArc);
      detachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    detachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
    attachCircle(lArc);
    attachCircle(rArc);
  }
  function addBeach(site) {
    var x2 = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node = beaches._;
    while (node) {
      dxl = leftBreakPoint(node, directrix) - x2;
      if (dxl > epsilon)
        node = node.L;
      else {
        dxr = x2 - rightBreakPoint(node, directrix);
        if (dxr > epsilon) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -epsilon) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -epsilon) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    createCell(site);
    var newArc = createBeach(site);
    beaches.insert(lArc, newArc);
    if (!lArc && !rArc)
      return;
    if (lArc === rArc) {
      detachCircle(lArc);
      rArc = createBeach(lArc.site);
      beaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
      attachCircle(lArc);
      attachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = createEdge(lArc.site, newArc.site);
      return;
    }
    detachCircle(lArc);
    detachCircle(rArc);
    var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
    setEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = createEdge(lSite, site, null, vertex);
    rArc.edge = createEdge(site, rSite, null, vertex);
    attachCircle(lArc);
    attachCircle(rArc);
  }
  function leftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
    if (!pby2)
      return rfocx;
    var lArc = arc.P;
    if (!lArc)
      return -Infinity;
    site = lArc.site;
    var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;
    if (!plby2)
      return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2)
      return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function rightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc)
      return leftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site[1] === directrix ? site[0] : Infinity;
  }

  // node_modules/d3-voronoi/src/Diagram.js
  var epsilon = 1e-6;
  var epsilon2 = 1e-12;
  var beaches;
  var cells;
  var circles;
  var edges;
  function triangleArea(a, b, c) {
    return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
  }
  function lexicographic(a, b) {
    return b[1] - a[1] || b[0] - a[0];
  }
  function Diagram(sites, extent) {
    var site = sites.sort(lexicographic).pop(), x2, y2, circle2;
    edges = [];
    cells = new Array(sites.length);
    beaches = new RedBlackTree_default();
    circles = new RedBlackTree_default();
    while (true) {
      circle2 = firstCircle;
      if (site && (!circle2 || site[1] < circle2.y || site[1] === circle2.y && site[0] < circle2.x)) {
        if (site[0] !== x2 || site[1] !== y2) {
          addBeach(site);
          x2 = site[0], y2 = site[1];
        }
        site = sites.pop();
      } else if (circle2) {
        removeBeach(circle2.arc);
      } else {
        break;
      }
    }
    sortCellHalfedges();
    if (extent) {
      var x02 = +extent[0][0], y0 = +extent[0][1], x12 = +extent[1][0], y1 = +extent[1][1];
      clipEdges(x02, y0, x12, y1);
      clipCells(x02, y0, x12, y1);
    }
    this.edges = edges;
    this.cells = cells;
    beaches = circles = edges = cells = null;
  }
  Diagram.prototype = {
    constructor: Diagram,
    polygons: function() {
      var edges2 = this.edges;
      return this.cells.map(function(cell) {
        var polygon2 = cell.halfedges.map(function(i) {
          return cellHalfedgeStart(cell, edges2[i]);
        });
        polygon2.data = cell.site.data;
        return polygon2;
      });
    },
    triangles: function() {
      var triangles = [], edges2 = this.edges;
      this.cells.forEach(function(cell, i) {
        if (!(m = (halfedges = cell.halfedges).length))
          return;
        var site = cell.site, halfedges, j = -1, m, s0, e1 = edges2[halfedges[m - 1]], s1 = e1.left === site ? e1.right : e1.left;
        while (++j < m) {
          s0 = s1;
          e1 = edges2[halfedges[j]];
          s1 = e1.left === site ? e1.right : e1.left;
          if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
            triangles.push([site.data, s0.data, s1.data]);
          }
        }
      });
      return triangles;
    },
    links: function() {
      return this.edges.filter(function(edge) {
        return edge.right;
      }).map(function(edge) {
        return {
          source: edge.left.data,
          target: edge.right.data
        };
      });
    },
    find: function(x2, y2, radius) {
      var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;
      while (!(cell = that.cells[i1]))
        if (++i1 >= n)
          return null;
      var dx = x2 - cell.site[0], dy = y2 - cell.site[1], d2 = dx * dx + dy * dy;
      do {
        cell = that.cells[i0 = i1], i1 = null;
        cell.halfedges.forEach(function(e) {
          var edge = that.edges[e], v = edge.left;
          if ((v === cell.site || !v) && !(v = edge.right))
            return;
          var vx = x2 - v[0], vy = y2 - v[1], v2 = vx * vx + vy * vy;
          if (v2 < d2)
            d2 = v2, i1 = v.index;
        });
      } while (i1 !== null);
      that._found = i0;
      return radius == null || d2 <= radius * radius ? cell.site : null;
    }
  };

  // node_modules/@turf/difference/dist/es/index.js
  var import_polygon_clipping = __toESM(require_polygon_clipping_umd(), 1);

  // node_modules/@turf/buffer/dist/es/index.js
  var import_turf_jsts = __toESM(require_jsts_min(), 1);

  // node_modules/d3-geo/src/adder.js
  function adder_default() {
    return new Adder();
  }
  function Adder() {
    this.reset();
  }
  Adder.prototype = {
    constructor: Adder,
    reset: function() {
      this.s = // rounded value
      this.t = 0;
    },
    add: function(y2) {
      add(temp, y2, this.t);
      add(this, temp.s, this.s);
      if (this.s)
        this.t += temp.t;
      else
        this.s = temp.t;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var temp = new Adder();
  function add(adder, a, b) {
    var x2 = adder.s = a + b, bv = x2 - a, av = x2 - bv;
    adder.t = a - av + (b - bv);
  }

  // node_modules/d3-geo/src/math.js
  var epsilon3 = 1e-6;
  var pi = Math.PI;
  var halfPi = pi / 2;
  var quarterPi = pi / 4;
  var tau = pi * 2;
  var degrees = 180 / pi;
  var radians = pi / 180;
  var abs = Math.abs;
  var atan = Math.atan;
  var atan2 = Math.atan2;
  var cos = Math.cos;
  var exp = Math.exp;
  var log = Math.log;
  var sin = Math.sin;
  var sqrt = Math.sqrt;
  var tan = Math.tan;
  function acos(x2) {
    return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
  }
  function asin(x2) {
    return x2 > 1 ? halfPi : x2 < -1 ? -halfPi : Math.asin(x2);
  }

  // node_modules/d3-geo/src/noop.js
  function noop() {
  }

  // node_modules/d3-geo/src/area.js
  var areaRingSum = adder_default();
  var areaSum = adder_default();

  // node_modules/d3-geo/src/cartesian.js
  function cartesian(spherical2) {
    var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
    return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
  }
  function cartesianCross(a, b) {
    return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
  }
  function cartesianNormalizeInPlace(d) {
    var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l, d[1] /= l, d[2] /= l;
  }

  // node_modules/d3-geo/src/bounds.js
  var deltaSum = adder_default();

  // node_modules/d3-geo/src/rotation.js
  function rotationIdentity(lambda, phi) {
    return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
  }
  rotationIdentity.invert = rotationIdentity;

  // node_modules/d3-geo/src/clip/buffer.js
  function buffer_default() {
    var lines = [], line;
    return {
      point: function(x2, y2) {
        line.push([x2, y2]);
      },
      lineStart: function() {
        lines.push(line = []);
      },
      lineEnd: noop,
      rejoin: function() {
        if (lines.length > 1)
          lines.push(lines.pop().concat(lines.shift()));
      },
      result: function() {
        var result = lines;
        lines = [];
        line = null;
        return result;
      }
    };
  }

  // node_modules/d3-geo/src/pointEqual.js
  function pointEqual_default(a, b) {
    return abs(a[0] - b[0]) < epsilon3 && abs(a[1] - b[1]) < epsilon3;
  }

  // node_modules/d3-geo/src/clip/polygon.js
  function Intersection(point2, points, other, entry) {
    this.x = point2;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function polygon_default(segments, compareIntersection2, startInside, interpolate, stream) {
    var subject = [], clip = [], i, n;
    segments.forEach(function(segment) {
      if ((n2 = segment.length - 1) <= 0)
        return;
      var n2, p0 = segment[0], p1 = segment[n2], x2;
      if (pointEqual_default(p0, p1)) {
        stream.lineStart();
        for (i = 0; i < n2; ++i)
          stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      subject.push(x2 = new Intersection(p0, segment, null, true));
      clip.push(x2.o = new Intersection(p0, null, x2, false));
      subject.push(x2 = new Intersection(p1, segment, null, false));
      clip.push(x2.o = new Intersection(p1, null, x2, true));
    });
    if (!subject.length)
      return;
    clip.sort(compareIntersection2);
    link(subject);
    link(clip);
    for (i = 0, n = clip.length; i < n; ++i) {
      clip[i].e = startInside = !startInside;
    }
    var start = subject[0], points, point2;
    while (1) {
      var current = start, isSubject = true;
      while (current.v)
        if ((current = current.n) === start)
          return;
      points = current.z;
      stream.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (i = 0, n = points.length; i < n; ++i)
              stream.point((point2 = points[i])[0], point2[1]);
          } else {
            interpolate(current.x, current.n.x, 1, stream);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (i = points.length - 1; i >= 0; --i)
              stream.point((point2 = points[i])[0], point2[1]);
          } else {
            interpolate(current.x, current.p.x, -1, stream);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      stream.lineEnd();
    }
  }
  function link(array2) {
    if (!(n = array2.length))
      return;
    var n, i = 0, a = array2[0], b;
    while (++i < n) {
      a.n = b = array2[i];
      b.p = a;
      a = b;
    }
    a.n = b = array2[0];
    b.p = a;
  }

  // node_modules/d3-array/src/ascending.js
  function ascending_default(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // node_modules/d3-array/src/bisector.js
  function bisector_default(compare) {
    if (compare.length === 1)
      compare = ascendingComparator(compare);
    return {
      left: function(a, x2, lo, hi) {
        if (lo == null)
          lo = 0;
        if (hi == null)
          hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x2) < 0)
            lo = mid + 1;
          else
            hi = mid;
        }
        return lo;
      },
      right: function(a, x2, lo, hi) {
        if (lo == null)
          lo = 0;
        if (hi == null)
          hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x2) > 0)
            hi = mid;
          else
            lo = mid + 1;
        }
        return lo;
      }
    };
  }
  function ascendingComparator(f) {
    return function(d, x2) {
      return ascending_default(f(d), x2);
    };
  }

  // node_modules/d3-array/src/bisect.js
  var ascendingBisect = bisector_default(ascending_default);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;

  // node_modules/d3-array/src/array.js
  var array = Array.prototype;
  var slice = array.slice;
  var map = array.map;

  // node_modules/d3-array/src/ticks.js
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);

  // node_modules/d3-array/src/merge.js
  function merge_default2(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array2;
    while (++i < n)
      j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array2 = arrays[n];
      m = array2.length;
      while (--m >= 0) {
        merged[--j] = array2[m];
      }
    }
    return merged;
  }

  // node_modules/d3-geo/src/clip/extent.js
  var clipMax = 1e9;
  var clipMin = -clipMax;

  // node_modules/d3-geo/src/polygonContains.js
  var sum = adder_default();
  function polygonContains_default(polygon2, point2) {
    var lambda = point2[0], phi = point2[1], normal = [sin(lambda), -cos(lambda), 0], angle = 0, winding = 0;
    sum.reset();
    for (var i = 0, n = polygon2.length; i < n; ++i) {
      if (!(m = (ring = polygon2[i]).length))
        continue;
      var ring, m, point0 = ring[m - 1], lambda0 = point0[0], phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);
      for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
        var point1 = ring[j], lambda1 = point1[0], phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi1), cosPhi1 = cos(phi1), delta = lambda1 - lambda0, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi, k = sinPhi0 * sinPhi1;
        sum.add(atan2(k * sign2 * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
        angle += antimeridian ? delta + sign2 * tau : delta;
        if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
          var arc = cartesianCross(cartesian(point0), cartesian(point1));
          cartesianNormalizeInPlace(arc);
          var intersection = cartesianCross(normal, arc);
          cartesianNormalizeInPlace(intersection);
          var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
          if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
            winding += antimeridian ^ delta >= 0 ? 1 : -1;
          }
        }
      }
    }
    return (angle < -epsilon3 || angle < epsilon3 && sum < -epsilon3) ^ winding & 1;
  }

  // node_modules/d3-geo/src/length.js
  var lengthSum = adder_default();

  // node_modules/d3-geo/src/path/area.js
  var areaSum2 = adder_default();
  var areaRingSum2 = adder_default();

  // node_modules/d3-geo/src/path/bounds.js
  var x0 = Infinity;
  var x1 = -x0;

  // node_modules/d3-geo/src/path/context.js
  function PathContext(context) {
    this._context = context;
  }
  PathContext.prototype = {
    _radius: 4.5,
    pointRadius: function(_) {
      return this._radius = _, this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0)
        this._context.closePath();
      this._point = NaN;
    },
    point: function(x2, y2) {
      switch (this._point) {
        case 0: {
          this._context.moveTo(x2, y2);
          this._point = 1;
          break;
        }
        case 1: {
          this._context.lineTo(x2, y2);
          break;
        }
        default: {
          this._context.moveTo(x2 + this._radius, y2);
          this._context.arc(x2, y2, this._radius, 0, tau);
          break;
        }
      }
    },
    result: noop
  };

  // node_modules/d3-geo/src/path/measure.js
  var lengthSum2 = adder_default();

  // node_modules/d3-geo/src/path/string.js
  function PathString() {
    this._string = [];
  }
  PathString.prototype = {
    _radius: 4.5,
    _circle: circle(4.5),
    pointRadius: function(_) {
      if ((_ = +_) !== this._radius)
        this._radius = _, this._circle = null;
      return this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0)
        this._string.push("Z");
      this._point = NaN;
    },
    point: function(x2, y2) {
      switch (this._point) {
        case 0: {
          this._string.push("M", x2, ",", y2);
          this._point = 1;
          break;
        }
        case 1: {
          this._string.push("L", x2, ",", y2);
          break;
        }
        default: {
          if (this._circle == null)
            this._circle = circle(this._radius);
          this._string.push("M", x2, ",", y2, this._circle);
          break;
        }
      }
    },
    result: function() {
      if (this._string.length) {
        var result = this._string.join("");
        this._string = [];
        return result;
      } else {
        return null;
      }
    }
  };
  function circle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }

  // node_modules/d3-geo/src/clip/index.js
  function clip_default(pointVisible, clipLine, interpolate, start) {
    return function(rotate, sink) {
      var line = clipLine(sink), rotatedStart = rotate.invert(start[0], start[1]), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon2, segments, ring;
      var clip = {
        point: point2,
        lineStart,
        lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon2 = [];
        },
        polygonEnd: function() {
          clip.point = point2;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = merge_default2(segments);
          var startInside = polygonContains_default(polygon2, rotatedStart);
          if (segments.length) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            polygon_default(segments, compareIntersection, startInside, interpolate, sink);
          } else if (startInside) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
          }
          if (polygonStarted)
            sink.polygonEnd(), polygonStarted = false;
          segments = polygon2 = null;
        },
        sphere: function() {
          sink.polygonStart();
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
          sink.polygonEnd();
        }
      };
      function point2(lambda, phi) {
        var point3 = rotate(lambda, phi);
        if (pointVisible(lambda = point3[0], phi = point3[1]))
          sink.point(lambda, phi);
      }
      function pointLine(lambda, phi) {
        var point3 = rotate(lambda, phi);
        line.point(point3[0], point3[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point2;
        line.lineEnd();
      }
      function pointRing(lambda, phi) {
        ring.push([lambda, phi]);
        var point3 = rotate(lambda, phi);
        ringSink.point(point3[0], point3[1]);
      }
      function ringStart() {
        ringSink.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringSink.lineEnd();
        var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point3;
        ring.pop();
        polygon2.push(ring);
        ring = null;
        if (!n)
          return;
        if (clean & 1) {
          segment = ringSegments[0];
          if ((m = segment.length - 1) > 0) {
            if (!polygonStarted)
              sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            for (i = 0; i < m; ++i)
              sink.point((point3 = segment[i])[0], point3[1]);
            sink.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2)
          ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(validSegment));
      }
      return clip;
    };
  }
  function validSegment(segment) {
    return segment.length > 1;
  }
  function compareIntersection(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon3 : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon3 : halfPi - b[1]);
  }

  // node_modules/d3-geo/src/clip/antimeridian.js
  var antimeridian_default = clip_default(
    function() {
      return true;
    },
    clipAntimeridianLine,
    clipAntimeridianInterpolate,
    [-pi, -halfPi]
  );
  function clipAntimeridianLine(stream) {
    var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
    return {
      lineStart: function() {
        stream.lineStart();
        clean = 1;
      },
      point: function(lambda1, phi1) {
        var sign1 = lambda1 > 0 ? pi : -pi, delta = abs(lambda1 - lambda0);
        if (abs(delta - pi) < epsilon3) {
          stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          stream.point(lambda1, phi0);
          clean = 0;
        } else if (sign0 !== sign1 && delta >= pi) {
          if (abs(lambda0 - sign0) < epsilon3)
            lambda0 -= sign0 * epsilon3;
          if (abs(lambda1 - sign1) < epsilon3)
            lambda1 -= sign1 * epsilon3;
          phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          clean = 0;
        }
        stream.point(lambda0 = lambda1, phi0 = phi1);
        sign0 = sign1;
      },
      lineEnd: function() {
        stream.lineEnd();
        lambda0 = phi0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
    var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);
    return abs(sinLambda0Lambda1) > epsilon3 ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
  }
  function clipAntimeridianInterpolate(from, to, direction, stream) {
    var phi;
    if (from == null) {
      phi = direction * halfPi;
      stream.point(-pi, phi);
      stream.point(0, phi);
      stream.point(pi, phi);
      stream.point(pi, 0);
      stream.point(pi, -phi);
      stream.point(0, -phi);
      stream.point(-pi, -phi);
      stream.point(-pi, 0);
      stream.point(-pi, phi);
    } else if (abs(from[0] - to[0]) > epsilon3) {
      var lambda = from[0] < to[0] ? pi : -pi;
      phi = direction * lambda / 2;
      stream.point(-lambda, phi);
      stream.point(0, phi);
      stream.point(lambda, phi);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  // node_modules/d3-geo/src/transform.js
  function transformer(methods) {
    return function(stream) {
      var s = new TransformStream();
      for (var key in methods)
        s[key] = methods[key];
      s.stream = stream;
      return s;
    };
  }
  function TransformStream() {
  }
  TransformStream.prototype = {
    constructor: TransformStream,
    point: function(x2, y2) {
      this.stream.point(x2, y2);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };

  // node_modules/d3-geo/src/projection/resample.js
  var cosMinDistance = cos(30 * radians);

  // node_modules/d3-geo/src/projection/index.js
  var transformRadians = transformer({
    point: function(x2, y2) {
      this.stream.point(x2 * radians, y2 * radians);
    }
  });

  // node_modules/d3-geo/src/projection/azimuthal.js
  function azimuthalRaw(scale) {
    return function(x2, y2) {
      var cx = cos(x2), cy = cos(y2), k = scale(cx * cy);
      return [
        k * cy * sin(x2),
        k * sin(y2)
      ];
    };
  }
  function azimuthalInvert(angle) {
    return function(x2, y2) {
      var z = sqrt(x2 * x2 + y2 * y2), c = angle(z), sc = sin(c), cc = cos(c);
      return [
        atan2(x2 * sc, z * cc),
        asin(z && y2 * sc / z)
      ];
    };
  }

  // node_modules/d3-geo/src/projection/azimuthalEqualArea.js
  var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
    return sqrt(2 / (1 + cxcy));
  });
  azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
    return 2 * asin(z / 2);
  });

  // node_modules/d3-geo/src/projection/azimuthalEquidistant.js
  var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
    return (c = acos(c)) && c / sin(c);
  });
  azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
    return z;
  });

  // node_modules/d3-geo/src/projection/mercator.js
  function mercatorRaw(lambda, phi) {
    return [lambda, log(tan((halfPi + phi) / 2))];
  }
  mercatorRaw.invert = function(x2, y2) {
    return [x2, 2 * atan(exp(y2)) - halfPi];
  };

  // node_modules/d3-geo/src/projection/equirectangular.js
  function equirectangularRaw(lambda, phi) {
    return [lambda, phi];
  }
  equirectangularRaw.invert = equirectangularRaw;

  // node_modules/d3-geo/src/projection/gnomonic.js
  function gnomonicRaw(x2, y2) {
    var cy = cos(y2), k = cos(x2) * cy;
    return [cy * sin(x2) / k, sin(y2) / k];
  }
  gnomonicRaw.invert = azimuthalInvert(atan);

  // node_modules/d3-geo/src/projection/naturalEarth1.js
  function naturalEarth1Raw(lambda, phi) {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    return [
      lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi2 - 1529e-6 * phi4))),
      phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4)))
    ];
  }
  naturalEarth1Raw.invert = function(x2, y2) {
    var phi = y2, i = 25, delta;
    do {
      var phi2 = phi * phi, phi4 = phi2 * phi2;
      phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4))) - y2) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 5916e-6 * 11 * phi4)));
    } while (abs(delta) > epsilon3 && --i > 0);
    return [
      x2 / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (3971e-6 - 1529e-6 * phi2)))),
      phi
    ];
  };

  // node_modules/d3-geo/src/projection/orthographic.js
  function orthographicRaw(x2, y2) {
    return [cos(y2) * sin(x2), sin(y2)];
  }
  orthographicRaw.invert = azimuthalInvert(asin);

  // node_modules/d3-geo/src/projection/stereographic.js
  function stereographicRaw(x2, y2) {
    var cy = cos(y2), k = 1 + cos(x2) * cy;
    return [cy * sin(x2) / k, sin(y2) / k];
  }
  stereographicRaw.invert = azimuthalInvert(function(z) {
    return 2 * atan(z);
  });

  // node_modules/d3-geo/src/projection/transverseMercator.js
  function transverseMercatorRaw(lambda, phi) {
    return [log(tan((halfPi + phi) / 2)), -lambda];
  }
  transverseMercatorRaw.invert = function(x2, y2) {
    return [-y2, 2 * atan(exp(x2)) - halfPi];
  };

  // node_modules/@turf/union/dist/es/index.js
  var import_polygon_clipping2 = __toESM(require_polygon_clipping_umd(), 1);

  // node_modules/@turf/intersect/dist/es/index.js
  var import_polygon_clipping3 = __toESM(require_polygon_clipping_umd(), 1);

  // node_modules/@turf/dissolve/dist/es/index.js
  var import_polygon_clipping4 = __toESM(require_polygon_clipping_umd(), 1);

  // node_modules/@turf/mask/dist/es/index.js
  var import_polygon_clipping5 = __toESM(require_polygon_clipping_umd(), 1);

  // ns-hugo:/home/martin/dev/martsmusings/assets/mappy-travels/ts/duration.ts
  function durationStringToMinutes(str) {
    const parts = str.split(":");
    const hours = parseInt(parts[0]);
    const minutes = parseInt(parts[1]);
    return hours * 60 + minutes;
  }
  function plural(n) {
    return n == 1 ? "" : "s";
  }
  function minutesToHuman(minutes) {
    const days = Math.floor(minutes / 1440);
    const hours = Math.floor(minutes % 1440 / 60);
    return `${days}d ${hours}hr${plural(hours)}`;
  }

  // ns-params:@params
  var icons = { Air: "/mappy-travels/icons/Plane.png", Rail: "/mappy-travels/icons/Train.png", Road: "/mappy-travels/icons/Bus.png", Sea: "/mappy-travels/icons/Ferry.png" };
  var route = "/mappy-travels/route.compressed.min.json";

  // <stdin>
  var routeRequest = new Request(route);
  function allTransportCategories() {
    return [
      "Air" /* Air */,
      "Rail" /* Rail */,
      "Road" /* Road */,
      "Sea" /* Sea */
    ];
  }
  function modeToCategory(mode) {
    switch (mode) {
      case "Train" /* Train */:
        return "Rail" /* Rail */;
      case "Plane" /* Plane */:
        return "Air" /* Air */;
      case "Coach" /* Coach */:
        return "Road" /* Road */;
      case "Ferry" /* Ferry */:
        return "Sea" /* Sea */;
      case "Speedboat" /* Speedboat */:
        return "Sea" /* Sea */;
      case "Minibus" /* Minibus */:
        return "Road" /* Road */;
      case "LongBoat" /* LongBoat */:
        return "Sea" /* Sea */;
      case "Tube" /* Tube */:
        return "Rail" /* Rail */;
      case "Bus" /* Bus */:
        return "Road" /* Road */;
      case "Taxi" /* Taxi */:
        return "Road" /* Road */;
    }
  }
  var startLngLat = [-2.136594, 53.3504035];
  var mapOptions = {
    container: "map",
    style: "https://api.maptiler.com/maps/basic-v2/style.json?key=C72nUT04CqVXILemJsg3",
    center: startLngLat,
    zoom: 6
  };
  var map2;
  var steps;
  var lineColour = "#8856a7";
  var lineColourHighlighted = "#e31c3d";
  var features = [];
  var featuresBBox;
  var initialSource = {
    type: "geojson",
    data: {
      type: "Feature",
      properties: {},
      geometry: {
        type: "LineString",
        coordinates: []
      }
    }
  };
  var startTime;
  var previousTimestamp;
  var currentFeature = 0;
  var modeIcon = document.createElement("img");
  modeIcon.width = 32;
  modeIcon.height = 32;
  modeIcon.classList.add("icon");
  var marker = new maplibreGl.Marker({ element: modeIcon });
  marker.setLngLat(startLngLat);
  var currentModeIcon;
  var highlighetedStepId;
  var alreadyStarted = false;
  var startMarkers = /* @__PURE__ */ new Map();
  var endMarkers = /* @__PURE__ */ new Map();
  var stepIdFeature = /* @__PURE__ */ new Map();
  var counts = transportCategoryZeroMap();
  var costs = transportCategoryZeroMap();
  var times = transportCategoryZeroMap();
  var distances = transportCategoryZeroMap();
  var countElements = /* @__PURE__ */ new Map();
  var costElements = /* @__PURE__ */ new Map();
  var timeElements = /* @__PURE__ */ new Map();
  var distanceElements = /* @__PURE__ */ new Map();
  var containerElements = /* @__PURE__ */ new Map();
  var inProgressCounts = transportCategoryZeroMap();
  var inProgressCosts = transportCategoryZeroMap();
  var inProgressTimes = transportCategoryZeroMap();
  var inProgressDistances = transportCategoryZeroMap();
  function transportCategoryZeroMap() {
    const map3 = /* @__PURE__ */ new Map();
    for (const category of allTransportCategories()) {
      map3.set(category, 0);
    }
    return map3;
  }
  var animationSpeeds = /* @__PURE__ */ new Map();
  animationSpeeds.set("Air" /* Air */, 1500);
  animationSpeeds.set("Rail" /* Rail */, 200);
  animationSpeeds.set("Road" /* Road */, 200);
  animationSpeeds.set("Sea" /* Sea */, 100);
  var zooms = /* @__PURE__ */ new Map();
  zooms.set("Air" /* Air */, 3);
  zooms.set("Road" /* Road */, 6);
  zooms.set("Rail" /* Rail */, 6);
  zooms.set("Sea" /* Sea */, 6);
  function iconFor(transportCategory) {
    return icons[transportCategory.toString()];
  }
  function lngLatLike(coords) {
    return [coords[0], coords[1]];
  }
  function toggleMarker(i, markers) {
    const prevStep = steps[i - 1];
    if (prevStep) {
      const prevId = prevStep.id;
      const prevMarker = markers.get(prevId);
      if (prevMarker) {
        prevMarker.togglePopup();
      }
    }
    const step = steps[i];
    if (step) {
      const id = step.id;
      const marker2 = markers.get(id);
      if (marker2) {
        marker2.togglePopup();
      }
    }
  }
  function total(currentMap, inProgressMap, transportCategory) {
    var result = 0;
    const current = currentMap.get(transportCategory);
    if (current) {
      result += current;
    }
    const inProgress = inProgressMap.get(transportCategory);
    if (inProgress) {
      result += inProgress;
    }
    return result;
  }
  function displayCostsAndCounts() {
    for (const category of allTransportCategories()) {
      const cost = total(costs, inProgressCosts, category);
      const count = total(counts, inProgressCounts, category);
      const time = total(times, inProgressTimes, category);
      const distance2 = total(distances, inProgressDistances, category);
      const countElement = countElements.get(category);
      if (countElement) {
        countElement.innerHTML = `${Math.ceil(count)}`;
      }
      const costElement = costElements.get(category);
      if (costElement) {
        costElement.innerHTML = `\xA3${cost.toFixed(2)}`;
      }
      const timeElement = timeElements.get(category);
      if (timeElement) {
        timeElement.innerHTML = minutesToHuman(time);
      }
      const distanceElement = distanceElements.get(category);
      if (distanceElement) {
        distanceElement.innerHTML = `${distance2.toLocaleString("en-US", { maximumFractionDigits: 0 })} km`;
      }
    }
  }
  function animateStep(timestamp, i) {
    startTime = void 0;
    const feature2 = features[i];
    const start = feature2.geometry.coordinates[0];
    map2.panTo(lngLatLike(start), { animate: false });
    if (steps) {
      if (i > 0) {
        const lastStep = steps[i - 1];
        const lastCategory = modeToCategory(lastStep.m);
        const lastCount = counts.get(lastCategory);
        const lastCost = costs.get(lastCategory);
        const lastTime = times.get(lastCategory);
        const lastDistance = distances.get(lastCategory);
        if (lastCount != void 0) {
          counts.set(lastCategory, lastCount + lastStep.c);
        }
        if (lastCost != void 0) {
          costs.set(lastCategory, lastCost + lastStep.x);
        }
        if (lastTime != void 0) {
          times.set(lastCategory, lastTime + durationStringToMinutes(lastStep.d));
        }
        const lastFeature = features[i - 1];
        if (lastFeature && lastDistance != void 0) {
          distances.set(lastCategory, lastDistance + length(lastFeature, { units: "kilometers" }));
        }
        inProgressCosts.set(lastCategory, 0);
        inProgressCounts.set(lastCategory, 0);
        inProgressTimes.set(lastCategory, 0);
        inProgressDistances.set(lastCategory, 0);
      }
      const step = steps[i];
      const stepCategory = modeToCategory(step.m);
      if (step) {
        map2.zoomTo(step.z, { animate: false });
      }
      for (const category of allTransportCategories()) {
        const containerElement = containerElements.get(category);
        if (containerElement) {
          const isActive = category == stepCategory;
          if (isActive) {
            containerElement.classList.add("activeContainer");
          } else {
            containerElement.classList.remove("activeContainer");
          }
        }
      }
    }
    toggleMarker(i, startMarkers);
    toggleMarker(i, endMarkers);
    displayCostsAndCounts();
  }
  function calculateBoundingBox(ofFeatures) {
    var minLng = Number.MAX_VALUE;
    var maxLng = Number.MIN_VALUE;
    var minLat = Number.MAX_VALUE;
    var maxLat = Number.MIN_VALUE;
    for (const feature2 of ofFeatures) {
      for (const p of feature2.geometry.coordinates) {
        minLng = Math.min(p[0], minLng);
        maxLng = Math.max(p[0], maxLng);
        minLat = Math.min(p[1], minLat);
        maxLat = Math.max(p[1], maxLat);
      }
    }
    return [[minLng, minLat], [maxLng, maxLat]];
  }
  function animationsFinished() {
    for (const category of allTransportCategories()) {
      const containerElement = containerElements.get(category);
      if (containerElement) {
        containerElement.classList.remove("activeContainer");
      }
    }
    toggleMarker(steps.length, startMarkers);
    toggleMarker(steps.length, endMarkers);
    marker.remove();
    map2.fitBounds(featuresBBox, {
      animate: false,
      padding: { top: 60, bottom: 60, left: 60, right: 60 }
    });
  }
  function timeFor(category, distance2) {
    const kms = animationSpeeds.get(category);
    if (kms != void 0) {
      return distance2 / kms * 1e3;
    } else {
      throw "woah!";
    }
  }
  function animateLine(timestamp) {
    if (previousTimestamp == timestamp) {
      requestAnimationFrame(animateLine);
      return;
    }
    if (startTime == void 0) {
      startTime = timestamp;
    }
    if (steps == void 0) {
      console.error("no steps defined");
      return;
    }
    const elapsed = timestamp - startTime;
    const step = steps[currentFeature];
    const category = modeToCategory(step.m);
    if (currentModeIcon != step.m?.toString()) {
      currentModeIcon = step.m?.toString();
      modeIcon.setAttribute("src", iconFor(category));
    }
    const feature2 = features[currentFeature];
    const sourceKey = sourceKeyFor(step.id);
    const maxKm = length(feature2, { units: "kilometers" });
    const progress = elapsed / timeFor(category, maxKm);
    const currentKm = Math.max(1e-5, Math.min(progress * maxKm, maxKm));
    if (currentKm < maxKm) {
      inProgressCounts.set(category, step.c * progress);
      inProgressCosts.set(category, step.x * progress);
      inProgressTimes.set(category, durationStringToMinutes(step.d) * progress);
      inProgressDistances.set(category, currentKm);
      const currentPoint = along(feature2, currentKm, { "units": "kilometers" });
      const lineString2 = es_default15(feature2.geometry.coordinates[0], currentPoint, feature2);
      const mapSource = map2.getSource(sourceKey);
      if (mapSource) {
        mapSource.setData(lineString2);
        map2.panTo(lngLatLike(currentPoint.geometry.coordinates), { animate: false });
        marker.setLngLat(lngLatLike(currentPoint.geometry.coordinates));
      }
      displayCostsAndCounts();
      requestAnimationFrame(animateLine);
    } else {
      const mapSource = map2.getSource(sourceKey);
      if (mapSource) {
        mapSource.setData(feature2.geometry);
        const end = lngLatLike(feature2.geometry.coordinates[feature2.geometry.coordinates.length - 1]);
        map2.panTo(end, { animate: false });
        marker.setLngLat(end);
      }
      if (++currentFeature < features.length) {
        animateStep(timestamp, currentFeature);
        requestAnimationFrame(animateLine);
      } else {
        animationsFinished();
      }
    }
  }
  function sourceKeyFor(id) {
    return `source${id}`;
  }
  function addMarker(coords, popupText) {
    const marker2 = new maplibreGl.Marker();
    marker2.setLngLat(coords).setPopup(new maplibreGl.Popup({ focusAfterOpen: false }).setText(popupText)).addTo(map2);
    return marker2;
  }
  function renderSteps(route2) {
    steps = [];
    map2.on("load", function() {
      const from = window.mappyTravelsFrom;
      const to = window.mappyTravelsTo;
      console.log(`starting for ${from} to ${to}`);
      const isForSubset = from != "" || to != "";
      var rangeStarted = false;
      for (let step of route2) {
        if (isForSubset && !rangeStarted && step.id != from) {
          continue;
        } else {
          rangeStarted = true;
        }
        steps.push(step);
        const feature2 = {
          "type": "Feature",
          "geometry": {
            "type": "LineString",
            "coordinates": step.p
          },
          properties: {}
        };
        features.push(feature2);
        stepIdFeature.set(step.id, feature2);
        const sourceKey = sourceKeyFor(step.id);
        map2.addSource(sourceKeyFor(step.id), initialSource);
        map2.addLayer({
          id: sourceKey,
          type: "line",
          source: sourceKey,
          layout: {
            "line-join": "round",
            "line-cap": "round"
          },
          paint: {
            "line-color": lineColour,
            "line-width": 3
          }
        });
        const start = lngLatLike(feature2.geometry.coordinates[0]);
        const end = lngLatLike(feature2.geometry.coordinates[feature2.geometry.coordinates.length - 1]);
        startMarkers.set(step.id, addMarker(start, `${step.fp} (${step.fc})`));
        endMarkers.set(step.id, addMarker(end, `${step.tp} (${step.tc})`));
        if (isForSubset && step.id == to) {
          break;
        }
      }
      featuresBBox = calculateBoundingBox(features);
      registerRowElementEvents();
      marker.addTo(map2);
      map2.fitBounds(featuresBBox, {
        animate: false,
        padding: { top: 60, bottom: 60, left: 60, right: 60 }
      });
      animateStep(performance.now(), 0);
      requestAnimationFrame(animateLine);
    });
  }
  function rowElementMouseDown(id) {
    return (ev) => {
      if (highlighetedStepId) {
        setLayerColour(highlighetedStepId, lineColour);
        const element2 = document.getElementById(rowElementId(highlighetedStepId));
        if (element2) {
          element2.classList.remove("row-highlighted");
        }
        const startMarker2 = startMarkers.get(highlighetedStepId);
        if (startMarker2) {
          startMarker2.togglePopup();
        }
        const endMarker2 = endMarkers.get(highlighetedStepId);
        if (endMarker2) {
          endMarker2.togglePopup();
        }
      }
      highlighetedStepId = id;
      setLayerColour(highlighetedStepId, lineColourHighlighted);
      const element = document.getElementById(rowElementId(highlighetedStepId));
      if (element) {
        element.classList.add("row-highlighted");
      }
      const startMarker = startMarkers.get(highlighetedStepId);
      if (startMarker) {
        startMarker.togglePopup();
      }
      const endMarker = endMarkers.get(highlighetedStepId);
      if (endMarker) {
        endMarker.togglePopup();
      }
      const feature2 = stepIdFeature.get(id);
      if (feature2) {
        const bbox3 = calculateBoundingBox([feature2]);
        map2.fitBounds(bbox3, {
          animate: false,
          padding: { top: 60, bottom: 60, left: 60, right: 60 }
        });
      }
    };
  }
  function setLayerColour(id, colour) {
    map2.setPaintProperty(sourceKeyFor(id), "line-color", colour);
  }
  function rowElementId(id) {
    return `row-${id}`;
  }
  function registerRowElementEvents() {
    for (const step of steps) {
      const element = document.getElementById(rowElementId(step.id));
      if (element) {
        element.addEventListener("mousedown", rowElementMouseDown(step.id));
      }
    }
  }
  function mappyStart() {
    if (alreadyStarted) {
      return;
    }
    alreadyStarted = true;
    map2 = new maplibreGl.Map(mapOptions);
    map2.addControl(new maplibreGl.NavigationControl({ showCompass: true, showZoom: true, visualizePitch: true }));
    map2.addControl(new maplibreGl.FullscreenControl({}));
    for (const category of allTransportCategories()) {
      const countElement = document.getElementById(`count-${category}`);
      if (countElement) {
        countElements.set(category, countElement);
      }
      const costElement = document.getElementById(`cost-${category}`);
      if (costElement) {
        costElements.set(category, costElement);
      }
      const timeElement = document.getElementById(`time-${category}`);
      if (timeElement) {
        timeElements.set(category, timeElement);
      }
      const distanceElement = document.getElementById(`distance-${category}`);
      if (distanceElement) {
        distanceElements.set(category, distanceElement);
      }
      const containerElement = document.getElementById(`container-${category}`);
      if (containerElement) {
        containerElements.set(category, containerElement);
      }
    }
    fetch(routeRequest).then((response) => {
      if (response.ok) {
        response.json().catch((e) => console.log(`successful route request, but was not json ${e}`)).then((data) => renderSteps(data));
      } else {
        console.log(`route request gave response code ${response.status}`);
      }
    });
  }
  window.mappyStart = mappyStart;
  document.addEventListener("DOMContentLoaded", () => {
    if (window.mappyAutoStart == "yes") {
      mappyStart();
    }
  });
})();
/*! Bundled license information:

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

polygon-clipping/dist/polygon-clipping.umd.js:
  (**
   * splaytree v3.1.0
   * Fast Splay tree for Node and browser
   *
   * @author Alexander Milevski <info@w8r.name>
   * @license MIT
   * @preserve
   *)

@turf/isolines/dist/es/index.js:
  (**
   * @license GNU Affero General Public License.
   * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
   * v. 1.2.0
   * https://github.com/RaumZeit/MarchingSquares.js
   *
   * MarchingSquaresJS is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Affero General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MarchingSquaresJS is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU Affero General Public License for more details.
   *
   * As additional permission under GNU Affero General Public License version 3
   * section 7, third-party projects (personal or commercial) may distribute,
   * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
   * requirement that said third-party project for that reason alone becomes
   * subject to any requirement of the GNU Affero General Public License version 3.
   * Any modifications to MarchingSquaresJS, however, must be shared with the public
   * and made available.
   *
   * In summary this:
   * - allows you to use MarchingSquaresJS at no cost
   * - allows you to use MarchingSquaresJS for both personal and commercial purposes
   * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
   *   license as long as this license notice is included
   * - enables you to keep the source code of your program that uses MarchingSquaresJS
   *   undisclosed
   * - forces you to share any modifications you have made to MarchingSquaresJS,
   *   e.g. bug-fixes
   *
   * You should have received a copy of the GNU Affero General Public License
   * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
   *)

@turf/isobands/dist/es/index.js:
  (*!
   * @license GNU Affero General Public License.
   * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>
   * v. 1.2.0
   * https://github.com/RaumZeit/MarchingSquares.js
   *
   * MarchingSquaresJS is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Affero General Public License as published by
   * the Free Software Foundation, either version 3 of the License, or
   * (at your option) any later version.
   *
   * MarchingSquaresJS is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU Affero General Public License for more details.
   *
   * As additional permission under GNU Affero General Public License version 3
   * section 7, third-party projects (personal or commercial) may distribute,
   * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the
   * requirement that said third-party project for that reason alone becomes
   * subject to any requirement of the GNU Affero General Public License version 3.
   * Any modifications to MarchingSquaresJS, however, must be shared with the public
   * and made available.
   *
   * In summary this:
   * - allows you to use MarchingSquaresJS at no cost
   * - allows you to use MarchingSquaresJS for both personal and commercial purposes
   * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any
   *   license as long as this license notice is included
   * - enables you to keep the source code of your program that uses MarchingSquaresJS
   *   undisclosed
   * - forces you to share any modifications you have made to MarchingSquaresJS,
   *   e.g. bug-fixes
   *
   * You should have received a copy of the GNU Affero General Public License
   * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.
   *)
*/
